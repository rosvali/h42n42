// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Sexplib0__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0 = [0];
   runtime.caml_register_global(0, Sexplib0, "Sexplib0__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp
//# unitInfo: Requires: Stdlib__Buffer, Stdlib__Bytes, Stdlib__BytesLabels, Stdlib__Char, Stdlib__Format, Stdlib__ListLabels, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$11 = "(",
    cst$12 = "()",
    cst$13 = ")",
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$2 = cst$11,
    cst$3 = cst$12,
    cst$4 = cst$13,
    cst$5 = " ",
    cst$6 = cst$11,
    cst$7 = cst$12,
    cst$8 = cst$13,
    cst$10 = cst$12,
    cst$9 = cst$12,
    cst = "\\",
    cst$0 = ' "',
    cst$1 = '"',
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    _b_ = [0, [15, [17, 2, 0]], "%a@?"],
    _a_ = [0, 0, 0],
    cst_n = "\\n",
    cst_Sexplib0_Sexp_Not_found_s = "Sexplib0__Sexp.Not_found_s",
    cst_Sexplib0_Sexp_Of_sexp_erro = "Sexplib0__Sexp.Of_sexp_error";
   function sexp_of_t(t){return t;}
   function t_of_sexp(t){return t;}
   function compare(a$0, b$0){
    if(a$0 === b$0) return 0;
    if(0 === a$0[0]){
     var a$1 = a$0[1];
     if(0 !== b$0[0]) return -1;
     var b$1 = b$0[1];
     return caml_call2(Stdlib_StringLabels[9], a$1, b$1);
    }
    var a$2 = a$0[1];
    if(0 === b$0[0]) return 1;
    var b$2 = b$0[1], a = a$2, b = b$2;
    for(;;){
     if(! a) return b ? -1 : 0;
     if(! b) return 1;
     var ys = b[2], y = b[1], xs = a[2], x = a[1], res = compare(x, y);
     if(0 !== res) return res;
     var a = xs, b = ys;
    }
   }
   function equal(a, b){return 0 === compare(a, b) ? 1 : 0;}
   var
    Not_found_s = [248, cst_Sexplib0_Sexp_Not_found_s, caml_fresh_oo_id(0)],
    Of_sexp_error = [248, cst_Sexplib0_Sexp_Of_sexp_erro, caml_fresh_oo_id(0)],
    default_indent = [0, 1];
   function must_escape(str){
    var len = caml_ml_string_length(str), _u_ = 0 === len ? 1 : 0;
    if(_u_) return _u_;
    var ix$1 = len - 1 | 0, ix = ix$1;
    for(;;){
     var match = caml_string_get(str, ix);
     a:
     {
      b:
      {
       if(92 <= match){
        var switcher = match - 93 | 0;
        if(33 < switcher >>> 0){if(0 <= switcher) break a; break b;}
        if(31 === switcher){
         var _v_ = 0 < ix ? 1 : 0;
         if(_v_){
          var
           next = ix - 1 | 0,
           _w_ = caml_string_get(str, next),
           _x_ = caml_call2(Stdlib_Char[8], _w_, 35);
          if(! _x_){var ix = next; continue;}
          var _y_ = _x_;
         }
         else
          var _y_ = _v_;
         return _y_;
        }
       }
       else
        if(42 <= match){
         if(59 === match) break b;
        }
        else{
         if(33 > match) break a;
         switch(match - 33 | 0){
           case 2:
            var _A_ = 0 < ix ? 1 : 0;
            if(_A_){
             var
              next$0 = ix - 1 | 0,
              _B_ = caml_string_get(str, next$0),
              _C_ = caml_call2(Stdlib_Char[8], _B_, 124);
             if(! _C_){var ix = next$0; continue;}
             var _D_ = _C_;
            }
            else
             var _D_ = _A_;
            return _D_;
           case 1:
           case 7:
           case 8:
            break b;
         }
        }
       var _z_ = 0 < ix ? 1 : 0;
       if(! _z_) return _z_;
       var ix$0 = ix - 1 | 0, ix = ix$0;
       continue;
      }
      return 1;
     }
     return 1;
    }
   }
   function escaped(s){
    var n = [0, 0], _k_ = caml_ml_string_length(s) - 1 | 0, _j_ = 0;
    if(_k_ >= 0){
     var i$0 = _j_;
     for(;;){
      var match = caml_string_unsafe_get(s, i$0);
      a:
      {
       b:
       {
        c:
        {
         if(32 <= match){
          var _r_ = match - 34 | 0;
          if(58 < _r_ >>> 0){
           if(93 <= _r_) break c;
          }
          else if(56 < _r_ - 1 >>> 0) break b;
          var _s_ = 1;
          break a;
         }
         if(11 <= match){
          if(13 === match) break b;
         }
         else if(8 <= match) break b;
        }
        var _s_ = 4;
        break a;
       }
       var _s_ = 2;
      }
      n[1] = n[1] + _s_ | 0;
      var _t_ = i$0 + 1 | 0;
      if(_k_ === i$0) break;
      var i$0 = _t_;
     }
    }
    if(n[1] === caml_ml_string_length(s)) return s;
    var s$0 = caml_create_bytes(n[1]);
    n[1] = 0;
    var _m_ = caml_ml_string_length(s) - 1 | 0, _l_ = 0;
    if(_m_ >= 0){
     var i = _l_;
     for(;;){
      var c = caml_string_unsafe_get(s, i);
      a:
      {
       b:
       {
        c:
        {
         if(35 <= c){
          if(92 !== c){if(127 <= c) break c; break b;}
         }
         else{
          if(32 > c){
           if(14 <= c) break c;
           switch(c){
             case 8:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 98);
              break a;
             case 9:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 116);
              break a;
             case 10:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 110);
              break a;
             case 13:
              caml_bytes_unsafe_set(s$0, n[1], 92);
              n[1]++;
              caml_bytes_unsafe_set(s$0, n[1], 114);
              break a;
             default: break c;
           }
          }
          if(34 > c) break b;
         }
         caml_bytes_unsafe_set(s$0, n[1], 92);
         n[1]++;
         caml_bytes_unsafe_set(s$0, n[1], c);
         break a;
        }
        caml_bytes_unsafe_set(s$0, n[1], 92);
        n[1]++;
        var _o_ = caml_call1(Stdlib_Char[1], 48 + (c / 100 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _o_);
        n[1]++;
        var
         _p_ = caml_call1(Stdlib_Char[1], 48 + ((c / 10 | 0) % 10 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _p_);
        n[1]++;
        var _q_ = caml_call1(Stdlib_Char[1], 48 + (c % 10 | 0) | 0);
        caml_bytes_unsafe_set(s$0, n[1], _q_);
        break a;
       }
       caml_bytes_unsafe_set(s$0, n[1], c);
      }
      n[1]++;
      var _n_ = i + 1 | 0;
      if(_m_ === i) break;
      var i = _n_;
     }
    }
    return caml_call1(Stdlib_BytesLabels[48], s$0);
   }
   function esc_str(str){
    var
     estr = escaped(str),
     elen = caml_ml_string_length(estr),
     res = caml_create_bytes(elen + 2 | 0);
    caml_call5(Stdlib_Bytes[12], estr, 0, res, 1, elen);
    caml_bytes_unsafe_set(res, 0, 34);
    caml_bytes_unsafe_set(res, elen + 1 | 0, 34);
    return caml_call1(Stdlib_BytesLabels[48], res);
   }
   function index_of_newline(str, start){
    return caml_call3(Stdlib_StringLabels[32], str, start, 10);
   }
   function mach_maybe_esc_str(str){
    return must_escape(str) ? esc_str(str) : str;
   }
   function pp_hum_indent(indent, ppf, param){
    if(0 === param[0]){
     var str = param[1];
     if(! must_escape(str)) return caml_call2(Stdlib_Format[13], ppf, str);
     var match = index_of_newline(str, 0);
     if(match)
      var
       index = match[1],
       _g_ = (index + 1 | 0) === caml_ml_string_length(str) ? 1 : 0;
     else
      var _g_ = 1;
     if(_g_){
      var _h_ = esc_str(str);
      return caml_call2(Stdlib_Format[13], ppf, _h_);
     }
     caml_call2(Stdlib_Format[1], ppf, 0);
     caml_call2(Stdlib_Format[13], ppf, cst$0);
     var index$0 = 0;
     for(;;){
      var next_newline = index_of_newline(str, index$0);
      if(next_newline)
       var end_pos = next_newline[1], end_pos$0 = end_pos;
      else
       var end_pos$0 = caml_ml_string_length(str);
      var
       next_line =
         caml_call3
          (Stdlib_StringLabels[15], str, index$0, end_pos$0 - index$0 | 0),
       _i_ = escaped(next_line);
      caml_call2(Stdlib_Format[13], ppf, _i_);
      if(! next_newline){
       caml_call2(Stdlib_Format[13], ppf, cst$1);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var newline_index = next_newline[1];
      caml_call2(Stdlib_Format[13], ppf, cst);
      caml_call2(Stdlib_Format[34], ppf, 0);
      caml_call2(Stdlib_Format[13], ppf, cst_n);
      var index$1 = newline_index + 1 | 0, index$0 = index$1;
     }
    }
    else{
     var match$0 = param[1];
     if(! match$0) return caml_call2(Stdlib_Format[13], ppf, cst$3);
     var t = match$0[2], h = match$0[1];
     caml_call2(Stdlib_Format[1], ppf, indent);
     caml_call2(Stdlib_Format[13], ppf, cst$2);
     pp_hum_indent(indent, ppf, h);
     var param$0 = t;
     for(;;){
      if(! param$0){
       caml_call2(Stdlib_Format[13], ppf, cst$4);
       return caml_call2(Stdlib_Format[3], ppf, 0);
      }
      var t$0 = param$0[2], h$0 = param$0[1];
      caml_call2(Stdlib_Format[27], ppf, 0);
      pp_hum_indent(indent, ppf, h$0);
      var param$0 = t$0;
     }
    }
   }
   function pp_mach_internal(may_need_space, ppf, param){
    if(0 === param[0]){
     var
      str = param[1],
      str$0 = mach_maybe_esc_str(str),
      new_may_need_space = str$0 === str ? 1 : 0,
      new_may_need_space$0 =
        may_need_space ? new_may_need_space : may_need_space;
     if(new_may_need_space$0) caml_call2(Stdlib_Format[13], ppf, cst$5);
     caml_call2(Stdlib_Format[13], ppf, str$0);
     return new_may_need_space;
    }
    var match = param[1];
    if(! match){caml_call2(Stdlib_Format[13], ppf, cst$7); return 0;}
    var t = match[2], h = match[1];
    caml_call2(Stdlib_Format[13], ppf, cst$6);
    var
     may_need_space$0 = pp_mach_internal(0, ppf, h),
     may_need_space$1 = may_need_space$0,
     param$0 = t;
    for(;;){
     if(! param$0){caml_call2(Stdlib_Format[13], ppf, cst$8); return 0;}
     var
      t$0 = param$0[2],
      h$0 = param$0[1],
      may_need_space$2 = pp_mach_internal(may_need_space$1, ppf, h$0),
      may_need_space$1 = may_need_space$2,
      param$0 = t$0;
    }
   }
   function pp_hum(ppf, sexp){
    return pp_hum_indent(default_indent[1], ppf, sexp);
   }
   function pp_mach(ppf, sexp){pp_mach_internal(0, ppf, sexp); return 0;}
   function size_loop(acc, param){
    var c = acc[2], v = acc[1];
    if(0 === param[0]){
     var str = param[1];
     return [0, v + 1 | 0, c + caml_ml_string_length(str) | 0];
    }
    var lst = param[1];
    return caml_call3(Stdlib_ListLabels[25], size_loop, acc, lst);
   }
   function size(sexp){return size_loop(_a_, sexp);}
   function to_buffer_hum(buf, opt, sexp){
    if(opt)
     var sth = opt[1], indent = sth;
    else
     var indent = default_indent[1];
    var ppf = caml_call1(Stdlib_Format[111], buf);
    function _d_(_e_, _f_){return pp_hum_indent(indent, _e_, _f_);}
    return caml_call4(Stdlib_Format[129], ppf, _b_, _d_, sexp);
   }
   function to_buffer_mach(buf, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(Stdlib_Buffer[12], buf, 32);
      caml_call2(Stdlib_Buffer[16], buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(Stdlib_Buffer[16], buf, cst$9); return 0;}
     var t = match[2], h = match[1];
     caml_call2(Stdlib_Buffer[12], buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(Stdlib_Buffer[12], buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0),
       may_need_space$1 = may_need_space$2,
       param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function to_buffer_gen(buf, add_char, add_string, sexp){
    function loop(may_need_space, param){
     if(0 === param[0]){
      var
       str = param[1],
       str$0 = mach_maybe_esc_str(str),
       new_may_need_space = str$0 === str ? 1 : 0,
       new_may_need_space$0 =
         may_need_space ? new_may_need_space : may_need_space;
      if(new_may_need_space$0) caml_call2(add_char, buf, 32);
      caml_call2(add_string, buf, str$0);
      return new_may_need_space;
     }
     var match = param[1];
     if(! match){caml_call2(add_string, buf, cst$10); return 0;}
     var t = match[2], h = match[1];
     caml_call2(add_char, buf, 40);
     var
      may_need_space$0 = loop(0, h),
      may_need_space$1 = may_need_space$0,
      param$0 = t;
     for(;;){
      if(! param$0){caml_call2(add_char, buf, 41); return 0;}
      var
       t$0 = param$0[2],
       h$0 = param$0[1],
       may_need_space$2 = loop(may_need_space$1, h$0),
       may_need_space$1 = may_need_space$2,
       param$0 = t$0;
     }
    }
    loop(0, sexp);
    return 0;
   }
   function buffer(param){return caml_call1(Stdlib_Buffer[1], 1024);}
   function to_string_hum(indent, sexp){
    if(0 === sexp[0]){
     var str = sexp[1], _c_ = index_of_newline(str, 0) ? 0 : 1;
     if(_c_) return mach_maybe_esc_str(str);
    }
    var buf = buffer(0);
    to_buffer_hum(buf, indent, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function to_string_mach(sexp){
    if(0 === sexp[0]){var str = sexp[1]; return mach_maybe_esc_str(str);}
    var buf = buffer(0);
    to_buffer_mach(buf, sexp);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   var of_float_style = [0, 1009018843], of_int_style = [0, 1009018843];
   function message(name, fields){
    function conv_fields(param){
     if(! param) return 0;
     var
      rest = param[2],
      match = param[1],
      fsexp = match[2],
      fname = match[1];
     return runtime.caml_string_notequal(fname, "")
             ? [0, [1, [0, [0, fname], [0, fsexp, 0]]], conv_fields(rest)]
             : [0, fsexp, conv_fields(rest)];
    }
    return [1, [0, [0, name], conv_fields(fields)]];
   }
   var
    Sexplib0_Sexp =
      [0,
       t_of_sexp,
       sexp_of_t,
       equal,
       compare,
       Not_found_s,
       Of_sexp_error,
       message,
       default_indent,
       pp_hum,
       pp_hum_indent,
       pp_mach,
       pp_mach,
       to_string_hum,
       to_string_mach,
       to_string_mach,
       of_float_style,
       of_int_style,
       [0,
        size,
        buffer,
        to_buffer_mach,
        to_buffer_hum,
        to_buffer_mach,
        to_buffer_gen,
        mach_maybe_esc_str,
        must_escape,
        esc_str]];
   runtime.caml_register_global(25, Sexplib0_Sexp, "Sexplib0__Sexp");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_grammar
(function(globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    doc_comment_tag = "sexp_grammar.doc_comment",
    type_name_tag = "sexp_grammar.type_name",
    assoc_tag = "sexp_grammar.assoc",
    assoc_key_tag = "sexp_grammar.assoc.key",
    assoc_value_tag = "sexp_grammar.assoc.value",
    completion_suggested = "sexp_grammar.completion-suggested";
   function coerce(t){return t;}
   function tag(param, key, value){return [5, [0, key, value, param]];}
   var
    Sexplib0_Sexp_grammar =
      [0,
       coerce,
       tag,
       doc_comment_tag,
       type_name_tag,
       assoc_tag,
       assoc_key_tag,
       assoc_value_tag,
       completion_suggested];
   runtime.caml_register_global
    (6, Sexplib0_Sexp_grammar, "Sexplib0__Sexp_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_grammar
//# unitInfo: Requires: Sexplib0__Sexp_grammar, Stdlib__ListLabels
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    unit_sexp_grammar = [2, 0],
    sexp_t_sexp_grammar = [0, "Sexp.t"],
    empty_sexp_grammar = [4, 0],
    Sexplib0_Sexp_grammar = global_data.Sexplib0__Sexp_grammar,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels;
   function sexp_grammar_with_tags(grammar, tags){
    function _b_(param, grammar){
     var value = param[2], key = param[1];
     return [5, [0, key, value, grammar]];
    }
    return caml_call3(Stdlib_ListLabels[26], _b_, tags, grammar);
   }
   function sexp_grammar_with_tag_list(x, tags){
    function _a_(param, grammar){
     var value = param[2], key = param[1];
     return [0, [0, key, value, grammar]];
    }
    return caml_call3(Stdlib_ListLabels[26], _a_, tags, x);
   }
   var
    bool_sexp_grammar = 0,
    string_sexp_grammar = 4,
    bytes_sexp_grammar = 4,
    char_sexp_grammar = 1,
    int_sexp_grammar = 2,
    float_sexp_grammar = 3,
    int32_sexp_grammar = 2,
    int64_sexp_grammar = 2,
    nativeint_sexp_grammar = 2;
   function ref_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function lazy_t_sexp_grammar(grammar){
    return caml_call1(Sexplib0_Sexp_grammar[1], grammar);
   }
   function option_sexp_grammar(param){return [1, param];}
   function list_sexp_grammar(param){return [2, [1, param]];}
   function array_sexp_grammar(param){return [2, [1, param]];}
   var
    Sexplib0_Sexp_conv_grammar =
      [0,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       empty_sexp_grammar,
       empty_sexp_grammar];
   runtime.caml_register_global
    (5, Sexplib0_Sexp_conv_grammar, "Sexplib0__Sexp_conv_grammar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv
//# unitInfo: Requires: Assert_failure, CamlinternalLazy, Sexplib0__Sexp, Sexplib0__Sexp_conv_grammar, Stdlib, Stdlib__Arg, Stdlib__ArrayLabels, Stdlib__BytesLabels, Stdlib__Ephemeron, Stdlib__Int32, Stdlib__Int64, Stdlib__Lazy, Stdlib__ListLabels, Stdlib__MoreLabels, Stdlib__Nativeint, Stdlib__Obj, Stdlib__Parsing, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue, Stdlib__Scanf, Stdlib__Stack, Stdlib__StringLabels, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Assert_failure$0 = "Assert_failure",
    cst_None = "None",
    cst_Some = "Some",
    cst_none = "none",
    cst_option_of_sexp_only_none_c$1 = "option_of_sexp: only none can be atom",
    cst_some = "some",
    cst_src_sexp_conv_ml = "src/sexp_conv.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_float_of_string = runtime.caml_float_of_string,
    caml_format_float = runtime.caml_format_float,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp = global_data.Sexplib0__Sexp,
    Stdlib_Arg = global_data.Stdlib__Arg,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Parsing = global_data.Stdlib__Parsing,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Scanf = global_data.Stdlib__Scanf,
    Stdlib_Stack = global_data.Stdlib__Stack,
    Stdlib_Sys = global_data.Stdlib__Sys,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_MoreLabels = global_data.Stdlib__MoreLabels,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_BytesLabels = global_data.Stdlib__BytesLabels,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Obj = global_data.Stdlib__Obj,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Nativeint = global_data.Stdlib__Nativeint,
    Stdlib_Int64 = global_data.Stdlib__Int64,
    Stdlib_Int32 = global_data.Stdlib__Int32,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib_Ephemeron = global_data.Stdlib__Ephemeron,
    Sexplib0_Sexp_conv_grammar = global_data.Sexplib0__Sexp_conv_grammar,
    _aF_ = [0, 0],
    _aG_ = [0, 1],
    _aB_ = [0, "Sexplib.Conv.Of_sexp_error"],
    _aC_ = [0, cst_src_sexp_conv_ml, 410, 15],
    _ay_ = [0, 0],
    _az_ = [0, 0],
    cst_Assert_failure = cst_Assert_failure$0,
    _av_ = [0, cst_src_sexp_conv_ml, 334, 15],
    _ar_ = [0, "Exit"],
    _as_ = [0, cst_src_sexp_conv_ml, 338, 15],
    _an_ = [0, "End_of_file"],
    _ao_ = [0, cst_src_sexp_conv_ml, 342, 15],
    _aj_ = [0, "Failure"],
    _ak_ = [0, cst_src_sexp_conv_ml, 346, 15],
    _af_ = [0, "Not_found"],
    _ag_ = [0, cst_src_sexp_conv_ml, 350, 15],
    _ab_ = [0, "Invalid_argument"],
    _ac_ = [0, cst_src_sexp_conv_ml, 354, 15],
    cst_Match_failure = "Match_failure",
    ___ = [0, cst_src_sexp_conv_ml, 358, 15],
    _W_ = [0, "Not_found_s"],
    _X_ = [0, cst_src_sexp_conv_ml, 362, 15],
    _S_ = [0, "Sys_error"],
    _T_ = [0, cst_src_sexp_conv_ml, 366, 15],
    _O_ = [0, "Arg.Help"],
    _P_ = [0, cst_src_sexp_conv_ml, 370, 15],
    _K_ = [0, "Arg.Bad"],
    _L_ = [0, cst_src_sexp_conv_ml, 374, 15],
    _G_ = [0, "Lazy.Undefined"],
    _H_ = [0, cst_src_sexp_conv_ml, 378, 15],
    _C_ = [0, "Parsing.Parse_error"],
    _D_ = [0, cst_src_sexp_conv_ml, 382, 15],
    _y_ = [0, "Queue.Empty"],
    _z_ = [0, cst_src_sexp_conv_ml, 386, 15],
    _u_ = [0, "Scanf.Scan_failure"],
    _v_ = [0, cst_src_sexp_conv_ml, 390, 15],
    _q_ = [0, "Stack.Empty"],
    _r_ = [0, cst_src_sexp_conv_ml, 394, 15],
    _m_ = [0, "Sys.Break"],
    _n_ = [0, cst_src_sexp_conv_ml, 398, 15],
    _j_ =
      [0,
       [2,
        0,
        [12, 32, [2, 0, [12, 58, [4, 0, 0, 0, [12, 58, [4, 0, 0, 0, 0]]]]]]],
       "%s %s:%d:%d"],
    cst_fun_of_sexp_cannot_convert =
      "fun_of_sexp: cannot convert function values",
    cst_opaque_of_sexp_cannot_conv =
      "opaque_of_sexp: cannot convert opaque values",
    cst_hashtbl_of_sexp_tuple_list = "hashtbl_of_sexp: tuple list needed",
    cst_hashtbl_of_sexp_list_neede = "hashtbl_of_sexp: list needed",
    cst_array_of_sexp_list_needed = "array_of_sexp: list needed",
    cst_list_of_sexp_list_needed = "list_of_sexp: list needed",
    cst_triple_of_sexp_list_needed = "triple_of_sexp: list needed",
    cst_triple_of_sexp_list_must_c =
      "triple_of_sexp: list must contain exactly three elements only",
    cst_pair_of_sexp_list_needed = "pair_of_sexp: list needed",
    cst_pair_of_sexp_list_must_con =
      "pair_of_sexp: list must contain exactly two elements only",
    cst_option_of_sexp_only_none_c = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_r =
      "option_of_sexp: list must represent optional value",
    cst_option_of_sexp_only_none_c$0 = cst_option_of_sexp_only_none_c$1,
    cst_option_of_sexp_list_must_b = "option_of_sexp: list must be (some el)",
    cst_nativeint_of_sexp = "nativeint_of_sexp: ",
    cst_nativeint_of_sexp_atom_nee = "nativeint_of_sexp: atom needed",
    cst_int64_of_sexp = "int64_of_sexp: ",
    cst_int64_of_sexp_atom_needed = "int64_of_sexp: atom needed",
    cst_int32_of_sexp = "int32_of_sexp: ",
    cst_int32_of_sexp_atom_needed = "int32_of_sexp: atom needed",
    cst_float_of_sexp = "float_of_sexp: ",
    cst_float_of_sexp_atom_needed = "float_of_sexp: atom needed",
    cst_int_of_sexp = "int_of_sexp: ",
    cst_int_of_sexp_atom_needed = "int_of_sexp: atom needed",
    cst_char_of_sexp_atom_string_m =
      "char_of_sexp: atom string must contain one character only",
    cst_char_of_sexp_atom_needed = "char_of_sexp: atom needed",
    cst_bytes_of_sexp_atom_needed = "bytes_of_sexp: atom needed",
    cst_string_of_sexp_atom_needed = "string_of_sexp: atom needed",
    cst_bool_of_sexp_unknown_strin = "bool_of_sexp: unknown string",
    cst_bool_of_sexp_atom_needed = "bool_of_sexp: atom needed",
    cst_unit_of_sexp_empty_list_ne = "unit_of_sexp: empty list needed",
    _i_ = [0, 2],
    _h_ = [0, 2],
    _f_ = [0, "<fun>"],
    _e_ = [0, "<opaque>"],
    _b_ = [0, cst_some],
    _c_ = [1, 0],
    _d_ = [0, cst_none],
    _a_ = [1, 0],
    default_string_of_float =
      [0,
       function(x){
        var y = caml_format_float("%.15G", x);
        return caml_float_of_string(y) == x
                ? y
                : caml_format_float("%.17G", x);
       }],
    read_old_option_format = [0, 1],
    write_old_option_format = [0, 1];
   function list_map(f, l){
    var _bo_ = caml_call2(Stdlib_ListLabels[21], f, l);
    return caml_call1(Stdlib_ListLabels[9], _bo_);
   }
   function sexp_of_unit(param){return _a_;}
   function sexp_of_bool(b){return [0, caml_call1(Stdlib[30], b)];}
   function sexp_of_string(str){return [0, str];}
   function sexp_of_bytes(bytes){
    return [0, caml_call1(Stdlib_BytesLabels[6], bytes)];
   }
   function sexp_of_char(c){
    return [0, caml_call2(Stdlib_StringLabels[1], 1, c)];
   }
   function sexp_of_int(n){return [0, caml_call1(Stdlib[33], n)];}
   function sexp_of_float(n){
    return [0, caml_call1(default_string_of_float[1], n)];
   }
   function sexp_of_int32(n){return [0, caml_call1(Stdlib_Int32[14], n)];}
   function sexp_of_int64(n){return [0, caml_call1(Stdlib_Int64[14], n)];}
   function sexp_of_nativeint(n){
    return [0, caml_call1(Stdlib_Nativeint[15], n)];
   }
   function sexp_of_ref(sexp_of_a, rf){return caml_call1(sexp_of_a, rf[1]);}
   function sexp_of_lazy_t(sexp_of_a, lv){
    var
     _bm_ = runtime.caml_obj_tag(lv),
     _bn_ =
       250 === _bm_
        ? lv[1]
        : 246 === _bm_ ? caml_call1(CamlinternalLazy[2], lv) : lv;
    return caml_call1(sexp_of_a, _bn_);
   }
   function sexp_of_option(sexp_of_a, param){
    if(! param) return write_old_option_format[1] ? _c_ : _d_;
    var x = param[1];
    return write_old_option_format[1]
            ? [1, [0, caml_call1(sexp_of_a, x), 0]]
            : [1, [0, _b_, [0, caml_call1(sexp_of_a, x), 0]]];
   }
   function sexp_of_pair(sexp_of_a, sexp_of_b, param){
    var b = param[2], a = param[1], _bl_ = [0, caml_call1(sexp_of_b, b), 0];
    return [1, [0, caml_call1(sexp_of_a, a), _bl_]];
   }
   function sexp_of_triple(sexp_of_a, sexp_of_b, sexp_of_c, param){
    var
     c = param[3],
     b = param[2],
     a = param[1],
     _bj_ = [0, caml_call1(sexp_of_c, c), 0],
     _bk_ = [0, caml_call1(sexp_of_b, b), _bj_];
    return [1, [0, caml_call1(sexp_of_a, a), _bk_]];
   }
   function sexp_of_list(sexp_of_a, lst){
    var _bi_ = caml_call2(Stdlib_ListLabels[21], sexp_of_a, lst);
    return [1, caml_call1(Stdlib_ListLabels[9], _bi_)];
   }
   function sexp_of_array(sexp_of_a, ar){
    var lst_ref = [0, 0], _bf_ = ar.length - 1 - 1 | 0;
    if(_bf_ >= 0){
     var i = _bf_;
     for(;;){
      var _bg_ = lst_ref[1];
      lst_ref[1] =
       [0, caml_call1(sexp_of_a, caml_check_bound(ar, i)[1 + i]), _bg_];
      var _bh_ = i - 1 | 0;
      if(0 === i) break;
      var i = _bh_;
     }
    }
    return [1, lst_ref[1]];
   }
   function sexp_of_hashtbl(sexp_of_key, sexp_of_val, htbl){
    function coll(k, v, acc){
     var _be_ = [0, caml_call1(sexp_of_val, v), 0];
     return [0, [1, [0, caml_call1(sexp_of_key, k), _be_]], acc];
    }
    return [1, caml_call3(Stdlib_MoreLabels[1][14], coll, htbl, 0)];
   }
   function sexp_of_opaque(param){return _e_;}
   function sexp_of_fun(param){return _f_;}
   function equal(_bd_, _bc_){return _bd_ === _bc_ ? 1 : 0;}
   var
    hash = Stdlib_Obj[22][3],
    Exn_table = caml_call1(Stdlib_Ephemeron[1][16], [0, equal, hash]),
    the_exn_table = caml_call1(Exn_table[1], 17);
   function add(opt, param, extension_constructor, sexp_of_exn){
    if(opt) var sth = opt[1], printexc = sth; else var printexc = 1;
    return caml_call3
            (Exn_table[5],
             the_exn_table,
             extension_constructor,
             [0, sexp_of_exn, printexc]);
   }
   function find_auto(for_printexc, exn){
    var
     extension_constructor = caml_call1(Stdlib_Obj[22][1], exn),
     match = caml_call2(Exn_table[8], the_exn_table, extension_constructor);
    if(! match) return 0;
    var match$0 = match[1], printexc = match$0[2], sexp_of_exn = match$0[1];
    if(for_printexc && ! printexc) return 0;
    return [0, caml_call1(sexp_of_exn, exn)];
   }
   function size(param){return caml_call1(Exn_table[24], the_exn_table)[1];}
   var For_unit_tests_only = [0, size];
   function sexp_of_exn_opt(exn){return find_auto(0, exn);}
   function sexp_of_exn(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return [1, [0, [0, caml_call1(Stdlib_Printexc[1], exn)], 0]];
    var sexp = match[1];
    return sexp;
   }
   function exn_to_string(e){
    var _bb_ = sexp_of_exn(e);
    return caml_call2(Sexplib0_Sexp[13], 0, _bb_);
   }
   function _g_(exn){
    var match = find_auto(1, exn);
    if(! match) return 0;
    var sexp = match[1];
    return [0, caml_call2(Sexplib0_Sexp[13], _h_, sexp)];
   }
   caml_call1(Stdlib_Printexc[9], _g_);
   function printexc_prefer_sexp(exn){
    var match = sexp_of_exn_opt(exn);
    if(! match) return caml_call1(Stdlib_Printexc[1], exn);
    var sexp = match[1];
    return caml_call2(Sexplib0_Sexp[13], _i_, sexp);
   }
   var Of_sexp_error = Sexplib0_Sexp[6], record_check_extra_fields = [0, 1];
   function of_sexp_error_exn(exc, sexp){
    throw caml_maybe_attach_backtrace([0, Of_sexp_error, exc, sexp], 1);
   }
   function of_sexp_error(what, sexp){
    throw caml_maybe_attach_backtrace
           ([0, Of_sexp_error, [0, Stdlib[7], what], sexp], 1);
   }
   function unit_of_sexp(sexp){
    if(1 === sexp[0] && ! sexp[1]) return 0;
    return of_sexp_error(cst_unit_of_sexp_empty_list_ne, sexp);
   }
   function bool_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bool_of_sexp_atom_needed, sexp);
    var _ba_ = sexp[1];
    a:
    if(caml_string_notequal(_ba_, "False")){
     if(caml_string_notequal(_ba_, "True")){
      if(! caml_string_notequal(_ba_, "false")) break a;
      if(caml_string_notequal(_ba_, "true"))
       return of_sexp_error(cst_bool_of_sexp_unknown_strin, sexp);
     }
     return 1;
    }
    return 0;
   }
   function string_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_string_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return str;
   }
   function bytes_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_bytes_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    return caml_call1(Stdlib_BytesLabels[5], str);
   }
   function char_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_char_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    if(1 !== runtime.caml_ml_string_length(str))
     of_sexp_error(cst_char_of_sexp_atom_string_m, sexp);
    return runtime.caml_string_get(str, 0);
   }
   function int_of_sexp(sexp){
    if(0 !== sexp[0]) return of_sexp_error(cst_int_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a$_ = caml_int_of_string(str); return _a$_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a__ = exn_to_string(exc);
     return of_sexp_error(caml_call2(Stdlib[28], cst_int_of_sexp, _a__), sexp);
    }
   }
   function float_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_float_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a9_ = caml_float_of_string(str); return _a9_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a8_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_float_of_sexp, _a8_), sexp);
    }
   }
   function int32_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int32_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a7_ = caml_int_of_string(str); return _a7_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a6_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int32_of_sexp, _a6_), sexp);
    }
   }
   function int64_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_int64_of_sexp_atom_needed, sexp);
    var str = sexp[1];
    try{var _a5_ = runtime.caml_int64_of_string(str); return _a5_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a4_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_int64_of_sexp, _a4_), sexp);
    }
   }
   function nativeint_of_sexp(sexp){
    if(0 !== sexp[0])
     return of_sexp_error(cst_nativeint_of_sexp_atom_nee, sexp);
    var str = sexp[1];
    try{var _a3_ = caml_int_of_string(str); return _a3_;}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0), _a2_ = exn_to_string(exc);
     return of_sexp_error
             (caml_call2(Stdlib[28], cst_nativeint_of_sexp, _a2_), sexp);
    }
   }
   function ref_of_sexp(a_of_sexp, sexp){
    return [0, caml_call1(a_of_sexp, sexp)];
   }
   function lazy_t_of_sexp(a_of_sexp, sexp){
    var _a1_ = caml_call1(a_of_sexp, sexp);
    return caml_call1(Stdlib_Lazy[4], _a1_);
   }
   function option_of_sexp(a_of_sexp, sexp){
    if(! read_old_option_format[1]){
     if(0 === sexp[0]){
      var _aW_ = sexp[1];
      if
       (caml_string_notequal(_aW_, cst_None)
        && caml_string_notequal(_aW_, cst_none))
       return of_sexp_error(cst_option_of_sexp_only_none_c$0, sexp);
      return 0;
     }
     var _aX_ = sexp[1];
     a:
     if(_aX_){
      var _aY_ = _aX_[1];
      if(0 === _aY_[0]){
       var _aZ_ = _aY_[1];
       if
        (caml_string_notequal(_aZ_, cst_Some)
         && caml_string_notequal(_aZ_, cst_some))
        break a;
       var _a0_ = _aX_[2];
       if(_a0_ && ! _a0_[2]){
        var el$0 = _a0_[1];
        return [0, caml_call1(a_of_sexp, el$0)];
       }
      }
     }
     return of_sexp_error(cst_option_of_sexp_list_must_b, sexp);
    }
    if(0 === sexp[0]){
     var _aR_ = sexp[1];
     if
      (caml_string_notequal(_aR_, cst_None)
       && caml_string_notequal(_aR_, cst_none))
      return of_sexp_error(cst_option_of_sexp_only_none_c, sexp);
    }
    else{
     var _aS_ = sexp[1];
     if(_aS_){
      var _aT_ = _aS_[1];
      a:
      {
       if(_aS_[2]){
        b:
        if(0 === _aT_[0]){
         var _aU_ = _aT_[1];
         if
          (caml_string_notequal(_aU_, cst_Some)
           && caml_string_notequal(_aU_, cst_some))
          break b;
         var _aV_ = _aS_[2];
         if(! _aV_[2]){var el = _aV_[1]; break a;}
        }
        return of_sexp_error(cst_option_of_sexp_list_must_r, sexp);
       }
       var el = _aT_;
      }
      return [0, caml_call1(a_of_sexp, el)];
     }
    }
    return 0;
   }
   function pair_of_sexp(a_of_sexp, b_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_pair_of_sexp_list_needed, sexp);
    var _aP_ = sexp[1];
    if(_aP_){
     var _aQ_ = _aP_[2];
     if(_aQ_ && ! _aQ_[2]){
      var
       b_sexp = _aQ_[1],
       a_sexp = _aP_[1],
       a = caml_call1(a_of_sexp, a_sexp),
       b = caml_call1(b_of_sexp, b_sexp);
      return [0, a, b];
     }
    }
    return of_sexp_error(cst_pair_of_sexp_list_must_con, sexp);
   }
   function triple_of_sexp(a_of_sexp, b_of_sexp, c_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_triple_of_sexp_list_needed, sexp);
    var _aM_ = sexp[1];
    if(_aM_){
     var _aN_ = _aM_[2];
     if(_aN_){
      var _aO_ = _aN_[2];
      if(_aO_ && ! _aO_[2]){
       var
        c_sexp = _aO_[1],
        b_sexp = _aN_[1],
        a_sexp = _aM_[1],
        a = caml_call1(a_of_sexp, a_sexp),
        b = caml_call1(b_of_sexp, b_sexp),
        c = caml_call1(c_of_sexp, c_sexp);
       return [0, a, b, c];
      }
     }
    }
    return of_sexp_error(cst_triple_of_sexp_list_must_c, sexp);
   }
   function list_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_list_of_sexp_list_needed, sexp);
    var
     lst = sexp[1],
     rev_lst = caml_call2(Stdlib_ListLabels[21], a_of_sexp, lst);
    return caml_call1(Stdlib_ListLabels[9], rev_lst);
   }
   function array_of_sexp(a_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_array_of_sexp_list_needed, sexp);
    var match = sexp[1];
    if(! match) return [0];
    var
     t = match[2],
     h = match[1],
     len = caml_call1(Stdlib_ListLabels[1], t) + 1 | 0,
     res = runtime.caml_make_vect(len, caml_call1(a_of_sexp, h)),
     i = 1,
     param = t;
    for(;;){
     if(! param) return res;
     var t$0 = param[2], h$0 = param[1], _aL_ = caml_call1(a_of_sexp, h$0);
     caml_check_bound(res, i)[1 + i] = _aL_;
     var i$0 = i + 1 | 0, i = i$0, param = t$0;
    }
   }
   function hashtbl_of_sexp(key_of_sexp, val_of_sexp, sexp){
    if(0 === sexp[0])
     return of_sexp_error(cst_hashtbl_of_sexp_list_neede, sexp);
    var lst = sexp[1], htbl = caml_call2(Stdlib_MoreLabels[1][1], 0, 0);
    function act(param){
     if(1 === param[0]){
      var _aH_ = param[1];
      if(_aH_){
       var _aI_ = _aH_[2];
       if(_aI_ && ! _aI_[2]){
        var
         v_sexp = _aI_[1],
         k_sexp = _aH_[1],
         _aJ_ = caml_call1(val_of_sexp, v_sexp),
         _aK_ = caml_call1(key_of_sexp, k_sexp);
        return caml_call3(Stdlib_MoreLabels[1][5], htbl, _aK_, _aJ_);
       }
      }
     }
     return of_sexp_error(cst_hashtbl_of_sexp_tuple_list, sexp);
    }
    caml_call2(Stdlib_ListLabels[17], act, lst);
    return htbl;
   }
   function opaque_of_sexp(sexp){
    return of_sexp_error(cst_opaque_of_sexp_cannot_conv, sexp);
   }
   function fun_of_sexp(sexp){
    return of_sexp_error(cst_fun_of_sexp_cannot_convert, sexp);
   }
   var
    sexp_grammar_with_tags = Sexplib0_Sexp_conv_grammar[1],
    sexp_grammar_with_tag_list = Sexplib0_Sexp_conv_grammar[2],
    unit_sexp_grammar = Sexplib0_Sexp_conv_grammar[3],
    bool_sexp_grammar = Sexplib0_Sexp_conv_grammar[4],
    string_sexp_grammar = Sexplib0_Sexp_conv_grammar[5],
    bytes_sexp_grammar = Sexplib0_Sexp_conv_grammar[6],
    char_sexp_grammar = Sexplib0_Sexp_conv_grammar[7],
    int_sexp_grammar = Sexplib0_Sexp_conv_grammar[8],
    float_sexp_grammar = Sexplib0_Sexp_conv_grammar[9],
    int32_sexp_grammar = Sexplib0_Sexp_conv_grammar[10],
    int64_sexp_grammar = Sexplib0_Sexp_conv_grammar[11],
    nativeint_sexp_grammar = Sexplib0_Sexp_conv_grammar[12],
    sexp_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[13],
    ref_sexp_grammar = Sexplib0_Sexp_conv_grammar[14],
    lazy_t_sexp_grammar = Sexplib0_Sexp_conv_grammar[15],
    option_sexp_grammar = Sexplib0_Sexp_conv_grammar[16],
    list_sexp_grammar = Sexplib0_Sexp_conv_grammar[17],
    array_sexp_grammar = Sexplib0_Sexp_conv_grammar[18],
    opaque_sexp_grammar = Sexplib0_Sexp_conv_grammar[19],
    fun_sexp_grammar = Sexplib0_Sexp_conv_grammar[20];
   function get_flc_error(name, param){
    var chr = param[3], line = param[2], file = param[1];
    return [0, caml_call5(Stdlib_Printf[4], _j_, name, file, line, chr)];
   }
   var _k_ = 0;
   function _l_(param){
    if(param === Stdlib_Sys[44]) return _m_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
   }
   var _o_ = [0, [0, Stdlib_Sys[44], _l_], _k_];
   function _p_(param){
    if(param === Stdlib_Stack[1]) return _q_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _r_], 1);
   }
   var _s_ = [0, [0, Stdlib_Stack[1], _p_], _o_];
   function _t_(param){
    if(param[1] !== Stdlib_Scanf[2])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _v_], 1);
    var arg = param[2];
    return [1, [0, _u_, [0, [0, arg], 0]]];
   }
   var _w_ = [0, [0, Stdlib_Scanf[2], _t_], _s_];
   function _x_(param){
    if(param === Stdlib_Queue[1]) return _y_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _z_], 1);
   }
   var _A_ = [0, [0, Stdlib_Queue[1], _x_], _w_];
   function _B_(param){
    if(param === Stdlib_Parsing[10]) return _C_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _D_], 1);
   }
   var _E_ = [0, [0, Stdlib_Parsing[10], _B_], _A_];
   function _F_(param){
    if(param === Stdlib_Lazy[1]) return _G_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
   }
   var _I_ = [0, [0, Stdlib_Lazy[1], _F_], _E_];
   function _J_(param){
    if(param[1] !== Stdlib_Arg[8])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _L_], 1);
    var arg = param[2];
    return [1, [0, _K_, [0, [0, arg], 0]]];
   }
   var _M_ = [0, [0, Stdlib_Arg[8], _J_], _I_];
   function _N_(param){
    if(param[1] !== Stdlib_Arg[7])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
    var arg = param[2];
    return [1, [0, _O_, [0, [0, arg], 0]]];
   }
   var _Q_ = [0, [0, Stdlib_Arg[7], _N_], _M_];
   function _R_(param){
    if(param[1] !== Stdlib[11])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _T_], 1);
    var arg = param[2];
    return [1, [0, _S_, [0, [0, arg], 0]]];
   }
   var _U_ = [0, [0, Stdlib[11], _R_], _Q_];
   function _V_(param){
    if(param[1] !== Sexplib0_Sexp[5])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _X_], 1);
    var arg = param[2];
    return [1, [0, _W_, [0, arg, 0]]];
   }
   var _Y_ = [0, [0, Sexplib0_Sexp[5], _V_], _U_];
   function _Z_(param){
    if(param[1] !== Stdlib[4])
     throw caml_maybe_attach_backtrace([0, Assert_failure, ___], 1);
    var arg = param[2];
    return get_flc_error(cst_Match_failure, arg);
   }
   var _$_ = [0, [0, Stdlib[4], _Z_], _Y_];
   function _aa_(param){
    if(param[1] !== Stdlib[6])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ac_], 1);
    var arg = param[2];
    return [1, [0, _ab_, [0, [0, arg], 0]]];
   }
   var _ad_ = [0, [0, Stdlib[6], _aa_], _$_];
   function _ae_(param){
    if(param === Stdlib[8]) return _af_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ag_], 1);
   }
   var _ah_ = [0, [0, Stdlib[8], _ae_], _ad_];
   function _ai_(param){
    if(param[1] !== Stdlib[7])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _ak_], 1);
    var arg = param[2];
    return [1, [0, _aj_, [0, [0, arg], 0]]];
   }
   var _al_ = [0, [0, Stdlib[7], _ai_], _ah_];
   function _am_(param){
    if(param === Stdlib[12]) return _an_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _ao_], 1);
   }
   var _ap_ = [0, [0, Stdlib[12], _am_], _al_];
   function _aq_(param){
    if(param === Stdlib[3]) return _ar_;
    throw caml_maybe_attach_backtrace([0, Assert_failure, _as_], 1);
   }
   var _at_ = [0, [0, Stdlib[3], _aq_], _ap_];
   function _au_(param){
    if(param[1] !== Stdlib[5])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _av_], 1);
    var arg = param[2];
    return get_flc_error(cst_Assert_failure, arg);
   }
   var _aw_ = [0, [0, Stdlib[5], _au_], _at_];
   function _ax_(param){
    var handler = param[2], extension_constructor = param[1];
    return add(_az_, _ay_, extension_constructor, handler);
   }
   caml_call2(Stdlib_ListLabels[17], _ax_, _aw_);
   var
    _aA_ = 0,
    _aD_ =
      [0,
       [0,
        Of_sexp_error,
        function(param){
         if(param[1] !== Of_sexp_error)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _aC_], 1);
         var sexp = param[3], exc = param[2];
         return [1, [0, _aB_, [0, sexp_of_exn(exc), [0, sexp, 0]]]];
        }],
       _aA_];
   function _aE_(param){
    var handler = param[2], extension_constructor = param[1];
    return add(_aG_, _aF_, extension_constructor, handler);
   }
   caml_call2(Stdlib_ListLabels[17], _aE_, _aD_);
   var
    Sexplib0_Sexp_conv =
      [0,
       default_string_of_float,
       write_old_option_format,
       read_old_option_format,
       list_map,
       sexp_of_unit,
       sexp_of_bool,
       sexp_of_string,
       sexp_of_bytes,
       sexp_of_char,
       sexp_of_int,
       sexp_of_float,
       sexp_of_int32,
       sexp_of_int64,
       sexp_of_nativeint,
       sexp_of_ref,
       sexp_of_lazy_t,
       sexp_of_option,
       sexp_of_pair,
       sexp_of_triple,
       sexp_of_list,
       sexp_of_array,
       sexp_of_hashtbl,
       sexp_of_opaque,
       sexp_of_fun,
       Of_sexp_error,
       record_check_extra_fields,
       of_sexp_error,
       of_sexp_error_exn,
       unit_of_sexp,
       bool_of_sexp,
       string_of_sexp,
       bytes_of_sexp,
       char_of_sexp,
       int_of_sexp,
       float_of_sexp,
       int32_of_sexp,
       int64_of_sexp,
       nativeint_of_sexp,
       ref_of_sexp,
       lazy_t_of_sexp,
       option_of_sexp,
       pair_of_sexp,
       triple_of_sexp,
       list_of_sexp,
       array_of_sexp,
       hashtbl_of_sexp,
       opaque_of_sexp,
       fun_of_sexp,
       sexp_grammar_with_tags,
       sexp_grammar_with_tag_list,
       unit_sexp_grammar,
       bool_sexp_grammar,
       string_sexp_grammar,
       bytes_sexp_grammar,
       char_sexp_grammar,
       int_sexp_grammar,
       float_sexp_grammar,
       int32_sexp_grammar,
       int64_sexp_grammar,
       nativeint_sexp_grammar,
       sexp_t_sexp_grammar,
       ref_sexp_grammar,
       lazy_t_sexp_grammar,
       option_sexp_grammar,
       list_sexp_grammar,
       array_sexp_grammar,
       opaque_sexp_grammar,
       fun_sexp_grammar,
       sexp_of_exn,
       printexc_prefer_sexp,
       sexp_of_exn_opt,
       [0, add, For_unit_tests_only]];
   runtime.caml_register_global
    (117, Sexplib0_Sexp_conv, "Sexplib0__Sexp_conv");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_error
//# unitInfo: Requires: Sexplib0__Sexp_conv, Stdlib, Stdlib__ListLabels, Stdlib__Printf, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = " ",
    cst_has_incorrect_number_of_ar = " has incorrect number of arguments",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Stdlib = global_data.Stdlib,
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Of_sexp_error = Sexplib0_Sexp_conv[25],
    cst_of_sexp_trying_to_convert_ =
      "_of_sexp: trying to convert an empty type",
    cst_of_sexp_the_empty_list_is_ =
      "_of_sexp: the empty list is an invalid polymorphic variant",
    cst_of_sexp_a_nested_list_is_a =
      "_of_sexp: a nested list is an invalid polymorphic variant",
    cst_of_sexp_polymorphic_varian$0 =
      "_of_sexp: polymorphic variant tag takes an argument",
    _e_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: polymorphic variant tag ",
         [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]]],
       "%s_of_sexp: polymorphic variant tag %S has incorrect number of arguments"],
    cst_of_sexp_polymorphic_varian =
      "_of_sexp: polymorphic variant does not take arguments",
    cst_of_sexp_no_matching_varian = "_of_sexp: no matching variant found",
    cst_of_sexp_cannot_convert_val =
      "_of_sexp: cannot convert values of types resulting from polymorphic record fields",
    cst_of_sexp_list_instead_of_at =
      "_of_sexp: list instead of atom for record expected",
    _d_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: the following record elements were undefined: ",
         [2, 0, 0]]],
       "%s_of_sexp: the following record elements were undefined: %s"],
    cst_extra_fields = "extra fields",
    cst_duplicate_fields = "duplicate fields",
    _c_ =
      [0,
       [2, 0, [11, "_of_sexp: ", [2, 0, [11, ": ", [2, 0, 0]]]]],
       "%s_of_sexp: %s: %s"],
    cst_of_sexp_record_conversion_$0 =
      "_of_sexp: record conversion: only pairs expected, their first element must be an atom",
    cst_of_sexp_record_conversion_ =
      "_of_sexp: record conversion: a [sexp.bool] field was given a payload.",
    cst_of_sexp_unexpected_variant =
      "_of_sexp: unexpected variant constructor",
    cst_of_sexp_expected_a_variant$0 =
      "_of_sexp: expected a variant type, saw an empty list",
    cst_of_sexp_expected_a_variant =
      "_of_sexp: expected a variant type, saw a nested list",
    cst_of_sexp_this_constructor_r =
      "_of_sexp: this constructor requires arguments",
    _b_ =
      [0,
       [2,
        0,
        [11,
         "_of_sexp: sum tag ",
         [3, 0, [11, cst_has_incorrect_number_of_ar, 0]]]],
       "%s_of_sexp: sum tag %S has incorrect number of arguments"],
    cst_of_sexp_this_constructor_d =
      "_of_sexp: this constructor does not take arguments",
    _a_ =
      [0,
       [2,
        0,
        [11, "_of_sexp: tuple of size ", [4, 0, 0, 0, [11, " expected", 0]]]],
       "%s_of_sexp: tuple of size %d expected"],
    cst_Sexplib0_Sexp_conv_error_N =
      "Sexplib0__Sexp_conv_error.No_variant_match";
   function tuple_of_size_n_expected(loc, n, sexp){
    var _t_ = caml_call3(Stdlib_Printf[4], _a_, loc, n);
    return caml_call2(Sexplib0_Sexp_conv[27], _t_, sexp);
   }
   function stag_no_args(loc, sexp){
    var _s_ = caml_call2(Stdlib[28], loc, cst_of_sexp_this_constructor_d);
    return caml_call2(Sexplib0_Sexp_conv[27], _s_, sexp);
   }
   function stag_incorrect_n_args(loc, tag, sexp){
    var msg = caml_call3(Stdlib_Printf[4], _b_, loc, tag);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function stag_takes_args(loc, sexp){
    var _r_ = caml_call2(Stdlib[28], loc, cst_of_sexp_this_constructor_r);
    return caml_call2(Sexplib0_Sexp_conv[27], _r_, sexp);
   }
   function nested_list_invalid_sum(loc, sexp){
    var _q_ = caml_call2(Stdlib[28], loc, cst_of_sexp_expected_a_variant);
    return caml_call2(Sexplib0_Sexp_conv[27], _q_, sexp);
   }
   function empty_list_invalid_sum(loc, sexp){
    var _p_ = caml_call2(Stdlib[28], loc, cst_of_sexp_expected_a_variant$0);
    return caml_call2(Sexplib0_Sexp_conv[27], _p_, sexp);
   }
   function unexpected_stag(loc, sexp){
    var _o_ = caml_call2(Stdlib[28], loc, cst_of_sexp_unexpected_variant);
    return caml_call2(Sexplib0_Sexp_conv[27], _o_, sexp);
   }
   function record_sexp_bool_with_payload(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_record_conversion_);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_only_pairs_expected(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_record_conversion_$0);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_superfluous_fields(what, loc, rev_fld_names, sexp){
    var
     _n_ = caml_call1(Stdlib_ListLabels[9], rev_fld_names),
     fld_names_str = caml_call2(Stdlib_StringLabels[6], cst, _n_),
     msg = caml_call4(Stdlib_Printf[4], _c_, loc, what, fld_names_str);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_duplicate_fields(loc, rev_fld_names, sexp){
    return record_superfluous_fields
            (cst_duplicate_fields, loc, rev_fld_names, sexp);
   }
   function record_extra_fields(loc, rev_fld_names, sexp){
    return record_superfluous_fields
            (cst_extra_fields, loc, rev_fld_names, sexp);
   }
   function record_get_undefined_loop(fields, param){
    var fields$0 = fields, param$0 = param;
    for(;;){
     if(! param$0){
      var _m_ = caml_call1(Stdlib_ListLabels[9], fields$0);
      return caml_call2(Stdlib_StringLabels[6], cst$0, _m_);
     }
     var _l_ = param$0[1];
     if(_l_[1])
      var
       rest = param$0[2],
       field = _l_[2],
       fields$1 = [0, field, fields$0],
       fields$0 = fields$1,
       param$0 = rest;
     else
      var rest$0 = param$0[2], param$0 = rest$0;
    }
   }
   function record_undefined_elements(loc, sexp, lst){
    var
     undefined$0 = record_get_undefined_loop(0, lst),
     msg = caml_call3(Stdlib_Printf[4], _d_, loc, undefined$0);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_list_instead_atom(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_list_instead_of_at);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function record_poly_field_value(loc, sexp){
    var msg = caml_call2(Stdlib[28], loc, cst_of_sexp_cannot_convert_val);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   var
    No_variant_match =
      [248, cst_Sexplib0_Sexp_conv_error_N, runtime.caml_fresh_oo_id(0)];
   function no_variant_match(param){
    throw caml_maybe_attach_backtrace(No_variant_match, 1);
   }
   function no_matching_variant_found(loc, sexp){
    var _k_ = caml_call2(Stdlib[28], loc, cst_of_sexp_no_matching_varian);
    return caml_call2(Sexplib0_Sexp_conv[27], _k_, sexp);
   }
   function ptag_no_args(loc, sexp){
    var _j_ = caml_call2(Stdlib[28], loc, cst_of_sexp_polymorphic_varian);
    return caml_call2(Sexplib0_Sexp_conv[27], _j_, sexp);
   }
   function ptag_incorrect_n_args(loc, cnstr, sexp){
    var msg = caml_call3(Stdlib_Printf[4], _e_, loc, cnstr);
    return caml_call2(Sexplib0_Sexp_conv[27], msg, sexp);
   }
   function ptag_takes_args(loc, sexp){
    var _i_ = caml_call2(Stdlib[28], loc, cst_of_sexp_polymorphic_varian$0);
    return caml_call2(Sexplib0_Sexp_conv[27], _i_, sexp);
   }
   function nested_list_invalid_poly_var(loc, sexp){
    var _h_ = caml_call2(Stdlib[28], loc, cst_of_sexp_a_nested_list_is_a);
    return caml_call2(Sexplib0_Sexp_conv[27], _h_, sexp);
   }
   function empty_list_invalid_poly_var(loc, sexp){
    var _g_ = caml_call2(Stdlib[28], loc, cst_of_sexp_the_empty_list_is_);
    return caml_call2(Sexplib0_Sexp_conv[27], _g_, sexp);
   }
   function empty_type(loc, sexp){
    var _f_ = caml_call2(Stdlib[28], loc, cst_of_sexp_trying_to_convert_);
    return caml_call2(Sexplib0_Sexp_conv[27], _f_, sexp);
   }
   var
    Sexplib0_Sexp_conv_error =
      [0,
       Of_sexp_error,
       tuple_of_size_n_expected,
       stag_no_args,
       stag_incorrect_n_args,
       stag_takes_args,
       nested_list_invalid_sum,
       empty_list_invalid_sum,
       unexpected_stag,
       record_sexp_bool_with_payload,
       record_only_pairs_expected,
       record_superfluous_fields,
       record_duplicate_fields,
       record_extra_fields,
       record_get_undefined_loop,
       record_undefined_elements,
       record_list_instead_atom,
       record_poly_field_value,
       No_variant_match,
       no_variant_match,
       no_matching_variant_found,
       ptag_no_args,
       ptag_incorrect_n_args,
       ptag_takes_args,
       nested_list_invalid_poly_var,
       empty_list_invalid_poly_var,
       empty_type];
   runtime.caml_register_global
    (30, Sexplib0_Sexp_conv_error, "Sexplib0__Sexp_conv_error");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexp_conv_record
//# unitInfo: Requires: Sexplib0__Sexp_conv, Sexplib0__Sexp_conv_error, Stdlib, Stdlib__ArrayLabels, Stdlib__ListLabels, Stdlib__Option, Stdlib__StringLabels
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    absent = [0, ""],
    Sexplib0_Sexp_conv = global_data.Sexplib0__Sexp_conv,
    Stdlib_StringLabels = global_data.Stdlib__StringLabels,
    Sexplib0_Sexp_conv_error = global_data.Sexplib0__Sexp_conv_error,
    Stdlib_ListLabels = global_data.Stdlib__ListLabels,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib = global_data.Stdlib,
    Kind = [0],
    _a_ = [1, 0],
    _b_ = [3, 0],
    cst_Sexplib0_Sexp_conv_record_ = "Sexplib0__Sexp_conv_record.Malformed";
   function combine(a, b){
    a:
    if(typeof a !== "number"){
     b:
     {
      c:
      {
       d:
       {
        e:
        switch(a[0]){
          case 0:
           var a$0 = a[1];
           if(typeof b !== "number")
            switch(b[0]){
              case 3: break;
              case 0:
               var b$0 = b[1]; return [0, caml_call2(Stdlib[37], a$0, b$0)];
              case 1:
               break d;
              default: var t$0 = a; break e;
            }
           break b;
          case 1:
           var a$1 = a[1];
           if(typeof b !== "number")
            switch(b[0]){
              case 3: break;
              case 1:
               var b$1 = b[1]; return [1, caml_call2(Stdlib[37], a$1, b$1)];
              default: var t = a; break c;
            }
           break b;
          case 2:
           var a$2 = a[1];
           if(typeof b !== "number")
            switch(b[0]){
              case 3: break;
              case 0:
               var t$0 = b; break e;
              case 1:
               break d;
              default:
               var b$2 = b[1]; return [2, caml_call2(Stdlib[37], a$2, b$2)];
            }
           break b;
          default: break a;
        }
        return t$0;
       }
       var t = b;
      }
      return t;
     }
     return b;
    }
    return a;
   }
   var
    Malformed =
      [248, cst_Sexplib0_Sexp_conv_record_, runtime.caml_fresh_oo_id(0)];
   function parse_value_malformed(malformed, fields, state, pos){
    try{
     parse_values(fields[4], state, pos + 1 | 0);
     var malformed$0 = malformed;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var other = exn[2], malformed$0 = combine(malformed, other);
    }
    throw caml_maybe_attach_backtrace([0, Malformed, malformed$0], 1);
   }
   function parse_values(fields, state, pos){
    if(! fields) return 0;
    var
     rest = fields[4],
     conv = fields[3],
     kind = fields[2],
     name = fields[1],
     sexp = state[1 + pos];
    a:
    {
     b:
     {
      if(typeof kind !== "number"){
       var default$0 = kind[1];
       if(0 === sexp[0])
        var _H_ = caml_call1(default$0, 0);
       else{
        var _I_ = sexp[1];
        if(! _I_) break b;
        var _J_ = _I_[2];
        if(! _J_) break b;
        if(_J_[2]) break b;
        var sexp$5 = _J_[1], _H_ = caml_call1(conv, sexp$5);
       }
       var value = _H_;
       break a;
      }
      switch(kind){
        case 0:
         if(0 === sexp[0]){var value = caml_call1(conv, _a_); break a;}
         var _t_ = sexp[1];
         if(_t_){
          var _u_ = _t_[2];
          if(_u_ && ! _u_[2]){
           var sexp$0 = _u_[1], value = caml_call1(conv, sexp$0);
           break a;
          }
         }
         break;
        case 1:
         if(0 === sexp[0]){
          var
           value =
             parse_value_malformed([2, [0, name, 0]], fields, state, pos);
          break a;
         }
         var _x_ = sexp[1];
         if(_x_){
          var _y_ = _x_[2];
          if(_y_ && ! _y_[2]){
           var sexp$1 = _y_[1], value = caml_call1(conv, sexp$1);
           break a;
          }
         }
         break;
        case 2:
         if(0 === sexp[0]){var value = [0]; break a;}
         var _z_ = sexp[1];
         if(_z_){
          var _A_ = _z_[2];
          if(_A_ && ! _A_[2]){
           var
            sexp$2 = _A_[1],
            value = caml_call2(Sexplib0_Sexp_conv[45], conv, sexp$2);
           break a;
          }
         }
         break;
        case 3:
         if(0 === sexp[0]){var value = 0; break a;}
         var _B_ = sexp[1];
         c:
         {
          if(_B_ && ! _B_[2]){var _C_ = 1; break c;}
          var _C_ = parse_value_malformed(0, fields, state, pos);
         }
         var value = _C_;
         break a;
        case 4:
         if(0 === sexp[0]){var value = 0; break a;}
         var _D_ = sexp[1];
         if(_D_){
          var _E_ = _D_[2];
          if(_E_ && ! _E_[2]){
           var
            sexp$3 = _E_[1],
            value = caml_call2(Sexplib0_Sexp_conv[44], conv, sexp$3);
           break a;
          }
         }
         break;
        default:
         if(0 === sexp[0]){var value = 0; break a;}
         var _F_ = sexp[1];
         if(_F_){
          var _G_ = _F_[2];
          if(_G_ && ! _G_[2]){
           var sexp$4 = _G_[1], value = [0, caml_call1(conv, sexp$4)];
           break a;
          }
         }
      }
     }
     var _v_ = sexp[1];
     b:
     {
      if(_v_ && _v_[2]){
       var _w_ = parse_value_malformed([3, [0, sexp]], fields, state, pos);
       break b;
      }
      var _w_ = parse_value_malformed(_b_, fields, state, pos);
     }
     var value = _w_;
    }
    return [0, value, parse_values(rest, state, pos + 1 | 0)];
   }
   function parse_spine_malformed
   (malformed, index, extra, seen, state, len, sexps){
    try{
     parse_spine_slow(index, extra, seen, state, len, sexps);
     var malformed$0 = malformed;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var other = exn[2], malformed$0 = combine(malformed, other);
    }
    throw caml_maybe_attach_backtrace([0, Malformed, malformed$0], 1);
   }
   function parse_spine_slow(index, extra, seen, state, len, sexps){
    var sexps$0 = sexps;
    for(;;){
     if(! sexps$0) return;
     var field = sexps$0[1];
     if(1 === field[0]){
      var _o_ = field[1];
      if(_o_){
       var match = _o_[1];
       if(0 === match[0]){
        var
         sexps$2 = sexps$0[2],
         name = match[1],
         i = caml_call1(index, name),
         _p_ = seen <= i ? 1 : 0,
         _q_ = _p_ ? i < len ? 1 : 0 : _p_;
        if(_q_){
         var pos = i - seen | 0;
         if(0 !== state[1 + pos][0])
          return parse_spine_malformed
                  ([1, [0, name, 0]], index, extra, seen, state, len, sexps$2);
         state[1 + pos] = field;
         var sexps$0 = sexps$2;
         continue;
        }
        var _r_ = 0 <= i ? 1 : 0, _s_ = _r_ ? i < seen ? 1 : 0 : _r_;
        if(_s_)
         return parse_spine_malformed
                 ([1, [0, name, 0]], index, extra, seen, state, len, sexps$2);
        if(! extra)
         return parse_spine_malformed
                 ([0, [0, name, 0]], index, extra, seen, state, len, sexps$2);
        var sexps$0 = sexps$2;
        continue;
       }
      }
     }
     var sexps$1 = sexps$0[2];
     return parse_spine_malformed
             ([3, [0, field]], index, extra, seen, state, len, sexps$1);
    }
   }
   function parse_record_slow(fields, index, extra, seen, sexps){
    var t = fields, unseen = 0;
    for(;;){
     if(! t){
      var
       state = runtime.caml_make_vect(unseen, absent),
       len = seen + unseen | 0;
      parse_spine_slow(index, extra, seen, state, len, sexps);
      return parse_values(fields, state, 0);
     }
     var rest = t[4], acc = unseen + 1 | 0, t = rest, unseen = acc;
    }
   }
   function parse_spine_fast(fields, index, extra, seen, sexps){
    if(! fields)
     return sexps ? parse_record_slow(fields, index, extra, seen, sexps) : 0;
    var
     rest = fields[4],
     conv = fields[3],
     kind = fields[2],
     name = fields[1];
    if(sexps){
     var _g_ = sexps[1];
     if(0 !== _g_[0]){
      var _h_ = _g_[1];
      if(_h_){
       var match = _h_[1];
       if(0 === match[0]){
        var others = sexps[2], args = _h_[2], atom = match[1];
        if(caml_call2(Stdlib_StringLabels[8], atom, name)){
         if(typeof kind === "number")
          switch(kind){
            case 0:
             if(args && ! args[2]){
              var
               sexp = args[1],
               _i_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, caml_call1(conv, sexp), _i_];
             }
             break;
            case 1:
             if(args && ! args[2]){
              var
               sexp$0 = args[1],
               _j_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, caml_call1(conv, sexp$0), _j_];
             }
             break;
            case 2:
             if(args && ! args[2]){
              var
               sexp$1 = args[1],
               _k_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0,
                      caml_call2(Sexplib0_Sexp_conv[45], conv, sexp$1),
                      _k_];
             }
             break;
            case 3:
             if(! args)
              return [0,
                      1,
                      parse_spine_fast(rest, index, extra, seen + 1 | 0, others)];
             break;
            case 4:
             if(args && ! args[2]){
              var
               sexp$2 = args[1],
               _l_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0,
                      caml_call2(Sexplib0_Sexp_conv[44], conv, sexp$2),
                      _l_];
             }
             break;
            default:
             if(args && ! args[2]){
              var
               sexp$3 = args[1],
               _m_ =
                 parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
              return [0, [0, caml_call1(conv, sexp$3)], _m_];
             }
          }
         else if(args && ! args[2]){
          var
           sexp$4 = args[1],
           _n_ = parse_spine_fast(rest, index, extra, seen + 1 | 0, others);
          return [0, caml_call1(conv, sexp$4), _n_];
         }
         return parse_record_slow(fields, index, extra, seen, sexps);
        }
       }
      }
     }
    }
    return parse_record_slow(fields, index, extra, seen, sexps);
   }
   function record_of_sexps
   (caller,
    context$0,
    fields,
    index_of_field,
    allow_extra_fields,
    create,
    sexps){
    var
     allow_extra_fields$0 =
       allow_extra_fields || 1 - Sexplib0_Sexp_conv[26][1];
    try{
     var
      value =
        parse_spine_fast
         (fields, index_of_field, allow_extra_fields$0, 0, sexps);
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(exn[1] !== Malformed) throw caml_maybe_attach_backtrace(exn, 0);
     var malformed = exn[2];
     if(typeof malformed === "number")
      return caml_call2(Sexplib0_Sexp_conv_error[9], caller, context$0);
     switch(malformed[0]){
       case 0:
        var
         names = malformed[1],
         _c_ = caml_call1(Stdlib_ListLabels[9], names);
        return caml_call3
                (Sexplib0_Sexp_conv_error[13], caller, _c_, context$0);
       case 1:
        var
         names$0 = malformed[1],
         _d_ = caml_call1(Stdlib_ListLabels[9], names$0);
        return caml_call3
                (Sexplib0_Sexp_conv_error[12], caller, _d_, context$0);
       case 2:
        var
         names$1 = malformed[1],
         _e_ = function(name){return [0, 1, name];},
         _f_ = caml_call2(Stdlib_ListLabels[19], _e_, names$1);
        return caml_call1
                (caml_call2(Sexplib0_Sexp_conv_error[15], caller, context$0),
                 _f_);
       default:
        var
         maybe_context = malformed[1],
         context = caml_call2(Stdlib_Option[3], maybe_context, context$0);
        return caml_call2(Sexplib0_Sexp_conv_error[10], caller, context);
     }
    }
    return caml_call1(create, value);
   }
   function record_of_sexp
   (caller, fields, index_of_field, allow_extra_fields, create, sexp){
    if(0 === sexp[0])
     return caml_call2(Sexplib0_Sexp_conv_error[16], caller, sexp);
    var sexps = sexp[1];
    return record_of_sexps
            (caller,
             sexp,
             fields,
             index_of_field,
             allow_extra_fields,
             create,
             sexps);
   }
   var
    Sexplib0_Sexp_conv_record =
      [0, Kind, [0], record_of_sexp, record_of_sexps];
   runtime.caml_register_global
    (10, Sexplib0_Sexp_conv_record, "Sexplib0__Sexp_conv_record");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0__Sexpable
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0_Sexpable = [0];
   runtime.caml_register_global(0, Sexplib0_Sexpable, "Sexplib0__Sexpable");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Sexplib0
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Sexplib0 = [0];
   runtime.caml_register_global(0, Sexplib0, "Sexplib0");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJzZXhwbGliMC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsic2V4cF9vZl90IiwidCIsInRfb2Zfc2V4cCIsImNvbXBhcmUiLCJhJDAiLCJiJDAiLCJhJDEiLCJiJDEiLCJhJDIiLCJiJDIiLCJhIiwiYiIsInlzIiwieSIsInhzIiwieCIsInJlcyIsImVxdWFsIiwiZGVmYXVsdF9pbmRlbnQiLCJtdXN0X2VzY2FwZSIsInN0ciIsImxlbiIsIml4JDEiLCJpeCIsIm5leHQiLCJuZXh0JDAiLCJpeCQwIiwiZXNjYXBlZCIsInMiLCJuIiwiaSQwIiwicyQwIiwiaSIsImMiLCJlc2Nfc3RyIiwiZXN0ciIsImVsZW4iLCJpbmRleF9vZl9uZXdsaW5lIiwic3RhcnQiLCJtYWNoX21heWJlX2VzY19zdHIiLCJwcF9odW1faW5kZW50IiwiaW5kZW50IiwicHBmIiwiaW5kZXgiLCJpbmRleCQwIiwibmV4dF9uZXdsaW5lIiwiZW5kX3BvcyIsImVuZF9wb3MkMCIsIm5leHRfbGluZSIsIm5ld2xpbmVfaW5kZXgiLCJpbmRleCQxIiwiaCIsInQkMCIsImgkMCIsInBwX21hY2hfaW50ZXJuYWwiLCJtYXlfbmVlZF9zcGFjZSIsInN0ciQwIiwibmV3X21heV9uZWVkX3NwYWNlIiwibmV3X21heV9uZWVkX3NwYWNlJDAiLCJtYXlfbmVlZF9zcGFjZSQwIiwibWF5X25lZWRfc3BhY2UkMSIsIm1heV9uZWVkX3NwYWNlJDIiLCJwcF9odW0iLCJzZXhwIiwicHBfbWFjaCIsInNpemVfbG9vcCIsImFjYyIsInYiLCJsc3QiLCJzaXplIiwidG9fYnVmZmVyX2h1bSIsImJ1ZiIsIm9wdCIsInN0aCIsInRvX2J1ZmZlcl9tYWNoIiwibG9vcCIsInRvX2J1ZmZlcl9nZW4iLCJhZGRfY2hhciIsImFkZF9zdHJpbmciLCJidWZmZXIiLCJ0b19zdHJpbmdfaHVtIiwidG9fc3RyaW5nX21hY2giLCJvZl9mbG9hdF9zdHlsZSIsIm9mX2ludF9zdHlsZSIsIm1lc3NhZ2UiLCJuYW1lIiwiZmllbGRzIiwiY29udl9maWVsZHMiLCJyZXN0IiwiZnNleHAiLCJmbmFtZSIsImRvY19jb21tZW50X3RhZyIsInR5cGVfbmFtZV90YWciLCJhc3NvY190YWciLCJhc3NvY19rZXlfdGFnIiwiYXNzb2NfdmFsdWVfdGFnIiwiY29tcGxldGlvbl9zdWdnZXN0ZWQiLCJjb2VyY2UiLCJ0YWciLCJwYXJhbSIsImtleSIsInZhbHVlIiwidW5pdF9zZXhwX2dyYW1tYXIiLCJzZXhwX3Rfc2V4cF9ncmFtbWFyIiwiZW1wdHlfc2V4cF9ncmFtbWFyIiwic2V4cF9ncmFtbWFyX3dpdGhfdGFncyIsImdyYW1tYXIiLCJ0YWdzIiwic2V4cF9ncmFtbWFyX3dpdGhfdGFnX2xpc3QiLCJib29sX3NleHBfZ3JhbW1hciIsInN0cmluZ19zZXhwX2dyYW1tYXIiLCJieXRlc19zZXhwX2dyYW1tYXIiLCJjaGFyX3NleHBfZ3JhbW1hciIsImludF9zZXhwX2dyYW1tYXIiLCJmbG9hdF9zZXhwX2dyYW1tYXIiLCJpbnQzMl9zZXhwX2dyYW1tYXIiLCJpbnQ2NF9zZXhwX2dyYW1tYXIiLCJuYXRpdmVpbnRfc2V4cF9ncmFtbWFyIiwicmVmX3NleHBfZ3JhbW1hciIsImxhenlfdF9zZXhwX2dyYW1tYXIiLCJvcHRpb25fc2V4cF9ncmFtbWFyIiwibGlzdF9zZXhwX2dyYW1tYXIiLCJhcnJheV9zZXhwX2dyYW1tYXIiLCJkZWZhdWx0X3N0cmluZ19vZl9mbG9hdCIsInJlYWRfb2xkX29wdGlvbl9mb3JtYXQiLCJ3cml0ZV9vbGRfb3B0aW9uX2Zvcm1hdCIsImxpc3RfbWFwIiwiZiIsImwiLCJzZXhwX29mX3VuaXQiLCJzZXhwX29mX2Jvb2wiLCJzZXhwX29mX3N0cmluZyIsInNleHBfb2ZfYnl0ZXMiLCJieXRlcyIsInNleHBfb2ZfY2hhciIsInNleHBfb2ZfaW50Iiwic2V4cF9vZl9mbG9hdCIsInNleHBfb2ZfaW50MzIiLCJzZXhwX29mX2ludDY0Iiwic2V4cF9vZl9uYXRpdmVpbnQiLCJzZXhwX29mX3JlZiIsInNleHBfb2ZfYSIsInJmIiwic2V4cF9vZl9sYXp5X3QiLCJsdiIsInNleHBfb2Zfb3B0aW9uIiwic2V4cF9vZl9wYWlyIiwic2V4cF9vZl9iIiwic2V4cF9vZl90cmlwbGUiLCJzZXhwX29mX2MiLCJzZXhwX29mX2xpc3QiLCJzZXhwX29mX2FycmF5IiwiYXIiLCJsc3RfcmVmIiwic2V4cF9vZl9oYXNodGJsIiwic2V4cF9vZl9rZXkiLCJzZXhwX29mX3ZhbCIsImh0YmwiLCJjb2xsIiwiayIsInNleHBfb2Zfb3BhcXVlIiwic2V4cF9vZl9mdW4iLCJoYXNoIiwidGhlX2V4bl90YWJsZSIsImFkZCIsImV4dGVuc2lvbl9jb25zdHJ1Y3RvciIsInNleHBfb2ZfZXhuIiwicHJpbnRleGMiLCJmaW5kX2F1dG8iLCJmb3JfcHJpbnRleGMiLCJleG4iLCJzZXhwX29mX2V4bl9vcHQiLCJleG5fdG9fc3RyaW5nIiwiZSIsInByaW50ZXhjX3ByZWZlcl9zZXhwIiwicmVjb3JkX2NoZWNrX2V4dHJhX2ZpZWxkcyIsIm9mX3NleHBfZXJyb3JfZXhuIiwiZXhjIiwib2Zfc2V4cF9lcnJvciIsIndoYXQiLCJ1bml0X29mX3NleHAiLCJib29sX29mX3NleHAiLCJzdHJpbmdfb2Zfc2V4cCIsImJ5dGVzX29mX3NleHAiLCJjaGFyX29mX3NleHAiLCJpbnRfb2Zfc2V4cCIsImV4YyQwIiwiZmxvYXRfb2Zfc2V4cCIsImludDMyX29mX3NleHAiLCJpbnQ2NF9vZl9zZXhwIiwibmF0aXZlaW50X29mX3NleHAiLCJyZWZfb2Zfc2V4cCIsImFfb2Zfc2V4cCIsImxhenlfdF9vZl9zZXhwIiwib3B0aW9uX29mX3NleHAiLCJlbCQwIiwiZWwiLCJwYWlyX29mX3NleHAiLCJiX29mX3NleHAiLCJiX3NleHAiLCJhX3NleHAiLCJ0cmlwbGVfb2Zfc2V4cCIsImNfb2Zfc2V4cCIsImNfc2V4cCIsImxpc3Rfb2Zfc2V4cCIsInJldl9sc3QiLCJhcnJheV9vZl9zZXhwIiwiaGFzaHRibF9vZl9zZXhwIiwia2V5X29mX3NleHAiLCJ2YWxfb2Zfc2V4cCIsImFjdCIsInZfc2V4cCIsImtfc2V4cCIsIm9wYXF1ZV9vZl9zZXhwIiwiZnVuX29mX3NleHAiLCJnZXRfZmxjX2Vycm9yIiwiY2hyIiwibGluZSIsImZpbGUiLCJhcmciLCJoYW5kbGVyIiwidHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkIiwibG9jIiwic3RhZ19ub19hcmdzIiwic3RhZ19pbmNvcnJlY3Rfbl9hcmdzIiwibXNnIiwic3RhZ190YWtlc19hcmdzIiwibmVzdGVkX2xpc3RfaW52YWxpZF9zdW0iLCJlbXB0eV9saXN0X2ludmFsaWRfc3VtIiwidW5leHBlY3RlZF9zdGFnIiwicmVjb3JkX3NleHBfYm9vbF93aXRoX3BheWxvYWQiLCJyZWNvcmRfb25seV9wYWlyc19leHBlY3RlZCIsInJlY29yZF9zdXBlcmZsdW91c19maWVsZHMiLCJyZXZfZmxkX25hbWVzIiwiZmxkX25hbWVzX3N0ciIsInJlY29yZF9kdXBsaWNhdGVfZmllbGRzIiwicmVjb3JkX2V4dHJhX2ZpZWxkcyIsInJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AiLCJmaWVsZHMkMCIsImZpZWxkIiwicmVzdCQwIiwicmVjb3JkX3VuZGVmaW5lZF9lbGVtZW50cyIsInVuZGVmaW5lZCQwIiwicmVjb3JkX2xpc3RfaW5zdGVhZF9hdG9tIiwicmVjb3JkX3BvbHlfZmllbGRfdmFsdWUiLCJub192YXJpYW50X21hdGNoIiwibm9fbWF0Y2hpbmdfdmFyaWFudF9mb3VuZCIsInB0YWdfbm9fYXJncyIsInB0YWdfaW5jb3JyZWN0X25fYXJncyIsImNuc3RyIiwicHRhZ190YWtlc19hcmdzIiwibmVzdGVkX2xpc3RfaW52YWxpZF9wb2x5X3ZhciIsImVtcHR5X2xpc3RfaW52YWxpZF9wb2x5X3ZhciIsImVtcHR5X3R5cGUiLCJhYnNlbnQiLCJjb21iaW5lIiwicGFyc2VfdmFsdWVfbWFsZm9ybWVkIiwibWFsZm9ybWVkIiwic3RhdGUiLCJwb3MiLCJwYXJzZV92YWx1ZXMiLCJtYWxmb3JtZWQkMCIsIm90aGVyIiwiY29udiIsImtpbmQiLCJkZWZhdWx0JDAiLCJzZXhwJDUiLCJzZXhwJDAiLCJzZXhwJDEiLCJzZXhwJDIiLCJzZXhwJDMiLCJzZXhwJDQiLCJwYXJzZV9zcGluZV9tYWxmb3JtZWQiLCJleHRyYSIsInNlZW4iLCJzZXhwcyIsInBhcnNlX3NwaW5lX3Nsb3ciLCJzZXhwcyQwIiwic2V4cHMkMiIsInNleHBzJDEiLCJwYXJzZV9yZWNvcmRfc2xvdyIsInVuc2VlbiIsInBhcnNlX3NwaW5lX2Zhc3QiLCJvdGhlcnMiLCJhcmdzIiwiYXRvbSIsInJlY29yZF9vZl9zZXhwcyIsImNhbGxlciIsImNvbnRleHQkMCIsImluZGV4X29mX2ZpZWxkIiwiYWxsb3dfZXh0cmFfZmllbGRzIiwiY3JlYXRlIiwiYWxsb3dfZXh0cmFfZmllbGRzJDAiLCJuYW1lcyIsIm5hbWVzJDAiLCJuYW1lcyQxIiwibWF5YmVfY29udGV4dCIsImNvbnRleHQiLCJyZWNvcmRfb2Zfc2V4cCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9yb3N2YWxpLy5vcGFtLzQuMTQuMS9saWIvc2V4cGxpYjAvc2V4cC5tbCIsIi9Vc2Vycy9yb3N2YWxpLy5vcGFtLzQuMTQuMS9saWIvc2V4cGxpYjAvc2V4cF9ncmFtbWFyLm1sIiwiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9zZXhwbGliMC9zZXhwX2NvbnZfZ3JhbW1hci5tbCIsIi9Vc2Vycy9yb3N2YWxpLy5vcGFtLzQuMTQuMS9saWIvc2V4cGxpYjAvc2V4cF9jb252Lm1sIiwiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9zZXhwbGliMC9zZXhwX2NvbnZfZXJyb3IubWwiLCIvVXNlcnMvcm9zdmFsaS8ub3BhbS80LjE0LjEvbGliL3NleHBsaWIwL3NleHBfY29udl9yZWNvcmQubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBZUlBLFVBQVVDLEdBQUks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QUFBLHdDQTBNZjhCLFFBQ0FDO1lBN01LL0I7O1FBR3FDO1NBQXBDb0MsUUFIRHBDO1NBR3FDLE1BQUEsaUNBQXBDb0M7UUFBUyxPQUFBOytDQXlNZk4sYUFDQUM7O1FBek00QztTQUF4Q00sVUFKQ3JDO1NBSXVDLE1BQUEsaUNBQXhDcUM7UUFBUyxPQUFBOytDQXdNYlAsYUFDQUM7O1FBdk1EO1NBRFFPLFVBTEZ0Qzt3QkFNaUI1SyxNQUFRLGNBQVJBLE1BQWtCO1NBQXpDLE1BQUEsdUNBRFFrTjtRQUNSLE9BQUE7aUJBQ0cseUNBcU1GUixRQUNBQzs7O1FBcE1hO1NBRExRLGdCQVJIdkM7U0FTRndDLFVBQVUsNkJBRExELGVBcU1SUjtRQW5NRCxPQUFBLHlDQWtNQ0QsUUFuTUdVOzs7SUFpTkcsT0FBQSxXQVROTixRQVNIOUw7R0FDMkU7WUFHM0VxTTtJQUFnQlgsUUFBUXpNLFFBQVEyTSxnQkFBZ0JDLG9CQUFvQkMsUUFBT3BPO0lBQzdFLFNBRDZFQTtLQUV0RCxPQUFBLHlDQUZMZ08sUUFBMkRoTztRQUd0RW9OLFFBSHNFcE47SUFJM0UsT0F2QkErTjthQW1CZ0JDO2FBQTJEaE87YUFBbkR1QjthQUFRMk07YUFBZ0JDO2FBQW9CQzthQUcvRGhCO0dBUUU7OztxQkFYUHVCLGdCQW5CQVo7Ozs7RTs7Ozs7Ozs7O0U7Ozs7Ozs7OztFIiwic291cmNlc0NvbnRlbnQiOlsiW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxuXG4oKiBibGl0X3N0cmluZyBkb2Vzbid0IGV4aXN0IGluIFtTdGRMYWJlbHMuQnl0ZXNdLi4uICAqKVxubGV0IGJ5dGVzX2JsaXRfc3RyaW5nIH5zcmMgfnNyY19wb3MgfmRzdCB+ZHN0X3BvcyB+bGVuID1cbiAgQnl0ZXMuYmxpdF9zdHJpbmcgc3JjIHNyY19wb3MgZHN0IGRzdF9wb3MgbGVuXG47O1xuXG5vcGVuIFN0ZExhYmVsc1xub3BlbiBGb3JtYXRcblxuKCoqIFR5cGUgb2YgUy1leHByZXNzaW9ucyAqKVxudHlwZSB0ID1cbiAgfCBBdG9tIG9mIHN0cmluZ1xuICB8IExpc3Qgb2YgdCBsaXN0XG5cbmxldCBzZXhwX29mX3QgdCA9IHRcbmxldCB0X29mX3NleHAgdCA9IHRcblxubGV0IHJlYyBjb21wYXJlX2xpc3QgYSBiID1cbiAgbWF0Y2ggYSwgYiB3aXRoXG4gIHwgW10sIFtdIC0+IDBcbiAgfCBbXSwgXyAtPiAtMVxuICB8IF8sIFtdIC0+IDFcbiAgfCB4IDo6IHhzLCB5IDo6IHlzIC0+XG4gICAgbGV0IHJlcyA9IGNvbXBhcmUgeCB5IGluXG4gICAgaWYgcmVzIDw+IDAgdGhlbiByZXMgZWxzZSBjb21wYXJlX2xpc3QgeHMgeXNcblxuYW5kIGNvbXBhcmUgYSBiID1cbiAgaWYgYSA9PSBiXG4gIHRoZW4gMFxuICBlbHNlIChcbiAgICBtYXRjaCBhLCBiIHdpdGhcbiAgICB8IEF0b20gYSwgQXRvbSBiIC0+IFN0cmluZy5jb21wYXJlIGEgYlxuICAgIHwgQXRvbSBfLCBfIC0+IC0xXG4gICAgfCBfLCBBdG9tIF8gLT4gMVxuICAgIHwgTGlzdCBhLCBMaXN0IGIgLT4gY29tcGFyZV9saXN0IGEgYilcbjs7XG5cbmxldCBlcXVhbCBhIGIgPSBjb21wYXJlIGEgYiA9IDBcblxuZXhjZXB0aW9uIE5vdF9mb3VuZF9zIG9mIHRcbmV4Y2VwdGlvbiBPZl9zZXhwX2Vycm9yIG9mIGV4biAqIHRcblxubW9kdWxlIFByaW50aW5nID0gc3RydWN0XG4gICgqIERlZmF1bHQgaW5kZW50YXRpb24gbGV2ZWwgZm9yIGh1bWFuLXJlYWRhYmxlIGNvbnZlcnNpb25zICopXG5cbiAgbGV0IGRlZmF1bHRfaW5kZW50ID0gcmVmIDFcblxuICAoKiBFc2NhcGluZyBvZiBzdHJpbmdzIHVzZWQgYXMgYXRvbXMgaW4gUy1leHByZXNzaW9ucyAqKVxuXG4gIGxldCBtdXN0X2VzY2FwZSBzdHIgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICAgIGxlbiA9IDBcbiAgICB8fFxuICAgIGxldCByZWMgbG9vcCBzdHIgaXggPVxuICAgICAgbWF0Y2ggc3RyLltpeF0gd2l0aFxuICAgICAgfCAnXCInIHwgJygnIHwgJyknIHwgJzsnIHwgJ1xcXFwnIC0+IHRydWVcbiAgICAgIHwgJ3wnIC0+XG4gICAgICAgIGl4ID4gMFxuICAgICAgICAmJlxuICAgICAgICBsZXQgbmV4dCA9IGl4IC0gMSBpblxuICAgICAgICBDaGFyLmVxdWFsIHN0ci5bbmV4dF0gJyMnIHx8IGxvb3Agc3RyIG5leHRcbiAgICAgIHwgJyMnIC0+XG4gICAgICAgIGl4ID4gMFxuICAgICAgICAmJlxuICAgICAgICBsZXQgbmV4dCA9IGl4IC0gMSBpblxuICAgICAgICBDaGFyLmVxdWFsIHN0ci5bbmV4dF0gJ3wnIHx8IGxvb3Agc3RyIG5leHRcbiAgICAgIHwgJ1xcMDAwJyAuLiAnXFwwMzInIHwgJ1xcMTI3JyAuLiAnXFwyNTUnIC0+IHRydWVcbiAgICAgIHwgXyAtPiBpeCA+IDAgJiYgbG9vcCBzdHIgKGl4IC0gMSlcbiAgICBpblxuICAgIGxvb3Agc3RyIChsZW4gLSAxKVxuICA7O1xuXG4gIGxldCBlc2NhcGVkIHMgPVxuICAgIGxldCBuID0gcmVmIDAgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzIC0gMSBkb1xuICAgICAgblxuICAgICAgOj0gIW5cbiAgICAgICAgICtcbiAgICAgICAgIG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgICB8ICdcXFwiJyB8ICdcXFxcJyB8ICdcXG4nIHwgJ1xcdCcgfCAnXFxyJyB8ICdcXGInIC0+IDJcbiAgICAgICAgIHwgJyAnIC4uICd+JyAtPiAxXG4gICAgICAgICB8IF8gLT4gNFxuICAgIGRvbmU7XG4gICAgaWYgIW4gPSBTdHJpbmcubGVuZ3RoIHNcbiAgICB0aGVuIHNcbiAgICBlbHNlIChcbiAgICAgIGxldCBzJyA9IEJ5dGVzLmNyZWF0ZSAhbiBpblxuICAgICAgbiA6PSAwO1xuICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggcyAtIDEgZG9cbiAgICAgICAgKG1hdGNoIFN0cmluZy51bnNhZmVfZ2V0IHMgaSB3aXRoXG4gICAgICAgICB8ICgnXFxcIicgfCAnXFxcXCcpIGFzIGMgLT5cbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiAnXFxcXCc7XG4gICAgICAgICAgIGluY3IgbjtcbiAgICAgICAgICAgQnl0ZXMudW5zYWZlX3NldCBzJyAhbiBjXG4gICAgICAgICB8ICdcXG4nIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ24nXG4gICAgICAgICB8ICdcXHQnIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ3QnXG4gICAgICAgICB8ICdcXHInIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ3InXG4gICAgICAgICB8ICdcXGInIC0+XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ2InXG4gICAgICAgICB8ICcgJyAuLiAnficgYXMgYyAtPiBCeXRlcy51bnNhZmVfc2V0IHMnICFuIGNcbiAgICAgICAgIHwgYyAtPlxuICAgICAgICAgICBsZXQgYSA9IENoYXIuY29kZSBjIGluXG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gJ1xcXFwnO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gKENoYXIuY2hyICg0OCArIChhIC8gMTAwKSkpO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gKENoYXIuY2hyICg0OCArIChhIC8gMTAgbW9kIDEwKSkpO1xuICAgICAgICAgICBpbmNyIG47XG4gICAgICAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgcycgIW4gKENoYXIuY2hyICg0OCArIChhIG1vZCAxMCkpKSk7XG4gICAgICAgIGluY3IgblxuICAgICAgZG9uZTtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcycpXG4gIDs7XG5cbiAgbGV0IGVzY19zdHIgc3RyID1cbiAgICBsZXQgZXN0ciA9IGVzY2FwZWQgc3RyIGluXG4gICAgbGV0IGVsZW4gPSBTdHJpbmcubGVuZ3RoIGVzdHIgaW5cbiAgICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIChlbGVuICsgMikgaW5cbiAgICBieXRlc19ibGl0X3N0cmluZyB+c3JjOmVzdHIgfnNyY19wb3M6MCB+ZHN0OnJlcyB+ZHN0X3BvczoxIH5sZW46ZWxlbjtcbiAgICBCeXRlcy51bnNhZmVfc2V0IHJlcyAwICdcIic7XG4gICAgQnl0ZXMudW5zYWZlX3NldCByZXMgKGVsZW4gKyAxKSAnXCInO1xuICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG4gIDs7XG5cbiAgbGV0IGluZGV4X29mX25ld2xpbmUgc3RyIHN0YXJ0ID0gU3RyaW5nLmluZGV4X2Zyb21fb3B0IHN0ciBzdGFydCAnXFxuJ1xuXG4gIGxldCBnZXRfc3Vic3RyaW5nIHN0ciBpbmRleCBlbmRfcG9zX29wdCA9XG4gICAgbGV0IGVuZF9wb3MgPVxuICAgICAgbWF0Y2ggZW5kX3Bvc19vcHQgd2l0aFxuICAgICAgfCBOb25lIC0+IFN0cmluZy5sZW5ndGggc3RyXG4gICAgICB8IFNvbWUgZW5kX3BvcyAtPiBlbmRfcG9zXG4gICAgaW5cbiAgICBTdHJpbmcuc3ViIHN0ciB+cG9zOmluZGV4IH5sZW46KGVuZF9wb3MgLSBpbmRleClcbiAgOztcblxuICBsZXQgaXNfb25lX2xpbmUgc3RyID1cbiAgICBtYXRjaCBpbmRleF9vZl9uZXdsaW5lIHN0ciAwIHdpdGhcbiAgICB8IE5vbmUgLT4gdHJ1ZVxuICAgIHwgU29tZSBpbmRleCAtPiBpbmRleCArIDEgPSBTdHJpbmcubGVuZ3RoIHN0clxuICA7O1xuXG4gIGxldCBwcF9odW1fbWF5YmVfZXNjX3N0ciBwcGYgc3RyID1cbiAgICBpZiBub3QgKG11c3RfZXNjYXBlIHN0cilcbiAgICB0aGVuIHBwX3ByaW50X3N0cmluZyBwcGYgc3RyXG4gICAgZWxzZSBpZiBpc19vbmVfbGluZSBzdHJcbiAgICB0aGVuIHBwX3ByaW50X3N0cmluZyBwcGYgKGVzY19zdHIgc3RyKVxuICAgIGVsc2UgKFxuICAgICAgbGV0IHJlYyBsb29wIGluZGV4ID1cbiAgICAgICAgbGV0IG5leHRfbmV3bGluZSA9IGluZGV4X29mX25ld2xpbmUgc3RyIGluZGV4IGluXG4gICAgICAgIGxldCBuZXh0X2xpbmUgPSBnZXRfc3Vic3RyaW5nIHN0ciBpbmRleCBuZXh0X25ld2xpbmUgaW5cbiAgICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiAoZXNjYXBlZCBuZXh0X2xpbmUpO1xuICAgICAgICBtYXRjaCBuZXh0X25ld2xpbmUgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICAgfCBTb21lIG5ld2xpbmVfaW5kZXggLT5cbiAgICAgICAgICBwcF9wcmludF9zdHJpbmcgcHBmIFwiXFxcXFwiO1xuICAgICAgICAgIHBwX2ZvcmNlX25ld2xpbmUgcHBmICgpO1xuICAgICAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCJcXFxcblwiO1xuICAgICAgICAgIGxvb3AgKG5ld2xpbmVfaW5kZXggKyAxKVxuICAgICAgaW5cbiAgICAgIHBwX29wZW5fYm94IHBwZiAwO1xuICAgICAgKCogdGhlIGxlYWRpbmcgc3BhY2UgaXMgdG8gbGluZSB1cCB0aGUgbGluZXMgKilcbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIgXFxcIlwiO1xuICAgICAgbG9vcCAwO1xuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIlxcXCJcIjtcbiAgICAgIHBwX2Nsb3NlX2JveCBwcGYgKCkpXG4gIDs7XG5cbiAgbGV0IG1hY2hfbWF5YmVfZXNjX3N0ciBzdHIgPSBpZiBtdXN0X2VzY2FwZSBzdHIgdGhlbiBlc2Nfc3RyIHN0ciBlbHNlIHN0clxuXG4gICgqIE91dHB1dCBvZiBTLWV4cHJlc3Npb25zIHRvIGZvcm1hdHRlcnMgKilcblxuICBsZXQgcmVjIHBwX2h1bV9pbmRlbnQgaW5kZW50IHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPiBwcF9odW1fbWF5YmVfZXNjX3N0ciBwcGYgc3RyXG4gICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICBwcF9vcGVuX2JveCBwcGYgaW5kZW50O1xuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIihcIjtcbiAgICAgIHBwX2h1bV9pbmRlbnQgaW5kZW50IHBwZiBoO1xuICAgICAgcHBfaHVtX3Jlc3QgaW5kZW50IHBwZiB0XG4gICAgfCBMaXN0IFtdIC0+IHBwX3ByaW50X3N0cmluZyBwcGYgXCIoKVwiXG5cbiAgYW5kIHBwX2h1bV9yZXN0IGluZGVudCBwcGYgPSBmdW5jdGlvblxuICAgIHwgaCA6OiB0IC0+XG4gICAgICBwcF9wcmludF9zcGFjZSBwcGYgKCk7XG4gICAgICBwcF9odW1faW5kZW50IGluZGVudCBwcGYgaDtcbiAgICAgIHBwX2h1bV9yZXN0IGluZGVudCBwcGYgdFxuICAgIHwgW10gLT5cbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIpXCI7XG4gICAgICBwcF9jbG9zZV9ib3ggcHBmICgpXG4gIDs7XG5cbiAgbGV0IHJlYyBwcF9tYWNoX2ludGVybmFsIG1heV9uZWVkX3NwYWNlIHBwZiA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0ciAtPlxuICAgICAgbGV0IHN0cicgPSBtYWNoX21heWJlX2VzY19zdHIgc3RyIGluXG4gICAgICBsZXQgbmV3X21heV9uZWVkX3NwYWNlID0gc3RyJyA9PSBzdHIgaW5cbiAgICAgIGlmIG1heV9uZWVkX3NwYWNlICYmIG5ld19tYXlfbmVlZF9zcGFjZSB0aGVuIHBwX3ByaW50X3N0cmluZyBwcGYgXCIgXCI7XG4gICAgICBwcF9wcmludF9zdHJpbmcgcHBmIHN0cic7XG4gICAgICBuZXdfbWF5X25lZWRfc3BhY2VcbiAgICB8IExpc3QgKGggOjogdCkgLT5cbiAgICAgIHBwX3ByaW50X3N0cmluZyBwcGYgXCIoXCI7XG4gICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBwcF9tYWNoX2ludGVybmFsIGZhbHNlIHBwZiBoIGluXG4gICAgICBwcF9tYWNoX3Jlc3QgbWF5X25lZWRfc3BhY2UgcHBmIHQ7XG4gICAgICBmYWxzZVxuICAgIHwgTGlzdCBbXSAtPlxuICAgICAgcHBfcHJpbnRfc3RyaW5nIHBwZiBcIigpXCI7XG4gICAgICBmYWxzZVxuXG4gIGFuZCBwcF9tYWNoX3Jlc3QgbWF5X25lZWRfc3BhY2UgcHBmID0gZnVuY3Rpb25cbiAgICB8IGggOjogdCAtPlxuICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gcHBfbWFjaF9pbnRlcm5hbCBtYXlfbmVlZF9zcGFjZSBwcGYgaCBpblxuICAgICAgcHBfbWFjaF9yZXN0IG1heV9uZWVkX3NwYWNlIHBwZiB0XG4gICAgfCBbXSAtPiBwcF9wcmludF9zdHJpbmcgcHBmIFwiKVwiXG4gIDs7XG5cbiAgbGV0IHBwX2h1bSBwcGYgc2V4cCA9IHBwX2h1bV9pbmRlbnQgIWRlZmF1bHRfaW5kZW50IHBwZiBzZXhwXG4gIGxldCBwcF9tYWNoIHBwZiBzZXhwID0gaWdub3JlIChwcF9tYWNoX2ludGVybmFsIGZhbHNlIHBwZiBzZXhwKVxuICBsZXQgcHAgPSBwcF9tYWNoXG5cbiAgKCogU2V4cCBzaXplICopXG5cbiAgbGV0IHJlYyBzaXplX2xvb3AgKCh2LCBjKSBhcyBhY2MpID0gZnVuY3Rpb25cbiAgICB8IEF0b20gc3RyIC0+IHYgKyAxLCBjICsgU3RyaW5nLmxlbmd0aCBzdHJcbiAgICB8IExpc3QgbHN0IC0+IExpc3QuZm9sZF9sZWZ0IGxzdCB+aW5pdDphY2MgfmY6c2l6ZV9sb29wXG4gIDs7XG5cbiAgbGV0IHNpemUgc2V4cCA9IHNpemVfbG9vcCAoMCwgMCkgc2V4cFxuXG4gICgqIEJ1ZmZlciBjb252ZXJzaW9ucyAqKVxuXG4gIGxldCB0b19idWZmZXJfaHVtIH5idWYgPyhpbmRlbnQgPSAhZGVmYXVsdF9pbmRlbnQpIHNleHAgPVxuICAgIGxldCBwcGYgPSBGb3JtYXQuZm9ybWF0dGVyX29mX2J1ZmZlciBidWYgaW5cbiAgICBGb3JtYXQuZnByaW50ZiBwcGYgXCIlYUA/XCIgKHBwX2h1bV9pbmRlbnQgaW5kZW50KSBzZXhwXG4gIDs7XG5cbiAgbGV0IHRvX2J1ZmZlcl9tYWNoIH5idWYgc2V4cCA9XG4gICAgbGV0IHJlYyBsb29wIG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgQXRvbSBzdHIgLT5cbiAgICAgICAgbGV0IHN0cicgPSBtYWNoX21heWJlX2VzY19zdHIgc3RyIGluXG4gICAgICAgIGxldCBuZXdfbWF5X25lZWRfc3BhY2UgPSBzdHInID09IHN0ciBpblxuICAgICAgICBpZiBtYXlfbmVlZF9zcGFjZSAmJiBuZXdfbWF5X25lZWRfc3BhY2UgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmICcgJztcbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIHN0cic7XG4gICAgICAgIG5ld19tYXlfbmVlZF9zcGFjZVxuICAgICAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJygnO1xuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIGZhbHNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHQ7XG4gICAgICAgIGZhbHNlXG4gICAgICB8IExpc3QgW10gLT5cbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiKClcIjtcbiAgICAgICAgZmFsc2VcbiAgICBhbmQgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgaCA6OiB0IC0+XG4gICAgICAgIGxldCBtYXlfbmVlZF9zcGFjZSA9IGxvb3AgbWF5X25lZWRfc3BhY2UgaCBpblxuICAgICAgICBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgdFxuICAgICAgfCBbXSAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmICcpJ1xuICAgIGluXG4gICAgaWdub3JlIChsb29wIGZhbHNlIHNleHApXG4gIDs7XG5cbiAgbGV0IHRvX2J1ZmZlciA9IHRvX2J1ZmZlcl9tYWNoXG5cbiAgbGV0IHRvX2J1ZmZlcl9nZW4gfmJ1ZiB+YWRkX2NoYXIgfmFkZF9zdHJpbmcgc2V4cCA9XG4gICAgbGV0IHJlYyBsb29wIG1heV9uZWVkX3NwYWNlID0gZnVuY3Rpb25cbiAgICAgIHwgQXRvbSBzdHIgLT5cbiAgICAgICAgbGV0IHN0cicgPSBtYWNoX21heWJlX2VzY19zdHIgc3RyIGluXG4gICAgICAgIGxldCBuZXdfbWF5X25lZWRfc3BhY2UgPSBzdHInID09IHN0ciBpblxuICAgICAgICBpZiBtYXlfbmVlZF9zcGFjZSAmJiBuZXdfbWF5X25lZWRfc3BhY2UgdGhlbiBhZGRfY2hhciBidWYgJyAnO1xuICAgICAgICBhZGRfc3RyaW5nIGJ1ZiBzdHInO1xuICAgICAgICBuZXdfbWF5X25lZWRfc3BhY2VcbiAgICAgIHwgTGlzdCAoaCA6OiB0KSAtPlxuICAgICAgICBhZGRfY2hhciBidWYgJygnO1xuICAgICAgICBsZXQgbWF5X25lZWRfc3BhY2UgPSBsb29wIGZhbHNlIGggaW5cbiAgICAgICAgbG9vcF9yZXN0IG1heV9uZWVkX3NwYWNlIHQ7XG4gICAgICAgIGZhbHNlXG4gICAgICB8IExpc3QgW10gLT5cbiAgICAgICAgYWRkX3N0cmluZyBidWYgXCIoKVwiO1xuICAgICAgICBmYWxzZVxuICAgIGFuZCBsb29wX3Jlc3QgbWF5X25lZWRfc3BhY2UgPSBmdW5jdGlvblxuICAgICAgfCBoIDo6IHQgLT5cbiAgICAgICAgbGV0IG1heV9uZWVkX3NwYWNlID0gbG9vcCBtYXlfbmVlZF9zcGFjZSBoIGluXG4gICAgICAgIGxvb3BfcmVzdCBtYXlfbmVlZF9zcGFjZSB0XG4gICAgICB8IFtdIC0+IGFkZF9jaGFyIGJ1ZiAnKSdcbiAgICBpblxuICAgIGlnbm9yZSAobG9vcCBmYWxzZSBzZXhwKVxuICA7O1xuXG4gICgqIFRoZSBtYXhpbXVtIHNpemUgb2YgYSB0aGluZyBvbiB0aGUgbWlub3IgaGVhcCBpcyAyNTYgd29yZHMuXG4gICAgIFByZXZpb3VzbHksIHRoaXMgc2l6ZSBvZiB0aGUgcmV0dXJuZWQgYnVmZmVyIGhlcmUgd2FzIDQwOTYgYnl0ZXMsIHdoaWNoXG4gICAgIGNhdXNlZCB0aGUgQnVmZmVyIHRvIGJlIGFsbG9jYXRlZCBvbiB0aGUgKm1ham9yKiBoZWFwIGV2ZXJ5IHRpbWUuXG5cbiAgICAgQWNjb3JkaW5nIHRvIGEgc2ltcGxlIGJlbmNobWFyayBieSBSb24sIHdlIGNhbiBpbXByb3ZlIHBlcmZvcm1hbmNlIGZvclxuICAgICBzbWFsbCBzLWV4cHJlc3Npb25zIGJ5IGEgZmFjdG9yIG9mIH40IGlmIHdlIG9ubHkgYWxsb2NhdGUgMTAyNCBieXRlc1xuICAgICAoMTI4IHdvcmRzICsgc29tZSBzbWFsbCBvdmVyaGVhZCkgd29ydGggb2YgYnVmZmVyIGluaXRpYWxseS4gIEFuZCBvbmVcbiAgICAgY2FuIGFyZ3VlIHRoYXQgaWYgaXQncyBmcmVlIHRvIGFsbG9jYXRlIHN0cmluZ3Mgc21hbGxlciB0aGFuIDI1NiB3b3JkcyxcbiAgICAgbGFyZ2Ugcy1leHByZXNzaW9ucyByZXF1aXJpbmcgbGFyZ2VyIGV4cGVuc2l2ZSBidWZmZXJzIHdvbid0IG5vdGljZVxuICAgICB0aGUgZXh0cmEgdHdvIGRvdWJsaW5ncyBmcm9tIDEwMjQgYnl0ZXMgdG8gMjA0OCBhbmQgNDA5Ni4gQW5kIGVzcGVjaWFsbHlcbiAgICAgcGVyZm9ybWFuY2Utc2Vuc2l0aXZlIGFwcGxpY2F0aW9ucyB0byBhbHdheXMgcGFzcyBpbiBhIGxhcmdlciBidWZmZXIgdG9cbiAgICAgdXNlLiAqKVxuICBsZXQgYnVmZmVyICgpID0gQnVmZmVyLmNyZWF0ZSAxMDI0XG5cbiAgKCogU3RyaW5nIGNvbnZlcnNpb25zICopXG5cbiAgbGV0IHRvX3N0cmluZ19odW0gP2luZGVudCA9IGZ1bmN0aW9uXG4gICAgfCBBdG9tIHN0clxuICAgICAgd2hlbiBtYXRjaCBpbmRleF9vZl9uZXdsaW5lIHN0ciAwIHdpdGhcbiAgICAgICAgfCBOb25lIC0+IHRydWVcbiAgICAgICAgfCBTb21lIF8gLT4gZmFsc2UgLT4gbWFjaF9tYXliZV9lc2Nfc3RyIHN0clxuICAgIHwgc2V4cCAtPlxuICAgICAgbGV0IGJ1ZiA9IGJ1ZmZlciAoKSBpblxuICAgICAgdG9fYnVmZmVyX2h1bSA/aW5kZW50IHNleHAgfmJ1ZjtcbiAgICAgIEJ1ZmZlci5jb250ZW50cyBidWZcbiAgOztcblxuICBsZXQgdG9fc3RyaW5nX21hY2ggPSBmdW5jdGlvblxuICAgIHwgQXRvbSBzdHIgLT4gbWFjaF9tYXliZV9lc2Nfc3RyIHN0clxuICAgIHwgc2V4cCAtPlxuICAgICAgbGV0IGJ1ZiA9IGJ1ZmZlciAoKSBpblxuICAgICAgdG9fYnVmZmVyX21hY2ggc2V4cCB+YnVmO1xuICAgICAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuICA7O1xuXG4gIGxldCB0b19zdHJpbmcgPSB0b19zdHJpbmdfbWFjaFxuZW5kXG5cbmluY2x1ZGUgUHJpbnRpbmdcblxubGV0IG9mX2Zsb2F0X3N0eWxlIDogWyBgVW5kZXJzY29yZXMgfCBgTm9fdW5kZXJzY29yZXMgXSByZWYgPSByZWYgYE5vX3VuZGVyc2NvcmVzXG5sZXQgb2ZfaW50X3N0eWxlIDogWyBgVW5kZXJzY29yZXMgfCBgTm9fdW5kZXJzY29yZXMgXSByZWYgPSByZWYgYE5vX3VuZGVyc2NvcmVzXG5cbm1vZHVsZSBQcml2YXRlID0gc3RydWN0XG4gIGluY2x1ZGUgUHJpbnRpbmdcbmVuZFxuXG5sZXQgbWVzc2FnZSBuYW1lIGZpZWxkcyA9XG4gIGxldCByZWMgY29udl9maWVsZHMgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IChmbmFtZSwgZnNleHApIDo6IHJlc3QgLT5cbiAgICAgIChtYXRjaCBmbmFtZSB3aXRoXG4gICAgICAgfCBcIlwiIC0+IGZzZXhwIDo6IGNvbnZfZmllbGRzIHJlc3RcbiAgICAgICB8IF8gLT4gTGlzdCBbIEF0b20gZm5hbWU7IGZzZXhwIF0gOjogY29udl9maWVsZHMgcmVzdClcbiAgaW5cbiAgTGlzdCAoQXRvbSBuYW1lIDo6IGNvbnZfZmllbGRzIGZpZWxkcylcbjs7XG4iLCIoKiogUmVwcmVzZW50YXRpb24gb2YgUy1leHByZXNzaW9uIGdyYW1tYXJzICopXG5cbigqKiBUaGlzIG1vZHVsZSBkZWZpbmVzIGEgcmVwcmVzZW50YXRpb24gZm9yIHMtZXhwcmVzc2lvbiBncmFtbWFycy4gVXNpbmcgcHB4X3NleHBfY29udlxuICAgIGFuZCBbW0BAZGVyaXZpbmcgc2V4cF9ncmFtbWFyXV0gcHJvZHVjZXMgYSBncmFtbWFyIHRoYXQgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBkZXJpdmVkXG4gICAgW29mX3NleHBdIGZvciBhIGdpdmVuIHR5cGUuXG5cbiAgICBBcyB3aXRoIG90aGVyIGRlcml2ZWQgZGVmaW5pdGlvbnMsIHBvbHltb3JwaGljIHR5cGVzIGRlcml2ZSBhIGZ1bmN0aW9uIHRoYXQgdGFrZXMgYVxuICAgIGdyYW1tYXIgZm9yIGVhY2ggdHlwZSBhcmd1bWVudCBhbmQgcHJvZHVjZXMgYSBncmFtbWFyIGZvciB0aGUgbW9ub21vcnBoaXplZCB0eXBlLlxuXG4gICAgTW9ub21vcnBoaWMgdHlwZXMgZGVyaXZlIGEgZ3JhbW1hciBkaXJlY3RseS4gVG8gYXZvaWQgdG9wLWxldmVsIHNpZGUgZWZmZWN0cyxcbiAgICBbW0BAZGVyaXZpbmcgc2V4cF9ncmFtbWFyXV0gd3JhcHMgZ3JhbW1hcnMgaW4gdGhlIFtMYXp5XSBjb25zdHJ1Y3RvciBhcyBuZWVkZWQuXG5cbiAgICBUaGlzIHR5cGUgbWF5IGNoYW5nZSBvdmVyIHRpbWUgYXMgb3VyIG5lZWRzIGZvciBleHByZXNzaXZlIGdyYW1tYXJzIGNoYW5nZS4gV2Ugd2lsbFxuICAgIGF0dGVtcHQgdG8gbWFrZSBjaGFuZ2VzIGJhY2t3YXJkLWNvbXBhdGlibGUsIG9yIGF0IGxlYXN0IHByb3ZpZGUgYSByZWFzb25hYmxlIHVwZ3JhZGVcbiAgICBwYXRoLiAqKVxuXG5bQEBAd2FybmluZyBcIi0zMFwiXSAoKiBhbGxvdyBkdXBsaWNhdGUgZmllbGQgbmFtZXMgKilcblxuKCoqIEdyYW1tYXIgb2YgYSBzZXhwLiAqKVxudHlwZSBncmFtbWFyID1cbiAgfCBBbnkgb2Ygc3RyaW5nICgqKiBhY2NlcHRzIGFueSBzZXhwOyBzdHJpbmcgaXMgYSB0eXBlIG5hbWUgZm9yIGh1bWFuIHJlYWRhYmlsaXR5ICopXG4gIHwgQm9vbCAoKiogYWNjZXB0cyB0aGUgYXRvbXMgXCJ0cnVlXCIgb3IgXCJmYWxzZVwiLCBtb2R1bG8gY2FwaXRhbGl6YXRpb24gKilcbiAgfCBDaGFyICgqKiBhY2NlcHRzIGFueSBzaW5nbGUtY2hhcmFjdGVyIGF0b20gKilcbiAgfCBJbnRlZ2VyICgqKiBhY2NlcHRzIGFueSBhdG9tIG1hdGNoaW5nIG9jYW1sIGludGVnZXIgc3ludGF4LCByZWdhcmRsZXNzIG9mIGJpdCB3aWR0aCAqKVxuICB8IEZsb2F0ICgqKiBhY2NlcHRzIGFueSBhdG9tIG1hdGNoaW5nIG9jYW1sIGZsb2F0IHN5bnRheCAqKVxuICB8IFN0cmluZyAoKiogYWNjZXB0cyBhbnkgYXRvbSAqKVxuICB8IE9wdGlvbiBvZiBncmFtbWFyICgqKiBhY2NlcHRzIGFuIG9wdGlvbiwgYm90aCBbTm9uZV0gdnMgW1NvbWUgX10gYW5kIFsoKV0gdnMgWyhfKV0uICopXG4gIHwgTGlzdCBvZiBsaXN0X2dyYW1tYXIgKCoqIGFjY2VwdHMgYSBsaXN0ICopXG4gIHwgVmFyaWFudCBvZiB2YXJpYW50ICgqKiBhY2NlcHRzIGNsYXVzZXMga2V5ZWQgYnkgYSBsZWFkaW5nIG9yIHNvbGUgYXRvbSAqKVxuICB8IFVuaW9uIG9mIGdyYW1tYXIgbGlzdCAoKiogYWNjZXB0cyBhIHNleHAgaWYgYW55IG9mIHRoZSBsaXN0ZWQgZ3JhbW1hcnMgYWNjZXB0cyBpdCAqKVxuICB8IFRhZ2dlZCBvZiBncmFtbWFyIHdpdGhfdGFnXG4gICgqKiBhbm5vdGF0ZXMgYSBncmFtbWFyIHdpdGggYSBjbGllbnQtc3BlY2lmaWMga2V5L3ZhbHVlIHBhaXIgKilcbiAgfCBUeXZhciBvZiBzdHJpbmdcbiAgKCoqIE5hbWUgb2YgYSB0eXBlIHZhcmlhYmxlLCBlLmcuIFtUeXZhciBcImFcIl0gZm9yIFsnYV0uIE9ubHkgbWVhbmluZ2Z1bCB3aGVuIHRoZSBib2R5IG9mXG4gICAgICB0aGUgaW5uZXJtb3N0IGVuY2xvc2luZyBbZGVmbl0gZGVmaW5lcyBhIGNvcnJlc3BvbmRpbmcgdHlwZSB2YXJpYWJsZS4gKilcbiAgfCBUeWNvbiBvZiBzdHJpbmcgKiBncmFtbWFyIGxpc3QgKiBkZWZuIGxpc3RcbiAgKCoqIFR5cGUgY29uc3RydWN0b3IgYXBwbGllZCB0byBhcmd1bWVudHMsIGFuZCBpdHMgZGVmaW5pdGlvbi5cblxuICAgICAgRm9yIGV4YW1wbGUsIHdyaXRpbmcgW1R5Y29uIChcInRyZWVcIiwgWyBJbnRlZ2VyIF0sIGRlZm5zKV0gcmVwcmVzZW50cyBbaW50IHRyZWVdLCBmb3JcbiAgICAgIHdoYXRldmVyIFt0cmVlXSBpcyBkZWZpbmVkIGFzIGluIFtkZWZuc10uIFRoZSBmb2xsb3dpbmcgZGVmaW5lcyBbdHJlZV0gYXMgYSBiaW5hcnlcbiAgICAgIHRyZWUgd2l0aCB0aGUgcGFyYW1ldGVyIHR5cGUgc3RvcmVkIGF0IHRoZSBsZWF2ZXMuXG5cbiAgICAgIHtbXG4gICAgICAgIGxldCBkZWZucyA9XG4gICAgICAgICAgWyB7IHR5Y29uID0gXCJ0cmVlXCJcbiAgICAgICAgICAgIDsgdHl2YXJzID0gW1wiYVwiXVxuICAgICAgICAgICAgOyBncmFtbWFyID1cbiAgICAgICAgICAgICAgICBWYXJpYW50XG4gICAgICAgICAgICAgICAgICB7IG5hbWVfa2luZCA9IENhcGl0YWxpemVkXG4gICAgICAgICAgICAgICAgICA7IGNsYXVzZXMgPVxuICAgICAgICAgICAgICAgICAgICAgIFsgeyBuYW1lID0gXCJOb2RlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFJlY3Vyc2l2ZSAoXCJub2RlXCIsIFtUeXZhciBcImFcIl0pLCBFbXB0eSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICA7IHsgbmFtZSA9IFwiTGVhZlwiXG4gICAgICAgICAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChSZWN1cnNpdmUgKFwibGVhZlwiLCBbVHl2YXIgXCJhXCJdKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIDsgeyB0eWNvbiA9IFwibm9kZVwiXG4gICAgICAgICAgICA7IHR5dmFycyA9IFtcImFcIl1cbiAgICAgICAgICAgIDsgZ3JhbW1hciA9IExpc3QgKE1hbnkgKFJlY3Vyc2l2ZSBcInRyZWVcIiwgW1R5dmFyIFwiYVwiXSkpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgOyB7IHR5Y29uID0gXCJsZWFmXCJcbiAgICAgICAgICAgIDsgdHl2YXJzID0gW1wiYVwiXVxuICAgICAgICAgICAgOyBncmFtbWFyID0gW1R5dmFyIFwiYVwiXVxuICAgICAgICAgICAgfVxuICAgICAgICAgIF1cbiAgICAgICAgOztcbiAgICAgIF19XG5cbiAgICAgIFRvIGlsbHVzdHJhdGUgdGhlIG1lYW5pbmcgb2YgW1R5Y29uXSB3aXRoIHJlc3BlY3QgdG8gW2RlZm5zXSwgYW5kIHRvIGRlbW9uc3RyYXRlIG9uZVxuICAgICAgd2F5IHRvIGFjY2VzcyB0aGVtLCBpdCBpcyBlcXVpdmFsZW50IHRvIGV4cGFuZCB0aGUgZGVmaW5pdGlvbiBvZiBcInRyZWVcIiBvbmUgbGV2ZWxcbiAgICAgIGFuZCBtb3ZlIHRoZSBbZGVmbnNdIHRvIGVuY2xvc2VkIHJlY3Vyc2l2ZSByZWZlcmVuY2VzOlxuXG4gICAgICB7W1xuICAgICAgICBUeWNvbiAoXCJ0cmVlXCIsIFsgSW50ZWdlciBdLCBkZWZucylcbiAgICAgICAgLS0+XG4gICAgICAgIFZhcmlhbnRcbiAgICAgICAgICB7IG5hbWVfa2luZCA9IENhcGl0YWxpemVkXG4gICAgICAgICAgOyBjbGF1c2VzID1cbiAgICAgICAgICAgICAgWyB7IG5hbWUgPSBcIk5vZGVcIlxuICAgICAgICAgICAgICAgIDsgYXJncyA9IENvbnMgKFR5Y29uIChcIm5vZGVcIiwgW1R5dmFyIFwiYVwiXSwgZGVmbnMpLCBFbXB0eSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIDsgeyBuYW1lID0gXCJMZWFmXCJcbiAgICAgICAgICAgICAgICA7IGFyZ3MgPSBDb25zIChUeWNvbiAoXCJsZWFmXCIsIFtUeXZhciBcImFcIl0sIGRlZm5zKSwgRW1wdHkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBdXG4gICAgICAgICAgfVxuICAgICAgXX1cblxuICAgICAgVGhpcyB0cmFuc2Zvcm1hdGlvbiBleHBvc2VzIHRoZSBzdHJ1Y3R1cmUgb2YgYSBncmFtbWFyIHdpdGggcmVjdXJzaXZlIHJlZmVyZW5jZXMsXG4gICAgICB3aGlsZSBwcmVzZXJ2aW5nIHRoZSBtZWFuaW5nIG9mIHJlY3Vyc2l2ZWx5LWRlZmluZWQgZWxlbWVudHMuICopXG4gIHwgUmVjdXJzaXZlIG9mIHN0cmluZyAqIGdyYW1tYXIgbGlzdFxuICAoKiogVHlwZSBjb25zdHJ1Y3RvciBhcHBsaWVkIHRvIGFyZ3VtZW50cy4gVXNlZCB0byBkZW5vdGUgcmVjdXJzaXZlIHR5cGUgcmVmZXJlbmNlcy5cbiAgICAgIE9ubHkgbWVhbmluZ2Z1bCB3aGVuIHVzZWQgaW5zaWRlIHRoZSBbZGVmbl1zIG9mIGEgW1R5Y29uXSBncmFtbWFyLCB0byByZWZlciB0byBhXG4gICAgICB0eXBlIGNvbnN0cnVjdG9yIGluIHRoZSBuZWFyZXN0IGVuY2xvc2luZyBbZGVmbl0gbGlzdC4gKilcbiAgfCBMYXp5IG9mIGdyYW1tYXIgbGF6eV90XG4gICgqKiBMYXppbHkgY29tcHV0ZWQgZ3JhbW1hci4gVXNlIFtMYXp5XSB0byBhdm9pZCB0b3AtbGV2ZWwgc2lkZSBlZmZlY3RzLiBUbyBkZWZpbmVcbiAgICAgIHJlY3Vyc2l2ZSBncmFtbWFycywgdXNlIFtSZWN1cnNpdmVdIGluc3RlYWQuICopXG5cbigqKiBHcmFtbWFyIG9mIGEgbGlzdCBvZiBzZXhwcy4gKilcbmFuZCBsaXN0X2dyYW1tYXIgPVxuICB8IEVtcHR5ICgqKiBhY2NlcHRzIGFuIGVtcHR5IGxpc3Qgb2Ygc2V4cHMgKilcbiAgfCBDb25zIG9mIGdyYW1tYXIgKiBsaXN0X2dyYW1tYXJcbiAgKCoqIGFjY2VwdHMgYSBub24tZW1wdHkgbGlzdCB3aXRoIGhlYWQgYW5kIHRhaWwgbWF0Y2hpbmcgdGhlIGdpdmVuIGdyYW1tYXJzICopXG4gIHwgTWFueSBvZiBncmFtbWFyICgqKiBhY2NlcHRzIHplcm8gb3IgbW9yZSBzZXhwcywgZWFjaCBtYXRjaGluZyB0aGUgZ2l2ZW4gZ3JhbW1hciAqKVxuICB8IEZpZWxkcyBvZiByZWNvcmQgKCoqIGFjY2VwdHMgc2V4cHMgcmVwcmVzZW50aW5nIGZpZWxkcyBvZiBhIHJlY29yZCAqKVxuXG4oKiogQ2FzZSBzZW5zaXRpdml0eSBvcHRpb25zIGZvciBuYW1lcyBvZiB2YXJpYW50IGNvbnN0cnVjdG9ycy4gKilcbmFuZCBjYXNlX3NlbnNpdGl2aXR5ID1cbiAgfCBDYXNlX2luc2Vuc2l0aXZlICgqKiBDb21wYXJpc29uIGlzIGNhc2UgaW5zZW5zaXRpdmUuIFVzZWQgZm9yIGN1c3RvbSBwYXJzZXJzLiAqKVxuICB8IENhc2Vfc2Vuc2l0aXZlICgqKiBDb21wYXJpc29uIGlzIGNhc2Ugc2Vuc2l0aXZlLiBVc2VkIGZvciBwb2x5bW9ycGhpYyB2YXJpYW50cy4gKilcbiAgfCBDYXNlX3NlbnNpdGl2ZV9leGNlcHRfZmlyc3RfY2hhcmFjdGVyXG4gICgqKiBDb21wYXJpc29uIGlzIGNhc2UgaW5zZW5zaXRpdmUgZm9yIHRoZSBmaXJzdCBjaGFyYWN0ZXIgYW5kIGNhc2Ugc2Vuc2l0aXZlIGFmdGVyd2FyZC5cbiAgICAgIFVzZWQgZm9yIHJlZ3VsYXIgdmFyaWFudHMuICopXG5cbigqKiBHcmFtbWFyIG9mIHZhcmlhbnRzLiBBY2NlcHRzIGFueSBzZXhwIG1hdGNoaW5nIG9uZSBvZiB0aGUgY2xhdXNlcy4gKilcbmFuZCB2YXJpYW50ID1cbiAgeyBjYXNlX3NlbnNpdGl2aXR5IDogY2FzZV9zZW5zaXRpdml0eVxuICA7IGNsYXVzZXMgOiBjbGF1c2Ugd2l0aF90YWdfbGlzdCBsaXN0XG4gIH1cblxuKCoqIEdyYW1tYXIgb2YgYSBzaW5nbGUgdmFyaWFudCBjbGF1c2UuIEFjY2VwdHMgc2V4cHMgYmFzZWQgb24gdGhlIFtjbGF1c2Vfa2luZF0uICopXG5hbmQgY2xhdXNlID1cbiAgeyBuYW1lIDogc3RyaW5nXG4gIDsgY2xhdXNlX2tpbmQgOiBjbGF1c2Vfa2luZFxuICB9XG5cbigqKiBHcmFtbWFyIG9mIGEgc2luZ2xlIHZhcmlhbnQgY2xhdXNlJ3MgY29udGVudHMuIFtBdG9tX2NsYXVzZV0gYWNjZXB0cyBhbiBhdG9tIG1hdGNoaW5nXG4gICAgdGhlIGNsYXVzZSdzIG5hbWUuIFtMaXN0X2NsYXVzZV0gYWNjZXB0cyBhIGxpc3Qgd2hvc2UgaGVhZCBpcyBhbiBhdG9tIG1hdGNoaW5nIHRoZVxuICAgIGNsYXVzZSdzIG5hbWUgYW5kIHdob3NlIHRhaWwgbWF0Y2hlcyBbYXJnc10uIFRoZSBjbGF1c2UncyBuYW1lIGlzIG1hdGNoZWQgbW9kdWxvIHRoZVxuICAgIHZhcmlhbnQncyBbbmFtZV9raW5kXS4gKilcbmFuZCBjbGF1c2Vfa2luZCA9XG4gIHwgQXRvbV9jbGF1c2VcbiAgfCBMaXN0X2NsYXVzZSBvZiB7IGFyZ3MgOiBsaXN0X2dyYW1tYXIgfVxuXG4oKiogR3JhbW1hciBvZiBhIHJlY29yZC4gQWNjZXB0cyBhbnkgbGlzdCBvZiBzZXhwcyBzcGVjaWZ5aW5nIGVhY2ggb2YgdGhlIGZpZWxkcyxcbiAgICByZWdhcmRsZXNzIG9mIG9yZGVyLiBJZiBbYWxsb3dfZXh0cmFfZmllbGRzXSBpcyBzcGVjaWZpZWQsIGlnbm9yZXMgc2V4cHMgd2l0aCBuYW1lc1xuICAgIG5vdCBmb3VuZCBpbiBbZmllbGRzXS4gKilcbmFuZCByZWNvcmQgPVxuICB7IGFsbG93X2V4dHJhX2ZpZWxkcyA6IGJvb2xcbiAgOyBmaWVsZHMgOiBmaWVsZCB3aXRoX3RhZ19saXN0IGxpc3RcbiAgfVxuXG4oKiogR3JhbW1hciBvZiBhIHJlY29yZCBmaWVsZC4gQSBmaWVsZCBtdXN0IHNob3cgdXAgZXhhY3RseSBvbmNlIGluIGEgcmVjb3JkIGlmXG4gICAgW3JlcXVpcmVkXSwgb3IgYXQgbW9zdCBvbmNlIG90aGVyd2lzZS4gQWNjZXB0cyBhIGxpc3QgaGVhZGVkIGJ5IFtuYW1lXSBhcyBhbiBhdG9tLFxuICAgIGZvbGxvd2VkIGJ5IHNleHBzIG1hdGNoaW5nIFthcmdzXS4gKilcbmFuZCBmaWVsZCA9XG4gIHsgbmFtZSA6IHN0cmluZ1xuICA7IHJlcXVpcmVkIDogYm9vbFxuICA7IGFyZ3MgOiBsaXN0X2dyYW1tYXJcbiAgfVxuXG4oKiogR3JhbW1hciB0YWdnZWQgd2l0aCBjbGllbnQtc3BlY2lmaWMga2V5L3ZhbHVlIHBhaXIuICopXG5hbmQgJ2Egd2l0aF90YWcgPVxuICB7IGtleSA6IHN0cmluZ1xuICA7IHZhbHVlIDogU2V4cC50XG4gIDsgZ3JhbW1hciA6ICdhXG4gIH1cblxuYW5kICdhIHdpdGhfdGFnX2xpc3QgPVxuICB8IFRhZyBvZiAnYSB3aXRoX3RhZ19saXN0IHdpdGhfdGFnXG4gIHwgTm9fdGFnIG9mICdhXG5cbigqKiBHcmFtbWFyIG9mIGEgcmVjdXJzaXZlIHR5cGUgZGVmaW5pdGlvbi4gTmFtZXMgdGhlIFt0eWNvbl0gYmVpbmcgZGVmaW5lZCwgYW5kIHRoZVxuICAgIFt0eXZhcnNdIGl0IHRha2VzIGFzIHBhcmFtZXRlcnMuIFNwZWNpZmllcyB0aGUgW2dyYW1tYXJdIG9mIHRoZSBbdHljb25dLiBUaGUgZ3JhbW1hclxuICAgIG1heSByZWZlciB0byBhbnkgb2YgdGhlIFt0eXZhcnNdLCBhbmQgdG8gYW55IG9mIHRoZSBbdHljb25dcyBmcm9tIHRoZSBzYW1lIHNldCBvZlxuICAgIFtSZWN1cnNpdmVdIGRlZmluaXRpb25zLiAqKVxuYW5kIGRlZm4gPVxuICB7IHR5Y29uIDogc3RyaW5nXG4gIDsgdHl2YXJzIDogc3RyaW5nIGxpc3RcbiAgOyBncmFtbWFyIDogZ3JhbW1hclxuICB9XG5cbigqKiBUb3AtbGV2ZWwgZ3JhbW1hciB0eXBlLiBIYXMgYSBwaGFudG9tIHR5cGUgcGFyYW1ldGVyIHRvIGFzc29jaWF0ZSBlYWNoIGdyYW1tYXIgd2l0aFxuICAgIHRoZSB0eXBlIGl0cyBzZXhwcyByZXByZXNlbnQuIFRoaXMgbWFrZXMgaXQgaGFyZGVyIHRvIGFwcGx5IGdyYW1tYXJzIHRvIHRoZSB3cm9uZ1xuICAgIHR5cGUsIHdoaWxlIGdyYW1tYXJzIGNhbiBzdGlsbCBiZSBlYXNpbHkgY29lcmNlZCB0byBhIG5ldyB0eXBlIGlmIG5lZWRlZC4gKilcbnR5cGUgXyB0ID0geyB1bnR5cGVkIDogZ3JhbW1hciB9IFtAQHVuYm94ZWRdXG5cbmxldCBjb2VyY2UgKHR5cGUgYSBiKSAoeyB1bnR5cGVkID0gXyB9IGFzIHQgOiBhIHQpIDogYiB0ID0gdFxuXG5sZXQgdGFnICh0eXBlIGEpICh7IHVudHlwZWQgPSBncmFtbWFyIH0gOiBhIHQpIH5rZXkgfnZhbHVlIDogYSB0ID1cbiAgeyB1bnR5cGVkID0gVGFnZ2VkIHsga2V5OyB2YWx1ZTsgZ3JhbW1hciB9IH1cbjs7XG5cbigqKiBUaGlzIHJlc2VydmVkIGtleSBpcyB1c2VkIGZvciBhbGwgdGFncyBnZW5lcmF0ZWQgZnJvbSBkb2MgY29tbWVudHMuICopXG5sZXQgZG9jX2NvbW1lbnRfdGFnID0gXCJzZXhwX2dyYW1tYXIuZG9jX2NvbW1lbnRcIlxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgY2FuIGJlIHVzZWQgdG8gYXNzb2NpYXRlIGEgdHlwZSBuYW1lIHdpdGggYSBncmFtbWFyLiAqKVxubGV0IHR5cGVfbmFtZV90YWcgPSBcInNleHBfZ3JhbW1hci50eXBlX25hbWVcIlxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgaW5kaWNhdGVzIHRoYXQgYSBzZXhwIHJlcHJlc2VudHMgYSBrZXkvdmFsdWUgYXNzb2NpYXRpb24uIFRoZSB0YWcnc1xuICAgIHZhbHVlIGlzIGlnbm9yZWQuICopXG5sZXQgYXNzb2NfdGFnID0gXCJzZXhwX2dyYW1tYXIuYXNzb2NcIlxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgaW5kaWNhdGVzIHRoYXQgYSBzZXhwIGlzIGEga2V5IGluIGEga2V5L3ZhbHVlIGFzc29jaWF0aW9uLiBUaGUgdGFnJ3NcbiAgICB2YWx1ZSBpcyBpZ25vcmVkLiAqKVxubGV0IGFzc29jX2tleV90YWcgPSBcInNleHBfZ3JhbW1hci5hc3NvYy5rZXlcIlxuXG4oKiogVGhpcyByZXNlcnZlZCBrZXkgaW5kaWNhdGVzIHRoYXQgYSBzZXhwIGlzIGEgdmFsdWUgaW4gYSBrZXkvdmFsdWUgYXNzb2NpYXRpb24uIFRoZVxuICAgIHRhZydzIHZhbHVlIGlzIGlnbm9yZWQuICopXG5sZXQgYXNzb2NfdmFsdWVfdGFnID0gXCJzZXhwX2dyYW1tYXIuYXNzb2MudmFsdWVcIlxuXG4oKiogV2hlbiB0aGUga2V5IGlzIHNldCB0byBbQXRvbSBcImZhbHNlXCJdIGZvciBhIHZhcmlhbnQgY2xhdXNlLCB0aGF0IGNsYXVzZSBzaG91bGQgbm90IGJlXG4gICAgc3VnZ2VzdGVkIGluIGF1dG8tY29tcGxldGlvbiBiYXNlZCBvbiB0aGUgc2V4cCBncmFtbWFyLiAqKVxubGV0IGNvbXBsZXRpb25fc3VnZ2VzdGVkID0gXCJzZXhwX2dyYW1tYXIuY29tcGxldGlvbi1zdWdnZXN0ZWRcIlxuIiwib3BlbiBTdGRMYWJlbHNcblxubGV0IHNleHBfZ3JhbW1hcl93aXRoX3RhZ3MgZ3JhbW1hciB+dGFncyA9XG4gIExpc3QuZm9sZF9yaWdodCB0YWdzIH5pbml0OmdyYW1tYXIgfmY6KGZ1biAoa2V5LCB2YWx1ZSkgZ3JhbW1hciAtPlxuICAgIFNleHBfZ3JhbW1hci5UYWdnZWQgeyBrZXk7IHZhbHVlOyBncmFtbWFyIH0pXG47O1xuXG5sZXQgc2V4cF9ncmFtbWFyX3dpdGhfdGFnX2xpc3QgeCB+dGFncyA9XG4gIExpc3QuZm9sZF9yaWdodCB0YWdzIH5pbml0OnggfmY6KGZ1biAoa2V5LCB2YWx1ZSkgZ3JhbW1hciAtPlxuICAgIFNleHBfZ3JhbW1hci5UYWcgeyBrZXk7IHZhbHVlOyBncmFtbWFyIH0pXG47O1xuXG5sZXQgdW5pdF9zZXhwX2dyYW1tYXIgOiB1bml0IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gTGlzdCBFbXB0eSB9XG5sZXQgYm9vbF9zZXhwX2dyYW1tYXIgOiBib29sIFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gQm9vbCB9XG5sZXQgc3RyaW5nX3NleHBfZ3JhbW1hciA6IHN0cmluZyBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IFN0cmluZyB9XG5sZXQgYnl0ZXNfc2V4cF9ncmFtbWFyIDogYnl0ZXMgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBTdHJpbmcgfVxubGV0IGNoYXJfc2V4cF9ncmFtbWFyIDogY2hhciBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IENoYXIgfVxubGV0IGludF9zZXhwX2dyYW1tYXIgOiBpbnQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBJbnRlZ2VyIH1cbmxldCBmbG9hdF9zZXhwX2dyYW1tYXIgOiBmbG9hdCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEZsb2F0IH1cbmxldCBpbnQzMl9zZXhwX2dyYW1tYXIgOiBpbnQzMiBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IGludDY0X3NleHBfZ3JhbW1hciA6IGludDY0IFNleHBfZ3JhbW1hci50ID0geyB1bnR5cGVkID0gSW50ZWdlciB9XG5sZXQgbmF0aXZlaW50X3NleHBfZ3JhbW1hciA6IG5hdGl2ZWludCBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IEludGVnZXIgfVxubGV0IHNleHBfdF9zZXhwX2dyYW1tYXIgOiBTZXhwLnQgU2V4cF9ncmFtbWFyLnQgPSB7IHVudHlwZWQgPSBBbnkgXCJTZXhwLnRcIiB9XG5sZXQgcmVmX3NleHBfZ3JhbW1hciBncmFtbWFyID0gU2V4cF9ncmFtbWFyLmNvZXJjZSBncmFtbWFyXG5sZXQgbGF6eV90X3NleHBfZ3JhbW1hciBncmFtbWFyID0gU2V4cF9ncmFtbWFyLmNvZXJjZSBncmFtbWFyXG5cbmxldCBvcHRpb25fc2V4cF9ncmFtbWFyICh7IHVudHlwZWQgfSA6IF8gU2V4cF9ncmFtbWFyLnQpIDogXyBvcHRpb24gU2V4cF9ncmFtbWFyLnQgPVxuICB7IHVudHlwZWQgPSBPcHRpb24gdW50eXBlZCB9XG47O1xuXG5sZXQgbGlzdF9zZXhwX2dyYW1tYXIgKHsgdW50eXBlZCB9IDogXyBTZXhwX2dyYW1tYXIudCkgOiBfIGxpc3QgU2V4cF9ncmFtbWFyLnQgPVxuICB7IHVudHlwZWQgPSBMaXN0IChNYW55IHVudHlwZWQpIH1cbjs7XG5cbmxldCBhcnJheV9zZXhwX2dyYW1tYXIgKHsgdW50eXBlZCB9IDogXyBTZXhwX2dyYW1tYXIudCkgOiBfIGFycmF5IFNleHBfZ3JhbW1hci50ID1cbiAgeyB1bnR5cGVkID0gTGlzdCAoTWFueSB1bnR5cGVkKSB9XG47O1xuXG5sZXQgZW1wdHlfc2V4cF9ncmFtbWFyIDogXyBTZXhwX2dyYW1tYXIudCA9IHsgdW50eXBlZCA9IFVuaW9uIFtdIH1cbmxldCBvcGFxdWVfc2V4cF9ncmFtbWFyID0gZW1wdHlfc2V4cF9ncmFtbWFyXG5sZXQgZnVuX3NleHBfZ3JhbW1hciA9IGVtcHR5X3NleHBfZ3JhbW1hclxuIiwiKCogVXRpbGl0eSBNb2R1bGUgZm9yIFMtZXhwcmVzc2lvbiBDb252ZXJzaW9ucyAqKVxuXG5vcGVuIFN0ZExhYmVsc1xub3BlbiBNb3JlTGFiZWxzXG5vcGVuIFByaW50Zlxub3BlbiBTZXhwXG5cbigqIENvbnZlcnNpb24gb2YgT0NhbWwtdmFsdWVzIHRvIFMtZXhwcmVzc2lvbnMgKilcbmV4dGVybmFsIGZvcm1hdF9mbG9hdCA6IHN0cmluZyAtPiBmbG9hdCAtPiBzdHJpbmcgPSBcImNhbWxfZm9ybWF0X2Zsb2F0XCJcblxuKCogJyUuMTdnJyBpcyBndWFyYW50ZWVkIHRvIGJlIHJvdW5kLXRyaXBwYWJsZS5cblxuICAgJyUuMTVnJyB3aWxsIGJlIHJvdW5kLXRyaXBwYWJsZSBhbmQgbm90IGhhdmUgbm9pc2UgYXQgdGhlIGxhc3QgZGlnaXQgb3IgdHdvIGZvciBhIGZsb2F0XG4gICB3aGljaCB3YXMgY29udmVydGVkIGZyb20gYSBkZWNpbWFsIChzdHJpbmcpIHdpdGggPD0gMTUgc2lnbmlmaWNhbnQgZGlnaXRzLiAgU28gaXQnc1xuICAgd29ydGggdHJ5aW5nIGZpcnN0IHRvIGF2b2lkIHRoaW5ncyBsaWtlIFwiMy4xNDAwMDAwMDAwMDAwMDAxXCIuXG5cbiAgIFNlZSBjb21tZW50IGFib3ZlIFt0b19zdHJpbmdfcm91bmRfdHJpcHBhYmxlXSBpbiB7IUNvcmUuRmxvYXR9IGZvclxuICAgZGV0YWlsZWQgZXhwbGFuYXRpb24gYW5kIGV4YW1wbGVzLiAqKVxubGV0IGRlZmF1bHRfc3RyaW5nX29mX2Zsb2F0ID1cbiAgcmVmIChmdW4geCAtPlxuICAgIGxldCB5ID0gZm9ybWF0X2Zsb2F0IFwiJS4xNUdcIiB4IGluXG4gICAgaWYgZmxvYXRfb2Zfc3RyaW5nIHkgPSB4IHRoZW4geSBlbHNlIGZvcm1hdF9mbG9hdCBcIiUuMTdHXCIgeClcbjs7XG5cbmxldCByZWFkX29sZF9vcHRpb25fZm9ybWF0ID0gcmVmIHRydWVcbmxldCB3cml0ZV9vbGRfb3B0aW9uX2Zvcm1hdCA9IHJlZiB0cnVlXG5sZXQgbGlzdF9tYXAgZiBsID0gTGlzdC5yZXYgKExpc3QucmV2X21hcCBsIH5mKVxubGV0IHNleHBfb2ZfdW5pdCAoKSA9IExpc3QgW11cbmxldCBzZXhwX29mX2Jvb2wgYiA9IEF0b20gKHN0cmluZ19vZl9ib29sIGIpXG5sZXQgc2V4cF9vZl9zdHJpbmcgc3RyID0gQXRvbSBzdHJcbmxldCBzZXhwX29mX2J5dGVzIGJ5dGVzID0gQXRvbSAoQnl0ZXMudG9fc3RyaW5nIGJ5dGVzKVxubGV0IHNleHBfb2ZfY2hhciBjID0gQXRvbSAoU3RyaW5nLm1ha2UgMSBjKVxubGV0IHNleHBfb2ZfaW50IG4gPSBBdG9tIChzdHJpbmdfb2ZfaW50IG4pXG5sZXQgc2V4cF9vZl9mbG9hdCBuID0gQXRvbSAoIWRlZmF1bHRfc3RyaW5nX29mX2Zsb2F0IG4pXG5sZXQgc2V4cF9vZl9pbnQzMiBuID0gQXRvbSAoSW50MzIudG9fc3RyaW5nIG4pXG5sZXQgc2V4cF9vZl9pbnQ2NCBuID0gQXRvbSAoSW50NjQudG9fc3RyaW5nIG4pXG5sZXQgc2V4cF9vZl9uYXRpdmVpbnQgbiA9IEF0b20gKE5hdGl2ZWludC50b19zdHJpbmcgbilcbmxldCBzZXhwX29mX3JlZiBzZXhwX29mX19hIHJmID0gc2V4cF9vZl9fYSAhcmZcbmxldCBzZXhwX29mX2xhenlfdCBzZXhwX29mX19hIGx2ID0gc2V4cF9vZl9fYSAoTGF6eS5mb3JjZSBsdilcblxubGV0IHNleHBfb2Zfb3B0aW9uIHNleHBfb2ZfX2EgPSBmdW5jdGlvblxuICB8IFNvbWUgeCB3aGVuICF3cml0ZV9vbGRfb3B0aW9uX2Zvcm1hdCAtPiBMaXN0IFsgc2V4cF9vZl9fYSB4IF1cbiAgfCBTb21lIHggLT4gTGlzdCBbIEF0b20gXCJzb21lXCI7IHNleHBfb2ZfX2EgeCBdXG4gIHwgTm9uZSB3aGVuICF3cml0ZV9vbGRfb3B0aW9uX2Zvcm1hdCAtPiBMaXN0IFtdXG4gIHwgTm9uZSAtPiBBdG9tIFwibm9uZVwiXG47O1xuXG5sZXQgc2V4cF9vZl9wYWlyIHNleHBfb2ZfX2Egc2V4cF9vZl9fYiAoYSwgYikgPSBMaXN0IFsgc2V4cF9vZl9fYSBhOyBzZXhwX29mX19iIGIgXVxuXG5sZXQgc2V4cF9vZl90cmlwbGUgc2V4cF9vZl9fYSBzZXhwX29mX19iIHNleHBfb2ZfX2MgKGEsIGIsIGMpID1cbiAgTGlzdCBbIHNleHBfb2ZfX2EgYTsgc2V4cF9vZl9fYiBiOyBzZXhwX29mX19jIGMgXVxuOztcblxuKCogTGlzdC5yZXYgKExpc3QucmV2X21hcCAuLi4pIGlzIHRhaWwgcmVjdXJzaXZlLCB0aGUgT0NhbWwgc3RhbmRhcmRcbiAgIGxpYnJhcnkgTGlzdC5tYXAgaXMgTk9ULiAqKVxubGV0IHNleHBfb2ZfbGlzdCBzZXhwX29mX19hIGxzdCA9IExpc3QgKExpc3QucmV2IChMaXN0LnJldl9tYXAgbHN0IH5mOnNleHBfb2ZfX2EpKVxuXG5sZXQgc2V4cF9vZl9hcnJheSBzZXhwX29mX19hIGFyID1cbiAgbGV0IGxzdF9yZWYgPSByZWYgW10gaW5cbiAgZm9yIGkgPSBBcnJheS5sZW5ndGggYXIgLSAxIGRvd250byAwIGRvXG4gICAgbHN0X3JlZiA6PSBzZXhwX29mX19hIGFyLihpKSA6OiAhbHN0X3JlZlxuICBkb25lO1xuICBMaXN0ICFsc3RfcmVmXG47O1xuXG5sZXQgc2V4cF9vZl9oYXNodGJsIHNleHBfb2Zfa2V5IHNleHBfb2ZfdmFsIGh0YmwgPVxuICBsZXQgY29sbCB+a2V5OmsgfmRhdGE6diBhY2MgPSBMaXN0IFsgc2V4cF9vZl9rZXkgazsgc2V4cF9vZl92YWwgdiBdIDo6IGFjYyBpblxuICBMaXN0IChIYXNodGJsLmZvbGQgaHRibCB+aW5pdDpbXSB+Zjpjb2xsKVxuOztcblxubGV0IHNleHBfb2Zfb3BhcXVlIF8gPSBBdG9tIFwiPG9wYXF1ZT5cIlxubGV0IHNleHBfb2ZfZnVuIF8gPSBBdG9tIFwiPGZ1bj5cIlxuXG4oKiBFeGNlcHRpb24gY29udmVydGVyIHJlZ2lzdHJhdGlvbiBhbmQgbG9va3VwICopXG5cbm1vZHVsZSBFeG5fY29udmVydGVyID0gc3RydWN0XG4gICgqIFRoZXNlIGV4Y2VwdGlvbiByZWdpc3RyYXRpb24gZnVuY3Rpb25zIGFzc3VtZSB0aGF0IGNvbnRleHQtc3dpdGNoZXNcbiAgICAgY2Fubm90IGhhcHBlbiB1bmxlc3MgdGhlcmUgaXMgYW4gYWxsb2NhdGlvbi4gIEl0IGlzIHJlYXNvbmFibGUgdG8gZXhwZWN0XG4gICAgIHRoYXQgdGhpcyB3aWxsIHJlbWFpbiB0cnVlIGZvciB0aGUgZm9yZXNlZWFibGUgZnV0dXJlLiAgVGhhdCB3YXkgd2VcbiAgICAgYXZvaWQgdXNpbmcgbXV0ZXhlcyBhbmQgdGh1cyBhIGRlcGVuZGVuY3kgb24gdGhlIHRocmVhZHMgbGlicmFyeS4gKilcblxuICAoKiBGYXN0IGFuZCBhdXRvbWF0aWMgZXhjZXB0aW9uIHJlZ2lzdHJhdGlvbiAqKVxuXG4gIG1vZHVsZSBSZWdpc3RyYXRpb24gPSBzdHJ1Y3RcbiAgICB0eXBlIHQgPVxuICAgICAgeyBzZXhwX29mX2V4biA6IGV4biAtPiBTZXhwLnRcbiAgICAgIDsgKCogSWYgW3ByaW50ZXhjID0gdHJ1ZV0gdGhlbiB0aGlzIHNleHAgY29udmVydGVyIGlzIHVzZWQgZm9yIFByaW50ZXhjLnRvX3N0cmluZyAqKVxuICAgICAgICBwcmludGV4YyA6IGJvb2xcbiAgICAgIH1cbiAgZW5kXG5cbiAgbW9kdWxlIEV4bl90YWJsZSA9IEVwaGVtZXJvbi5LMS5NYWtlIChzdHJ1Y3RcbiAgICAgIHR5cGUgdCA9IGV4dGVuc2lvbl9jb25zdHJ1Y3RvclxuXG4gICAgICBsZXQgZXF1YWwgPSAoID09IClcbiAgICAgIGxldCBoYXNoID0gT2JqLkV4dGVuc2lvbl9jb25zdHJ1Y3Rvci5pZFxuICAgIGVuZClcblxuICBsZXQgdGhlX2V4bl90YWJsZSA6IFJlZ2lzdHJhdGlvbi50IEV4bl90YWJsZS50ID0gRXhuX3RhYmxlLmNyZWF0ZSAxN1xuXG4gICgqIEVwaGVtZXJvbnMgYXJlIHVzZWQgc28gdGhhdCBbc2V4cF9vZl9leG5dIGNsb3N1cmUgZG9uJ3Qga2VlcCB0aGVcbiAgICAgZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIGxpdmUuICopXG4gIGxldCBhZGQgPyhwcmludGV4YyA9IHRydWUpID9maW5hbGlzZTpfIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBzZXhwX29mX2V4biA9XG4gICAgRXhuX3RhYmxlLmFkZCB0aGVfZXhuX3RhYmxlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciB7IHNleHBfb2ZfZXhuOyBwcmludGV4YyB9XG4gIDs7XG5cbiAgbGV0IGZpbmRfYXV0byB+Zm9yX3ByaW50ZXhjIGV4biA9XG4gICAgbGV0IGV4dGVuc2lvbl9jb25zdHJ1Y3RvciA9IE9iai5FeHRlbnNpb25fY29uc3RydWN0b3Iub2ZfdmFsIGV4biBpblxuICAgIG1hdGNoIEV4bl90YWJsZS5maW5kX29wdCB0aGVfZXhuX3RhYmxlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgeyBzZXhwX29mX2V4bjsgcHJpbnRleGMgfSAtPlxuICAgICAgKG1hdGNoIGZvcl9wcmludGV4YywgcHJpbnRleGMgd2l0aFxuICAgICAgIHwgZmFsc2UsIF8gfCBfLCB0cnVlIC0+IFNvbWUgKHNleHBfb2ZfZXhuIGV4bilcbiAgICAgICB8IHRydWUsIGZhbHNlIC0+IE5vbmUpXG4gIDs7XG5cbiAgbW9kdWxlIEZvcl91bml0X3Rlc3RzX29ubHkgPSBzdHJ1Y3RcbiAgICBsZXQgc2l6ZSAoKSA9IChFeG5fdGFibGUuc3RhdHNfYWxpdmUgdGhlX2V4bl90YWJsZSkubnVtX2JpbmRpbmdzXG4gIGVuZFxuZW5kXG5cbmxldCBzZXhwX29mX2V4bl9vcHRfZm9yX3ByaW50ZXhjIGV4biA9IEV4bl9jb252ZXJ0ZXIuZmluZF9hdXRvIH5mb3JfcHJpbnRleGM6dHJ1ZSBleG5cbmxldCBzZXhwX29mX2V4bl9vcHQgZXhuID0gRXhuX2NvbnZlcnRlci5maW5kX2F1dG8gfmZvcl9wcmludGV4YzpmYWxzZSBleG5cblxubGV0IHNleHBfb2ZfZXhuIGV4biA9XG4gIG1hdGNoIHNleHBfb2ZfZXhuX29wdCBleG4gd2l0aFxuICB8IE5vbmUgLT4gTGlzdCBbIEF0b20gKFByaW50ZXhjLnRvX3N0cmluZyBleG4pIF1cbiAgfCBTb21lIHNleHAgLT4gc2V4cFxuOztcblxubGV0IGV4bl90b19zdHJpbmcgZSA9IFNleHAudG9fc3RyaW5nX2h1bSAoc2V4cF9vZl9leG4gZSlcblxuKCoge1tleGNlcHRpb24gQmxhaCBbQEBkZXJpdmluZyBzZXhwXV19IGdlbmVyYXRlcyBhIGNhbGwgdG8gdGhlIGZ1bmN0aW9uXG4gICBbRXhuX2NvbnZlcnRlci5hZGRdIGRlZmluZWQgaW4gdGhpcyBmaWxlLiAgU28gd2UgYXJlIGd1YXJhbnRlZCB0aGF0IGFzIHNvb24gYXMgd2VcbiAgIG1hcmsgYW4gZXhjZXB0aW9uIGFzIHNleHBhYmxlLCB0aGlzIG1vZHVsZSB3aWxsIGJlIGxpbmtlZCBpbiBhbmQgdGhpcyBwcmludGVyIHdpbGwgYmVcbiAgIHJlZ2lzdGVyZWQsIHdoaWNoIGlzIHdoYXQgd2Ugd2FudC4gKilcbmxldCAoKSA9XG4gIFByaW50ZXhjLnJlZ2lzdGVyX3ByaW50ZXIgKGZ1biBleG4gLT5cbiAgICBtYXRjaCBzZXhwX29mX2V4bl9vcHRfZm9yX3ByaW50ZXhjIGV4biB3aXRoXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgc2V4cCAtPiBTb21lIChTZXhwLnRvX3N0cmluZ19odW0gfmluZGVudDoyIHNleHApKVxuOztcblxubGV0IHByaW50ZXhjX3ByZWZlcl9zZXhwIGV4biA9XG4gIG1hdGNoIHNleHBfb2ZfZXhuX29wdCBleG4gd2l0aFxuICB8IE5vbmUgLT4gUHJpbnRleGMudG9fc3RyaW5nIGV4blxuICB8IFNvbWUgc2V4cCAtPiBTZXhwLnRvX3N0cmluZ19odW0gfmluZGVudDoyIHNleHBcbjs7XG5cbigqIENvbnZlcnNpb24gb2YgUy1leHByZXNzaW9ucyB0byBPQ2FtbC12YWx1ZXMgKilcblxuZXhjZXB0aW9uIE9mX3NleHBfZXJyb3IgPSBTZXhwLk9mX3NleHBfZXJyb3JcblxubGV0IHJlY29yZF9jaGVja19leHRyYV9maWVsZHMgPSByZWYgdHJ1ZVxubGV0IG9mX3NleHBfZXJyb3JfZXhuIGV4YyBzZXhwID0gcmFpc2UgKE9mX3NleHBfZXJyb3IgKGV4Yywgc2V4cCkpXG5sZXQgb2Zfc2V4cF9lcnJvciB3aGF0IHNleHAgPSByYWlzZSAoT2Zfc2V4cF9lcnJvciAoRmFpbHVyZSB3aGF0LCBzZXhwKSlcblxubGV0IHVuaXRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbXSAtPiAoKVxuICB8IEF0b20gXyB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwidW5pdF9vZl9zZXhwOiBlbXB0eSBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBib29sX29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gKFwidHJ1ZVwiIHwgXCJUcnVlXCIpIC0+IHRydWVcbiAgfCBBdG9tIChcImZhbHNlXCIgfCBcIkZhbHNlXCIpIC0+IGZhbHNlXG4gIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJib29sX29mX3NleHA6IHVua25vd24gc3RyaW5nXCIgc2V4cFxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiYm9vbF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBzdHJpbmdfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT4gc3RyXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJzdHJpbmdfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgYnl0ZXNfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT4gQnl0ZXMub2Zfc3RyaW5nIHN0clxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiYnl0ZXNfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgY2hhcl9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgIGlmIFN0cmluZy5sZW5ndGggc3RyIDw+IDFcbiAgICB0aGVuIG9mX3NleHBfZXJyb3IgXCJjaGFyX29mX3NleHA6IGF0b20gc3RyaW5nIG11c3QgY29udGFpbiBvbmUgY2hhcmFjdGVyIG9ubHlcIiBzZXhwO1xuICAgIHN0ci5bMF1cbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImNoYXJfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgaW50X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBpbnRfb2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiaW50X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJpbnRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgZmxvYXRfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgQXRvbSBzdHIgLT5cbiAgICAodHJ5IGZsb2F0X29mX3N0cmluZyBzdHIgd2l0aFxuICAgICB8IGV4YyAtPiBvZl9zZXhwX2Vycm9yIChcImZsb2F0X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJmbG9hdF9vZl9zZXhwOiBhdG9tIG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBpbnQzMl9vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBBdG9tIHN0ciAtPlxuICAgICh0cnkgSW50MzIub2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwiaW50MzJfb2Zfc2V4cDogXCIgXiBleG5fdG9fc3RyaW5nIGV4Yykgc2V4cClcbiAgfCBMaXN0IF8gLT4gb2Zfc2V4cF9lcnJvciBcImludDMyX29mX3NleHA6IGF0b20gbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGludDY0X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBJbnQ2NC5vZl9zdHJpbmcgc3RyIHdpdGhcbiAgICAgfCBleGMgLT4gb2Zfc2V4cF9lcnJvciAoXCJpbnQ2NF9vZl9zZXhwOiBcIiBeIGV4bl90b19zdHJpbmcgZXhjKSBzZXhwKVxuICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwiaW50NjRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgbmF0aXZlaW50X29mX3NleHAgc2V4cCA9XG4gIG1hdGNoIHNleHAgd2l0aFxuICB8IEF0b20gc3RyIC0+XG4gICAgKHRyeSBOYXRpdmVpbnQub2Zfc3RyaW5nIHN0ciB3aXRoXG4gICAgIHwgZXhjIC0+IG9mX3NleHBfZXJyb3IgKFwibmF0aXZlaW50X29mX3NleHA6IFwiIF4gZXhuX3RvX3N0cmluZyBleGMpIHNleHApXG4gIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJuYXRpdmVpbnRfb2Zfc2V4cDogYXRvbSBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgcmVmX29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID0gcmVmIChhX19vZl9zZXhwIHNleHApXG5sZXQgbGF6eV90X29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID0gTGF6eS5mcm9tX3ZhbCAoYV9fb2Zfc2V4cCBzZXhwKVxuXG5sZXQgb3B0aW9uX29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID1cbiAgaWYgIXJlYWRfb2xkX29wdGlvbl9mb3JtYXRcbiAgdGhlbiAoXG4gICAgbWF0Y2ggc2V4cCB3aXRoXG4gICAgfCBMaXN0IFtdIHwgQXRvbSAoXCJub25lXCIgfCBcIk5vbmVcIikgLT4gTm9uZVxuICAgIHwgTGlzdCBbIGVsIF0gfCBMaXN0IFsgQXRvbSAoXCJzb21lXCIgfCBcIlNvbWVcIik7IGVsIF0gLT4gU29tZSAoYV9fb2Zfc2V4cCBlbClcbiAgICB8IExpc3QgXyAtPiBvZl9zZXhwX2Vycm9yIFwib3B0aW9uX29mX3NleHA6IGxpc3QgbXVzdCByZXByZXNlbnQgb3B0aW9uYWwgdmFsdWVcIiBzZXhwXG4gICAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcIm9wdGlvbl9vZl9zZXhwOiBvbmx5IG5vbmUgY2FuIGJlIGF0b21cIiBzZXhwKVxuICBlbHNlIChcbiAgICBtYXRjaCBzZXhwIHdpdGhcbiAgICB8IEF0b20gKFwibm9uZVwiIHwgXCJOb25lXCIpIC0+IE5vbmVcbiAgICB8IExpc3QgWyBBdG9tIChcInNvbWVcIiB8IFwiU29tZVwiKTsgZWwgXSAtPiBTb21lIChhX19vZl9zZXhwIGVsKVxuICAgIHwgQXRvbSBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogb25seSBub25lIGNhbiBiZSBhdG9tXCIgc2V4cFxuICAgIHwgTGlzdCBfIC0+IG9mX3NleHBfZXJyb3IgXCJvcHRpb25fb2Zfc2V4cDogbGlzdCBtdXN0IGJlIChzb21lIGVsKVwiIHNleHApXG47O1xuXG5sZXQgcGFpcl9vZl9zZXhwIGFfX29mX3NleHAgYl9fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbIGFfc2V4cDsgYl9zZXhwIF0gLT5cbiAgICBsZXQgYSA9IGFfX29mX3NleHAgYV9zZXhwIGluXG4gICAgbGV0IGIgPSBiX19vZl9zZXhwIGJfc2V4cCBpblxuICAgIGEsIGJcbiAgfCBMaXN0IF8gLT5cbiAgICBvZl9zZXhwX2Vycm9yIFwicGFpcl9vZl9zZXhwOiBsaXN0IG11c3QgY29udGFpbiBleGFjdGx5IHR3byBlbGVtZW50cyBvbmx5XCIgc2V4cFxuICB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwicGFpcl9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCB0cmlwbGVfb2Zfc2V4cCBhX19vZl9zZXhwIGJfX29mX3NleHAgY19fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBbIGFfc2V4cDsgYl9zZXhwOyBjX3NleHAgXSAtPlxuICAgIGxldCBhID0gYV9fb2Zfc2V4cCBhX3NleHAgaW5cbiAgICBsZXQgYiA9IGJfX29mX3NleHAgYl9zZXhwIGluXG4gICAgbGV0IGMgPSBjX19vZl9zZXhwIGNfc2V4cCBpblxuICAgIGEsIGIsIGNcbiAgfCBMaXN0IF8gLT5cbiAgICBvZl9zZXhwX2Vycm9yIFwidHJpcGxlX29mX3NleHA6IGxpc3QgbXVzdCBjb250YWluIGV4YWN0bHkgdGhyZWUgZWxlbWVudHMgb25seVwiIHNleHBcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcInRyaXBsZV9vZl9zZXhwOiBsaXN0IG5lZWRlZFwiIHNleHBcbjs7XG5cbmxldCBsaXN0X29mX3NleHAgYV9fb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBsc3QgLT5cbiAgICBsZXQgcmV2X2xzdCA9IExpc3QucmV2X21hcCBsc3QgfmY6YV9fb2Zfc2V4cCBpblxuICAgIExpc3QucmV2IHJldl9sc3RcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImxpc3Rfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgYXJyYXlfb2Zfc2V4cCBhX19vZl9zZXhwIHNleHAgPVxuICBtYXRjaCBzZXhwIHdpdGhcbiAgfCBMaXN0IFtdIC0+IFt8fF1cbiAgfCBMaXN0IChoIDo6IHQpIC0+XG4gICAgbGV0IGxlbiA9IExpc3QubGVuZ3RoIHQgKyAxIGluXG4gICAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgbGVuIChhX19vZl9zZXhwIGgpIGluXG4gICAgbGV0IHJlYyBsb29wIGkgPSBmdW5jdGlvblxuICAgICAgfCBbXSAtPiByZXNcbiAgICAgIHwgaCA6OiB0IC0+XG4gICAgICAgIHJlcy4oaSkgPC0gYV9fb2Zfc2V4cCBoO1xuICAgICAgICBsb29wIChpICsgMSkgdFxuICAgIGluXG4gICAgbG9vcCAxIHRcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImFycmF5X29mX3NleHA6IGxpc3QgbmVlZGVkXCIgc2V4cFxuOztcblxubGV0IGhhc2h0Ymxfb2Zfc2V4cCBrZXlfb2Zfc2V4cCB2YWxfb2Zfc2V4cCBzZXhwID1cbiAgbWF0Y2ggc2V4cCB3aXRoXG4gIHwgTGlzdCBsc3QgLT5cbiAgICBsZXQgaHRibCA9IEhhc2h0YmwuY3JlYXRlIDAgaW5cbiAgICBsZXQgYWN0ID0gZnVuY3Rpb25cbiAgICAgIHwgTGlzdCBbIGtfc2V4cDsgdl9zZXhwIF0gLT5cbiAgICAgICAgSGFzaHRibC5hZGQgaHRibCB+a2V5OihrZXlfb2Zfc2V4cCBrX3NleHApIH5kYXRhOih2YWxfb2Zfc2V4cCB2X3NleHApXG4gICAgICB8IExpc3QgXyB8IEF0b20gXyAtPiBvZl9zZXhwX2Vycm9yIFwiaGFzaHRibF9vZl9zZXhwOiB0dXBsZSBsaXN0IG5lZWRlZFwiIHNleHBcbiAgICBpblxuICAgIExpc3QuaXRlciBsc3QgfmY6YWN0O1xuICAgIGh0YmxcbiAgfCBBdG9tIF8gLT4gb2Zfc2V4cF9lcnJvciBcImhhc2h0Ymxfb2Zfc2V4cDogbGlzdCBuZWVkZWRcIiBzZXhwXG47O1xuXG5sZXQgb3BhcXVlX29mX3NleHAgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgXCJvcGFxdWVfb2Zfc2V4cDogY2Fubm90IGNvbnZlcnQgb3BhcXVlIHZhbHVlc1wiIHNleHBcbjs7XG5cbmxldCBmdW5fb2Zfc2V4cCBzZXhwID0gb2Zfc2V4cF9lcnJvciBcImZ1bl9vZl9zZXhwOiBjYW5ub3QgY29udmVydCBmdW5jdGlvbiB2YWx1ZXNcIiBzZXhwXG5cbigqIFNleHAgR3JhbW1hcnMgKilcblxuaW5jbHVkZSBTZXhwX2NvbnZfZ3JhbW1hclxuXG4oKiBSZWdpc3RlcmluZyBkZWZhdWx0IGV4Y2VwdGlvbiBwcmludGVycyAqKVxuXG5sZXQgZ2V0X2ZsY19lcnJvciBuYW1lIChmaWxlLCBsaW5lLCBjaHIpID0gQXRvbSAoc3ByaW50ZiBcIiVzICVzOiVkOiVkXCIgbmFtZSBmaWxlIGxpbmUgY2hyKVxuXG5sZXQgKCkgPVxuICBMaXN0Lml0ZXJcbiAgICB+ZjooZnVuIChleHRlbnNpb25fY29uc3RydWN0b3IsIGhhbmRsZXIpIC0+XG4gICAgICBFeG5fY29udmVydGVyLmFkZCB+cHJpbnRleGM6ZmFsc2UgfmZpbmFsaXNlOmZhbHNlIGV4dGVuc2lvbl9jb25zdHJ1Y3RvciBoYW5kbGVyKVxuICAgIFsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBBc3NlcnRfZmFpbHVyZV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBBc3NlcnRfZmFpbHVyZSBhcmcgLT4gZ2V0X2ZsY19lcnJvciBcIkFzc2VydF9mYWlsdXJlXCIgYXJnXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBFeGl0XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEV4aXQgLT4gQXRvbSBcIkV4aXRcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgRW5kX29mX2ZpbGVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgRW5kX29mX2ZpbGUgLT4gQXRvbSBcIkVuZF9vZl9maWxlXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIEZhaWx1cmVdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgRmFpbHVyZSBhcmcgLT4gTGlzdCBbIEF0b20gXCJGYWlsdXJlXCI7IEF0b20gYXJnIF1cbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIE5vdF9mb3VuZF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBOb3RfZm91bmQgLT4gQXRvbSBcIk5vdF9mb3VuZFwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBJbnZhbGlkX2FyZ3VtZW50XVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IEludmFsaWRfYXJndW1lbnQgYXJnIC0+IExpc3QgWyBBdG9tIFwiSW52YWxpZF9hcmd1bWVudFwiOyBBdG9tIGFyZyBdXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBNYXRjaF9mYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IE1hdGNoX2ZhaWx1cmUgYXJnIC0+IGdldF9mbGNfZXJyb3IgXCJNYXRjaF9mYWlsdXJlXCIgYXJnXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBOb3RfZm91bmRfc11cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBOb3RfZm91bmRfcyBhcmcgLT4gTGlzdCBbIEF0b20gXCJOb3RfZm91bmRfc1wiOyBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU3lzX2Vycm9yXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFN5c19lcnJvciBhcmcgLT4gTGlzdCBbIEF0b20gXCJTeXNfZXJyb3JcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgQXJnLkhlbHBdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgQXJnLkhlbHAgYXJnIC0+IExpc3QgWyBBdG9tIFwiQXJnLkhlbHBcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgQXJnLkJhZF1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBBcmcuQmFkIGFyZyAtPiBMaXN0IFsgQXRvbSBcIkFyZy5CYWRcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgTGF6eS5VbmRlZmluZWRdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgTGF6eS5VbmRlZmluZWQgLT4gQXRvbSBcIkxhenkuVW5kZWZpbmVkXCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFBhcnNpbmcuUGFyc2VfZXJyb3JdXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgUGFyc2luZy5QYXJzZV9lcnJvciAtPiBBdG9tIFwiUGFyc2luZy5QYXJzZV9lcnJvclwiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIDsgKCBbJWV4dGVuc2lvbl9jb25zdHJ1Y3RvciBRdWV1ZS5FbXB0eV1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBRdWV1ZS5FbXB0eSAtPiBBdG9tIFwiUXVldWUuRW1wdHlcIlxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU2NhbmYuU2Nhbl9mYWlsdXJlXVxuICAgICAgLCBmdW5jdGlvblxuICAgICAgICB8IFNjYW5mLlNjYW5fZmFpbHVyZSBhcmcgLT4gTGlzdCBbIEF0b20gXCJTY2FuZi5TY2FuX2ZhaWx1cmVcIjsgQXRvbSBhcmcgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICA7ICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgU3RhY2suRW1wdHldXG4gICAgICAsIGZ1bmN0aW9uXG4gICAgICAgIHwgU3RhY2suRW1wdHkgLT4gQXRvbSBcIlN0YWNrLkVtcHR5XCJcbiAgICAgICAgfCBfIC0+IGFzc2VydCBmYWxzZSApXG4gICAgOyAoIFslZXh0ZW5zaW9uX2NvbnN0cnVjdG9yIFN5cy5CcmVha11cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBTeXMuQnJlYWsgLT4gQXRvbSBcIlN5cy5CcmVha1wiXG4gICAgICAgIHwgXyAtPiBhc3NlcnQgZmFsc2UgKVxuICAgIF1cbjs7XG5cbmxldCAoKSA9XG4gIExpc3QuaXRlclxuICAgIH5mOihmdW4gKGV4dGVuc2lvbl9jb25zdHJ1Y3RvciwgaGFuZGxlcikgLT5cbiAgICAgIEV4bl9jb252ZXJ0ZXIuYWRkIH5wcmludGV4Yzp0cnVlIH5maW5hbGlzZTpmYWxzZSBleHRlbnNpb25fY29uc3RydWN0b3IgaGFuZGxlcilcbiAgICBbICggWyVleHRlbnNpb25fY29uc3RydWN0b3IgT2Zfc2V4cF9lcnJvcl1cbiAgICAgICwgZnVuY3Rpb25cbiAgICAgICAgfCBPZl9zZXhwX2Vycm9yIChleGMsIHNleHApIC0+XG4gICAgICAgICAgTGlzdCBbIEF0b20gXCJTZXhwbGliLkNvbnYuT2Zfc2V4cF9lcnJvclwiOyBzZXhwX29mX2V4biBleGM7IHNleHAgXVxuICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlIClcbiAgICBdXG47O1xuXG5leHRlcm5hbCBpZ25vcmUgOiBfIC0+IHVuaXQgPSBcIiVpZ25vcmVcIlxuZXh0ZXJuYWwgKCA9ICkgOiAnYSAtPiAnYSAtPiBib29sID0gXCIlZXF1YWxcIlxuIiwiKCogQ29udl9lcnJvcjogTW9kdWxlIGZvciBIYW5kbGluZyBFcnJvcnMgZHVyaW5nIEF1dG9tYXRlZCBTLWV4cHJlc3Npb25cbiAgIENvbnZlcnNpb25zICopXG5cbm9wZW4gU3RkTGFiZWxzXG5vcGVuIFByaW50Zlxub3BlbiBTZXhwX2NvbnZcblxuZXhjZXB0aW9uIE9mX3NleHBfZXJyb3IgPSBPZl9zZXhwX2Vycm9yXG5cbigqIEVycm9ycyBjb25jZXJuaW5nIHR1cGxlcyAqKVxuXG5sZXQgdHVwbGVfb2Zfc2l6ZV9uX2V4cGVjdGVkIGxvYyBuIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChzcHJpbnRmIFwiJXNfb2Zfc2V4cDogdHVwbGUgb2Ygc2l6ZSAlZCBleHBlY3RlZFwiIGxvYyBuKSBzZXhwXG47O1xuXG4oKiBFcnJvcnMgY29uY2VybmluZyBzdW0gdHlwZXMgKilcblxubGV0IHN0YWdfbm9fYXJncyBsb2Mgc2V4cCA9XG4gIG9mX3NleHBfZXJyb3IgKGxvYyBeIFwiX29mX3NleHA6IHRoaXMgY29uc3RydWN0b3IgZG9lcyBub3QgdGFrZSBhcmd1bWVudHNcIikgc2V4cFxuOztcblxubGV0IHN0YWdfaW5jb3JyZWN0X25fYXJncyBsb2MgdGFnIHNleHAgPVxuICBsZXQgbXNnID0gc3ByaW50ZiBcIiVzX29mX3NleHA6IHN1bSB0YWcgJVMgaGFzIGluY29ycmVjdCBudW1iZXIgb2YgYXJndW1lbnRzXCIgbG9jIHRhZyBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgc3RhZ190YWtlc19hcmdzIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogdGhpcyBjb25zdHJ1Y3RvciByZXF1aXJlcyBhcmd1bWVudHNcIikgc2V4cFxuOztcblxubGV0IG5lc3RlZF9saXN0X2ludmFsaWRfc3VtIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogZXhwZWN0ZWQgYSB2YXJpYW50IHR5cGUsIHNhdyBhIG5lc3RlZCBsaXN0XCIpIHNleHBcbjs7XG5cbmxldCBlbXB0eV9saXN0X2ludmFsaWRfc3VtIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogZXhwZWN0ZWQgYSB2YXJpYW50IHR5cGUsIHNhdyBhbiBlbXB0eSBsaXN0XCIpIHNleHBcbjs7XG5cbmxldCB1bmV4cGVjdGVkX3N0YWcgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiB1bmV4cGVjdGVkIHZhcmlhbnQgY29uc3RydWN0b3JcIikgc2V4cFxuOztcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgcmVjb3JkcyAqKVxuXG5sZXQgcmVjb3JkX3NleHBfYm9vbF93aXRoX3BheWxvYWQgbG9jIHNleHAgPVxuICBsZXQgbXNnID1cbiAgICBsb2MgXiBcIl9vZl9zZXhwOiByZWNvcmQgY29udmVyc2lvbjogYSBbc2V4cC5ib29sXSBmaWVsZCB3YXMgZ2l2ZW4gYSBwYXlsb2FkLlwiXG4gIGluXG4gIG9mX3NleHBfZXJyb3IgbXNnIHNleHBcbjs7XG5cbmxldCByZWNvcmRfb25seV9wYWlyc19leHBlY3RlZCBsb2Mgc2V4cCA9XG4gIGxldCBtc2cgPVxuICAgIGxvY1xuICAgIF4gXCJfb2Zfc2V4cDogcmVjb3JkIGNvbnZlcnNpb246IG9ubHkgcGFpcnMgZXhwZWN0ZWQsIHRoZWlyIGZpcnN0IGVsZW1lbnQgbXVzdCBiZSBhbiBcXFxuICAgICAgIGF0b21cIlxuICBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX3N1cGVyZmx1b3VzX2ZpZWxkcyB+d2hhdCB+bG9jIHJldl9mbGRfbmFtZXMgc2V4cCA9XG4gIGxldCBmbGRfbmFtZXNfc3RyID0gU3RyaW5nLmNvbmNhdCAoTGlzdC5yZXYgcmV2X2ZsZF9uYW1lcykgfnNlcDpcIiBcIiBpblxuICBsZXQgbXNnID0gc3ByaW50ZiBcIiVzX29mX3NleHA6ICVzOiAlc1wiIGxvYyB3aGF0IGZsZF9uYW1lc19zdHIgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxubGV0IHJlY29yZF9kdXBsaWNhdGVfZmllbGRzIGxvYyByZXZfZmxkX25hbWVzIHNleHAgPVxuICByZWNvcmRfc3VwZXJmbHVvdXNfZmllbGRzIH53aGF0OlwiZHVwbGljYXRlIGZpZWxkc1wiIH5sb2MgcmV2X2ZsZF9uYW1lcyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX2V4dHJhX2ZpZWxkcyBsb2MgcmV2X2ZsZF9uYW1lcyBzZXhwID1cbiAgcmVjb3JkX3N1cGVyZmx1b3VzX2ZpZWxkcyB+d2hhdDpcImV4dHJhIGZpZWxkc1wiIH5sb2MgcmV2X2ZsZF9uYW1lcyBzZXhwXG47O1xuXG5sZXQgcmVjIHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgZmllbGRzID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBTdHJpbmcuY29uY2F0IChMaXN0LnJldiBmaWVsZHMpIH5zZXA6XCIgXCJcbiAgfCAodHJ1ZSwgZmllbGQpIDo6IHJlc3QgLT4gcmVjb3JkX2dldF91bmRlZmluZWRfbG9vcCAoZmllbGQgOjogZmllbGRzKSByZXN0XG4gIHwgXyA6OiByZXN0IC0+IHJlY29yZF9nZXRfdW5kZWZpbmVkX2xvb3AgZmllbGRzIHJlc3Rcbjs7XG5cbmxldCByZWNvcmRfdW5kZWZpbmVkX2VsZW1lbnRzIGxvYyBzZXhwIGxzdCA9XG4gIGxldCB1bmRlZmluZWQgPSByZWNvcmRfZ2V0X3VuZGVmaW5lZF9sb29wIFtdIGxzdCBpblxuICBsZXQgbXNnID1cbiAgICBzcHJpbnRmIFwiJXNfb2Zfc2V4cDogdGhlIGZvbGxvd2luZyByZWNvcmQgZWxlbWVudHMgd2VyZSB1bmRlZmluZWQ6ICVzXCIgbG9jIHVuZGVmaW5lZFxuICBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX2xpc3RfaW5zdGVhZF9hdG9tIGxvYyBzZXhwID1cbiAgbGV0IG1zZyA9IGxvYyBeIFwiX29mX3NleHA6IGxpc3QgaW5zdGVhZCBvZiBhdG9tIGZvciByZWNvcmQgZXhwZWN0ZWRcIiBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgcmVjb3JkX3BvbHlfZmllbGRfdmFsdWUgbG9jIHNleHAgPVxuICBsZXQgbXNnID1cbiAgICBsb2NcbiAgICBeIFwiX29mX3NleHA6IGNhbm5vdCBjb252ZXJ0IHZhbHVlcyBvZiB0eXBlcyByZXN1bHRpbmcgZnJvbSBwb2x5bW9ycGhpYyByZWNvcmQgZmllbGRzXCJcbiAgaW5cbiAgb2Zfc2V4cF9lcnJvciBtc2cgc2V4cFxuOztcblxuKCogRXJyb3JzIGNvbmNlcm5pbmcgcG9seW1vcnBoaWMgdmFyaWFudHMgKilcblxuZXhjZXB0aW9uIE5vX3ZhcmlhbnRfbWF0Y2hcblxubGV0IG5vX3ZhcmlhbnRfbWF0Y2ggKCkgPSByYWlzZSBOb192YXJpYW50X21hdGNoXG5cbmxldCBub19tYXRjaGluZ192YXJpYW50X2ZvdW5kIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogbm8gbWF0Y2hpbmcgdmFyaWFudCBmb3VuZFwiKSBzZXhwXG47O1xuXG5sZXQgcHRhZ19ub19hcmdzIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogcG9seW1vcnBoaWMgdmFyaWFudCBkb2VzIG5vdCB0YWtlIGFyZ3VtZW50c1wiKSBzZXhwXG47O1xuXG5sZXQgcHRhZ19pbmNvcnJlY3Rfbl9hcmdzIGxvYyBjbnN0ciBzZXhwID1cbiAgbGV0IG1zZyA9XG4gICAgc3ByaW50ZlxuICAgICAgXCIlc19vZl9zZXhwOiBwb2x5bW9ycGhpYyB2YXJpYW50IHRhZyAlUyBoYXMgaW5jb3JyZWN0IG51bWJlciBvZiBhcmd1bWVudHNcIlxuICAgICAgbG9jXG4gICAgICBjbnN0clxuICBpblxuICBvZl9zZXhwX2Vycm9yIG1zZyBzZXhwXG47O1xuXG5sZXQgcHRhZ190YWtlc19hcmdzIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogcG9seW1vcnBoaWMgdmFyaWFudCB0YWcgdGFrZXMgYW4gYXJndW1lbnRcIikgc2V4cFxuOztcblxubGV0IG5lc3RlZF9saXN0X2ludmFsaWRfcG9seV92YXIgbG9jIHNleHAgPVxuICBvZl9zZXhwX2Vycm9yIChsb2MgXiBcIl9vZl9zZXhwOiBhIG5lc3RlZCBsaXN0IGlzIGFuIGludmFsaWQgcG9seW1vcnBoaWMgdmFyaWFudFwiKSBzZXhwXG47O1xuXG5sZXQgZW1wdHlfbGlzdF9pbnZhbGlkX3BvbHlfdmFyIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogdGhlIGVtcHR5IGxpc3QgaXMgYW4gaW52YWxpZCBwb2x5bW9ycGhpYyB2YXJpYW50XCIpIHNleHBcbjs7XG5cbmxldCBlbXB0eV90eXBlIGxvYyBzZXhwID1cbiAgb2Zfc2V4cF9lcnJvciAobG9jIF4gXCJfb2Zfc2V4cDogdHJ5aW5nIHRvIGNvbnZlcnQgYW4gZW1wdHkgdHlwZVwiKSBzZXhwXG47O1xuIiwib3BlbiEgU3RkTGFiZWxzXG5vcGVuISBTZXhwX2NvbnZcbm9wZW4hIFNleHBfY29udl9lcnJvclxuXG5tb2R1bGUgS2luZCA9IHN0cnVjdFxuICB0eXBlIChfLCBfKSB0ID1cbiAgICB8IERlZmF1bHQgOiAodW5pdCAtPiAnYSkgLT4gKCdhLCBTZXhwLnQgLT4gJ2EpIHRcbiAgICB8IE9taXRfbmlsIDogKCdhLCBTZXhwLnQgLT4gJ2EpIHRcbiAgICB8IFJlcXVpcmVkIDogKCdhLCBTZXhwLnQgLT4gJ2EpIHRcbiAgICB8IFNleHBfYXJyYXkgOiAoJ2EgYXJyYXksIFNleHAudCAtPiAnYSkgdFxuICAgIHwgU2V4cF9ib29sIDogKGJvb2wsIHVuaXQpIHRcbiAgICB8IFNleHBfbGlzdCA6ICgnYSBsaXN0LCBTZXhwLnQgLT4gJ2EpIHRcbiAgICB8IFNleHBfb3B0aW9uIDogKCdhIG9wdGlvbiwgU2V4cC50IC0+ICdhKSB0XG5lbmRcblxubW9kdWxlIEZpZWxkcyA9IHN0cnVjdFxuICB0eXBlIF8gdCA9XG4gICAgfCBFbXB0eSA6IHVuaXQgdFxuICAgIHwgRmllbGQgOlxuICAgICAgICB7IG5hbWUgOiBzdHJpbmdcbiAgICAgICAgOyBraW5kIDogKCdhLCAnY29udikgS2luZC50XG4gICAgICAgIDsgY29udiA6ICdjb252XG4gICAgICAgIDsgcmVzdCA6ICdiIHRcbiAgICAgICAgfVxuICAgICAgICAtPiAoJ2EgKiAnYikgdFxuXG4gIGxldCBsZW5ndGggPVxuICAgIGxldCByZWMgbGVuZ3RoX2xvb3AgOiB0eXBlIGEuIGEgdCAtPiBpbnQgLT4gaW50ID1cbiAgICAgIGZ1biB0IGFjYyAtPlxuICAgICAgICBtYXRjaCB0IHdpdGhcbiAgICAgICAgfCBGaWVsZCB7IHJlc3Q7IF8gfSAtPiBsZW5ndGhfbG9vcCByZXN0IChhY2MgKyAxKVxuICAgICAgICB8IEVtcHR5IC0+IGFjY1xuICAgIGluXG4gICAgZnVuIHQgLT4gbGVuZ3RoX2xvb3AgdCAwXG4gIDs7XG5lbmRcblxubW9kdWxlIE1hbGZvcm1lZCA9IHN0cnVjdFxuICAoKiBSZXByZXNlbnRzIGVycm9ycyB0aGF0IGNhbiBvY2N1ciBkdWUgdG8gbWFsZm9ybWVkIHJlY29yZCBzZXhwcy4gQWNjdW11bGF0ZWQgYXMgYVxuICAgICB2YWx1ZSBzbyB3ZSBjYW4gcmVwb3J0IG11bHRpcGxlIG5hbWVzIGF0IG9uY2UgZm9yIGV4dHJhIGZpZWxkcywgZHVwbGljYXRlIGZpZWxkcywgb3JcbiAgICAgbWlzc2luZyBmaWVsZHMuICopXG4gIHR5cGUgdCA9XG4gICAgfCBCb29sX3BheWxvYWRcbiAgICB8IEV4dHJhcyBvZiBzdHJpbmcgbGlzdFxuICAgIHwgRHVwcyBvZiBzdHJpbmcgbGlzdFxuICAgIHwgTWlzc2luZyBvZiBzdHJpbmcgbGlzdFxuICAgIHwgTm9uX3BhaXIgb2YgU2V4cC50IG9wdGlvblxuXG4gIGxldCBjb21iaW5lIGEgYiA9XG4gICAgbWF0Y2ggYSwgYiB3aXRoXG4gICAgKCogY2hvb3NlIHRoZSBmaXJzdCBib29sLXBheWxvYWQgb3Igbm9uLXBhaXIgZXJyb3IgdGhhdCBvY2N1cnMgKilcbiAgICB8ICgoQm9vbF9wYXlsb2FkIHwgTm9uX3BhaXIgXykgYXMgdCksIF8gLT4gdFxuICAgIHwgXywgKChCb29sX3BheWxvYWQgfCBOb25fcGFpciBfKSBhcyB0KSAtPiB0XG4gICAgKCogY29tYmluZSBsaXN0cyBvZiBzaW1pbGFyIGVycm9ycyAqKVxuICAgIHwgRXh0cmFzIGEsIEV4dHJhcyBiIC0+IEV4dHJhcyAoYSBAIGIpXG4gICAgfCBEdXBzIGEsIER1cHMgYiAtPiBEdXBzIChhIEAgYilcbiAgICB8IE1pc3NpbmcgYSwgTWlzc2luZyBiIC0+IE1pc3NpbmcgKGEgQCBiKVxuICAgICgqIG90aGVyd2lzZSwgZHVwcyA+IGV4dHJhcyA+IG1pc3NpbmcgKilcbiAgICB8IChEdXBzIF8gYXMgdCksIF8gfCBfLCAoRHVwcyBfIGFzIHQpIC0+IHRcbiAgICB8IChFeHRyYXMgXyBhcyB0KSwgXyB8IF8sIChFeHRyYXMgXyBhcyB0KSAtPiB0XG4gIDs7XG5cbiAgbGV0IHJhaXNlIHQgfmNhbGxlciB+Y29udGV4dCA9XG4gICAgbWF0Y2ggdCB3aXRoXG4gICAgfCBCb29sX3BheWxvYWQgLT4gcmVjb3JkX3NleHBfYm9vbF93aXRoX3BheWxvYWQgY2FsbGVyIGNvbnRleHRcbiAgICB8IEV4dHJhcyBuYW1lcyAtPiByZWNvcmRfZXh0cmFfZmllbGRzIGNhbGxlciAoTGlzdC5yZXYgbmFtZXMpIGNvbnRleHRcbiAgICB8IER1cHMgbmFtZXMgLT4gcmVjb3JkX2R1cGxpY2F0ZV9maWVsZHMgY2FsbGVyIChMaXN0LnJldiBuYW1lcykgY29udGV4dFxuICAgIHwgTWlzc2luZyBuYW1lcyAtPlxuICAgICAgTGlzdC5tYXAgbmFtZXMgfmY6KGZ1biBuYW1lIC0+IHRydWUsIG5hbWUpXG4gICAgICB8PiByZWNvcmRfdW5kZWZpbmVkX2VsZW1lbnRzIGNhbGxlciBjb250ZXh0XG4gICAgfCBOb25fcGFpciBtYXliZV9jb250ZXh0IC0+XG4gICAgICBsZXQgY29udGV4dCA9IE9wdGlvbi52YWx1ZSBtYXliZV9jb250ZXh0IH5kZWZhdWx0OmNvbnRleHQgaW5cbiAgICAgIHJlY29yZF9vbmx5X3BhaXJzX2V4cGVjdGVkIGNhbGxlciBjb250ZXh0XG4gIDs7XG5lbmRcblxuZXhjZXB0aW9uIE1hbGZvcm1lZCBvZiBNYWxmb3JtZWQudFxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgKCogU3RvcmVzIHNleHBzIGNvcnJlc3BvbmRpbmcgdG8gcmVjb3JkIGZpZWxkcywgaW4gdGhlIG9yZGVyIHRoZSBmaWVsZHMgd2VyZSBkZWNsYXJlZC5cbiAgICAgRXhjbHVkZXMgZmllbGRzIGFscmVhZHkgcGFyc2VkIGluIHRoZSBmYXN0IHBhdGguXG5cbiAgICAgTGlzdCBzZXhwcyByZXByZXNlbnQgYSBmaWVsZCB0aGF0IGlzIHByZXNlbnQsIHN1Y2ggYXMgKHggMSkgZm9yIGEgZmllbGQgbmFtZWQgXCJ4XCIuXG4gICAgIEF0b20gc2V4cHMgcmVwcmVzZW50IGEgZmllbGQgdGhhdCBpcyBhYnNlbnQsIG9yIGF0IGxlYXN0IG5vdCB5ZXQgc2Vlbi4gKilcbiAgdHlwZSB0ID0geyBzdGF0ZSA6IFNleHAudCBhcnJheSB9IFtAQHVuYm94ZWRdXG5cbiAgbGV0IHVuc2FmZV9nZXQgdCBwb3MgPSBBcnJheS51bnNhZmVfZ2V0IHQuc3RhdGUgcG9zXG4gIGxldCB1bnNhZmVfc2V0IHQgcG9zIHNleHAgPSBBcnJheS51bnNhZmVfc2V0IHQuc3RhdGUgcG9zIHNleHBcbiAgbGV0IGFic2VudCA9IFNleHAuQXRvbSBcIlwiXG4gIGxldCBjcmVhdGUgbGVuID0geyBzdGF0ZSA9IEFycmF5Lm1ha2UgbGVuIGFic2VudCB9XG5lbmRcblxuKCogUGFyc2luZyBmaWVsZCB2YWx1ZXMgZnJvbSBzdGF0ZS4gKilcblxubGV0IHJlYyBwYXJzZV92YWx1ZV9tYWxmb3JtZWRcbiAgOiB0eXBlIGEgYi4gTWFsZm9ybWVkLnQgLT4gZmllbGRzOihhICogYikgRmllbGRzLnQgLT4gc3RhdGU6U3RhdGUudCAtPiBwb3M6aW50IC0+IGFcbiAgPVxuICBmdW4gbWFsZm9ybWVkIH5maWVsZHMgfnN0YXRlIH5wb3MgLT5cbiAgbGV0IChGaWVsZCBmaWVsZCkgPSBmaWVsZHMgaW5cbiAgbGV0IG1hbGZvcm1lZCA9XG4gICAgbWF0Y2ggcGFyc2VfdmFsdWVzIH5maWVsZHM6ZmllbGQucmVzdCB+c3RhdGUgfnBvczoocG9zICsgMSkgd2l0aFxuICAgIHwgKF8gOiBiKSAtPiBtYWxmb3JtZWRcbiAgICB8IGV4Y2VwdGlvbiBNYWxmb3JtZWQgb3RoZXIgLT4gTWFsZm9ybWVkLmNvbWJpbmUgbWFsZm9ybWVkIG90aGVyXG4gIGluXG4gIHJhaXNlIChNYWxmb3JtZWQgbWFsZm9ybWVkKVxuXG5hbmQgcGFyc2VfdmFsdWUgOiB0eXBlIGEgYi4gZmllbGRzOihhICogYikgRmllbGRzLnQgLT4gc3RhdGU6U3RhdGUudCAtPiBwb3M6aW50IC0+IGEgKiBiID1cbiAgZnVuIH5maWVsZHMgfnN0YXRlIH5wb3MgLT5cbiAgbGV0IChGaWVsZCB7IG5hbWU7IGtpbmQ7IGNvbnY7IHJlc3QgfSkgPSBmaWVsZHMgaW5cbiAgbGV0IHZhbHVlIDogYSA9XG4gICAgbWF0Y2gga2luZCwgU3RhdGUudW5zYWZlX2dldCBzdGF0ZSBwb3Mgd2l0aFxuICAgICgqIHdlbGwtZm9ybWVkICopXG4gICAgfCBSZXF1aXJlZCwgTGlzdCBbIF87IHNleHAgXSAtPiBjb252IHNleHBcbiAgICB8IERlZmF1bHQgXywgTGlzdCBbIF87IHNleHAgXSAtPiBjb252IHNleHBcbiAgICB8IE9taXRfbmlsLCBMaXN0IFsgXzsgc2V4cCBdIC0+IGNvbnYgc2V4cFxuICAgIHwgU2V4cF9vcHRpb24sIExpc3QgWyBfOyBzZXhwIF0gLT4gU29tZSAoY29udiBzZXhwKVxuICAgIHwgU2V4cF9saXN0LCBMaXN0IFsgXzsgc2V4cCBdIC0+IGxpc3Rfb2Zfc2V4cCBjb252IHNleHBcbiAgICB8IFNleHBfYXJyYXksIExpc3QgWyBfOyBzZXhwIF0gLT4gYXJyYXlfb2Zfc2V4cCBjb252IHNleHBcbiAgICB8IFNleHBfYm9vbCwgTGlzdCBbIF8gXSAtPiB0cnVlXG4gICAgKCogaWxsLWZvcm1lZCAqKVxuICAgIHwgKCAoUmVxdWlyZWQgfCBEZWZhdWx0IF8gfCBPbWl0X25pbCB8IFNleHBfb3B0aW9uIHwgU2V4cF9saXN0IHwgU2V4cF9hcnJheSlcbiAgICAgICwgKExpc3QgKF8gOjogXyA6OiBfIDo6IF8pIGFzIHNleHApICkgLT5cbiAgICAgIHBhcnNlX3ZhbHVlX21hbGZvcm1lZCAoTm9uX3BhaXIgKFNvbWUgc2V4cCkpIH5maWVsZHMgfnN0YXRlIH5wb3NcbiAgICB8ICggKFJlcXVpcmVkIHwgRGVmYXVsdCBfIHwgT21pdF9uaWwgfCBTZXhwX29wdGlvbiB8IFNleHBfbGlzdCB8IFNleHBfYXJyYXkpXG4gICAgICAsIExpc3QgKFtdIHwgWyBfIF0pICkgLT4gcGFyc2VfdmFsdWVfbWFsZm9ybWVkIChOb25fcGFpciBOb25lKSB+ZmllbGRzIH5zdGF0ZSB+cG9zXG4gICAgfCBTZXhwX2Jvb2wsIExpc3QgKFtdIHwgXyA6OiBfIDo6IF8pIC0+XG4gICAgICBwYXJzZV92YWx1ZV9tYWxmb3JtZWQgQm9vbF9wYXlsb2FkIH5maWVsZHMgfnN0YXRlIH5wb3NcbiAgICAoKiBhYnNlbnQgKilcbiAgICB8IFJlcXVpcmVkLCBBdG9tIF8gLT4gcGFyc2VfdmFsdWVfbWFsZm9ybWVkIChNaXNzaW5nIFsgbmFtZSBdKSB+ZmllbGRzIH5zdGF0ZSB+cG9zXG4gICAgfCBEZWZhdWx0IGRlZmF1bHQsIEF0b20gXyAtPiBkZWZhdWx0ICgpXG4gICAgfCBPbWl0X25pbCwgQXRvbSBfIC0+IGNvbnYgKExpc3QgW10pXG4gICAgfCBTZXhwX29wdGlvbiwgQXRvbSBfIC0+IE5vbmVcbiAgICB8IFNleHBfbGlzdCwgQXRvbSBfIC0+IFtdXG4gICAgfCBTZXhwX2FycmF5LCBBdG9tIF8gLT4gW3x8XVxuICAgIHwgU2V4cF9ib29sLCBBdG9tIF8gLT4gZmFsc2VcbiAgaW5cbiAgdmFsdWUsIHBhcnNlX3ZhbHVlcyB+ZmllbGRzOnJlc3QgfnN0YXRlIH5wb3M6KHBvcyArIDEpXG5cbmFuZCBwYXJzZV92YWx1ZXMgOiB0eXBlIGEuIGZpZWxkczphIEZpZWxkcy50IC0+IHN0YXRlOlN0YXRlLnQgLT4gcG9zOmludCAtPiBhID1cbiAgZnVuIH5maWVsZHMgfnN0YXRlIH5wb3MgLT5cbiAgbWF0Y2ggZmllbGRzIHdpdGhcbiAgfCBGaWVsZCBfIC0+IHBhcnNlX3ZhbHVlIH5maWVsZHMgfnN0YXRlIH5wb3NcbiAgfCBFbXB0eSAtPiAoKVxuOztcblxuKCogUG9wdWxhdGluZyBzdGF0ZS4gSGFuZGxlcyBzbG93IHBhdGggY2FzZXMgd2hlcmUgdGhlcmUgbWF5IGJlIHJlb3JkZXJlZCwgZHVwbGljYXRlZCxcbiAgIG1pc3NpbmcsIG9yIGV4dHJhIGZpZWxkcy4gKilcblxubGV0IHJlYyBwYXJzZV9zcGluZV9tYWxmb3JtZWQgbWFsZm9ybWVkIH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHMgPVxuICBsZXQgbWFsZm9ybWVkID1cbiAgICBtYXRjaCBwYXJzZV9zcGluZV9zbG93IH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHMgd2l0aFxuICAgIHwgKCkgLT4gbWFsZm9ybWVkXG4gICAgfCBleGNlcHRpb24gTWFsZm9ybWVkIG90aGVyIC0+IE1hbGZvcm1lZC5jb21iaW5lIG1hbGZvcm1lZCBvdGhlclxuICBpblxuICByYWlzZSAoTWFsZm9ybWVkIG1hbGZvcm1lZClcblxuYW5kIHBhcnNlX3NwaW5lX3Nsb3cgfmluZGV4IH5leHRyYSB+c2VlbiB+c3RhdGUgfmxlbiBzZXhwcyA9XG4gIG1hdGNoIChzZXhwcyA6IFNleHAudCBsaXN0KSB3aXRoXG4gIHwgW10gLT4gKClcbiAgfCAoTGlzdCAoQXRvbSBuYW1lIDo6IF8pIGFzIGZpZWxkKSA6OiBzZXhwcyAtPlxuICAgIGxldCBpID0gaW5kZXggbmFtZSBpblxuICAgIChtYXRjaCBzZWVuIDw9IGkgJiYgaSA8IGxlbiB3aXRoXG4gICAgIHwgdHJ1ZSAtPlxuICAgICAgICgqIHZhbGlkIGZpZWxkIGZvciBzbG93LXBhdGggcGFyc2luZyAqKVxuICAgICAgIGxldCBwb3MgPSBpIC0gc2VlbiBpblxuICAgICAgIChtYXRjaCBTdGF0ZS51bnNhZmVfZ2V0IHN0YXRlIHBvcyB3aXRoXG4gICAgICAgIHwgQXRvbSBfIC0+XG4gICAgICAgICAgKCogZmllbGQgbm90IHNlZW4geWV0ICopXG4gICAgICAgICAgU3RhdGUudW5zYWZlX3NldCBzdGF0ZSBwb3MgZmllbGQ7XG4gICAgICAgICAgcGFyc2Vfc3BpbmVfc2xvdyB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzXG4gICAgICAgIHwgTGlzdCBfIC0+XG4gICAgICAgICAgKCogZmllbGQgYWxyZWFkeSBzZWVuICopXG4gICAgICAgICAgcGFyc2Vfc3BpbmVfbWFsZm9ybWVkIChEdXBzIFsgbmFtZSBdKSB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzKVxuICAgICB8IGZhbHNlIC0+XG4gICAgICAgKG1hdGNoIDAgPD0gaSAmJiBpIDwgc2VlbiB3aXRoXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgICgqIGZpZWxkIHNlZW4gaW4gZmFzdCBwYXRoICopXG4gICAgICAgICAgcGFyc2Vfc3BpbmVfbWFsZm9ybWVkIChEdXBzIFsgbmFtZSBdKSB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzXG4gICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICAoKiBleHRyYSBmaWVsZCAqKVxuICAgICAgICAgIChtYXRjaCBleHRyYSB3aXRoXG4gICAgICAgICAgIHwgdHJ1ZSAtPiBwYXJzZV9zcGluZV9zbG93IH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHNcbiAgICAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgICAgIHBhcnNlX3NwaW5lX21hbGZvcm1lZCAoRXh0cmFzIFsgbmFtZSBdKSB+aW5kZXggfmV4dHJhIH5zZWVuIH5zdGF0ZSB+bGVuIHNleHBzKSkpXG4gIHwgc2V4cCA6OiBzZXhwcyAtPlxuICAgIHBhcnNlX3NwaW5lX21hbGZvcm1lZCAoTm9uX3BhaXIgKFNvbWUgc2V4cCkpIH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHNcbjs7XG5cbigqIFNsb3cgcGF0aCBmb3IgcmVjb3JkIHBhcnNpbmcuIFVzZXMgc3RhdGUgdG8gc3RvcmUgZmllbGRzIGFzIHRoZXkgYXJlIGRpc2NvdmVyZWQuICopXG5cbmxldCBwYXJzZV9yZWNvcmRfc2xvdyB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW4gc2V4cHMgPVxuICBsZXQgdW5zZWVuID0gRmllbGRzLmxlbmd0aCBmaWVsZHMgaW5cbiAgbGV0IHN0YXRlID0gU3RhdGUuY3JlYXRlIHVuc2VlbiBpblxuICBsZXQgbGVuID0gc2VlbiArIHVuc2VlbiBpblxuICAoKiBwb3B1bGF0ZSBzdGF0ZSAqKVxuICBwYXJzZV9zcGluZV9zbG93IH5pbmRleCB+ZXh0cmEgfnNlZW4gfnN0YXRlIH5sZW4gc2V4cHM7XG4gICgqIHBhcnNlIHZhbHVlcyBmcm9tIHN0YXRlICopXG4gIHBhcnNlX3ZhbHVlcyB+ZmllbGRzIH5zdGF0ZSB+cG9zOjBcbjs7XG5cbigqIEZhc3QgcGF0aCBmb3IgcmVjb3JkIHBhcnNpbmcuIERpcmVjdGx5IHBhcnNlcyBhbmQgcmV0dXJucyBmaWVsZHMgaW4gdGhlIG9yZGVyIHRoZXkgYXJlXG4gICBkZWNsYXJlZC4gRmFsbHMgYmFjayBvbiBzbG93IHBhdGggaWYgYW55IGZpZWxkcyBhcmUgYWJzZW50LCByZW9yZGVyZWQsIG9yIG1hbGZvcm1lZC4gKilcblxubGV0IHJlYyBwYXJzZV9maWVsZF9mYXN0XG4gIDogdHlwZSBhIGIuXG4gICAgZmllbGRzOihhICogYikgRmllbGRzLnRcbiAgICAtPiBpbmRleDooc3RyaW5nIC0+IGludClcbiAgICAtPiBleHRyYTpib29sXG4gICAgLT4gc2VlbjppbnRcbiAgICAtPiBTZXhwLnQgbGlzdFxuICAgIC0+IGEgKiBiXG4gID1cbiAgZnVuIH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwcyAtPlxuICBsZXQgKEZpZWxkIHsgbmFtZTsga2luZDsgY29udjsgcmVzdCB9KSA9IGZpZWxkcyBpblxuICBtYXRjaCBzZXhwcyB3aXRoXG4gIHwgTGlzdCAoQXRvbSBhdG9tIDo6IGFyZ3MpIDo6IG90aGVycyB3aGVuIFN0cmluZy5lcXVhbCBhdG9tIG5hbWUgLT5cbiAgICAobWF0Y2gga2luZCwgYXJncyB3aXRoXG4gICAgIHwgUmVxdWlyZWQsIFsgc2V4cCBdIC0+XG4gICAgICAgY29udiBzZXhwLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzXG4gICAgIHwgRGVmYXVsdCBfLCBbIHNleHAgXSAtPlxuICAgICAgIGNvbnYgc2V4cCwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVyc1xuICAgICB8IE9taXRfbmlsLCBbIHNleHAgXSAtPlxuICAgICAgIGNvbnYgc2V4cCwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVyc1xuICAgICB8IFNleHBfb3B0aW9uLCBbIHNleHAgXSAtPlxuICAgICAgICggU29tZSAoY29udiBzZXhwKVxuICAgICAgICwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVycyApXG4gICAgIHwgU2V4cF9saXN0LCBbIHNleHAgXSAtPlxuICAgICAgICggbGlzdF9vZl9zZXhwIGNvbnYgc2V4cFxuICAgICAgICwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVycyApXG4gICAgIHwgU2V4cF9hcnJheSwgWyBzZXhwIF0gLT5cbiAgICAgICAoIGFycmF5X29mX3NleHAgY29udiBzZXhwXG4gICAgICAgLCBwYXJzZV9zcGluZV9mYXN0IH5maWVsZHM6cmVzdCB+aW5kZXggfmV4dHJhIH5zZWVuOihzZWVuICsgMSkgb3RoZXJzIClcbiAgICAgfCBTZXhwX2Jvb2wsIFtdIC0+XG4gICAgICAgdHJ1ZSwgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzOnJlc3QgfmluZGV4IH5leHRyYSB+c2Vlbjooc2VlbiArIDEpIG90aGVyc1xuICAgICAoKiBtYWxmb3JtZWQgZmllbGQgb2Ygc29tZSBraW5kLCBkaXNwYXRjaCB0byBzbG93IHBhdGggKilcbiAgICAgfCBfLCBfIC0+IHBhcnNlX3JlY29yZF9zbG93IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwcylcbiAgKCogbWFsZm9ybWVkIG9yIG91dC1vZi1vcmRlciBmaWVsZCwgZGlzcGF0Y2ggdG8gc2xvdyBwYXRoICopXG4gIHwgXyAtPiBwYXJzZV9yZWNvcmRfc2xvdyB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW4gc2V4cHNcblxuYW5kIHBhcnNlX3NwaW5lX2Zhc3RcbiAgOiB0eXBlIGEuXG4gICAgZmllbGRzOmEgRmllbGRzLnRcbiAgICAtPiBpbmRleDooc3RyaW5nIC0+IGludClcbiAgICAtPiBleHRyYTpib29sXG4gICAgLT4gc2VlbjppbnRcbiAgICAtPiBTZXhwLnQgbGlzdFxuICAgIC0+IGFcbiAgPVxuICBmdW4gfmZpZWxkcyB+aW5kZXggfmV4dHJhIH5zZWVuIHNleHBzIC0+XG4gIG1hdGNoIGZpZWxkcyB3aXRoXG4gIHwgRmllbGQgXyAtPiBwYXJzZV9maWVsZF9mYXN0IH5maWVsZHMgfmluZGV4IH5leHRyYSB+c2VlbiBzZXhwc1xuICB8IEVtcHR5IC0+XG4gICAgKG1hdGNoIHNleHBzIHdpdGhcbiAgICAgfCBbXSAtPiAoKVxuICAgICB8IF8gOjogXyAtPlxuICAgICAgICgqIGV4dHJhIHNleHBzLCBkaXNwYXRjaCB0byBzbG93IHBhdGggKilcbiAgICAgICBwYXJzZV9yZWNvcmRfc2xvdyB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW4gc2V4cHMpXG47O1xuXG5sZXQgcGFyc2VfcmVjb3JkX2Zhc3QgfmZpZWxkcyB+aW5kZXggfmV4dHJhIHNleHBzID1cbiAgcGFyc2Vfc3BpbmVfZmFzdCB+ZmllbGRzIH5pbmRleCB+ZXh0cmEgfnNlZW46MCBzZXhwc1xuOztcblxuKCogRW50cnkgcG9pbnRzLiAqKVxuXG5sZXQgcmVjb3JkX29mX3NleHBzXG4gICAgICB+Y2FsbGVyXG4gICAgICB+Y29udGV4dFxuICAgICAgfmZpZWxkc1xuICAgICAgfmluZGV4X29mX2ZpZWxkXG4gICAgICB+YWxsb3dfZXh0cmFfZmllbGRzXG4gICAgICB+Y3JlYXRlXG4gICAgICBzZXhwc1xuICA9XG4gIGxldCBhbGxvd19leHRyYV9maWVsZHMgPVxuICAgIGFsbG93X2V4dHJhX2ZpZWxkcyB8fCBub3QgIVNleHBfY29udi5yZWNvcmRfY2hlY2tfZXh0cmFfZmllbGRzXG4gIGluXG4gIG1hdGNoXG4gICAgcGFyc2VfcmVjb3JkX2Zhc3QgfmZpZWxkcyB+aW5kZXg6aW5kZXhfb2ZfZmllbGQgfmV4dHJhOmFsbG93X2V4dHJhX2ZpZWxkcyBzZXhwc1xuICB3aXRoXG4gIHwgdmFsdWUgLT4gY3JlYXRlIHZhbHVlXG4gIHwgZXhjZXB0aW9uIE1hbGZvcm1lZCBtYWxmb3JtZWQgLT4gTWFsZm9ybWVkLnJhaXNlIG1hbGZvcm1lZCB+Y2FsbGVyIH5jb250ZXh0XG47O1xuXG5sZXQgcmVjb3JkX29mX3NleHAgfmNhbGxlciB+ZmllbGRzIH5pbmRleF9vZl9maWVsZCB+YWxsb3dfZXh0cmFfZmllbGRzIH5jcmVhdGUgc2V4cCA9XG4gIG1hdGNoIChzZXhwIDogU2V4cC50KSB3aXRoXG4gIHwgQXRvbSBfIGFzIGNvbnRleHQgLT4gcmVjb3JkX2xpc3RfaW5zdGVhZF9hdG9tIGNhbGxlciBjb250ZXh0XG4gIHwgTGlzdCBzZXhwcyBhcyBjb250ZXh0IC0+XG4gICAgcmVjb3JkX29mX3NleHBzXG4gICAgICB+Y2FsbGVyXG4gICAgICB+Y29udGV4dFxuICAgICAgfmZpZWxkc1xuICAgICAgfmluZGV4X29mX2ZpZWxkXG4gICAgICB+YWxsb3dfZXh0cmFfZmllbGRzXG4gICAgICB+Y3JlYXRlXG4gICAgICBzZXhwc1xuOztcbiJdfQ==
