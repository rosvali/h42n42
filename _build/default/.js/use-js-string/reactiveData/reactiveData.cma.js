// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: ReactiveData
//# unitInfo: Requires: Assert_failure, React, Stdlib, Stdlib__Array, Stdlib__Hashtbl, Stdlib__Int, Stdlib__List, Stdlib__Map, Stdlib__Set
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_ReactiveData_Rlist_merge$3 = "ReactiveData.Rlist.merge",
    cst_merge_invalid_index$1 = "merge: invalid index",
    cst_src_reactiveData_ml = "src/reactiveData.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_equal = runtime.caml_equal,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib_List = global_data.Stdlib__List,
    React = global_data.React,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Int = global_data.Stdlib__Int,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Set = global_data.Stdlib__Set,
    _g_ = [0, 68],
    _f_ = [0, cst_src_reactiveData_ml, 553, 6],
    _e_ = [0, cst_src_reactiveData_ml, 459, 23],
    _d_ = [0, cst_src_reactiveData_ml, 427, 17],
    _c_ = [0, 0, 0],
    _a_ = [0, cst_src_reactiveData_ml, 215, 4],
    cst_invalid_index = "invalid index",
    cst_merge_invalid_index = cst_merge_invalid_index$1,
    cst_merge_invalid_index$0 = cst_merge_invalid_index$1,
    cst_linear_merge_X_not_support = "linear_merge: X not supported",
    _b_ = [0, cst_src_reactiveData_ml, 251, 4],
    cst_ReactiveData_Rlist_merge$0 = cst_ReactiveData_Rlist_merge$3,
    cst_ReactiveData_Rlist_merge = cst_ReactiveData_Rlist_merge$3,
    cst_ReactiveData_Rlist_merge$1 = cst_ReactiveData_Rlist_merge$3,
    cst_ReactiveData_Rlist_merge$2 = cst_ReactiveData_Rlist_merge$3;
   function Make(D){
    var merge = D[1], map_patch = D[2], map_data = D[3], empty = [0, D[4]];
    function create(l){
     var
      match = caml_call1(React[1][2], 0),
      send = match[2],
      initial_event = match[1],
      current = [0, l];
     function _aZ_(msg){
      if(0 === msg[0]){
       var p = msg[1];
       current[1] = caml_call2(merge, p, current[1]);
      }
      else{var l = msg[1]; current[1] = l;}
      return msg;
     }
     var event = caml_call2(React[1][10], _aZ_, initial_event);
     return [0, [1, [0, current, event]], send];
    }
    function from_event(l, initial_event){
     var current = [0, l];
     function _aY_(msg){
      if(0 === msg[0]){
       var p = msg[1];
       current[1] = caml_call2(merge, p, current[1]);
      }
      else{var l = msg[1]; current[1] = l;}
      return msg;
     }
     var event = caml_call2(React[1][10], _aY_, initial_event);
     return [1, [0, current, event]];
    }
    function const$0(x){return [0, x];}
    function map_msg(f, param){
     if(0 === param[0]){
      var p = param[1];
      return [0, caml_call2(map_patch, f, p)];
     }
     var l = param[1];
     return [1, caml_call2(map_data, f, l)];
    }
    function map(f, s){
     if(0 === s[0]){var x = s[1]; return [0, caml_call2(map_data, f, x)];}
     var
      s$0 = s[1],
      current = [0, caml_call2(map_data, f, s$0[1][1])],
      _aW_ = s$0[2];
     function _aX_(msg){
      var msg$0 = map_msg(f, msg);
      if(0 === msg$0[0]){
       var p = msg$0[1];
       current[1] = caml_call2(merge, p, current[1]);
      }
      else{var l = msg$0[1]; current[1] = l;}
      return msg$0;
     }
     var event = caml_call2(React[1][10], _aX_, _aW_);
     return [1, [0, current, event]];
    }
    function value(s){
     if(0 === s[0]){var c = s[1]; return c;}
     var s$0 = s[1];
     return s$0[1][1];
    }
    function event(s){
     if(0 === s[0]) return React[1][1];
     var s$0 = s[1];
     return s$0[2];
    }
    function patch(s, p){return caml_call2(s, 0, [0, p]);}
    function set(s, p){return caml_call2(s, 0, [1, p]);}
    function fold(f, s, acc){
     if(0 === s[0]){
      var c = s[1], _aV_ = caml_call2(f, acc, [1, c]);
      return caml_call1(React[2][1], _aV_);
     }
     var s$0 = s[1], acc$0 = caml_call2(f, acc, [1, s$0[1][1]]);
     return caml_call4(React[2][21], 0, f, acc$0, s$0[2]);
    }
    function signal(opt, s){
     if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
     if(0 === s[0]){var c = s[1]; return caml_call1(React[2][1], c);}
     var s$0 = s[1], _aR_ = s$0[2], _aS_ = s$0[1][1];
     function _aT_(l, msg){
      if(0 === msg[0]){var p = msg[1]; return caml_call2(merge, p, l);}
      var l$0 = msg[1];
      return l$0;
     }
     var _aU_ = [0, caml_call1(D[5], eq)];
     return caml_call4(React[2][21], _aU_, _aT_, _aS_, _aR_);
    }
    function from_signal(opt, s){
     if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
     function f(d$0, d){return [0, caml_call3(D[6], eq, d, d$0)];}
     var _aQ_ = caml_call2(React[2][14], f, s);
     return from_event(caml_call1(React[2][3], s), _aQ_);
    }
    return [0,
            empty,
            create,
            from_event,
            from_signal,
            const$0,
            patch,
            set,
            map_msg,
            map,
            value,
            fold,
            signal,
            event];
   }
   var map_data = Stdlib_List[19], empty = 0;
   function map_patch(f){
    function _aP_(param){
     switch(param[0]){
       case 0:
        var x = param[2], i = param[1]; return [0, i, caml_call1(f, x)];
       case 1:
        var i$0 = param[1]; return [1, i$0];
       case 2:
        var x$0 = param[2], i$1 = param[1];
        return [2, i$1, caml_call1(f, x$0)];
       default: var j = param[2], i$2 = param[1]; return [3, i$2, j];
     }
    }
    return caml_call1(Stdlib_List[19], _aP_);
   }
   function merge(p$5, l$7){
    a:
    {
     b:
     c:
     {
      var n = 0, p$3 = p$5;
      for(;;){
       if(0 > n)
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
       if(! p$3) break;
       var match$1 = p$3[1];
       if(3 === match$1[0]) break b;
       var i$3 = match$1[1], p$4 = p$3[2];
       if(n > i$3) break c;
       var n = i$3, p$3 = p$4;
      }
      var _aD_ = 1;
      break a;
     }
     var _aD_ = 0;
    }
    if(! _aD_){
     var
      _aE_ =
        function(l$2, op){
         switch(op[0]){
           case 0:
            var
             x = op[2],
             i = op[1],
             i$0 =
               0 <= i ? i : (caml_call1(Stdlib_List[1], l$2) + 1 | 0) + i | 0,
             acc = 0,
             n = i$0,
             l = l$2;
            for(;;){
             if(0 === n) return caml_call2(Stdlib_List[12], acc, [0, x, l]);
             if(! l)
              return caml_call1(Stdlib[2], cst_ReactiveData_Rlist_merge);
             var
              xs = l[2],
              x$0 = l[1],
              n$0 = n - 1 | 0,
              acc$0 = [0, x$0, acc],
              acc = acc$0,
              n = n$0,
              l = xs;
            }
            break;
           case 1:
            var
             i$1 = op[1],
             i$2 = 0 <= i$1 ? i$1 : caml_call1(Stdlib_List[1], l$2) + i$1 | 0,
             acc$1 = 0,
             n$1 = i$2,
             l$0 = l$2;
            for(;;){
             if(0 === n$1 && l$0){
              var l$1 = l$0[2];
              return caml_call2(Stdlib_List[12], acc$1, l$1);
             }
             if(! l$0)
              return caml_call1(Stdlib[2], cst_ReactiveData_Rlist_merge$0);
             var
              xs$0 = l$0[2],
              x$1 = l$0[1],
              n$2 = n$1 - 1 | 0,
              acc$2 = [0, x$1, acc$1],
              acc$1 = acc$2,
              n$1 = n$2,
              l$0 = xs$0;
            }
            break;
           case 2:
            var
             x$2 = op[2],
             i$3 = op[1],
             i$4 = 0 <= i$3 ? i$3 : caml_call1(Stdlib_List[1], l$2) + i$3 | 0,
             a = caml_call1(Stdlib_Array[12], l$2);
            caml_check_bound(a, i$4)[1 + i$4] = x$2;
            return caml_call1(Stdlib_Array[11], a);
           default:
            var
             offset = op[2],
             i$5 = op[1],
             a$0 = caml_call1(Stdlib_Array[12], l$2),
             len = a$0.length - 1,
             i$6 = 0 <= i$5 ? i$5 : len + i$5 | 0,
             v = caml_check_bound(a$0, i$6)[1 + i$6];
            if(0 < offset){
             if(len <= (i$6 + offset | 0))
              caml_call1(Stdlib[2], cst_ReactiveData_Rlist_merge$1);
             var _aF_ = (i$6 + offset | 0) - 1 | 0;
             if(_aF_ >= i$6){
              var j = i$6;
              for(;;){
               var
                _aH_ = j + 1 | 0,
                _aI_ = caml_check_bound(a$0, _aH_)[1 + _aH_];
               caml_check_bound(a$0, j)[1 + j] = _aI_;
               var _aJ_ = j + 1 | 0;
               if(_aF_ === j) break;
               var j = _aJ_;
              }
             }
             var _aG_ = i$6 + offset | 0;
             caml_check_bound(a$0, _aG_)[1 + _aG_] = v;
            }
            else{
             if((i$6 + offset | 0) < 0)
              caml_call1(Stdlib[2], cst_ReactiveData_Rlist_merge$2);
             var _aK_ = (i$6 + offset | 0) + 1 | 0;
             if(i$6 >= _aK_){
              var j$0 = i$6;
              for(;;){
               var
                _aM_ = j$0 - 1 | 0,
                _aN_ = caml_check_bound(a$0, _aM_)[1 + _aM_];
               caml_check_bound(a$0, j$0)[1 + j$0] = _aN_;
               var _aO_ = j$0 - 1 | 0;
               if(_aK_ === j$0) break;
               var j$0 = _aO_;
              }
             }
             var _aL_ = i$6 + offset | 0;
             caml_check_bound(a$0, _aL_)[1 + _aL_] = v;
            }
            return caml_call1(Stdlib_Array[11], a$0);
         }
        };
     return caml_call3(Stdlib_List[25], _aE_, l$7, p$5);
    }
    var acc$1 = 0, i0 = 0, p = p$5, l$1 = l$7;
    for(;;){
     a:
     {
      if(p){
       var match = p[1];
       if(3 !== match[0]){
        var i$1 = match[1];
        if(i0 < i$1){
         var i$2 = i$1 - i0 | 0;
         b:
         {
          c:
          {
           var acc = acc$1, i = i$2, l = l$1;
           for(;;){
            if(0 > i)
             throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
            if(0 >= i) break;
            if(! l) break c;
            var
             l$0 = l[2],
             h = l[1],
             acc$0 = [0, h, acc],
             i$0 = i - 1 | 0,
             acc = acc$0,
             i = i$0,
             l = l$0;
           }
           var _aC_ = [0, l, acc];
           break b;
          }
          var _aC_ = caml_call1(Stdlib[1], cst_invalid_index);
         }
         var acc$2 = _aC_[2], l$2 = _aC_[1];
         break a;
        }
       }
      }
      var acc$2 = acc$1, l$2 = l$1;
     }
     if(! p) return caml_call2(Stdlib_List[12], acc$2, l$2);
     var match$0 = p[1];
     switch(match$0[0]){
       case 0:
        var
         p$0 = p[2],
         x = match$0[2],
         i0$0 = match$0[1],
         l$3 = [0, x, l$2],
         acc$1 = acc$2,
         i0 = i0$0,
         p = p$0,
         l$1 = l$3;
        break;
       case 1:
        var p$1 = p[2], i0$1 = match$0[1];
        if(! l$2) return caml_call1(Stdlib[1], cst_merge_invalid_index);
        var l$4 = l$2[2], acc$1 = acc$2, i0 = i0$1, p = p$1, l$1 = l$4;
        break;
       case 2:
        var p$2 = p[2], x$0 = match$0[2], i0$2 = match$0[1];
        if(! l$2) return caml_call1(Stdlib[1], cst_merge_invalid_index$0);
        var
         l$5 = l$2[2],
         l$6 = [0, x$0, l$5],
         acc$1 = acc$2,
         i0 = i0$2,
         p = p$2,
         l$1 = l$6;
        break;
       default: return caml_call1(Stdlib[2], cst_linear_merge_X_not_support);
     }
    }
   }
   function equal(f, l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var x2 = l2$0[1], l1$1 = l1$0[2], x1 = l1$0[1], l2$1 = l2$0[2];
       if(caml_call2(f, x1, x2)){var l1$0 = l1$1, l2$0 = l2$1; continue;}
      }
     }
     else if(! l2$0) return 1;
     return 0;
    }
   }
   function mem(l){
    var hash = Stdlib_Hashtbl[28];
    function equal(_aB_, _aA_){return _aB_ === _aA_ ? 1 : 0;}
    var
     H = caml_call1(Stdlib_Hashtbl[26], [0, equal, hash]),
     h = caml_call1(H[1], 16);
    function _az_(x){return caml_call3(H[5], h, x, 0);}
    caml_call2(Stdlib_List[17], _az_, l);
    return caml_call1(H[11], h);
   }
   function diff(sth$0, lx$1, ly$3){
    function add(acc, i, v){return [0, [0, i, v], acc];}
    function remove(acc, i){return [0, [1, i], acc];}
    var
     memx = mem(lx$1),
     memy = mem(ly$3),
     acc = 0,
     left = 1,
     lx = lx$1,
     ly = ly$3,
     n = 0;
    for(;;)
     if(lx){
      var lx$0 = lx[2], x = lx[1];
      if(ly){
       var y = ly[1], ly$0 = ly[2];
       if(caml_call2(sth$0, x, y))
        var n$0 = n + 1 | 0, lx = lx$0, ly = ly$0, n = n$0;
       else if(caml_call1(memy, x))
        if(caml_call1(memx, y))
         if(left)
          var acc$0 = remove(acc, n), acc = acc$0, left = 0, lx = lx$0;
         else
          var
           ly$1 = ly[2],
           acc$1 = add(acc, n, y),
           n$1 = n + 1 | 0,
           acc = acc$1,
           left = 1,
           ly = ly$1,
           n = n$1;
        else
         var
          acc$2 = add(acc, n, y),
          n$2 = n + 1 | 0,
          acc = acc$2,
          ly = ly$0,
          n = n$2;
       else
        var acc$3 = remove(acc, n), acc = acc$3, lx = lx$0;
      }
      else
       var acc$4 = remove(acc, n), acc = acc$4, lx = lx$0, ly = 0;
     }
     else{
      if(! ly) break;
      var
       ly$2 = ly[2],
       y$0 = ly[1],
       acc$5 = add(acc, n, y$0),
       n$3 = n + 1 | 0,
       acc = acc$5,
       lx = 0,
       ly = ly$2,
       n = n$3;
     }
    var opt = 0, param = acc;
    for(;;){
     if(opt) var sth = opt[1], acc$6 = sth; else var acc$6 = 0;
     if(! param) return acc$6;
     var
      t = param[2],
      h = param[1],
      acc$7 = [0, h, acc$6],
      opt$0 = [0, acc$7],
      opt = opt$0,
      param = t;
    }
   }
   var
    include = Make([0, merge, map_patch, map_data, empty, equal, diff]),
    empty$0 = include[1],
    create = include[2],
    from_event = include[3],
    from_signal = include[4],
    const$0 = include[5],
    patch = include[6],
    set = include[7],
    map_msg = include[8],
    map = include[9],
    value = include[10],
    fold = include[11],
    signal = include[12],
    event = include[13];
   function cons(x, s){return caml_call2(patch, s, [0, [0, 0, x], 0]);}
   function snoc(x, s){return caml_call2(patch, s, [0, [0, -1, x], 0]);}
   function insert(x, i, s){return caml_call2(patch, s, [0, [0, i, x], 0]);}
   function update(x, i, s){return caml_call2(patch, s, [0, [2, i, x], 0]);}
   function move(i, j, s){return caml_call2(patch, s, [0, [3, i, j], 0]);}
   function remove(i, s){return caml_call2(patch, s, [0, [1, i], 0]);}
   function index(opt, l, x){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    var n = 0, param = l;
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var hd = param[1];
     if(caml_call2(eq, hd, x)) return n;
     var tl = param[2], n$0 = n + 1 | 0, n = n$0, param = tl;
    }
   }
   function update_eq(eq, param, x, y){
    var
     handle = param[2],
     data = param[1],
     i = index(eq, caml_call1(value, data), x);
    return update(y, i, handle);
   }
   function remove_last(param){
    var handle = param[2], data = param[1], _ay_ = caml_call1(value, data);
    return remove(caml_call1(Stdlib_List[1], _ay_) - 1 | 0, handle);
   }
   function remove_eq(eq, param, x){
    var
     handle = param[2],
     data = param[1],
     i = index(eq, caml_call1(value, data), x);
    return remove(i, handle);
   }
   function singleton(x){return caml_call1(const$0, [0, x, 0]);}
   function singleton_s(s){
    var
     first = [0, 1],
     match = caml_call1(React[1][2], 0),
     send = match[2],
     e = match[1],
     result = caml_call2(from_event, 0, e);
    function _ax_(x){
     return first[1]
             ? (first[1] = 0, caml_call2(send, 0, [0, [0, [0, 0, x], 0]]))
             : caml_call2(send, 0, [0, [0, [2, 0, x], 0]]);
    }
    caml_call3(React[2][11], 0, _ax_, s);
    return result;
   }
   function concat(x, y){
    var
     v1 = caml_call1(value, x),
     v2 = caml_call1(value, y),
     size1 = [0, 0],
     size2 = [0, 0];
    function size_with_patch(sizex, param){
     switch(param[0]){
       case 0:
        sizex[1]++; return;
       case 1:
        sizex[1] += -1; return;
       default: return;
     }
    }
    function size_with_set(sizex, l){
     sizex[1] = caml_call1(Stdlib_List[1], l);
     return;
    }
    size_with_set(size1, v1);
    size_with_set(size2, v2);
    function _ab_(p){
     switch(p[0]){
       case 0:
        var
         x = p[2],
         pos = p[1],
         i = 0 <= pos ? pos : pos - size2[1] | 0,
         m = [0, i, x];
        break;
       case 1:
        var
         pos$0 = p[1],
         pos$1 = 0 <= pos$0 ? pos$0 : pos$0 - size2[1] | 0,
         m = [1, pos$1];
        break;
       case 2:
        var
         x$0 = p[2],
         pos$2 = p[1],
         pos$3 = 0 <= pos$2 ? pos$2 : pos$2 - size2[1] | 0,
         m = [2, pos$3, x$0];
        break;
       default:
        var
         j = p[2],
         i$0 = p[1],
         i$1 = 0 <= i$0 ? i$0 : i$0 - size2[1] | 0,
         m = [3, i$1, j];
     }
     size_with_patch(size1, m);
     return m;
    }
    var update_patch1 = caml_call1(Stdlib_List[19], _ab_);
    function _ac_(p){
     switch(p[0]){
       case 0:
        var
         x = p[2],
         pos = p[1],
         _at_ = 0 <= pos ? size1[1] + pos | 0 : pos,
         m = [0, _at_, x];
        break;
       case 1:
        var
         pos$0 = p[1],
         _au_ = 0 <= pos$0 ? size1[1] + pos$0 | 0 : pos$0,
         m = [1, _au_];
        break;
       case 2:
        var
         x$0 = p[2],
         pos$1 = p[1],
         _av_ = 0 <= pos$1 ? size1[1] + pos$1 | 0 : pos$1,
         m = [2, _av_, x$0];
        break;
       default:
        var
         j = p[2],
         i = p[1],
         _aw_ = 0 <= i ? size1[1] + i | 0 : i,
         m = [3, _aw_, j];
     }
     size_with_patch(size2, m);
     return m;
    }
    var
     update_patch2 = caml_call1(Stdlib_List[19], _ac_),
     _ad_ = 0,
     _ae_ = caml_call1(event, y);
    function _af_(e){return [0, 15437, e];}
    var
     _ag_ = [0, caml_call2(React[1][10], _af_, _ae_), _ad_],
     _ah_ = caml_call1(event, x);
    function _ai_(e){return [0, 15436, e];}
    var _aj_ = [0, caml_call2(React[1][10], _ai_, _ah_), _ag_];
    function _ak_(acc, x){
     var p1 = acc[1];
     if(! p1 && typeof x !== "number" && 15436 === x[1]){
      var x$1 = x[2], p2 = acc[2];
      return [0, [0, x$1], p2];
     }
     if(! acc[2] && typeof x !== "number" && 15437 === x[1]){var x$0 = x[2]; return [0, p1, [0, x$0]];}
     throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
    }
    var tuple_ev = caml_call3(React[1][23], _ak_, _c_, _aj_);
    function _al_(p){
     var _am_ = p[1];
     if(! _am_){
      var _ar_ = p[2];
      if(! _ar_)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var match$1 = _ar_[1];
      if(0 === match$1[0]){
       var p2$2 = match$1[1];
       return [0, caml_call1(update_patch2, p2$2)];
      }
      var p2$3 = match$1[1];
      size_with_set(size2, p2$3);
      var _as_ = caml_call1(value, x);
      return [1, caml_call2(Stdlib[37], _as_, p2$3)];
     }
     var _an_ = _am_[1];
     if(0 === _an_[0]){
      var _ao_ = p[2], p1 = _an_[1];
      if(! _ao_) return [0, caml_call1(update_patch1, p1)];
      var match = _ao_[1];
      if(0 === match[0]){
       var
        p2 = match[1],
        p1$0 = caml_call1(update_patch1, p1),
        p2$0 = caml_call1(update_patch2, p2);
       return [0, caml_call2(Stdlib[37], p1$0, p2$0)];
      }
      var s2 = match[1], s1 = caml_call1(value, x);
      size_with_set(size1, s1);
      size_with_set(size2, s2);
      return [1, caml_call2(Stdlib[37], s1, s2)];
     }
     var _ap_ = p[2], p1$1 = _an_[1];
     if(! _ap_){
      size_with_set(size1, p1$1);
      var _aq_ = caml_call1(value, y);
      return [1, caml_call2(Stdlib[37], p1$1, _aq_)];
     }
     var match$0 = _ap_[1];
     if(0 === match$0[0]){
      size_with_set(size1, p1$1);
      var s2$0 = caml_call1(value, y);
      size_with_set(size2, s2$0);
      return [1, caml_call2(Stdlib[37], p1$1, s2$0)];
     }
     var p2$1 = match$0[1];
     size_with_set(size1, p1$1);
     size_with_set(size2, p2$1);
     return [1, caml_call2(Stdlib[37], p1$1, p2$1)];
    }
    var merged_ev = caml_call2(React[1][10], _al_, tuple_ev);
    return caml_call2(from_event, caml_call2(Stdlib[37], v1, v2), merged_ev);
   }
   function inverse(param){
    switch(param[0]){
      case 0:
       var x = param[2], i = param[1]; return [0, (- i | 0) - 1 | 0, x];
      case 1:
       var i$0 = param[1]; return [1, (- i$0 | 0) - 1 | 0];
      case 2:
       var x$0 = param[2], i$1 = param[1];
       return [2, (- i$1 | 0) - 1 | 0, x$0];
      default:
       var j = param[2], i$2 = param[1];
       return [3, (- i$2 | 0) - 1 | 0, - j | 0];
    }
   }
   function rev(t){
    var ___ = caml_call1(event, t);
    function _$_(param){
     if(0 === param[0]){
      var p = param[1];
      return [0, caml_call2(Stdlib_List[19], inverse, p)];
     }
     var l = param[1];
     return [1, caml_call1(Stdlib_List[9], l)];
    }
    var e = caml_call2(React[1][10], _$_, ___), _aa_ = caml_call1(value, t);
    return caml_call2(from_event, caml_call1(Stdlib_List[9], _aa_), e);
   }
   function filter(pred, l){
    var
     IntMap = caml_call1(Stdlib_Map[1], [0, Stdlib_Int[9]]),
     index = [0, IntMap[1]],
     size = [0, 0];
    function filter_list(l){
     size[1] = caml_call1(Stdlib_List[1], l);
     index[1] = IntMap[1];
     var l$0 = l, res = 0, their_i = 0, my_i = -1;
     for(;;){
      if(! l$0) return caml_call1(Stdlib_List[9], res);
      var xs = l$0[2], x = l$0[1];
      if(caml_call1(pred, x)){
       index[1] = caml_call3(IntMap[4], their_i, my_i + 1 | 0, index[1]);
       var
        my_i$0 = my_i + 1 | 0,
        their_i$0 = their_i + 1 | 0,
        res$0 = [0, x, res],
        l$0 = xs,
        res = res$0,
        their_i = their_i$0,
        my_i = my_i$0;
      }
      else
       var their_i$1 = their_i + 1 | 0, l$0 = xs, their_i = their_i$1;
     }
    }
    function normalise(i){return 0 <= i ? i : (size[1] + 1 | 0) + i | 0;}
    function update_index_insert(insert_pos_full_list, visible){
     var
      insert_pos_full_list$0 = normalise(insert_pos_full_list),
      match = caml_call2(IntMap[27], insert_pos_full_list$0, index[1]),
      updatables = match[3],
      displaced = match[2],
      left_alone = match[1];
     if(displaced)
      var
       displaced_in_filtered = displaced[1],
       updatables$0 =
         caml_call3
          (IntMap[4],
           insert_pos_full_list$0,
           displaced_in_filtered,
           updatables);
     else
      var updatables$0 = updatables;
     function update_j(j_full_list, j_filtered_list){
      var
       new_j_filtered = visible ? j_filtered_list + 1 | 0 : j_filtered_list;
      index[1] =
       caml_call3(IntMap[4], j_full_list + 1 | 0, new_j_filtered, index[1]);
      return 0;
     }
     caml_call2(IntMap[12], update_j, updatables$0);
     var
      insert_pos_filtered =
        caml_call1(IntMap[2], left_alone)
         ? 0
         : caml_call1(IntMap[23], left_alone)[2] + 1 | 0;
     if(visible)
      index[1] =
       caml_call3
        (IntMap[4], insert_pos_full_list$0, insert_pos_filtered, index[1]);
     size[1]++;
     return insert_pos_filtered;
    }
    function update_index_move(from_full_list, to_full_list, to_filtered){
     var
      was_visible = to_filtered ? 1 : 0,
      forward = from_full_list < to_full_list ? 1 : 0;
     if(forward){
      var _S_ = from_full_list + 1 | 0;
      if(to_full_list >= _S_){
       var i_full = _S_;
       for(;;){
        var delta = was_visible ? -1 : 0;
        try{
         var
          i_filtered = caml_call2(IntMap[28], i_full, index[1]),
          new_val = i_filtered + delta | 0;
         index[1] = caml_call3(IntMap[4], i_full - 1 | 0, new_val, index[1]);
        }
        catch(_Y_){
         var _T_ = caml_wrap_exception(_Y_);
         if(_T_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_T_, 0);
        }
        var _U_ = i_full + 1 | 0;
        if(to_full_list === i_full) break;
        var i_full = _U_;
       }
      }
     }
     else{
      var _V_ = from_full_list - 1 | 0;
      if(_V_ >= to_full_list){
       var i_full$0 = _V_;
       for(;;){
        try{
         var
          delta$0 = was_visible ? 1 : 0,
          i_filtered$0 = caml_call2(IntMap[28], i_full$0, index[1]),
          new_val$0 = i_filtered$0 + delta$0 | 0;
         index[1] =
          caml_call3(IntMap[4], i_full$0 + 1 | 0, new_val$0, index[1]);
        }
        catch(_Z_){
         var _W_ = caml_wrap_exception(_Z_);
         if(_W_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_W_, 0);
        }
        var _X_ = i_full$0 - 1 | 0;
        if(to_full_list === i_full$0) break;
        var i_full$0 = _X_;
       }
      }
     }
     if(to_filtered){
      var to_filtered$0 = to_filtered[1];
      index[1] = caml_call3(IntMap[4], to_full_list, to_filtered$0, index[1]);
      return;
     }
     index[1] = caml_call2(IntMap[7], to_full_list, index[1]);
     return;
    }
    function convert_p(param){
     switch(param[0]){
       case 0:
        var x = param[2], i = param[1];
        if(caml_call1(pred, x)){
         var my_i = update_index_insert(i, 1);
         return [0, [0, my_i, x], 0];
        }
        update_index_insert(i, 0);
        return 0;
       case 1:
        var i$0 = param[1], remove_pos_full_list = normalise(i$0);
        try{
         var
          j = caml_call2(IntMap[28], remove_pos_full_list, index[1]),
          _F_ = [0, [1, j], 0],
          ret = _F_;
        }
        catch(_R_){
         var _E_ = caml_wrap_exception(_R_);
         if(_E_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_E_, 0);
         var ret = 0;
        }
        var
         was_visible = caml_call2(IntMap[3], remove_pos_full_list, index[1]),
         updatables =
           caml_call2(IntMap[27], remove_pos_full_list, index[1])[3],
         update_j =
           function(j_full_list, j_filtered_list){
            var
             new_j = was_visible ? j_filtered_list : j_filtered_list - 1 | 0;
            index[1] =
             caml_call3(IntMap[4], j_full_list - 1 | 0, new_j, index[1]);
            return 0;
           };
        if(! caml_call1(IntMap[2], index[1])){
         var last_i = caml_call1(IntMap[23], index[1])[1];
         index[1] = caml_call2(IntMap[7], last_i, index[1]);
        }
        size[1] += -1;
        caml_call2(IntMap[12], update_j, updatables);
        return ret;
       case 2:
        var
         x$0 = param[2],
         i$1 = param[1],
         update_pos_full_list = normalise(i$1);
        try{
         var old_j = caml_call2(IntMap[28], update_pos_full_list, index[1]);
         if(caml_call1(pred, x$0))
          var _H_ = [0, [2, old_j, x$0], 0];
         else{
          var
           updatables$0 =
             caml_call2(IntMap[27], update_pos_full_list, index[1])[3],
           update_j$0 =
             function(j_full_list, j_filtered_list){
              index[1] =
               caml_call3
                (IntMap[4], j_full_list, j_filtered_list - 1 | 0, index[1]);
              return 0;
             };
          index[1] = caml_call2(IntMap[7], update_pos_full_list, index[1]);
          caml_call2(IntMap[12], update_j$0, updatables$0);
          var _H_ = [0, [1, old_j], 0];
         }
         return _H_;
        }
        catch(_P_){
         var _G_ = caml_wrap_exception(_P_);
         if(_G_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_G_, 0);
         if(! caml_call1(pred, x$0)) return 0;
         var
          match = caml_call2(IntMap[27], update_pos_full_list, index[1]),
          updatables$1 = match[3],
          none = match[2],
          left_alone = match[1];
         if(0 !== none)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
         var
          update_j$1 =
            function(j_full_list, j_filtered_list){
             index[1] =
              caml_call3
               (IntMap[4], j_full_list, j_filtered_list + 1 | 0, index[1]);
             return 0;
            };
         try{
          var
           _D_ = caml_call1(IntMap[23], left_alone)[2],
           previous_pos_filtered = _D_;
         }
         catch(_Q_){
          var _C_ = caml_wrap_exception(_Q_);
          if(_C_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_C_, 0);
          var previous_pos_filtered = -1;
         }
         var new_pos_filtered_list = previous_pos_filtered + 1 | 0;
         index[1] =
          caml_call3
           (IntMap[4], update_pos_full_list, new_pos_filtered_list, index[1]);
         caml_call2(IntMap[12], update_j$1, updatables$1);
         return [0, [0, new_pos_filtered_list, x$0], 0];
        }
       default:
        var
         offset_full = param[2],
         origin_full = param[1],
         origin_full$0 = normalise(origin_full),
         dest_full = origin_full$0 + offset_full | 0;
        try{
         var
          origin_filtered = caml_call2(IntMap[28], origin_full$0, index[1]);
         try{
          var
           _M_ = caml_call2(IntMap[28], dest_full, index[1]),
           dest_filtered = _M_;
         }
         catch(_O_){
          var _J_ = caml_wrap_exception(_O_);
          if(_J_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_J_, 0);
          var
           small_ones = caml_call2(IntMap[27], origin_full$0, index[1])[1],
           _K_ =
             caml_call1(IntMap[2], small_ones)
              ? 0
              : caml_call1(IntMap[23], small_ones)[2] + 1 | 0,
           dest_filtered = _K_;
         }
         update_index_move(origin_full$0, dest_full, [0, dest_filtered]);
         var
          _L_ =
            dest_filtered !== origin_filtered
             ? [0,
               [3, origin_filtered, dest_filtered - origin_filtered | 0],
               0]
             : 0;
         return _L_;
        }
        catch(_N_){
         var _I_ = caml_wrap_exception(_N_);
         if(_I_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_I_, 0);
         update_index_move(origin_full$0, dest_full, 0);
         return 0;
        }
     }
    }
    function filter_e(param){
     if(0 === param[0]){
      var p = param[1], _B_ = caml_call2(Stdlib_List[19], convert_p, p);
      return [0, caml_call1(Stdlib_List[13], _B_)];
     }
     var l = param[1];
     return [1, filter_list(l)];
    }
    var
     _A_ = caml_call1(event, l),
     e = caml_call2(React[1][10], filter_e, _A_);
    return caml_call2(from_event, filter_list(caml_call1(value, l)), e);
   }
   var IntSet = caml_call1(Stdlib_Set[1], [0, Stdlib_Int[9]]);
   function for_all(fn, data){
    function maybe_update(acc, i, v){
     return caml_call1(fn, v) ? acc : caml_call2(IntSet[4], i, acc);
    }
    var acc = IntSet[1], i = 0;
    function init(param$0){
     var i$0 = i, acc$0 = acc, param = param$0;
     for(;;){
      if(! param) return acc$0;
      var
       tl = param[2],
       v = param[1],
       acc$1 = maybe_update(acc$0, i$0, v),
       i$1 = i$0 + 1 | 0,
       i$0 = i$1,
       acc$0 = acc$1,
       param = tl;
     }
    }
    function update_idx_after(i, f, acc){
     function _z_(i$0){return i <= i$0 ? caml_call2(f, i$0, 1) : i$0;}
     return caml_call2(IntSet[15], _z_, acc);
    }
    function f(acc, param){
     if(0 === param[0]){
      var
       updates = param[1],
       _q_ =
         function(acc, param){
          switch(param[0]){
            case 0:
             var
              v = param[2],
              i = param[1],
              acc$0 =
                update_idx_after
                 (i, function(_y_, _x_){return _y_ + _x_ | 0;}, acc);
             return maybe_update(acc$0, i, v);
            case 1:
             var i$0 = param[1], _r_ = caml_call2(IntSet[6], i$0, acc);
             return update_idx_after
                     (i$0, function(_w_, _v_){return _w_ - _v_ | 0;}, _r_);
            case 2:
             var v$0 = param[2], i$1 = param[1];
             return maybe_update(caml_call2(IntSet[6], i$1, acc), i$1, v$0);
            default:
             var
              i$2 = param[2],
              i$3 = param[1],
              _s_ = caml_call2(IntSet[3], i$2, acc);
             if(caml_call2(IntSet[3], i$3, acc) === _s_) return acc;
             if(caml_call2(IntSet[3], i$3, acc)){
              var _t_ = caml_call2(IntSet[6], i$3, acc);
              return caml_call2(IntSet[4], i$2, _t_);
             }
             var _u_ = caml_call2(IntSet[6], i$2, acc);
             return caml_call2(IntSet[4], i$3, _u_);
          }
         };
      return caml_call3(Stdlib_List[25], _q_, acc, updates);
     }
     var x = param[1];
     return init(x);
    }
    var
     _n_ = caml_call1(event, data),
     _o_ = init(caml_call1(value, data)),
     _p_ = caml_call4(React[2][21], 0, f, _o_, _n_);
    return caml_call1(caml_call2(React[2][11], 0, IntSet[2]), _p_);
   }
   var
    ReactiveData =
      [0,
       [0,
        empty$0,
        create,
        from_event,
        from_signal,
        const$0,
        patch,
        set,
        map_msg,
        map,
        value,
        fold,
        signal,
        event,
        cons,
        snoc,
        insert,
        remove,
        remove_last,
        remove_eq,
        update,
        update_eq,
        move,
        singleton,
        singleton_s,
        concat,
        rev,
        filter,
        for_all],
       function(M){
        function merge(p, acc){
         function _m_(acc, p){
          if(3404203 <= p[1]){var k = p[2]; return caml_call2(M[7], k, acc);}
          var match = p[2], a = match[2], k$0 = match[1];
          return caml_call3(M[4], k$0, a, acc);
         }
         return caml_call3(Stdlib_List[25], _m_, acc, p);
        }
        function map_patch(f){
         function _l_(param){
          if(3404203 <= param[1]){var k = param[2]; return [0, 3404203, k];}
          var match = param[2], a = match[2], k$0 = match[1];
          return [0, 3254785, [0, k$0, caml_call1(f, a)]];
         }
         return caml_call1(Stdlib_List[19], _l_);
        }
        function map_data(f, d){return caml_call2(M[34], f, d);}
        var empty = M[1];
        function equal(f){return caml_call1(M[11], f);}
        function diff(eq, x, y){
         function g(key, v, w){
          if(v){
           var v$0 = v[1];
           if(! w) return _g_;
           var w$0 = w[1];
           return caml_call2(eq, v$0, w$0) ? 0 : [0, [0, 85, w$0]];
          }
          if(! w) return 0;
          var v$1 = w[1];
          return [0, [0, 65, v$1]];
         }
         var m = caml_call3(M[8], g, x, y);
         function g$0(key, x, acc){
          if(typeof x === "number") return [0, [0, 3404203, key], acc];
          if(85 <= x[1]){
           var v = x[2];
           return [0, [0, 3404203, key], [0, [0, 3254785, [0, key, v]], acc]];
          }
          var v$0 = x[2];
          return [0, [0, 3254785, [0, key, v$0]], acc];
         }
         var _k_ = caml_call3(M[13], g$0, m, 0);
         return caml_call1(Stdlib_List[9], _k_);
        }
        var
         include = Make([0, merge, map_patch, map_data, empty, equal, diff]),
         empty$0 = include[1],
         create = include[2],
         from_event = include[3],
         from_signal = include[4],
         const$0 = include[5],
         patch = include[6],
         set = include[7],
         map_msg = include[8],
         map = include[9],
         value = include[10],
         fold = include[11],
         signal = include[12],
         event = include[13];
        function filter(pred, m){
         function convert_p(param){
          if(3404203 <= param[1]){
           var k = param[2];
           return [0, [0, 3404203, k], 0];
          }
          var match = param[2], v = match[2], k$0 = match[1];
          return caml_call2(pred, k$0, v)
                  ? [0, [0, 3254785, [0, k$0, v]], 0]
                  : 0;
         }
         function filter_e(param){
          if(0 === param[0]){
           var p = param[1], _j_ = caml_call2(Stdlib_List[19], convert_p, p);
           return [0, caml_call1(Stdlib_List[13], _j_)];
          }
          var m = param[1];
          return [1, caml_call2(M[16], pred, m)];
         }
         var
          _h_ = caml_call1(event, m),
          e = caml_call2(React[1][10], filter_e, _h_),
          _i_ = caml_call1(value, m);
         return caml_call2(from_event, caml_call2(M[16], pred, _i_), e);
        }
        return [0,
                empty$0,
                create,
                from_event,
                from_signal,
                const$0,
                patch,
                set,
                map_msg,
                map,
                value,
                fold,
                signal,
                event,
                filter];
       },
       Make];
   runtime.caml_register_global(24, ReactiveData, "ReactiveData");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJyZWFjdGl2ZURhdGEuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbIm1lcmdlIiwibWFwX3BhdGNoIiwibWFwX2RhdGEiLCJlbXB0eSIsImNyZWF0ZSIsImwiLCJzZW5kIiwiaW5pdGlhbF9ldmVudCIsImN1cnJlbnQiLCJtc2ciLCJwIiwiZXZlbnQiLCJmcm9tX2V2ZW50IiwiY29uc3QkMCIsIngiLCJtYXBfbXNnIiwiZiIsIm1hcCIsInMiLCJzJDAiLCJtc2ckMCIsInZhbHVlIiwiYyIsInBhdGNoIiwic2V0IiwiZm9sZCIsImFjYyIsImFjYyQwIiwic2lnbmFsIiwib3B0Iiwic3RoIiwiZXEiLCJsJDAiLCJmcm9tX3NpZ25hbCIsImQkMCIsImQiLCJpIiwiaSQwIiwieCQwIiwiaSQxIiwiaiIsImkkMiIsInAkNSIsImwkNyIsIm4iLCJwJDMiLCJpJDMiLCJwJDQiLCJsJDIiLCJvcCIsInhzIiwibiQwIiwiYWNjJDEiLCJuJDEiLCJsJDEiLCJ4cyQwIiwieCQxIiwibiQyIiwiYWNjJDIiLCJ4JDIiLCJpJDQiLCJhIiwib2Zmc2V0IiwiaSQ1IiwiYSQwIiwibGVuIiwiaSQ2IiwidiIsImokMCIsImkwIiwiaCIsInAkMCIsImkwJDAiLCJsJDMiLCJwJDEiLCJpMCQxIiwibCQ0IiwicCQyIiwiaTAkMiIsImwkNSIsImwkNiIsImVxdWFsIiwibDEiLCJsMiIsImwxJDAiLCJsMiQwIiwieDIiLCJsMSQxIiwieDEiLCJsMiQxIiwibWVtIiwiaGFzaCIsImRpZmYiLCJzdGgkMCIsImx4JDEiLCJseSQzIiwiYWRkIiwicmVtb3ZlIiwibWVteCIsIm1lbXkiLCJsZWZ0IiwibHgiLCJseSIsImx4JDAiLCJ5IiwibHkkMCIsImx5JDEiLCJhY2MkMyIsImFjYyQ0IiwibHkkMiIsInkkMCIsImFjYyQ1IiwibiQzIiwiYWNjJDYiLCJhY2MkNyIsIm9wdCQwIiwiZW1wdHkkMCIsImNvbnMiLCJzbm9jIiwiaW5zZXJ0IiwidXBkYXRlIiwibW92ZSIsImluZGV4IiwiaGQiLCJ0bCIsInVwZGF0ZV9lcSIsImhhbmRsZSIsImRhdGEiLCJyZW1vdmVfbGFzdCIsInJlbW92ZV9lcSIsInNpbmdsZXRvbiIsInNpbmdsZXRvbl9zIiwiZmlyc3QiLCJlIiwicmVzdWx0IiwiY29uY2F0IiwidjEiLCJ2MiIsInNpemUxIiwic2l6ZTIiLCJzaXplX3dpdGhfcGF0Y2giLCJzaXpleCIsInNpemVfd2l0aF9zZXQiLCJwb3MiLCJtIiwicG9zJDAiLCJwb3MkMSIsInBvcyQyIiwicG9zJDMiLCJ1cGRhdGVfcGF0Y2gxIiwidXBkYXRlX3BhdGNoMiIsInAxIiwicDIiLCJ0dXBsZV9ldiIsInAyJDIiLCJwMiQzIiwicDEkMCIsInAyJDAiLCJzMiIsInMxIiwicDEkMSIsInMyJDAiLCJwMiQxIiwibWVyZ2VkX2V2IiwiaW52ZXJzZSIsInJldiIsInQiLCJmaWx0ZXIiLCJwcmVkIiwic2l6ZSIsImZpbHRlcl9saXN0IiwicmVzIiwidGhlaXJfaSIsIm15X2kiLCJteV9pJDAiLCJ0aGVpcl9pJDAiLCJyZXMkMCIsInRoZWlyX2kkMSIsIm5vcm1hbGlzZSIsInVwZGF0ZV9pbmRleF9pbnNlcnQiLCJpbnNlcnRfcG9zX2Z1bGxfbGlzdCIsInZpc2libGUiLCJpbnNlcnRfcG9zX2Z1bGxfbGlzdCQwIiwidXBkYXRhYmxlcyIsImRpc3BsYWNlZCIsImxlZnRfYWxvbmUiLCJkaXNwbGFjZWRfaW5fZmlsdGVyZWQiLCJ1cGRhdGFibGVzJDAiLCJ1cGRhdGVfaiIsImpfZnVsbF9saXN0Iiwial9maWx0ZXJlZF9saXN0IiwibmV3X2pfZmlsdGVyZWQiLCJpbnNlcnRfcG9zX2ZpbHRlcmVkIiwidXBkYXRlX2luZGV4X21vdmUiLCJmcm9tX2Z1bGxfbGlzdCIsInRvX2Z1bGxfbGlzdCIsInRvX2ZpbHRlcmVkIiwid2FzX3Zpc2libGUiLCJmb3J3YXJkIiwiaV9mdWxsIiwiZGVsdGEiLCJpX2ZpbHRlcmVkIiwibmV3X3ZhbCIsImlfZnVsbCQwIiwiZGVsdGEkMCIsImlfZmlsdGVyZWQkMCIsIm5ld192YWwkMCIsInRvX2ZpbHRlcmVkJDAiLCJjb252ZXJ0X3AiLCJyZW1vdmVfcG9zX2Z1bGxfbGlzdCIsInJldCIsIm5ld19qIiwibGFzdF9pIiwidXBkYXRlX3Bvc19mdWxsX2xpc3QiLCJvbGRfaiIsInVwZGF0ZV9qJDAiLCJ1cGRhdGFibGVzJDEiLCJub25lIiwidXBkYXRlX2okMSIsInByZXZpb3VzX3Bvc19maWx0ZXJlZCIsIm5ld19wb3NfZmlsdGVyZWRfbGlzdCIsIm9mZnNldF9mdWxsIiwib3JpZ2luX2Z1bGwiLCJvcmlnaW5fZnVsbCQwIiwiZGVzdF9mdWxsIiwib3JpZ2luX2ZpbHRlcmVkIiwiZGVzdF9maWx0ZXJlZCIsInNtYWxsX29uZXMiLCJmaWx0ZXJfZSIsImZvcl9hbGwiLCJmbiIsIm1heWJlX3VwZGF0ZSIsImluaXQiLCJ1cGRhdGVfaWR4X2FmdGVyIiwidXBkYXRlcyIsInYkMCIsImsiLCJrJDAiLCJnIiwia2V5IiwidyIsInckMCIsInYkMSIsImckMCJdLCJzb3VyY2VzIjpbIi9Vc2Vycy9yb3N2YWxpLy5vcGFtLzQuMTQuMS9saWIvcmVhY3RpdmVEYXRhL3JlYWN0aXZlRGF0YS5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBMkVjLElBbkJSQSxjQUNBQyxrQkFDQUMsaUJBaUJBQzthQUVBQyxPQUFPQztLQUNUO01BQXlCLFFBQUE7TUFBUEM7TUFBZEM7TUFDQUMsY0FGS0g7bUJBR29CSTtNQUN6QixTQUR5QkE7V0FHZkMsSUFIZUQ7T0FEekJELGFBSTBCLFdBM0I1QlIsT0EyQllVLEdBSlZGOztlQUdRSCxJQUZpQkksUUFEekJELGFBR1FIO01BR1IsT0FMeUJJO0tBS3RCO0tBTEssSUFBUkUsUUFBUSwrQkFGUko7S0FRSixtQkFQSUMsU0FDQUcsU0FGY0w7SUFRTTthQUV0Qk0sV0FBV1AsR0FBRUU7S0FDRCxJQUFWQyxjQURTSDttQkFFZ0JJO01BQ3pCLFNBRHlCQTtXQUdmQyxJQUhlRDtPQUR6QkQsYUFJMEIsV0FyQzVCUixPQXFDWVUsR0FKVkY7O2VBR1FILElBRmlCSSxRQUR6QkQsYUFHUUg7TUFHUixPQUx5Qkk7S0FLdEI7S0FMSyxJQUFSRSxRQUFRLCtCQUZHSjtLQVFmLGVBUElDLFNBQ0FHO0lBTWU7YUFFakJFLFFBQU1DLEdBQUksV0FBSkEsR0FBVzthQUVqQkMsUUFBU0M7SztVQUVITjtNQUFLLFdBQU0sV0E3Q2pCVCxXQTJDU2UsR0FFSE47O1NBREZMO0tBQUssV0FBSSxXQTNDYkgsVUEwQ1NjLEdBQ0xYOzthQUdKWSxJQUFJRCxHQUFFRTtLQUNSLFNBRFFBLFVBRUFKLElBRkFJLE1BRUssV0FBTSxXQWhEakJoQixVQThDSWMsR0FFRUY7S0FFUTtNQURWSyxNQUhFRDtNQUlGVixjQUFjLFdBbERsQk4sVUE4Q0ljLEdBR0FHO01BRUosT0FGSUE7bUJBRXlCVjtNQUNmLElBQU5XLFFBVlJMLFFBSUlDLEdBS3lCUDtNQUV6QixTQURJVztXQUdNVixJQUhOVTtPQUZKWixhQUswQixXQXpEOUJSLE9BeURjVSxHQUxWRjs7ZUFJUUgsSUFGSmUsVUFGSlosYUFJUUg7TUFHUixPQUxJZTtLQUtEO0tBTkssSUFBUlQsUUFBUTtLQU9aLGVBUklILFNBQ0FHO0lBT2dCO2FBRXBCVSxNQUFNSDtLQUFJLFNBQUpBLFVBQ0FJLElBREFKLE1BQ0ssT0FBTEk7U0FDRkgsTUFGRUQ7WUFFRkM7SUFBaUI7YUFFckJSLE1BQU1PO0tBQUksU0FBSkE7U0FFRkMsTUFGRUQ7S0FFRyxPQUFMQztJQUFZO2FBRWhCSSxNQUFPTCxHQUFlUixHQUFJLE9BQUUsV0FBckJRLFVBQWVSLElBQWU7YUFFckNjLElBQUtOLEdBQWVSLEdBQUksT0FBRSxXQUFyQlEsVUFBZVIsSUFBYTthQUVqQ2UsS0FBS1QsR0FBRUUsR0FBRVE7S0FDWCxTQURTUjtNQUVrQixJQUFuQkksSUFGQ0osTUFFa0IsT0FBQSxXQUZwQkYsR0FBSVUsU0FFSEo7TUFBbUIsT0FBQTs7S0FFZixJQUROSCxNQUhHRCxNQUlIUyxRQUFNLFdBSkxYLEdBQUlVLFNBR0xQO0tBRUosT0FBQSw0QkFMS0gsR0FJRFcsT0FEQVI7SUFFc0I7YUFFMUJTLE9BQVNDO0ssR0FBQUEsU0FBS0MsTUFBTEQsUUFBQUUsS0FBS0QsY0FBTEM7S0FDWCxtQkFDUVQsVUFBSyxPQUFBLHdCQUFMQTtLQUVOLElBRElILFlBQ0osT0FESUEsZUFBQUE7bUJBQytCZCxHQUFFSTtNQUNqQyxTQURpQ0EsWUFHekJDLElBSHlCRCxRQUdwQixPQUFBLFdBeEZqQlQsT0F3RllVLEdBSHVCTDtVQUV6QjJCLE1BRjJCdkI7TUFFdEIsT0FBTHVCO0tBQ2dCO0tBSFQsZUFBQSxpQkFKUkQ7S0FJVCxPQUFBOzthQUtBRSxZQUFjSixLQUFVWDtLQUMxQixHQURnQlcsU0FBS0MsTUFBTEQsUUFBQUUsS0FBS0QsY0FBTEM7Y0FDWmYsRUFBRWtCLEtBQUdDLEdBQUksV0FBTSxpQkFESEosSUFDUEksR0FBSEQsTUFBOEI7S0FDUCxXQUFBLHlCQUR6QmxCLEdBRHNCRTtLQUVHLE9BNUQzQk4sV0E0RFMsd0JBRmVNO0lBRXFCO0lBaEdiO1lBdUJoQ2Y7WUFFQUM7WUFXQVE7WUEwREFxQjtZQWhEQXBCO1lBNEJBVTtZQUVBQztZQTVCQVQ7WUFJQUU7WUFjQUk7WUFZQUk7WUFPQUc7WUFmQWpCOztHQXhFSyxJQStHTFQsNEJBREFDO1lBT0FGLFVBQVVlO0lBQWE7Szs7WUFKbEJGLGNBQUZzQixjQUFRLFdBQVJBLEdBQWMsV0FJUHBCLEdBSkxGOztZQUNIdUIsZ0JBQUssV0FBTEE7O1lBRUdDLGdCQUFGQztRQUFRLFdBQVJBLEtBQWEsV0FDTnZCLEdBRExzQjtvQkFEQUUsY0FBRkMsZ0JBQVEsV0FBUkEsS0FBRUQ7OztJQUVrQixPQUFBO0dBQWE7WUE2RnBDeEMsTUFBTTBDLEtBQUVDO0lBQ1Y7Ozs7O1VBWndCQyxPQUFFQyxNQVdsQkg7TUFWUjtjQUR3QkU7UUFDeEIsTUFBQTtZQUQwQkM7cUJBQUFBOztXQUFGQyxrQkFBRUMsTUFBQUY7VUFBRkQsSUFBQUU7V0FBQUYsSUFBQUUsS0FBRUQsTUFBQUU7Ozs7Ozs7SUFZdkI7OztpQkFHbUJDLEtBQUVDO1NBQUssT0FBTEE7O1lBNUZ0QjthQURNbkMsSUE2RmdCbUM7YUE3Rm5CYixJQTZGbUJhO2FBM0ZOWjtvQkFGYkQsSUFBQUEsS0FDb0IsMkJBNEZIWSxnQkE3RmpCWjthQUVTVjthQUdSa0IsSUFIWVA7YUFBRWhDLElBMkZFMkM7WUEzRkU7c0JBR2xCSixHQUYyQixPQUFBLDRCQURuQmxCLFNBRk5aLEdBRVlUO2tCQUFBQTtjQUVOLE9BQUE7YUFDRztjQUhHNkMsS0FBQTdDO2NBR1ppQyxNQUhZakM7Y0FBRjhDLE1BR1pQO2NBSFFqQixZQUdOVyxLQUhNWjtjQUFBQSxNQUFBQztjQUdSaUIsSUFIWU87Y0FBRTlDLElBQUE2Qzs7OztZQU1sQjthQURFWCxNQXNGb0JVO2FBcEZOUixXQUZkRixNQUFBQSxNQUNxQiwyQkFxRkhTLE9BdEZsQlQ7YUFFVWE7YUFHUkMsTUFIWVo7YUFBRVQsTUFvRkVnQjtZQXBGRTtzQkFHbEJLLE9BSGNyQjtrQkFDVHNCLE1BRFN0QjtjQUNKLE9BQUEsNEJBREZvQixPQUNIRTs7a0JBRFN0QjtjQUVOLE9BQUE7YUFDRztjQUhHdUIsT0FBQXZCO2NBR1p3QixNQUhZeEI7Y0FBRnlCLE1BR1pKO2NBSFFLLFlBR05GLEtBSE1KO2NBQUFBLFFBQUFNO2NBR1JMLE1BSFlJO2NBQUV6QixNQUFBdUI7Ozs7WUFNbEI7YUFETUksTUErRWdCVjthQS9FbkJILE1BK0VtQkc7YUE5RWxCVyxXQUREZCxNQUFBQSxNQUNvQiwyQkE4RUhFLE9BL0VqQkY7YUFFQ2UsSUFBSSw2QkE2RVliO1lBNUVwQixpQkFESWEsR0FEQUQsU0FBQUEsT0FERUQ7WUFHTixPQUFBLDZCQURJRTs7WUFJSTthQURGQyxTQTBFZ0JiO2FBMUVuQmMsTUEwRW1CZDthQXpFbEJlLE1BQUksNkJBeUVZaEI7YUF4RWhCaUIsTUFEQUQ7YUFFQUUsV0FIREgsTUFBQUEsTUFFQ0UsTUFGREY7YUFJQ0kscUJBSEFILEtBRUFFLFNBQUFBO1lBRUosT0FMTUo7Z0JBRUZHLFFBQ0FDLE1BSEVKO2NBT3dCO3lCQUoxQkksTUFIRUo7d0JBR0ZJO2tCQUtGMUIsSUFMRTBCOztlQU1BO2dCQUFBLE9BREYxQjtnQkFDVyx3QkFSVHdCO2VBUUEsaUJBUkFBLEtBT0Z4QixPQUFBQTtlQUNFLFdBREZBOzJCQUFBQTttQkFBQUE7Ozt3QkFMRTBCLE1BSEVKO2FBV0osaUJBVkVFLHVCQUdBRzs7O2lCQURBRCxNQUhFSjtjQWNxQjt5QkFYdkJJLE1BSEVKO2dCQUdGSTtrQkFZRkUsTUFaRUY7O2VBYUE7Z0JBQUEsT0FERkU7Z0JBQ1csd0JBZlRKO2VBZUEsaUJBZkFBLEtBY0ZJLFNBQUFBO2VBQ0UsV0FERkE7MkJBQUFBO21CQUFBQTs7O3dCQVpFRixNQUhFSjthQWtCSixpQkFqQkVFLHVCQUdBRzs7WUFjRixPQUFBLDZCQWpCRUg7O1FBeUVrQztLQUF0QyxPQUFBLGtDQUpRckIsS0FBRkQ7O1FBbkNZVSxXQUFJaUIsUUFBRzNELElBbUNuQmdDLEtBbkNxQlksTUFtQ25CWDtJQWxDVjs7O1NBRDJCakM7bUJBQUFBOztZQUduQjZCO1dBSGdCOEIsS0FHaEI5QjthQWZvQkUsTUFlcEJGLE1BSGdCOEI7Ozs7O2VBWkEzQyxNQVlKMEIsT0FaUWhCLElBQUFLLEtBQUVwQyxJQVlEaUQ7V0FYN0I7bUJBRDRCbEI7YUFDNUIsTUFBQTtvQkFENEJBO2lCQUFFL0I7WUFLaEI7YUFMZ0IyQixNQUFBM0I7YUFJMUJpRSxJQUowQmpFO2FBQU5zQixZQUlwQjJDLEdBSm9CNUM7YUFBSVcsTUFBQUQ7YUFBSlYsTUFBQUM7YUFBSVMsSUFBQUM7YUFBRWhDLElBQUEyQjs7MEJBQUEzQixHQUFOcUI7OztxQkFRcEI7O2FBS0dnQyxpQkFrQkRWOzs7OztVQWxCQ1UsUUFEYU4sT0FtQmRKLE1BbkJ1Qk07O1VBQUY1QyxHQW9CekIsT0FBQSw0QkFuQktnRCxPQWtCRFY7bUJBbkJxQnRDOzs7UUFVSDtTQVZHNkQsTUFBQTdEO1NBU25CSTtTQVRnQjBEO1NBQUtDLFVBU3JCM0QsR0FVRmtDO1NBbkJjSSxRQUNiTTtTQURpQlcsS0FBQUc7U0FBRzlELElBQUE2RDtTQUFFakIsTUFBQW1COzs7WUFBRkMsTUFBQWhFLE1BQUhpRTthQW1CbEIzQixLQUxKLE9BQUE7WUFkMkI0QixNQW1CdkI1QixRQW5CY0ksUUFDYk0sT0FEaUJXLEtBQUFNLE1BQUdqRSxJQUFBZ0UsS0FBRXBCLE1BQUFzQjs7O1lBQUZDLE1BQUFuRSxNQWVuQjRCLGtCQWZnQndDO2FBbUJsQjlCLEtBREosT0FBQTtRQUZzQjtTQURGK0IsTUFJaEIvQjtTQW5CdUJnQyxVQWVyQjFDLEtBQWN5QztTQWZGM0IsUUFDYk07U0FEaUJXLEtBQUFTO1NBQUdwRSxJQUFBbUU7U0FBRXZCLE1BQUEwQjs7Z0JBc0IzQixPQUFBOzs7R0FpQjJDO1lBRXZDQyxNQUFNakUsR0FBRWtFLElBQUdDO0lBQ2pCLElBRGNDLE9BQUFGLElBQUdHLE9BQUFGO0lBQ2pCO1FBRGNDO1NBQUdDO1dBRUxDLEtBRktELFNBQUhFLE9BQUFILFNBRVpJLEtBRllKLFNBQUdLLE9BQUFKO09BRVMsR0FBQSxXQUZkckUsR0FFVndFLElBQVVGLFNBRkVGLE9BQUFHLE1BQUdGLE9BQUFJOzs7ZUFBQUosTUFLZjtLQUlBOztHQUFLO1lBRUxLLElBQWFyRjtJQUNmLElBRTJCc0Y7YUFBd0JWLGtCO0lBQzNDOzRDQUQyQ0EsT0FBeEJVO0tBQ3ZCckIsSUFBSTtrQkFDT3hELEdBQUssT0FBQSxpQkFEaEJ3RCxHQUNXeEQsTUFBaUI7SUFBaEMsa0NBTGVUO0lBS2YsT0FBQSxrQkFESWlFO0dBRUc7WUE4Q0xzQixLQTVDWUMsT0E0Q0hDLE1BQUVDO0lBQ2IsU0E3Q3NDQyxJQTZDOUJ0RSxLQUFJVSxHQUFFK0IsR0FBSSxlQUFOL0IsR0FBRStCLElBQU56QyxLQUF5QjthQTdDSHVFLE9BOENuQnZFLEtBQUlVLEdBQUksZUFBSkEsSUFBSlYsS0FBa0I7SUE3Q2xCO0tBQVB3RSxPQVRGUixJQW9EU0k7S0ExQ1BLLE9BVkZULElBb0RXSzs7S0F6Q0dLO0tBQUtDLEtBeUNWUDtLQXpDYVEsS0F5Q1hQO0tBekNjbkQ7SUFDekI7UUFEbUJ5RDtVQUFBRSxPQUFBRixPQWlCakJ2RixJQWpCaUJ1RjtTQUFHQztXQXFCWkUsSUFyQllGLE9BQUFHLE9BQUFIO09BY0UsR0FBQSxXQWpCWlQsT0FvQlYvRSxHQUlRMEY7UUFOUixJQWZ1QnJELE1BQUFQLFdBQU55RCxLQUFBRSxNQUFHRCxLQUFBRyxNQUFHN0QsSUFBQU87ZUFpQkUsV0FsQnpCZ0QsTUFrQkFyRjtRQUl5QixHQUFBLFdBdkJ6Qm9GLE1BdUJRTTtTQUlhLEdBekJUSjtVQTBCRixJQTFCSHpFLFFBSG1Cc0UsWUFHSHJELFVBQWhCakIsT0FBS3lFLFVBQUtDLEtBQUFFOztVQTZCUDtXQTdCVUcsT0FBQUo7V0FBYmxELFFBSDJCNEMsU0FHWHBELEdBcUJmNEQ7V0FyQmVuRCxNQUFBVDtpQkFBaEJRO1dBQUtnRDtXQUFRRSxLQUFBSTtXQUFHOUQsSUFBQVM7O1NBc0JiO1VBdEJISyxRQUgyQnNDLFNBR1hwRCxHQXFCZjREO1VBckJlL0MsTUFBQWI7Z0JBQWhCYztVQUFhNEMsS0FBQUc7VUFBRzdELElBQUFhOztRQWtCYixJQWxCSGtELFFBSG1CVixZQUdIckQsVUFBaEIrRCxPQUFVTixLQUFBRTs7O09BSVAsSUFKSEssUUFIbUJYLFlBR0hyRCxVQUFoQmdFLE9BQVVQLEtBQUFFLE1BQUdEOzs7V0FBQUE7TUFRVjtPQVJVTyxPQUFBUDtPQU9oQlEsTUFQZ0JSO09BQWJTLFFBSDJCZixTQUdYcEQsR0FPbkJrRTtPQVBtQkUsTUFBQXBFO2FBQWhCbUU7T0FBVVY7T0FBR0MsS0FBQU87T0FBR2pFLElBQUFvRTs7UUFrQ1ZuRjs7S0FBWSxHQUFaQSxTQUFNQyxNQUFORCxRQUFBb0YsUUFBTW5GLGNBQU5tRjtLQUFZLFlBSzNCLE9BTGVBO0tBRUw7O01BRFYzQztNQUNJNEMsWUFESjVDLEdBRGUyQztNQUFBRSxZQUVYRDtNQUZXckYsTUFBQXNGOzs7R0FXNkI7O3VCQXpFNUNuSCxPQTdGQUMsV0FOQUMsVUFEQUMsT0EwR0k4RSxPQStESlc7SUF0U0p3QjtJQUNBaEg7SUFDQVE7SUFDQXFCO0lBQ0FwQjtJQUNBVTtJQUNBQztJQUNBVDtJQUNBRTtJQUNBSTtJQUNBSTtJQUNBRztJQUNBakI7WUEyU0kwRyxLQUFLdkcsR0FBRUksR0FBSSxPQUFRLFdBbFR2QkssT0FrVFdMLGNBQUZKLFFBQXlCO1lBQzlCd0csS0FBS3hHLEdBQUVJLEdBQUksT0FBUSxXQW5UdkJLLE9BbVRXTCxlQUFGSixRQUEwQjtZQUMvQnlHLE9BQU96RyxHQUFFc0IsR0FBRWxCLEdBQUksT0FBUSxXQXBUM0JLLE9Bb1RlTCxXQUFGa0IsR0FBRnRCLFFBQTJCO1lBQ2xDMEcsT0FBTzFHLEdBQUVzQixHQUFFbEIsR0FBSSxPQUFRLFdBclQzQkssT0FxVGVMLFdBQUZrQixHQUFGdEIsUUFBMkI7WUFDbEMyRyxLQUFLckYsR0FBRUksR0FBRXRCLEdBQUksT0FBUSxXQXRUekJLLE9Bc1RhTCxXQUFKa0IsR0FBRUksUUFBeUI7WUFDaEN5RCxPQUFPN0QsR0FBRWxCLEdBQUksT0FBUSxXQXZUekJLLE9BdVRhTCxXQUFGa0IsUUFBcUI7WUFFNUJzRixNQUFRN0YsS0FBVXhCLEdBQUVTO0lBQ3RCLEdBRFVlLFNBQUtDLE1BQUxELFFBQUFFLEtBQUtELGNBQUxDO1FBQ0FhLGVBRFV2Qzs7aUJBSVYsTUFBQTtTQUZOc0g7S0FBYSxHQUFBLFdBRlA1RixJQUVONEYsSUFGa0I3RyxJQUVNLE9BRGxCOEI7S0FFSyxJQUFOZ0YsZUFBTSxNQUZMaEYsV0FBQUEsaUJBRURnRjs7R0FHSjtZQUVIQyxVQUFXOUYsV0FBa0JqQixHQUFFMEY7SUFDekI7S0FEZXNCO0tBQU5DO0tBQ2IzRixJQVRGc0YsTUFRVzNGLElBQ0ssV0E5VHBCVixPQTZUbUIwRyxPQUFjakg7SUFFL0IsT0FkRTBHLE9BWStCaEIsR0FDN0JwRSxHQURtQjBGOztZQUlyQkU7SUFDa0IsSUFEQ0YsbUJBQU5DLGlCQUNLLE9BQUEsV0FsVXRCMUcsT0FpVWlCMEc7SUFDZixPQWZFOUIsT0FlTSwwQ0FEYTZCOztZQUduQkcsVUFBV2xHLFdBQWtCakI7SUFDdkI7S0FEZWdIO0tBQU5DO0tBQ2IzRixJQWhCRnNGLE1BZVczRixJQUNLLFdBclVwQlYsT0FvVW1CMEcsT0FBY2pIO0lBRS9CLE9BbkJFbUYsT0FrQkU3RCxHQURtQjBGOztZQUlyQkksVUFBVXBILEdBQUksT0FBTSxXQTdVeEJELGFBNlVjQyxPQUFhO1lBRXZCcUgsWUFBWWpIO0lBQ2Q7S0FBSWtIO0tBQ1MsUUFBQTtLQUFQOUg7S0FBRitIO0tBQ0FDLFNBQVMsV0FwVmYxSCxlQW1WTXlIO2tCQUVxQnZIO0tBQ3JCLE9BSkFzSDtnQkFBQUEsY0FPTyxXQU5MOUgsd0JBRW1CUTtlQU1YLFdBUlJSLHdCQUVtQlE7SUFNSztJQU50QixrQ0FKTUk7SUFJTixPQURKb0g7R0FRRTtZQUVKQyxPQUFvQ3pILEdBQUUwRjtJQUN4QztLQUFJZ0MsS0FBSyxXQXhWWG5ILE9BdVZ3Q1A7S0FFbEMySCxLQUFLLFdBelZYcEgsT0F1VjBDbUY7S0FHcENrQztLQUNBQztJQUNKLFNBQUlDLGdCQUFnQkM7Szs7UUFBQUE7O1FBQUFBO2dCQUdHOzs7SUFDdkIsU0FBSUMsY0FBY0QsT0FBTXhJO0tBQU53SSxXQUFpQiwyQkFBWHhJOztJQUF3QjtJQUE1Q3lJLGNBTkFKLE9BRkFGO0lBUUFNLGNBTEFILE9BRkFGO2tCQVk4Qi9IO0tBQzlCLE9BRDhCQTs7UUFHMUI7U0FEU0ksSUFGaUJKO1NBRXJCcUksTUFGcUJySTtTQUd0QjBCLFNBREMyRyxNQUFBQSxNQUFBQSxNQVpUSjtTQVdJSyxRQUVJNUcsR0FES3RCOzs7UUFHTTtTQUFYbUksUUFMc0J2STtTQUt0QndJLGFBQUFELFFBQUFBLFFBQUFBLFFBZlJOO1NBV0lLLFFBSUlFOzs7O1NBQ0s1RyxNQU5pQjVCO1NBTXJCeUksUUFOcUJ6STtTQU1yQjBJLGFBQUFELFFBQUFBLFFBQUFBLFFBaEJUUjtTQVdJSyxRQUtLSSxPQUFJOUc7Ozs7U0FDRkUsSUFQbUI5QjtTQU9yQjJCLE1BUHFCM0I7U0FPckI2QixXQUFBRixNQUFBQSxNQUFBQSxNQWpCVHNHO1NBV0lLLFFBTUt6RyxLQUFFQzs7S0FoQlhvRyxnQkFGQUYsT0FZSU07S0FRSixPQVJJQTtJQVNIO0lBVmUsSUFBaEJLLGdCQUFnQjtrQkFXYzNJO0tBQzlCLE9BRDhCQTs7O1NBRWpCSSxJQUZpQko7U0FFckJxSSxNQUZxQnJJO3FCQUVyQnFJLE1BeEJUTCxXQXdCU0ssVUFBQUE7U0FETEMsY0FDU2xJOzs7UUFDTTtTQUFYbUksUUFIc0J2STtTQUdYLFlBQVh1SSxRQXpCUlAsV0F5QlFPLFlBQUFBO1NBRkpEOzs7O1NBR1MxRyxNQUppQjVCO1NBSXJCd0ksUUFKcUJ4STtxQkFJckJ3SSxRQTFCVFIsV0EwQlNRLFlBQUFBO1NBSExGLGNBR1MxRzs7OztTQUNGRSxJQUxtQjlCO1NBS3JCMEIsSUFMcUIxQjtxQkFLckIwQixJQTNCVHNHLFdBMkJTdEcsUUFBQUE7U0FKTDRHLGNBSU94Rzs7S0F6QlhvRyxnQkFEQUQsT0FzQklLO0tBTUosT0FOSUE7SUFPSDtJQVJlO0tBQWhCTSxnQkFBZ0I7S0FBQTtLQWlCYyxPQUFBLFdBOVhwQzNJLE9Bb1YwQzZGO2tCQTBDbEI2QixHQUFLLGtCQUFMQSxHQUFVO0lBREU7Z0JBQzdCO0tBRDZCLE9BQUEsV0E3WHBDMUgsT0FvVndDRztrQkF5Q2hCdUgsR0FBSyxrQkFBTEEsR0FBVTtJQUE1QixlQUFDO2tCQU5nQjNHLEtBQUlaO0tBQ25CLElBRUd5SSxLQUhZN0g7VUFHWjZILGFBSGdCekksNEJBQUFBO1VBRUgwQyxNQUZHMUMsTUFFWDBJLEtBRk85SDtNQUVNLGVBQUw4QixNQUFSZ0c7O1VBRk85SCxpQkFBSVosNEJBQUFBLFVBR0h3QixNQUhHeEIsTUFHRSxXQUFsQnlJLFFBQWFqSDtLQUNULE1BQUE7SUFBWTtJQUp2QixJQURFbUgsV0FDRjtrQkFRK0IvSTtLQUM3QixXQUQ2QkE7O2lCQUFBQTs7T0E0QmQsTUFBQTs7O1dBWEtnSjtPQUFPLFdBQU0sV0FuQ2pDSixlQW1Db0JJOztVQVJGQztNQTNDbEJiLGNBTEFILE9BZ0RrQmdCO01BRVgsV0FBQSxXQTdZYnRJLE9BdVZ3Q1A7TUFzRGhDLFdBQUksNkJBRlk2STs7OztpQkFUV2pKLE1BZ0JmNkk7aUJBQWEsV0FBTSxXQTdDakNGLGVBNkNjRTs7O09BSEg7UUFEb0JDO1FBQ3pCSSxPQUFLLFdBMUNYUCxlQTZDY0U7UUFGUk0sT0FBSyxXQWhDWFAsZUE4QitCRTtPQUc3QixXQUFNLHVCQUZGSSxNQUNBQzs7TUFLSyxJQURpQkMsZUFDdEJDLEtBQUssV0FyWmpCMUksT0F1VndDUDtNQVNsQ2dJLGNBTkFKLE9BMkRNcUI7TUFyRE5qQixjQUxBSCxPQXlENEJtQjtNQUkxQixXQUFHLHVCQUhDQyxJQURzQkQ7O2dCQWxCQ3BKLE1BTWpCc0o7O01BeENabEIsY0FOQUosT0E4Q1lzQjtNQUVBLFdBQUEsV0ExWWxCM0ksT0F1VjBDbUY7TUFtRGxDLFdBQUksdUJBRk13RDs7OztNQXhDWmxCLGNBTkFKLE9BOENZc0I7TUFtQkQsSUFBTEMsT0FBSyxXQTNaakI1SSxPQXVWMENtRjtNQVNwQ3NDLGNBTEFILE9BZ0VNc0I7TUFFSixXQUFHLHVCQXJCT0QsTUFtQk5DOztTQXZCcUJDO0tBcEMzQnBCLGNBTkFKLE9BOENZc0I7S0F4Q1psQixjQUxBSCxPQXlDMkJ1QjtLQUd6QixXQUFJLHVCQUNNRixNQUplRTtJQTBCQTtJQTVCZixJQUFaQyxZQUFZLCtCQVRaVjtJQXVDSixPQUFBLFdBdmFGN0ksWUF1YWEsdUJBeEVQNEgsSUFDQUMsS0F5Q0EwQjtHQThCMEI7WUFFNUJDO0lBQThCOztXQUN6QnRKLGNBQUZzQixjQUFRLGNBQVJBLGdCQUFFdEI7O1dBRUh1QixnQkFBSyxjQUFMQTs7V0FER0MsZ0JBQUZDO09BQVEsY0FBUkEsa0JBQUVEOztXQUVBRSxjQUFGQztPQUFRLGNBQVJBLG9CQUFFRDs7R0FBaUI7WUFFdEI2SCxJQUFJQztJQUd3QyxVQUFBLFdBeGFoRDNKLE9BcWFRMko7O0tBQ2M7VUFFUjVKO01BQUssV0FBTSw0QkFUckIwSixTQVNVMUo7O1NBREZMO0tBQUssV0FBSSwyQkFBVEE7SUFDa0M7SUFGcEMsSUFBSmdJLElBQUksb0NBSWEsT0FBQSxXQTdhdkJoSCxPQXdhUWlKO0lBS04sT0FBQSxXQXBiRjFKLFlBb2JhLGtDQUpQeUg7R0FJNkI7WUFFL0JrQyxPQUFPQyxNQUFLbks7SUFDZDs7S0FFSXFIO0tBQ0ErQzthQUVBQyxZQUNXcks7S0FIWG9LLFVBaUJNLDJCQWRLcEs7S0FKWHFIO1NBSVcxRixNQUFBM0IsR0FBWXNLLFNBQUlDLGFBQVFDO0tBQU87V0FBL0I3SSxLQWdCSixPQUFBLDJCQWhCZ0IySTtVQUFaekgsS0FBQWxCLFFBRVRsQixJQUZTa0I7TUFHTCxHQUFBLFdBVkR3SSxNQVNIMUo7T0FORjRHLFdBVWdCLHNCQU5Xa0QsU0FBUUMsY0FKbkNuRDtPQVdPO1FBUDRCb0QsU0FBQUQ7UUFBUkUsWUFBQUg7UUFBSkksWUFFckJsSyxHQUZxQjZKO1FBQVozSSxNQUFBa0I7UUFBWXlILE1BQUFLO1FBQUlKLFVBQUFHO1FBQVFGLE9BQUFDOzs7V0FBUkcsWUFBQUwsaUJBQWhCNUksTUFBQWtCLElBQWdCMEgsVUFBQUs7O0lBZ0JIO0lBRzVCLFNBQUlDLFVBQVU5SSxHQUFJLFlBQUpBLElBQUFBLEtBdEJWcUksbUJBc0JVckksTUFBc0M7YUFFaEQrSSxvQkFBb0JDLHNCQUFxQkM7S0FDM0M7TUFBSUMseUJBSEZKLFVBRW9CRTtNQUVrQixRQUFBLHVCQURwQ0Usd0JBMUJGNUQ7TUEyQnlCNkQ7TUFBWEM7TUFBWkM7S0FDSixHQURnQkQ7O09BR1BFLHdCQUhPRjtPQUNaRztTQUdDOztXQUxETDtXQUlLSTtXQUhrQkg7O1VBQ3ZCSSxlQUR1Qko7Y0FNdkJLLFNBQVNDLGFBQVlDO01BQ3ZCO09BQUlDLGlCQVRxQ1YsVUFRbEJTLDBCQUFBQTtNQWpDdkJwRTtPQW1DUyxzQkFGRW1FLHFCQUNQRSxnQkFsQ0pyRTs7S0FtQzJEO0tBRXBELHVCQUpMa0UsVUFMQUQ7S0FVeUI7TUFBekJLO1FBQXlCLHNCQVh6QlA7O1dBYWdDLHVCQWJoQ0E7S0FlSixHQWpCMkNKO01BekJ6QzNEO09BMEN1QjtvQkFoQnJCNEQsd0JBWUFVLHFCQXRDRnRFO0tBQ0ErQztLQTJDRixPQU5JdUI7SUFNZTthQTJDakJDLGtCQUFrQkMsZ0JBQWVDLGNBQWFDO0tBQ2hEO01BQUlDLGNBRDRDRDtNQUU1Q0UsVUFGZ0JKLGlCQUFlQztLQUduQyxHQURJRztNQUVGLFVBSmtCSjtTQUFlQztXQUlqQ0k7O1lBQ01DLFFBSkpIO1FBS0E7U0FDbUI7VUFBYkksYUFBYSx1QkFIckJGLFFBM0ZBN0U7VUErRlFnRixVQURBRCxhQUZGRDtTQTVGTjlFLFdBZ0dhLHNCQUxiNkUsZ0JBSVFHLFNBL0ZSaEY7Ozs7OztRQTJGQSxVQUFBNkU7V0FKaUNKLGlCQUlqQ0k7WUFBQUE7Ozs7O01BVUEsVUFka0JMO2dCQUFlQztXQWNqQ1E7O1FBQ0U7U0FFbUI7VUFEYkMsVUFmTlA7VUFnQk1RLGVBQWEsdUJBSHJCRixVQXJHQWpGO1VBeUdRb0YsWUFEQUQsZUFEQUQ7U0F2R1JsRjtVQTBHYSxzQkFMYmlGLGtCQUlRRyxXQXpHUnBGOzs7Ozs7UUFxR0EsVUFBQWlGO1dBZGlDUixpQkFjakNRO1lBQUFBOzs7O1FBZDhDUDtVQXdCekNXLGdCQXhCeUNYO01BdkY5QzFFLFdBZ0hVLHNCQXpCdUJ5RSxjQXdCNUJZLGVBL0dMckY7OztLQUFBQSxXQWtIVSxzQkEzQnVCeUUsY0F2RmpDekU7O0lBa0gyQzthQUczQ3NGO0tBQVk7O1lBQ05sTSxjQUFIc0I7UUFDQyxHQUFBLFdBMUhDb0ksTUF5SEMxSjtTQUdRLElBQVArSixPQWhHUE0sb0JBNkZHL0k7U0FJQSxlQURJeUksTUFIRC9KOztRQTdGTnFLLG9CQTZGRy9JO1FBUUU7O1FBR0ksSUFEUEMsZ0JBakZrQjRLLHVCQXhCcEIvQixVQXlHRTdJO1FBRUQ7U0FBc0I7VUFBSkcsSUFBSSx1QkFuRkh5SyxzQkEvQ3BCdkY7VUFrSStDLGNBQTVCbEY7VUFBZDBLOzs7OzthQUFBQTs7UUFsRlc7U0FBZGIsY0FBYyxzQkFESVksc0JBL0NwQnZGO1NBaURNNkQ7V0FBYSx1QkFGQzBCLHNCQS9DcEJ2RjtTQWtERWtFO29CQUFTQyxhQUFZQztZQUN2QjthQUFJcUIsUUFIRmQsY0FFcUJQLGtCQUFBQTtZQWxEdkJwRTthQW9EUyxzQkFGRW1FLHFCQUNQc0IsT0FuREp6Rjs7V0FvRGtEO1FBRTdDLEtBQUEsc0JBdERMQTthQXdESTBGLFNBQVksdUJBeERoQjFGO1NBQUFBLFdBeURTLHNCQURMMEYsUUF4REoxRjs7UUFDQStDO1FBMkRGLHVCQVZJbUIsVUFESUw7UUFtRkwsT0FGSTJCOztRQUlJO1NBREg1SztTQUFIQztTQTdEd0I4Syx1QkFqRDNCbkMsVUE4R0czSTtRQUVGO1NBRWdCLElBQVIrSyxRQUFRLHVCQWpFVUQsc0JBeEUzQjNGO1NBMElRLEdBQUEsV0E3SUg4QyxNQXdJQ2xJOzRCQUlHZ0wsT0FKSGhMOzs7V0FyRUVxSjthQUFhLHVCQVFNMEIsc0JBeEUzQjNGO1dBaUVFNkY7c0JBQVMxQixhQUFZQztjQWpFdkJwRTtlQWtFUzs0QkFERW1FLGFBQVlDLHlCQWpFdkJwRTs7YUFrRTREO1VBbEU1REEsV0FvRU8sc0JBSW9CMkYsc0JBeEUzQjNGO1VBcUVGLHVCQUpJNkYsWUFETTVCOzRCQXlFQzJCOztTQUVDOzs7OztTQUlELEtBQUEsV0FsSko5QyxNQXdJQ2xJLE1BZUU7U0EzRXlCO1VBQUEsUUFBQSx1QkFETitLLHNCQXhFM0IzRjtVQXlFb0I4RjtVQUFOQztVQUFaaEM7U0FDSixTQURnQmdDO1VBQ2hCLE1BQUE7O1VBQ0lDO3FCQUFTN0IsYUFBWUM7YUEzRXZCcEU7Y0E0RVM7MkJBREVtRSxhQUFZQyx5QkEzRXZCcEU7O1lBNEU0RDtTQUU5RDtVQUN1QztXQUFBLE1BQUEsdUJBTm5DK0Q7V0FNRWtDOzs7OztjQUFBQTs7U0FBb0YsSUFrRTVFQyx3QkFsRVJEO1NBL0VKakc7VUFrRk87dUJBVm9CMkYsc0JBeUVmTyx1QkFqSlpsRztTQW1GRix1QkFSSWdHLFlBRmtCRjtTQXlFWixlQURJSSx1QkFaTnRMOzs7UUFrQmE7U0FESHVMO1NBQWJDO1NBQ0VDLGdCQWhJTDdDLFVBK0hHNEM7U0FFRUUsWUFEQUQsZ0JBRFdGO1FBR2Y7U0FDd0I7VUFBbEJJLGtCQUFrQix1QkFIcEJGLGVBdkpMckc7U0EySkc7VUFDTTtXQUFBLE1BQUEsdUJBSkpzRyxXQXhKTHRHO1dBMkpPd0c7Ozs7O1VBS0k7V0FEQ0MsYUFBbUIsdUJBUjFCSixlQXZKTHJHO1dBZ0tXO2FBQUEsc0JBREN5Rzs7Z0JBR0ssdUJBSExBO1dBSkxEOztTQXBFUGpDLGtCQWdFSzhCLGVBQ0FDLGVBR0VFOzs7WUFBQUEsa0JBREFEOzttQkFBQUEsaUJBQ0FDLGdCQURBRDs7O1NBWUM7Ozs7O1NBL0VSaEMsa0JBZ0VLOEIsZUFDQUM7U0FtQkQ7OztJQUNFO2FBR05JO0tBQVc7TUFHUyxJQURkMU4sY0FDYyxNQUFBLDRCQTdEcEJzTSxXQTRETXRNO01BQ0wsV0FBTTs7U0FGSEw7S0FBSyxXQTdLVHFLLFlBNktJcks7SUFFdUM7SUFFbEI7S0FBQSxNQUFBLFdBbm1CL0JNLE9BNGFnQk47S0F1TFZnSSxJQUFJLHlCQUxKK0Y7SUFNSixPQUFBLFdBOW1CRnhOLFlBNGJNOEosWUFrTG9CLFdBdm1CMUJySixPQSthZ0JoQixLQXVMVmdJO0dBQ2dDOztZQUlsQ2dHLFFBQVFDLElBQUd2RzthQUNUd0csYUFBYTdNLEtBQUlVLEdBQUUrQjtLQUFJLE9BQUcsV0FEcEJtSyxJQUNhbkssS0FBTnpDLE1BQWdDLHNCQUE1QlUsR0FBSlY7SUFBZ0Q7O0lBTS9ELFNBTEU4TTtTQUNXbk0sU0FBRVY7O2tCQUVMLE9BRktBO01BQ2E7T0FBbkJpRztPQUFMekQ7T0FBd0IsUUFIMUJvSyxhQUVhNU0sT0FBRlUsS0FDVDhCO09BQXdCLE1BRGY5QjtPQUFBQTtPQUFFVjtlQUNOaUc7OztJQUtYLFNBQUk2RyxpQkFBaUJyTSxHQUFFcEIsR0FBRVU7a0JBQ1BXLEtBQU0sT0FESEQsS0FDSEMsTUFBc0IsV0FEakJyQixHQUNMcUIsVUFBQUEsSUFBb0M7S0FBcEQsT0FBQSw0QkFEdUJYO0lBQ2tDO2FBRXZEVixFQUFRVTtLQUFKOztPQUVFZ047O2tCQUVDaE47VUFBTDs7YUFVZTtjQURKeUM7Y0FBSC9CO2NBQ0NUO2dCQWpCWDhNO2tCQWdCVXJNLHNCLHdCQVRIVjthQVdBLE9BMUJQNk0sYUF5Qlc1TSxPQUREUyxHQUFHK0I7O2FBRGlCLElBRHJCOUIsZ0JBQ3FCLE1BQUEsc0JBRHJCQSxLQVBGWDthQVF1QixPQWY5QitNO3NCQWNTcE0sd0I7O2lCQUtJc00sZ0JBQUhwTTthQUNILE9BNUJQZ00sYUE0Qm9CLHNCQURWaE0sS0FaSGIsTUFZR2EsS0FBR29NOzthQVZnQjtjQURoQmxNO2NBQUhLO2NBQ21CLE1BQUEsc0JBRGhCTCxLQUROZjtnQkFFRyxzQkFEQW9CLEtBREhwQixjQUdLLE9BSExBO2FBSVEsR0FBQSxzQkFITG9CLEtBREhwQjtjQUttQixVQUFBLHNCQUpoQm9CLEtBREhwQjtjQUttQixPQUFBLHNCQUpiZTs7YUFLWSxVQUFBLHNCQUxaQSxLQUROZjthQU1rQixPQUFBLHNCQUxmb0I7O1NBWW9DO01BZDlDLE9BQUEsaUNBSFFwQixLQUVGZ047O1NBREY1TjtLQUFLLE9BWFQwTixLQVdJMU47SUFrQks7SUFFc0I7S0FBQSxNQUFBLFdBem9CckNILE9Bd21CZW9IO0tBaUNFLE1BL0JYeUcsS0ErQmlCLFdBNW9CdkJuTixPQTJtQmUwRztLQWlDYixNQUFBLDRCQXJCSS9HO0lBcUJKLE9BQUEsV0FDRztHQUEyQjs7Ozs7UUF0cEJoQ29HO1FBQ0FoSDtRQUNBUTtRQUNBcUI7UUFDQXBCO1FBQ0FVO1FBQ0FDO1FBQ0FUO1FBQ0FFO1FBQ0FJO1FBQ0FJO1FBQ0FHO1FBQ0FqQjtRQTJTSTBHO1FBQ0FDO1FBQ0FDO1FBR0F0QjtRQWNBK0I7UUFHQUM7UUFuQkFUO1FBWUFLO1FBWEFKO1FBc0JBUztRQUVBQztRQWFBSTtRQWlGQThCO1FBT0FFO1FBNExBOEQ7O2lCQXFERXJPLE1BQU1VLEdBQUVnQjtzQkFMRUEsS0FBRmhCO1VBS21DLGNBTG5DQSxVQUdIa08sSUFIR2xPLE1BR0UsT0FBQSxpQkFBTGtPLEdBSEtsTjtzQkFBRmhCLE1BRUFtRCxjQUFGZ0w7VUFBUSxPQUFBLGlCQUFSQSxLQUFFaEwsR0FGRW5DO1NBSzhDO1NBQTFDLE9BQUEsaUNBQU5BLEtBQUZoQjtRQUF5RDtpQkFNL0RULFVBSk1lO1NBSWlCO1UsNEJBRmxCNE4sY0FBSyxvQkFBTEE7Z0NBREcvSyxjQUFGZ0w7VUFBUSx3QkFBUkEsS0FBZ0IsV0FEaEI3TixHQUNFNkM7O1NBR2UsT0FBQTtRQUFTO2lCQUVoQzNELFNBQVNjLEdBQUVtQixHQUFJLE9BQUEsa0JBQU5uQixHQUFFbUIsR0FBYTtZQUV4QmhDO2lCQUVBOEUsTUFBTWpFLEdBQUksT0FBQSxrQkFBSkEsR0FBYTtpQkFFbkI0RSxLQUFNN0QsSUFBR2pCLEdBQUUwRjtrQkFFUHNJLEVBQUVDLEtBQUs1SyxHQUFFNks7VUFDWCxHQURTN0s7ZUFFRndLLE1BRkV4SztnQkFBRTZLLEdBT1Q7ZUFIYUMsTUFKSkQ7V0FFVyxPQUFBLFdBSmxCak4sSUFJRzRNLEtBRVFNLHVCQUFBQTs7ZUFKSkQsR0FXVDtjQUhXRSxNQVJGRjtVQVNULG1CQURXRTtTQUdQO1NBRVIsSUFkRWxHLElBY0YsaUJBYkk4RixHQUZLaE8sR0FBRTBGO2tCQWdCVDJJLElBQUVKLEtBQUlqTyxHQUFFWTtVQUNWLFVBRFFaLGdCQUtOLHdCQUxFaU8sTUFBTXJOO21CQUFGWjtlQUVIcUQsSUFGR3JEO1dBR04sd0JBSEVpTywyQkFBQUEsS0FFQzVLLEtBRkt6Qzs7Y0FNTGlOLE1BTkc3TjtVQU9OLDRCQVBFaU8sS0FNQ0osT0FOS2pOO1NBT1k7U0FFZixVQUFBLGtCQVRMeU4sS0FmQW5HO1NBd0JLLE9BQUE7UUFBZ0I7OzRCQXZDdkJoSixPQU1BQyxXQUVBQyxVQUVBQyxPQUVBOEUsT0FFQVc7U0F2ckJOd0I7U0FDQWhIO1NBQ0FRO1NBQ0FxQjtTQUNBcEI7U0FDQVU7U0FDQUM7U0FDQVQ7U0FDQUU7U0FDQUk7U0FDQUk7U0FDQUc7U0FDQWpCO2lCQTBzQkk0SixPQUFPQyxNQUFLeEI7a0JBRVZnRTtVQUFZO2VBS1A0QjtXQUFLLHdCQUFMQTs7Z0NBSkd6SyxjQUFGMEs7VUFDRixPQUFBLFdBSkNyRSxNQUdDcUUsS0FBRTFLO3lDQUFGMEssS0FBRTFLOztTQUlVO2tCQUdsQmlLO1VBQVc7V0FFbUIsSUFBeEIxTixjQUF3QixNQUFBLDRCQVY5QnNNLFdBVU10TTtXQUFLLFdBQU07O2NBRGJzSTtVQUFLLFdBQUksa0JBWFJ3QixNQVdEeEI7U0FDaUQ7U0FHNUI7VUFBQSxNQUFBLFdBenRCL0JySSxPQTBzQmdCcUk7VUFlVlgsSUFBSSx5QkFMSitGO1VBTXNCLE1BQUEsV0E3dEI1Qi9NLE9BNnNCZ0IySDtTQWdCZCxPQUFBLFdBcHVCRnBJLFlBb3VCYSxrQkFoQkY0SixZQWVMbkM7UUFDa0M7O2dCQXR1QnhDakI7Z0JBQ0FoSDtnQkFDQVE7Z0JBQ0FxQjtnQkFDQXBCO2dCQUNBVTtnQkFDQUM7Z0JBQ0FUO2dCQUNBRTtnQkFDQUk7Z0JBQ0FJO2dCQUNBRztnQkFDQWpCO2dCQTBzQkk0Sjs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIFJlYWN0aXZlRGF0YVxuICogaHR0cHM6Ly9naXRodWIuY29tL2hodWdvL3JlYWN0aXZlRGF0YVxuICogQ29weXJpZ2h0IChDKSAyMDE0IEh1Z28gSGV1emFyZFxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5XG4gKiBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnlcbiAqIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGggbGlua2luZyBleGNlcHRpb247XG4gKiBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdCB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gKiBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICogTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZVxuICogR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG4gKlxuICogWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gKiBhbG9uZyB3aXRoIHRoaXMgcHJvZ3JhbTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICogRm91bmRhdGlvbiwgSW5jLiwgNTkgVGVtcGxlIFBsYWNlIC0gU3VpdGUgMzMwLCBCb3N0b24sIE1BIDAyMTExLTEzMDcsIFVTQS5cbiAqKVxuXG5tb2R1bGUgdHlwZSBEQVRBID0gc2lnXG4gIHR5cGUgJ2EgZGF0YVxuICB0eXBlICdhIHBhdGNoXG4gIHZhbCBtZXJnZSA6ICdhIHBhdGNoIC0+ICdhIGRhdGEgLT4gJ2EgZGF0YVxuICB2YWwgbWFwX3BhdGNoIDogKCdhIC0+ICdiKSAtPiAnYSBwYXRjaCAtPiAnYiBwYXRjaFxuICB2YWwgbWFwX2RhdGEgOiAoJ2EgLT4gJ2IpIC0+ICdhIGRhdGEgLT4gJ2IgZGF0YVxuICB2YWwgZW1wdHkgOiAnYSBkYXRhXG4gIHZhbCBlcXVhbCA6ICgnYSAtPiAnYSAtPiBib29sKSAtPiAnYSBkYXRhIC0+ICdhIGRhdGEgLT4gYm9vbFxuICB2YWwgZGlmZiA6IGVxOignYSAtPiAnYSAtPiBib29sKSAtPiAnYSBkYXRhIC0+ICdhIGRhdGEgLT4gJ2EgcGF0Y2hcbmVuZFxubW9kdWxlIHR5cGUgUyA9IHNpZ1xuICB0eXBlICdhIHRcbiAgdHlwZSAnYSBkYXRhXG4gIHR5cGUgJ2EgcGF0Y2hcbiAgdHlwZSAnYSBtc2cgPSBQYXRjaCBvZiAnYSBwYXRjaCB8IFNldCBvZiAnYSBkYXRhXG4gIHR5cGUgJ2EgaGFuZGxlXG4gIHZhbCBlbXB0eSA6ICdhIHRcbiAgdmFsIGNyZWF0ZSA6ICdhIGRhdGEgLT4gJ2EgdCAqICdhIGhhbmRsZVxuICB2YWwgZnJvbV9ldmVudCA6ICdhIGRhdGEgLT4gJ2EgbXNnIFJlYWN0LkUudCAtPiAnYSB0XG4gIHZhbCBmcm9tX3NpZ25hbCA6ID9lcTooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgZGF0YSBSZWFjdC5TLnQgLT4gJ2EgdFxuICB2YWwgY29uc3QgOiAnYSBkYXRhIC0+ICdhIHRcbiAgdmFsIHBhdGNoIDogJ2EgaGFuZGxlIC0+ICdhIHBhdGNoIC0+IHVuaXRcbiAgdmFsIHNldCAgIDogJ2EgaGFuZGxlIC0+ICdhIGRhdGEgLT4gdW5pdFxuICB2YWwgbWFwX21zZyA6ICgnYSAtPiAnYikgLT4gJ2EgbXNnIC0+ICdiIG1zZ1xuICB2YWwgbWFwIDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgdmFsIHZhbHVlIDogJ2EgdCAtPiAnYSBkYXRhXG4gIHZhbCBmb2xkIDogKCdhIC0+ICdiIG1zZyAtPiAnYSkgLT4gJ2IgdCAtPiAnYSAtPiAnYSBSZWFjdC5zaWduYWxcbiAgdmFsIHNpZ25hbCA6ID9lcTooJ2EgLT4gJ2EgLT4gYm9vbCkgLT4gJ2EgdCAtPiAnYSBkYXRhIFJlYWN0LlMudFxuICB2YWwgZXZlbnQgOiAnYSB0IC0+ICdhIG1zZyBSZWFjdC5FLnRcbmVuZFxuXG5tb2R1bGUgTWFrZShEIDogREFUQSkgOlxuICBTIHdpdGggdHlwZSAnYSBkYXRhID0gJ2EgRC5kYXRhXG4gICAgIGFuZCB0eXBlICdhIHBhdGNoID0gJ2EgRC5wYXRjaCA9IHN0cnVjdFxuXG4gIHR5cGUgJ2EgZGF0YSA9ICdhIEQuZGF0YVxuICB0eXBlICdhIHBhdGNoID0gJ2EgRC5wYXRjaFxuICBsZXQgbWVyZ2UgPSBELm1lcmdlXG4gIGxldCBtYXBfcGF0Y2ggPSBELm1hcF9wYXRjaFxuICBsZXQgbWFwX2RhdGEgPSBELm1hcF9kYXRhXG5cbiAgdHlwZSAnYSBtc2cgPVxuICAgIHwgUGF0Y2ggb2YgJ2EgcGF0Y2hcbiAgICB8IFNldCBvZiAnYSBkYXRhXG5cbiAgdHlwZSAnYSBoYW5kbGUgPSA/c3RlcDpSZWFjdC5zdGVwIC0+ICdhIG1zZyAtPiB1bml0XG5cbiAgdHlwZSAnYSBtdXQgPSB7XG4gICAgY3VycmVudCA6ICdhIGRhdGEgcmVmO1xuICAgIGV2ZW50IDogJ2EgbXNnIFJlYWN0LkUudDtcbiAgfVxuXG4gIHR5cGUgJ2EgdCA9XG4gICAgfCBDb25zdCBvZiAnYSBkYXRhXG4gICAgfCBNdXQgb2YgJ2EgbXV0XG5cbiAgbGV0IGVtcHR5ID0gQ29uc3QgRC5lbXB0eVxuXG4gIGxldCBjcmVhdGUgbCA9XG4gICAgbGV0IGluaXRpYWxfZXZlbnQsc2VuZCA9IFJlYWN0LkUuY3JlYXRlICgpIGluXG4gICAgbGV0IGN1cnJlbnQgPSByZWYgbCBpblxuICAgIGxldCBldmVudCA9IFJlYWN0LkUubWFwIChmdW4gbXNnIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIG1zZyB3aXRoXG4gICAgICAgICAgfCBTZXQgbCAtPiBjdXJyZW50IDo9IGw7XG4gICAgICAgICAgfCBQYXRjaCBwIC0+IGN1cnJlbnQgOj0gbWVyZ2UgcCAhY3VycmVudFxuICAgICAgICBlbmQ7XG4gICAgICAgIG1zZykgaW5pdGlhbF9ldmVudCBpblxuICAgIE11dCB7Y3VycmVudDtldmVudH0sc2VuZFxuXG4gIGxldCBmcm9tX2V2ZW50IGwgaW5pdGlhbF9ldmVudCA9XG4gICAgbGV0IGN1cnJlbnQgPSByZWYgbCBpblxuICAgIGxldCBldmVudCA9IFJlYWN0LkUubWFwIChmdW4gbXNnIC0+XG4gICAgICAgIGJlZ2luIG1hdGNoIG1zZyB3aXRoXG4gICAgICAgICAgfCBTZXQgbCAtPiBjdXJyZW50IDo9IGw7XG4gICAgICAgICAgfCBQYXRjaCBwIC0+IGN1cnJlbnQgOj0gbWVyZ2UgcCAhY3VycmVudFxuICAgICAgICBlbmQ7XG4gICAgICAgIG1zZykgaW5pdGlhbF9ldmVudCBpblxuICAgIE11dCB7Y3VycmVudDtldmVudH1cblxuICBsZXQgY29uc3QgeCA9IENvbnN0IHhcblxuICBsZXQgbWFwX21zZyAoZiA6ICdhIC0+ICdiKSA6ICdhIG1zZyAtPiAnYiBtc2cgPSBmdW5jdGlvblxuICAgIHwgU2V0IGwgLT4gU2V0IChtYXBfZGF0YSBmIGwpXG4gICAgfCBQYXRjaCBwIC0+IFBhdGNoIChtYXBfcGF0Y2ggZiBwKVxuXG4gIGxldCBtYXAgZiBzID1cbiAgICBtYXRjaCBzIHdpdGhcbiAgICB8IENvbnN0IHggLT4gQ29uc3QgKG1hcF9kYXRhIGYgeClcbiAgICB8IE11dCBzIC0+XG4gICAgICBsZXQgY3VycmVudCA9IHJlZiAobWFwX2RhdGEgZiAhKHMuY3VycmVudCkpIGluXG4gICAgICBsZXQgZXZlbnQgPSBSZWFjdC5FLm1hcCAoZnVuIG1zZyAtPlxuICAgICAgICAgIGxldCBtc2cgPSBtYXBfbXNnIGYgbXNnIGluXG4gICAgICAgICAgYmVnaW4gbWF0Y2ggbXNnIHdpdGhcbiAgICAgICAgICAgIHwgU2V0IGwgLT4gY3VycmVudCA6PSBsO1xuICAgICAgICAgICAgfCBQYXRjaCBwIC0+IGN1cnJlbnQgOj0gbWVyZ2UgcCAhY3VycmVudFxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBtc2cpIHMuZXZlbnQgaW5cbiAgICAgIE11dCB7Y3VycmVudCA7ZXZlbnR9XG5cbiAgbGV0IHZhbHVlIHMgPSBtYXRjaCBzIHdpdGhcbiAgICB8IENvbnN0IGMgLT4gY1xuICAgIHwgTXV0IHMgLT4gIShzLmN1cnJlbnQpXG5cbiAgbGV0IGV2ZW50IHMgPSBtYXRjaCBzIHdpdGhcbiAgICB8IENvbnN0IF8gLT4gUmVhY3QuRS5uZXZlclxuICAgIHwgTXV0IHMgLT4gcy5ldmVudFxuXG4gIGxldCBwYXRjaCAocyA6ICdhIGhhbmRsZSkgcCA9IHMgKFBhdGNoIHApXG5cbiAgbGV0IHNldCAocyA6ICdhIGhhbmRsZSkgcCA9IHMgKFNldCBwKVxuXG4gIGxldCBmb2xkIGYgcyBhY2MgPVxuICAgIG1hdGNoIHMgd2l0aFxuICAgIHwgQ29uc3QgYyAtPiBSZWFjdC5TLmNvbnN0IChmIGFjYyAoU2V0IGMpKVxuICAgIHwgTXV0IHMgLT5cbiAgICAgIGxldCBhY2MgPSBmIGFjYyAoU2V0ICghKHMuY3VycmVudCkpKSBpblxuICAgICAgUmVhY3QuUy5mb2xkIGYgYWNjIHMuZXZlbnRcblxuICBsZXQgc2lnbmFsID8oZXEgPSAoPSkpIChzIDogJ2EgdCkgOiAnYSBkYXRhIFJlYWN0LlMudCA9XG4gICAgbWF0Y2ggcyB3aXRoXG4gICAgfCBDb25zdCBjIC0+IFJlYWN0LlMuY29uc3QgY1xuICAgIHwgTXV0IHMgLT5cbiAgICAgIFJlYWN0LlMuZm9sZCB+ZXE6KEQuZXF1YWwgZXEpIChmdW4gbCBtc2cgLT5cbiAgICAgICAgICBtYXRjaCBtc2cgd2l0aFxuICAgICAgICAgIHwgU2V0IGwgLT4gbFxuICAgICAgICAgIHwgUGF0Y2ggcCAtPiBtZXJnZSBwIGwpICghKHMuY3VycmVudCkpIHMuZXZlbnRcblxuICBsZXQgZnJvbV9zaWduYWwgPyhlcSA9ICg9KSkgcyA9XG4gICAgbGV0IGYgZCcgZCA9IFBhdGNoIChELmRpZmYgfmVxIGQgZCcpIGluXG4gICAgZnJvbV9ldmVudCAoUmVhY3QuUy52YWx1ZSBzKSAoUmVhY3QuUy5kaWZmIGYgcylcblxuZW5kXG5cbm1vZHVsZSBEYXRhTGlzdCA9IHN0cnVjdFxuICB0eXBlICdhIGRhdGEgPSAnYSBsaXN0XG4gIHR5cGUgJ2EgcCA9XG4gICAgfCBJIG9mIGludCAqICdhXG4gICAgfCBSIG9mIGludFxuICAgIHwgVSBvZiBpbnQgKiAnYVxuICAgIHwgWCBvZiBpbnQgKiBpbnRcbiAgdHlwZSAnYSBwYXRjaCA9ICdhIHAgbGlzdFxuICBsZXQgZW1wdHkgPSBbXVxuICBsZXQgbWFwX2RhdGEgPSBMaXN0Lm1hcFxuICBsZXQgbWFwX3BhdGNoIGYgPSBmdW5jdGlvblxuICAgIHwgSSAoaSx4KSAtPiBJIChpLCBmIHgpXG4gICAgfCBSIGkgLT4gUiBpXG4gICAgfCBYIChpLGopIC0+IFggKGksailcbiAgICB8IFUgKGkseCkgLT4gVSAoaSxmIHgpXG4gIGxldCBtYXBfcGF0Y2ggZiA9IExpc3QubWFwIChtYXBfcGF0Y2ggZilcblxuICBsZXQgbWVyZ2VfcCBvcCBsID1cbiAgICBtYXRjaCBvcCB3aXRoXG4gICAgfCBJIChpJyx4KSAtPlxuICAgICAgbGV0IGkgPSBpZiBpJyA8IDAgdGhlbiBMaXN0Lmxlbmd0aCBsICsgMSArIGknIGVsc2UgaScgaW5cbiAgICAgIGxldCByZWMgYXV4IGFjYyBuIGwgPSBtYXRjaCBuLGwgd2l0aFxuICAgICAgICB8IDAsbCAtPiBMaXN0LnJldl9hcHBlbmQgYWNjICh4OjpsKVxuICAgICAgICB8IF8sW10gLT4gZmFpbHdpdGggXCJSZWFjdGl2ZURhdGEuUmxpc3QubWVyZ2VcIlxuICAgICAgICB8IG4seDo6eHMgLT4gYXV4ICh4OjphY2MpIChwcmVkIG4pIHhzXG4gICAgICBpbiBhdXggW10gaSBsXG4gICAgfCBSIGknIC0+XG4gICAgICBsZXQgaSA9IGlmIGknIDwgMCB0aGVuIExpc3QubGVuZ3RoIGwgKyBpJyBlbHNlIGknIGluXG4gICAgICBsZXQgcmVjIGF1eCBhY2MgbiBsID0gbWF0Y2ggbixsIHdpdGhcbiAgICAgICAgfCAwLF86OmwgLT4gTGlzdC5yZXZfYXBwZW5kIGFjYyBsXG4gICAgICAgIHwgXyxbXSAtPiBmYWlsd2l0aCBcIlJlYWN0aXZlRGF0YS5SbGlzdC5tZXJnZVwiXG4gICAgICAgIHwgbix4Ojp4cyAtPiBhdXggKHg6OmFjYykgKHByZWQgbikgeHNcbiAgICAgIGluIGF1eCBbXSBpIGxcbiAgICB8IFUgKGknLHgpIC0+XG4gICAgICBsZXQgaSA9IGlmIGknIDwgMCB0aGVuIExpc3QubGVuZ3RoIGwgKyBpJyBlbHNlIGknIGluXG4gICAgICBsZXQgYSA9IEFycmF5Lm9mX2xpc3QgbCBpblxuICAgICAgYS4oaSkgPC0geDtcbiAgICAgIEFycmF5LnRvX2xpc3QgYVxuICAgIHwgWCAoaScsb2Zmc2V0KSAtPlxuICAgICAgbGV0IGEgPSBBcnJheS5vZl9saXN0IGwgaW5cbiAgICAgIGxldCBsZW4gPSBBcnJheS5sZW5ndGggYSBpblxuICAgICAgbGV0IGkgPSBpZiBpJyA8IDAgdGhlbiBsZW4gKyBpJyBlbHNlIGknIGluXG4gICAgICBsZXQgdiA9IGEuKGkpIGluXG4gICAgICBpZiBvZmZzZXQgPiAwXG4gICAgICB0aGVuIGJlZ2luXG4gICAgICAgIGlmIChpICsgb2Zmc2V0ID49IGxlbikgdGhlbiBmYWlsd2l0aCBcIlJlYWN0aXZlRGF0YS5SbGlzdC5tZXJnZVwiO1xuICAgICAgICBmb3IgaiA9IGkgdG8gaSArIG9mZnNldCAtIDEgZG9cbiAgICAgICAgICBhLihqKSA8LSBhLihqICsgMSlcbiAgICAgICAgZG9uZTtcbiAgICAgICAgYS4oaStvZmZzZXQpIDwtIHZcbiAgICAgIGVuZFxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBpZiAoaSArIG9mZnNldCA8IDApIHRoZW4gZmFpbHdpdGggXCJSZWFjdGl2ZURhdGEuUmxpc3QubWVyZ2VcIjtcbiAgICAgICAgZm9yIGogPSBpIGRvd250byBpICsgb2Zmc2V0ICsgMSBkb1xuICAgICAgICAgIGEuKGopIDwtIGEuKGogLSAxKVxuICAgICAgICBkb25lO1xuICAgICAgICBhLihpK29mZnNldCkgPC0gdlxuICAgICAgZW5kO1xuICAgICAgQXJyYXkudG9fbGlzdCBhXG5cbiAgKCogYWNjdW11bGF0ZXMgaW50byBhY2MgaSB1bm1vZGlmaWVkIGVsZW1lbnRzIGZyb20gbCAqKVxuICBsZXQgcmVjIGxpbmVhcl9tZXJnZV9md2QgfmFjYyBpIGwgPVxuICAgIGFzc2VydCAoaSA+PSAwKTtcbiAgICBpZiBpID4gMCB0aGVuXG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgaCA6OiBsIC0+XG4gICAgICAgIGxldCBhY2MgPSBoIDo6IGFjYyBpblxuICAgICAgICBsaW5lYXJfbWVyZ2VfZndkIH5hY2MgKGkgLSAxKSBsXG4gICAgICB8IFtdIC0+XG4gICAgICAgIGludmFsaWRfYXJnIFwiaW52YWxpZCBpbmRleFwiXG4gICAgZWxzZVxuICAgICAgbCwgYWNjXG5cbiAgbGV0IHJlYyBsaW5lYXJfbWVyZ2UgfmFjYyBpMCBwIGwgPVxuICAgIGxldCBsLCBhY2MgPVxuICAgICAgbWF0Y2ggcCB3aXRoXG4gICAgICB8IChJIChpLCBfKSB8IFIgaSB8IFUgKGksIF8pKSA6OiBfIHdoZW4gaSA+IGkwIC0+XG4gICAgICAgIGxpbmVhcl9tZXJnZV9md2QgfmFjYyAoaSAtIGkwKSBsXG4gICAgICB8IF8gLT5cbiAgICAgICAgbCwgYWNjXG4gICAgaW5cbiAgICBtYXRjaCBwLCBsIHdpdGhcbiAgICB8IEkgKGksIHgpIDo6IHAsIF8gLT5cbiAgICAgIGxpbmVhcl9tZXJnZSB+YWNjIGkgcCAoeCA6OiBsKVxuICAgIHwgUiBpIDo6IHAsIF8gOjogbCAtPlxuICAgICAgbGluZWFyX21lcmdlIH5hY2MgaSBwIGxcbiAgICB8IFIgXyA6OiBfLCBbXSAtPlxuICAgICAgaW52YWxpZF9hcmcgXCJtZXJnZTogaW52YWxpZCBpbmRleFwiXG4gICAgfCBVIChpLCB4KSA6OiBwLCBfIDo6IGwgLT5cbiAgICAgIGxpbmVhcl9tZXJnZSB+YWNjIGkgcCAoeCA6OiBsKVxuICAgIHwgVSAoXywgXykgOjogXywgW10gLT5cbiAgICAgIGludmFsaWRfYXJnIFwibWVyZ2U6IGludmFsaWQgaW5kZXhcIlxuICAgIHwgW10sIGwgLT5cbiAgICAgIExpc3QucmV2X2FwcGVuZCBhY2MgbFxuICAgIHwgWCAoXywgXykgOjogXywgXyAtPlxuICAgICAgZmFpbHdpdGggXCJsaW5lYXJfbWVyZ2U6IFggbm90IHN1cHBvcnRlZFwiXG5cbiAgbGV0IHJlYyBsaW5lYXJfbWVyZ2VhYmxlIH5uIHAgPVxuICAgIGFzc2VydCAobiA+PSAwKTtcbiAgICBtYXRjaCBwIHdpdGhcbiAgICB8IChJIChpLCBfKSB8IFIgaSB8IFUgKGksIF8pKSA6OiBwIHdoZW4gaSA+PSBuIC0+XG4gICAgICAoKiBuZWdhdGl2ZSBpJ3MgcnVsZWQgb3V0IChhbW9uZyBvdGhlcnMpICopXG4gICAgICBsaW5lYXJfbWVyZ2VhYmxlIH5uOmkgcFxuICAgIHwgXyA6OiBfIC0+XG4gICAgICBmYWxzZVxuICAgIHwgW10gLT5cbiAgICAgIHRydWVcblxuICBsZXQgbWVyZ2UgcCBsID1cbiAgICBpZiBsaW5lYXJfbWVyZ2VhYmxlIH5uOjAgcCB0aGVuXG4gICAgICBsaW5lYXJfbWVyZ2UgfmFjYzpbXSAwIHAgbFxuICAgIGVsc2VcbiAgICAgIExpc3QuZm9sZF9sZWZ0IChmdW4gbCB4IC0+IG1lcmdlX3AgeCBsKSBsIHBcblxuICBsZXQgcmVjIGVxdWFsIGYgbDEgbDIgPVxuICAgIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCB4MSA6OiBsMSwgeDIgOjogbDIgd2hlbiBmIHgxIHgyIC0+XG4gICAgICBlcXVhbCBmIGwxIGwyXG4gICAgfCBbXSwgW10gLT5cbiAgICAgIHRydWVcbiAgICB8IF8gOjogXyAsIF8gOjogX1xuICAgIHwgXyA6OiBfICwgW11cbiAgICB8IFtdICAgICAsIF8gOjogXyAtPlxuICAgICAgZmFsc2VcblxuICBsZXQgbWVtICh0eXBlIHUpIGwgPVxuICAgIGxldCBtb2R1bGUgSCA9XG4gICAgICBIYXNodGJsLk1ha2VcbiAgICAgICAgKHN0cnVjdCB0eXBlIHQgPSB1IGxldCBoYXNoID0gSGFzaHRibC5oYXNoIGxldCBlcXVhbCA9ICg9PSkgZW5kKSBpblxuICAgIGxldCBoID0gSC5jcmVhdGUgMTYgaW5cbiAgICBMaXN0Lml0ZXIgKGZ1biB4IC0+IEguYWRkIGggeCAoKSkgbDtcbiAgICBILm1lbSBoXG5cbiAgbGV0IGZvbGRfZGlmZiA/KGVxID0gKD0pKSB+YWNjIH5yZW1vdmUgfmFkZCBseCBseSA9XG4gICAgbGV0IG1lbXggPSBtZW0gbHhcbiAgICBhbmQgbWVteSA9IG1lbSBseSBpblxuICAgIGxldCByZWMgZiB+YWNjIH5sZWZ0IGx4IGx5IG4gPVxuICAgICAgbWF0Y2ggbHgsIGx5IHdpdGhcbiAgICAgICgqIHRyYWlsaW5nIGVsZW1lbnRzIHRvIGJlIHJlbW92ZWQgKilcbiAgICAgIHwgXyA6OiBseCwgW10gLT5cbiAgICAgICAgbGV0IGFjYyA9IHJlbW92ZSBhY2MgbiBpblxuICAgICAgICBmIH5hY2MgfmxlZnQgbHggW10gblxuICAgICAgKCogdHJhaWxpbmcgZWxlbWVudHMgdG8gYmUgYWRkZWQgKilcbiAgICAgIHwgW10sIHkgOjogbHkgLT5cbiAgICAgICAgbGV0IGFjYyA9IGFkZCBhY2MgbiB5IGluXG4gICAgICAgIGYgfmFjYyB+bGVmdCBbXSBseSAobiArIDEpXG4gICAgICAoKiBkb25lISAqKVxuICAgICAgfCBbXSwgW10gLT5cbiAgICAgICAgYWNjXG4gICAgICAoKiBzYW1lICopXG4gICAgICB8IHggOjogbHgsIHkgOjogbHkgd2hlbiBlcSB4IHkgLT5cbiAgICAgICAgZiB+YWNjIH5sZWZ0IGx4IGx5IChuICsgMSlcbiAgICAgICgqIHggbmVlZHMgdG8gYmUgcmVtb3ZlZCBmb3Igc3VyZSAqKVxuICAgICAgfCB4IDo6IGx4LCBfIDo6IF8gd2hlbiBub3QgKG1lbXkgeCkgLT5cbiAgICAgICAgbGV0IGFjYyA9IHJlbW92ZSBhY2MgbiBpblxuICAgICAgICBmIH5hY2MgfmxlZnQgbHggbHkgblxuICAgICAgKCogeSBuZWVkcyB0byBiZSBhZGRlZCBmb3Igc3VyZSAqKVxuICAgICAgfCBfIDo6IF8sIHkgOjogbHkgd2hlbiBub3QgKG1lbXggeSkgLT5cbiAgICAgICAgbGV0IGFjYyA9IGFkZCBhY2MgbiB5IGluXG4gICAgICAgIGYgfmFjYyB+bGVmdCBseCBseSAobiArIDEpXG4gICAgICAoKiBubyBtb3JlIGNlcnRhaW50eSwgfmxlZnQgZGVjaWRlcyB3aGF0IHRvIHJlY3VyIG9uICopXG4gICAgICB8IF8gOjogbHgsIF8gOjogXyB3aGVuIGxlZnQgLT5cbiAgICAgICAgbGV0IGFjYyA9IHJlbW92ZSBhY2MgbiBpblxuICAgICAgICBmIH5hY2MgfmxlZnQ6ZmFsc2UgbHggbHkgblxuICAgICAgfCBfIDo6IF8sIHkgOjogbHkgLT5cbiAgICAgICAgbGV0IGFjYyA9IGFkZCBhY2MgbiB5IGluXG4gICAgICAgIGYgfmFjYyB+bGVmdDp0cnVlIGx4IGx5IChuICsgMSlcbiAgICBpblxuICAgIGYgfmFjYyB+bGVmdDp0cnVlIGx4IGx5IDBcblxuICBsZXQgcmVjIGxpc3RfcmV2ID8oYWNjID0gW10pID0gZnVuY3Rpb25cbiAgICB8IGggOjogdCAtPlxuICAgICAgbGV0IGFjYyA9IGggOjogYWNjIGluXG4gICAgICBsaXN0X3JldiB+YWNjIHRcbiAgICB8IFtdIC0+XG4gICAgICBhY2NcblxuICBsZXQgZGlmZiB+ZXEgeCB5ID1cbiAgICBsZXQgYWRkIGFjYyBpIHYgPSBJIChpLCB2KSA6OiBhY2NcbiAgICBhbmQgcmVtb3ZlIGFjYyBpID0gUiBpIDo6IGFjY1xuICAgIGFuZCBhY2MgPSBbXSBpblxuICAgIGxpc3RfcmV2IChmb2xkX2RpZmYgfmVxIH5hY2MgfmFkZCB+cmVtb3ZlIHggeSlcblxuZW5kXG5cbm1vZHVsZSBSTGlzdCA9IHN0cnVjdFxuICBpbmNsdWRlIE1ha2UgKERhdGFMaXN0KVxuICBtb2R1bGUgRCA9IERhdGFMaXN0XG4gIHR5cGUgJ2EgcCA9ICdhIEQucCA9XG4gICAgfCBJIG9mIGludCAqICdhXG4gICAgfCBSIG9mIGludFxuICAgIHwgVSBvZiBpbnQgKiAnYVxuICAgIHwgWCBvZiBpbnQgKiBpbnRcblxuICBsZXQgY29ucyB4IHMgPSBwYXRjaCBzIFtELkkgKDAseCldXG4gIGxldCBzbm9jIHggcyA9IHBhdGNoIHMgW0QuSSAoLTEseCldXG4gIGxldCBpbnNlcnQgeCBpIHMgPSBwYXRjaCBzIFtELkkgKGkseCldXG4gIGxldCB1cGRhdGUgeCBpIHMgPSBwYXRjaCBzIFtELlUgKGkseCldXG4gIGxldCBtb3ZlIGkgaiBzID0gcGF0Y2ggcyBbRC5YIChpLGopXVxuICBsZXQgcmVtb3ZlIGkgcyA9IHBhdGNoIHMgW0QuUiBpXVxuXG4gIGxldCBpbmRleCA/KGVxID0gKD0pKSBsIHggPVxuICAgIGxldCByZWMgZiBuID0gZnVuY3Rpb25cbiAgICAgIHwgaGQgOjogXyB3aGVuIGVxIGhkIHggLT4gblxuICAgICAgfCBfIDo6IHRsIC0+IGYgKG4gKyAxKSB0bFxuICAgICAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICBpblxuICAgIGYgMCBsXG5cbiAgbGV0IHVwZGF0ZV9lcSA/ZXEgKGRhdGEsIGhhbmRsZSkgeCB5ID1cbiAgICBsZXQgaSA9IGluZGV4ID9lcSAodmFsdWUgZGF0YSkgeCBpblxuICAgIHVwZGF0ZSB5IGkgaGFuZGxlXG5cbiAgbGV0IHJlbW92ZV9sYXN0IChkYXRhLCBoYW5kbGUpID1cbiAgICByZW1vdmUgKExpc3QubGVuZ3RoICh2YWx1ZSBkYXRhKSAtIDEpIGhhbmRsZVxuXG4gIGxldCByZW1vdmVfZXEgP2VxIChkYXRhLCBoYW5kbGUpIHggPVxuICAgIGxldCBpID0gaW5kZXggP2VxICh2YWx1ZSBkYXRhKSB4IGluXG4gICAgcmVtb3ZlIGkgaGFuZGxlXG5cbiAgbGV0IHNpbmdsZXRvbiB4ID0gY29uc3QgW3hdXG5cbiAgbGV0IHNpbmdsZXRvbl9zIHMgPVxuICAgIGxldCBmaXJzdCA9IHJlZiB0cnVlIGluXG4gICAgbGV0IGUsc2VuZCA9IFJlYWN0LkUuY3JlYXRlICgpIGluXG4gICAgbGV0IHJlc3VsdCA9IGZyb21fZXZlbnQgW10gZSBpblxuICAgIGxldCBfID0gUmVhY3QuUy5tYXAgKGZ1biB4IC0+XG4gICAgICAgIGlmICFmaXJzdFxuICAgICAgICB0aGVuIGJlZ2luXG4gICAgICAgICAgZmlyc3Q6PWZhbHNlO1xuICAgICAgICAgIHNlbmQgKFBhdGNoIFtJKDAseCldKVxuICAgICAgICBlbmRcbiAgICAgICAgZWxzZSBzZW5kIChQYXRjaCBbVSgwLHgpXSkpIHMgaW5cbiAgICByZXN1bHRcblxuICBsZXQgY29uY2F0IDogJ2EgdCAtPiAnYSB0IC0+ICdhIHQgPSBmdW4geCB5IC0+XG4gICAgbGV0IHYxID0gdmFsdWUgeFxuICAgIGFuZCB2MiA9IHZhbHVlIHkgaW5cbiAgICBsZXQgc2l6ZTEgPSByZWYgMFxuICAgIGFuZCBzaXplMiA9IHJlZiAwIGluXG4gICAgbGV0IHNpemVfd2l0aF9wYXRjaCBzaXpleCA6ICdhIEQucCAtPiB1bml0ID0gZnVuY3Rpb25cbiAgICAgIHwgKEQuSSBfKSAtPiBpbmNyIHNpemV4XG4gICAgICB8IChELlIgXykgLT4gZGVjciBzaXpleFxuICAgICAgfCAoRC5YIF8gfCBELlUgXykgLT4gKCkgaW5cbiAgICBsZXQgc2l6ZV93aXRoX3NldCBzaXpleCBsID0gc2l6ZXg6PUxpc3QubGVuZ3RoIGwgaW5cblxuICAgIHNpemVfd2l0aF9zZXQgc2l6ZTEgdjE7XG4gICAgc2l6ZV93aXRoX3NldCBzaXplMiB2MjtcblxuICAgIGxldCB1cGRhdGVfcGF0Y2gxID0gTGlzdC5tYXAgKGZ1biBwIC0+XG4gICAgICAgIGxldCBtID0gbWF0Y2ggcCB3aXRoXG4gICAgICAgICAgfCBELkkgKHBvcyx4KSAtPlxuICAgICAgICAgICAgbGV0IGkgPSBpZiBwb3MgPCAwIHRoZW4gcG9zIC0gIXNpemUyIGVsc2UgcG9zIGluXG4gICAgICAgICAgICBELkkgKGksIHgpXG4gICAgICAgICAgfCBELlIgcG9zICAgICAtPiBELlIgIChpZiBwb3MgPCAwIHRoZW4gcG9zIC0gIXNpemUyIGVsc2UgcG9zKVxuICAgICAgICAgIHwgRC5VIChwb3MseCkgLT4gRC5VICgoaWYgcG9zIDwgMCB0aGVuIHBvcyAtICFzaXplMiBlbHNlIHBvcyksIHgpXG4gICAgICAgICAgfCBELlggKGksaikgLT4gICBELlggKChpZiBpIDwgMCB0aGVuIGkgLSAhc2l6ZTIgZWxzZSBpKSxqKVxuICAgICAgICBpblxuICAgICAgICBzaXplX3dpdGhfcGF0Y2ggc2l6ZTEgbTtcbiAgICAgICAgbSkgaW5cbiAgICBsZXQgdXBkYXRlX3BhdGNoMiA9IExpc3QubWFwIChmdW4gcCAtPlxuICAgICAgICBsZXQgbSA9IG1hdGNoIHAgd2l0aFxuICAgICAgICAgIHwgRC5JIChwb3MseCkgLT4gRC5JICgoaWYgcG9zIDwgMCB0aGVuIHBvcyBlbHNlICFzaXplMSArIHBvcyksIHgpXG4gICAgICAgICAgfCBELlIgcG9zICAgICAtPiBELlIgIChpZiBwb3MgPCAwIHRoZW4gcG9zIGVsc2UgIXNpemUxICsgcG9zKVxuICAgICAgICAgIHwgRC5VIChwb3MseCkgLT4gRC5VICgoaWYgcG9zIDwgMCB0aGVuIHBvcyBlbHNlICFzaXplMSArIHBvcyksIHgpXG4gICAgICAgICAgfCBELlggKGksaikgLT4gICBELlggKChpZiBpIDwgMCB0aGVuIGkgZWxzZSAhc2l6ZTEgKyBpKSxqKVxuICAgICAgICBpblxuICAgICAgICBzaXplX3dpdGhfcGF0Y2ggc2l6ZTIgbTtcbiAgICAgICAgbSkgaW5cbiAgICBsZXQgdHVwbGVfZXYgPVxuICAgICAgUmVhY3QuRS5tZXJnZSAoZnVuIGFjYyB4IC0+XG4gICAgICAgICAgbWF0Y2ggYWNjLHggd2l0aFxuICAgICAgICAgIHwgKE5vbmUscDIpLGBFMSB4IC0+IFNvbWUgeCxwMlxuICAgICAgICAgIHwgKHAxLE5vbmUpLGBFMiB4IC0+IHAxLCBTb21lIHhcbiAgICAgICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuICAgICAgICAoTm9uZSxOb25lKVxuICAgICAgICBbUmVhY3QuRS5tYXAgKGZ1biBlIC0+IGBFMSBlKSAoZXZlbnQgeCk7XG4gICAgICAgICBSZWFjdC5FLm1hcCAoZnVuIGUgLT4gYEUyIGUpIChldmVudCB5KV0gaW5cbiAgICBsZXQgbWVyZ2VkX2V2ID0gUmVhY3QuRS5tYXAgKGZ1biBwIC0+XG4gICAgICAgIG1hdGNoIHAgd2l0aFxuICAgICAgICB8IFNvbWUgKFNldCBwMSksIFNvbWUgKFNldCBwMikgLT5cbiAgICAgICAgICBzaXplX3dpdGhfc2V0IHNpemUxIHAxO1xuICAgICAgICAgIHNpemVfd2l0aF9zZXQgc2l6ZTIgcDI7XG4gICAgICAgICAgU2V0IChwMSBAIHAyKVxuICAgICAgICB8IFNvbWUgKFNldCBwMSksIE5vbmUgLT5cbiAgICAgICAgICBzaXplX3dpdGhfc2V0IHNpemUxIHAxO1xuICAgICAgICAgIFNldCAocDEgQCB2YWx1ZSB5KVxuICAgICAgICB8IE5vbmUsIFNvbWUgKFNldCBwMikgLT5cbiAgICAgICAgICBzaXplX3dpdGhfc2V0IHNpemUyIHAyO1xuICAgICAgICAgIFNldCAodmFsdWUgeCBAIHAyIClcbiAgICAgICAgfCBTb21lIChQYXRjaCBwMSksIFNvbWUgKFBhdGNoIHAyKSAtPlxuICAgICAgICAgIGxldCBwMSA9IHVwZGF0ZV9wYXRjaDEgcDEgaW5cbiAgICAgICAgICBsZXQgcDIgPSB1cGRhdGVfcGF0Y2gyIHAyIGluXG4gICAgICAgICAgUGF0Y2ggKHAxIEAgcDIpXG4gICAgICAgIHwgU29tZSAoUGF0Y2ggcDEpLCBOb25lIC0+IFBhdGNoICh1cGRhdGVfcGF0Y2gxIHAxKVxuICAgICAgICB8IE5vbmUsIFNvbWUgKFBhdGNoIHAyKSAtPiBQYXRjaCAodXBkYXRlX3BhdGNoMiBwMilcbiAgICAgICAgfCBTb21lIChQYXRjaCBfKSwgU29tZSAoU2V0IHMyKSAtPlxuICAgICAgICAgIGxldCBzMSA9IHZhbHVlIHggaW5cbiAgICAgICAgICBzaXplX3dpdGhfc2V0IHNpemUxIHMxO1xuICAgICAgICAgIHNpemVfd2l0aF9zZXQgc2l6ZTIgczI7XG4gICAgICAgICAgU2V0KHMxIEAgczIpXG4gICAgICAgIHwgU29tZSAoU2V0IHMxKSwgU29tZSAoUGF0Y2ggXykgLT5cbiAgICAgICAgICBzaXplX3dpdGhfc2V0IHNpemUxIHMxO1xuICAgICAgICAgIGxldCBzMiA9IHZhbHVlIHkgaW5cbiAgICAgICAgICBzaXplX3dpdGhfc2V0IHNpemUyIHMyO1xuICAgICAgICAgIFNldChzMSBAIHMyKVxuICAgICAgICB8IE5vbmUsTm9uZSAtPiBhc3NlcnQgZmFsc2VcbiAgICAgICkgdHVwbGVfZXYgaW5cbiAgICBmcm9tX2V2ZW50ICh2MSBAIHYyKSBtZXJnZWRfZXZcblxuICBsZXQgaW52ZXJzZSA6ICdhIC4gJ2EgcCAtPiAnYSBwID0gZnVuY3Rpb25cbiAgICB8IEkgKGkseCkgLT4gSSgtaS0xLCB4KVxuICAgIHwgVSAoaSx4KSAtPiBVKC1pLTEsIHgpXG4gICAgfCBSIGkgLT4gUiAoLWktMSlcbiAgICB8IFggKGksaikgLT4gWCAoLWktMSwtailcblxuICBsZXQgcmV2IHQgPVxuICAgIGxldCBlID0gUmVhY3QuRS5tYXAgKGZ1bmN0aW9uXG4gICAgICAgIHwgU2V0IGwgLT4gU2V0IChMaXN0LnJldiBsKVxuICAgICAgICB8IFBhdGNoIHAgLT4gUGF0Y2ggKExpc3QubWFwIGludmVyc2UgcCkpICAoZXZlbnQgdClcbiAgICBpblxuICAgIGZyb21fZXZlbnQgKExpc3QucmV2ICh2YWx1ZSB0KSkgZVxuXG4gIGxldCBmaWx0ZXIgcHJlZCBsID1cbiAgICBsZXQgbW9kdWxlIEludE1hcCA9IE1hcC5NYWtlKEludCkgaW5cblxuICAgIGxldCBpbmRleCA9IHJlZiBJbnRNYXAuZW1wdHkgaW5cbiAgICBsZXQgc2l6ZSA9IHJlZiAwIGluXG5cbiAgICBsZXQgZmlsdGVyX2xpc3QgbCA9XG4gICAgICBsZXQgcmVjIGF1eCAobDogJ2EgbGlzdCkgcmVzIHRoZWlyX2kgbXlfaSA9IG1hdGNoIGwgd2l0aFxuICAgICAgICB8IFtdIC0+IHJlc1xuICAgICAgICB8IHg6OnhzIC0+XG4gICAgICAgICAgIGlmIHByZWQgeFxuICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgYmVnaW5cbiAgICAgICAgICAgICAgIGluZGV4IDo9IEludE1hcC5hZGQgdGhlaXJfaSAobXlfaSArIDEpICFpbmRleDtcbiAgICAgICAgICAgICAgIGF1eCB4cyAoeDo6cmVzKSAodGhlaXJfaSArIDEpIChteV9pICsgMSlcbiAgICAgICAgICAgICBlbmRcbiAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgIGJlZ2luXG4gICAgICAgICAgICAgICBhdXggeHMgcmVzICh0aGVpcl9pICsgMSkgbXlfaVxuICAgICAgICAgICAgIGVuZFxuICAgICAgaW5cbiAgICAgIHNpemUgOj0gTGlzdC5sZW5ndGggbDtcbiAgICAgIGluZGV4IDo9IEludE1hcC5lbXB0eTtcbiAgICAgIExpc3QucmV2IChhdXggbCBbXSAwICgtMSkpXG4gICAgaW5cblxuICAgIGxldCBub3JtYWxpc2UgaSA9IGlmIGkgPCAwIHRoZW4gIXNpemUgKyAxICsgaSBlbHNlIGkgaW5cblxuICAgIGxldCB1cGRhdGVfaW5kZXhfaW5zZXJ0IGluc2VydF9wb3NfZnVsbF9saXN0IHZpc2libGUgPVxuICAgICAgbGV0IGluc2VydF9wb3NfZnVsbF9saXN0ID0gbm9ybWFsaXNlIGluc2VydF9wb3NfZnVsbF9saXN0IGluXG4gICAgICBsZXQgbGVmdF9hbG9uZSwgZGlzcGxhY2VkLCB1cGRhdGFibGVzID0gSW50TWFwLnNwbGl0IGluc2VydF9wb3NfZnVsbF9saXN0ICFpbmRleCBpblxuICAgICAgbGV0IHVwZGF0YWJsZXMgPSBtYXRjaCBkaXNwbGFjZWQgd2l0aFxuICAgICAgICB8IE5vbmUgLT4gdXBkYXRhYmxlc1xuICAgICAgICB8IFNvbWUgZGlzcGxhY2VkX2luX2ZpbHRlcmVkIC0+XG4gICAgICAgICAgIEludE1hcC5hZGQgaW5zZXJ0X3Bvc19mdWxsX2xpc3QgZGlzcGxhY2VkX2luX2ZpbHRlcmVkIHVwZGF0YWJsZXNcbiAgICAgIGluXG4gICAgICBsZXQgdXBkYXRlX2ogal9mdWxsX2xpc3Qgal9maWx0ZXJlZF9saXN0ID1cbiAgICAgICAgbGV0IG5ld19qX2ZpbHRlcmVkID0gaWYgdmlzaWJsZSB0aGVuIGpfZmlsdGVyZWRfbGlzdCArIDEgZWxzZSBqX2ZpbHRlcmVkX2xpc3QgaW5cbiAgICAgICAgaW5kZXggOj0gSW50TWFwLmFkZCAoal9mdWxsX2xpc3QgKyAxKSBuZXdfal9maWx0ZXJlZCAhaW5kZXhcbiAgICAgIGluXG4gICAgICBsZXQgKCkgPSBJbnRNYXAuaXRlciB1cGRhdGVfaiB1cGRhdGFibGVzIGluXG4gICAgICBsZXQgaW5zZXJ0X3Bvc19maWx0ZXJlZCA9IGlmIEludE1hcC5pc19lbXB0eSBsZWZ0X2Fsb25lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoZW4gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIChzbmQgKEludE1hcC5tYXhfYmluZGluZyBsZWZ0X2Fsb25lKSkgKyAxXG4gICAgICBpblxuICAgICAgaWYgdmlzaWJsZSB0aGVuIGluZGV4IDo9IEludE1hcC5hZGQgaW5zZXJ0X3Bvc19mdWxsX2xpc3QgaW5zZXJ0X3Bvc19maWx0ZXJlZCAhaW5kZXg7XG4gICAgICBpbmNyIHNpemU7XG4gICAgICBpbnNlcnRfcG9zX2ZpbHRlcmVkXG4gICAgaW5cblxuICAgIGxldCB1cGRhdGVfaW5kZXhfcmVtb3ZlIHJlbW92ZV9wb3NfZnVsbF9saXN0ID1cbiAgICAgIGxldCB3YXNfdmlzaWJsZSA9IEludE1hcC5tZW0gcmVtb3ZlX3Bvc19mdWxsX2xpc3QgIWluZGV4IGluXG4gICAgICBsZXQgXyxfLHVwZGF0YWJsZXMgPSBJbnRNYXAuc3BsaXQgcmVtb3ZlX3Bvc19mdWxsX2xpc3QgIWluZGV4IGluXG4gICAgICBsZXQgdXBkYXRlX2ogal9mdWxsX2xpc3Qgal9maWx0ZXJlZF9saXN0ID1cbiAgICAgICAgbGV0IG5ld19qID0gaWYgd2FzX3Zpc2libGUgdGhlbiBqX2ZpbHRlcmVkX2xpc3QgZWxzZSBqX2ZpbHRlcmVkX2xpc3QgLSAxIGluXG4gICAgICAgIGluZGV4IDo9IEludE1hcC5hZGQgKGpfZnVsbF9saXN0IC0gMSkgbmV3X2ogIWluZGV4XG4gICAgICBpblxuICAgICAgaWYgbm90IChJbnRNYXAuaXNfZW1wdHkgIWluZGV4KVxuICAgICAgdGhlblxuICAgICAgICBsZXQgbGFzdF9pLCBfID0gSW50TWFwLm1heF9iaW5kaW5nICFpbmRleCBpblxuICAgICAgICBpbmRleCA6PSBJbnRNYXAucmVtb3ZlIGxhc3RfaSAhaW5kZXhcbiAgICAgIGVsc2UgKCk7XG4gICAgICBkZWNyIHNpemU7XG4gICAgICBJbnRNYXAuaXRlciB1cGRhdGVfaiB1cGRhdGFibGVzXG4gICAgaW5cblxuICAgIGxldCB1cGRhdGVfaW5kZXhfdXBkYXRlX2RlbGV0ZSB1cGRhdGVfcG9zX2Z1bGxfbGlzdCA9XG4gICAgICBsZXQgXywgXywgdXBkYXRhYmxlcyA9IEludE1hcC5zcGxpdCB1cGRhdGVfcG9zX2Z1bGxfbGlzdCAhaW5kZXggaW5cbiAgICAgIGxldCB1cGRhdGVfaiBqX2Z1bGxfbGlzdCBqX2ZpbHRlcmVkX2xpc3QgPVxuICAgICAgICBpbmRleCA6PSBJbnRNYXAuYWRkIGpfZnVsbF9saXN0IChqX2ZpbHRlcmVkX2xpc3QgLSAxKSAhaW5kZXhcbiAgICAgIGluXG4gICAgICBpbmRleCA6PSBJbnRNYXAucmVtb3ZlIHVwZGF0ZV9wb3NfZnVsbF9saXN0ICFpbmRleDtcbiAgICAgIEludE1hcC5pdGVyIHVwZGF0ZV9qIHVwZGF0YWJsZXNcbiAgICBpblxuXG4gICAgbGV0IHVwZGF0ZV9pbmRleF91cGRhdGVfaW5zZXJ0IHVwZGF0ZV9wb3NfZnVsbF9saXN0ID1cbiAgICAgIGxldCBsZWZ0X2Fsb25lLCBub25lLCB1cGRhdGFibGVzID0gSW50TWFwLnNwbGl0IHVwZGF0ZV9wb3NfZnVsbF9saXN0ICFpbmRleCBpblxuICAgICAgYXNzZXJ0IChub25lID0gTm9uZSk7XG4gICAgICBsZXQgdXBkYXRlX2ogal9mdWxsX2xpc3Qgal9maWx0ZXJlZF9saXN0ID1cbiAgICAgICAgaW5kZXggOj0gSW50TWFwLmFkZCBqX2Z1bGxfbGlzdCAoal9maWx0ZXJlZF9saXN0ICsgMSkgIWluZGV4XG4gICAgICBpblxuICAgICAgbGV0IG5ld19wb3NfZmlsdGVyZWRfbGlzdCA9XG4gICAgICAgIGxldCBwcmV2aW91c19wb3NfZmlsdGVyZWQgPSB0cnkgKHNuZCAoSW50TWFwLm1heF9iaW5kaW5nIGxlZnRfYWxvbmUpKSB3aXRoIE5vdF9mb3VuZCAtPiAoLTEpIGluXG4gICAgICAgIHByZXZpb3VzX3Bvc19maWx0ZXJlZCArIDFcbiAgICAgIGluXG4gICAgICBpbmRleCA6PSBJbnRNYXAuYWRkIHVwZGF0ZV9wb3NfZnVsbF9saXN0IG5ld19wb3NfZmlsdGVyZWRfbGlzdCAhaW5kZXg7XG4gICAgICBJbnRNYXAuaXRlciB1cGRhdGVfaiB1cGRhdGFibGVzO1xuICAgICAgbmV3X3Bvc19maWx0ZXJlZF9saXN0XG4gICAgaW5cblxuICAgIGxldCB1cGRhdGVfaW5kZXhfbW92ZSBmcm9tX2Z1bGxfbGlzdCB0b19mdWxsX2xpc3QgdG9fZmlsdGVyZWQgPVxuICAgICAgbGV0IHdhc192aXNpYmxlID0gbWF0Y2ggdG9fZmlsdGVyZWQgd2l0aCB8IFNvbWUgXyAtPiB0cnVlIHwgTm9uZSAtPiBmYWxzZSBpblxuICAgICAgbGV0IGZvcndhcmQgPSBmcm9tX2Z1bGxfbGlzdCA8IHRvX2Z1bGxfbGlzdCBpblxuICAgICAgaWYgZm9yd2FyZCB0aGVuXG4gICAgICAgIGZvciBpX2Z1bGwgPSBmcm9tX2Z1bGxfbGlzdCArIDEgdG8gdG9fZnVsbF9saXN0IGRvXG4gICAgICAgICAgbGV0IGRlbHRhID0gaWYgd2FzX3Zpc2libGUgdGhlbiAoLTEpIGVsc2UgMCBpblxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IGlfZmlsdGVyZWQgPSBJbnRNYXAuZmluZCBpX2Z1bGwgIWluZGV4IGluXG4gICAgICAgICAgICBsZXQgbmV3X3ZhbCA9IGlfZmlsdGVyZWQgKyBkZWx0YSBpblxuICAgICAgICAgICAgaW5kZXggOj0gSW50TWFwLmFkZCAoaV9mdWxsIC0gMSkgbmV3X3ZhbCAhaW5kZXhcbiAgICAgICAgICB3aXRoXG4gICAgICAgICAgfCBOb3RfZm91bmQgLT4gKClcbiAgICAgICAgZG9uZVxuICAgICAgZWxzZVxuICAgICAgICBmb3IgaV9mdWxsID0gZnJvbV9mdWxsX2xpc3QgLSAxIGRvd250byB0b19mdWxsX2xpc3QgZG9cbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIGxldCBkZWx0YSA9IGlmIHdhc192aXNpYmxlIHRoZW4gMSBlbHNlIDAgaW5cbiAgICAgICAgICAgIGxldCBpX2ZpbHRlcmVkID0gSW50TWFwLmZpbmQgaV9mdWxsICFpbmRleCBpblxuICAgICAgICAgICAgbGV0IG5ld192YWwgPSBpX2ZpbHRlcmVkICsgZGVsdGEgaW5cbiAgICAgICAgICAgIGluZGV4IDo9IEludE1hcC5hZGQgKGlfZnVsbCArIDEpIG5ld192YWwgIWluZGV4XG4gICAgICAgICAgd2l0aFxuICAgICAgICAgIHwgTm90X2ZvdW5kIC0+ICgpXG4gICAgICAgIGRvbmU7XG4gICAgICBtYXRjaCB0b19maWx0ZXJlZCB3aXRoXG4gICAgICB8IFNvbWUgdG9fZmlsdGVyZWQgLT5cbiAgICAgICAgIGluZGV4IDo9IEludE1hcC5hZGQgdG9fZnVsbF9saXN0IHRvX2ZpbHRlcmVkICFpbmRleFxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICBpbmRleCA6PSBJbnRNYXAucmVtb3ZlIHRvX2Z1bGxfbGlzdCAhaW5kZXhcbiAgICBpblxuXG4gICAgbGV0IGNvbnZlcnRfcCA9IGZ1bmN0aW9uXG4gICAgICB8IEkgKGksIHgpIC0+XG4gICAgICAgICBpZiBwcmVkIHhcbiAgICAgICAgIHRoZW5cbiAgICAgICAgICAgbGV0IG15X2kgPSB1cGRhdGVfaW5kZXhfaW5zZXJ0IGkgdHJ1ZSBpblxuICAgICAgICAgICBbSSAobXlfaSwgeCldXG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIGJlZ2luXG4gICAgICAgICAgICAgaWdub3JlICh1cGRhdGVfaW5kZXhfaW5zZXJ0IGkgZmFsc2UpO1xuICAgICAgICAgICAgIFtdXG4gICAgICAgICAgIGVuZFxuICAgICAgfCBSIGkgLT5cbiAgICAgICAgIGxldCBpID0gbm9ybWFsaXNlIGkgaW5cbiAgICAgICAgIGxldCByZXQgPSB0cnkgbGV0IGogPSBJbnRNYXAuZmluZCBpICFpbmRleCBpbiBbUiBqXSB3aXRoIHwgTm90X2ZvdW5kIC0+IFtdIGluXG4gICAgICAgICBsZXQgKCkgPSB1cGRhdGVfaW5kZXhfcmVtb3ZlIGkgaW5cbiAgICAgICAgIHJldFxuICAgICAgfCBVIChpLCB4KSAtPlxuICAgICAgICAgbGV0IGkgPSBub3JtYWxpc2UgaSBpblxuICAgICAgICAgYmVnaW5cbiAgICAgICAgICAgdHJ5XG4gICAgICAgICAgICAgbGV0IG9sZF9qID0gSW50TWFwLmZpbmQgaSAhaW5kZXggaW5cbiAgICAgICAgICAgICBpZiBwcmVkIHhcbiAgICAgICAgICAgICB0aGVuIFtVIChvbGRfaiwgeCldXG4gICAgICAgICAgICAgZWxzZSAodXBkYXRlX2luZGV4X3VwZGF0ZV9kZWxldGUgaTsgW1Igb2xkX2pdKVxuICAgICAgICAgICB3aXRoXG4gICAgICAgICAgIHwgTm90X2ZvdW5kIC0+XG4gICAgICAgICAgICAgIGlmIHByZWQgeFxuICAgICAgICAgICAgICB0aGVuXG4gICAgICAgICAgICAgICAgbGV0IG5ld19qID0gdXBkYXRlX2luZGV4X3VwZGF0ZV9pbnNlcnQgaSBpblxuICAgICAgICAgICAgICAgIFtJIChuZXdfaiwgeCldXG4gICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBbXVxuICAgICAgICAgZW5kXG4gICAgICB8IFggKG9yaWdpbl9mdWxsLCBvZmZzZXRfZnVsbCkgLT5cbiAgICAgICAgIGxldCBvcmlnaW5fZnVsbCA9IG5vcm1hbGlzZSBvcmlnaW5fZnVsbCBpblxuICAgICAgICAgbGV0IGRlc3RfZnVsbCA9IG9yaWdpbl9mdWxsICsgb2Zmc2V0X2Z1bGwgaW5cbiAgICAgICAgIHRyeVxuICAgICAgICAgICBsZXQgb3JpZ2luX2ZpbHRlcmVkID0gSW50TWFwLmZpbmQgb3JpZ2luX2Z1bGwgIWluZGV4IGluXG4gICAgICAgICAgIGxldCBkZXN0X2ZpbHRlcmVkID1cbiAgICAgICAgICAgICB0cnkgSW50TWFwLmZpbmQgZGVzdF9mdWxsICFpbmRleFxuICAgICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICB8IE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgICAgIGxldCBzbWFsbF9vbmVzLCBfLCBfID0gSW50TWFwLnNwbGl0IG9yaWdpbl9mdWxsICFpbmRleCBpblxuICAgICAgICAgICAgICAgIGlmIEludE1hcC5pc19lbXB0eSBzbWFsbF9vbmVzXG4gICAgICAgICAgICAgICAgdGhlbiAwXG4gICAgICAgICAgICAgICAgZWxzZSBzbmQgKEludE1hcC5tYXhfYmluZGluZyBzbWFsbF9vbmVzKSArIDFcbiAgICAgICAgICAgaW5cbiAgICAgICAgICAgdXBkYXRlX2luZGV4X21vdmUgb3JpZ2luX2Z1bGwgZGVzdF9mdWxsIChTb21lIGRlc3RfZmlsdGVyZWQpO1xuICAgICAgICAgICBpZiBkZXN0X2ZpbHRlcmVkICE9IG9yaWdpbl9maWx0ZXJlZFxuICAgICAgICAgICB0aGVuIFtYIChvcmlnaW5fZmlsdGVyZWQsIGRlc3RfZmlsdGVyZWQgLSBvcmlnaW5fZmlsdGVyZWQpXVxuICAgICAgICAgICBlbHNlIFtdXG4gICAgICAgICB3aXRoXG4gICAgICAgICB8IE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgKCogbW92aW5nIGFuIGVsZW1lbnQgdGhhdCB3YXMgZmlsdGVyZWQgb3V0ICopXG4gICAgICAgICAgICB1cGRhdGVfaW5kZXhfbW92ZSBvcmlnaW5fZnVsbCBkZXN0X2Z1bGwgTm9uZTtcbiAgICAgICAgICAgIFtdXG4gICAgaW5cblxuICAgIGxldCBmaWx0ZXJfZSA9IGZ1bmN0aW9uXG4gICAgICB8IFNldCBsIC0+IFNldCAoZmlsdGVyX2xpc3QgbClcbiAgICAgIHwgUGF0Y2ggcCAtPlxuICAgICAgICAgUGF0Y2ggKExpc3QuY29uY2F0IChMaXN0Lm1hcCBjb252ZXJ0X3AgcCkpXG4gICAgaW5cbiAgICBsZXQgZSA9IFJlYWN0LkUubWFwIGZpbHRlcl9lIChldmVudCBsKSBpblxuICAgIGZyb21fZXZlbnQgKGZpbHRlcl9saXN0ICh2YWx1ZSBsKSkgZVxuXG4gIG1vZHVsZSBJbnRTZXQgPSBTZXQuTWFrZSAoSW50KVxuXG4gIGxldCBmb3JfYWxsIGZuIGRhdGEgPVxuICAgIGxldCBtYXliZV91cGRhdGUgYWNjIGkgdiA9IGlmIGZuIHYgdGhlbiBhY2MgZWxzZSBJbnRTZXQuYWRkIGkgYWNjIGluXG4gICAgbGV0IGluaXQgPVxuICAgICAgbGV0IHJlYyBmb2xkIGkgYWNjID0gZnVuY3Rpb25cbiAgICAgICAgfCB2IDo6IHRsIC0+IGZvbGQgKGkgKyAxKSAobWF5YmVfdXBkYXRlIGFjYyBpIHYpIHRsXG4gICAgICAgIHwgW10gLT4gYWNjXG4gICAgICBpblxuICAgICAgZm9sZCAwIEludFNldC5lbXB0eVxuICAgIGluXG4gICAgbGV0IHVwZGF0ZV9pZHhfYWZ0ZXIgaSBmIGFjYyA9XG4gICAgICBJbnRTZXQubWFwIChmdW4gaScgLT4gaWYgaScgPj0gaSB0aGVuIGYgaScgMSBlbHNlIGknKSBhY2NcbiAgICBpblxuICAgIGxldCBmID0gZnVuIGFjYyAtPiBmdW5jdGlvblxuICAgICAgfCBTZXQgeCAtPiBpbml0IHhcbiAgICAgIHwgUGF0Y2ggdXBkYXRlcyAtPlxuICAgICAgICBMaXN0LmZvbGRfbGVmdFxuICAgICAgICAgIChmdW4gYWNjIC0+IGZ1bmN0aW9uXG4gICAgICAgICAgICAgfCBYIChpLCBpJykgLT5cbiAgICAgICAgICAgICAgIGlmIEludFNldC5tZW0gaSBhY2MgPSBJbnRTZXQubWVtIGknIGFjY1xuICAgICAgICAgICAgICAgdGhlbiBhY2NcbiAgICAgICAgICAgICAgIGVsc2UgaWYgSW50U2V0Lm1lbSBpIGFjY1xuICAgICAgICAgICAgICAgdGhlbiBJbnRTZXQuYWRkIGknIChJbnRTZXQucmVtb3ZlIGkgYWNjKVxuICAgICAgICAgICAgICAgZWxzZSBJbnRTZXQuYWRkIGkgKEludFNldC5yZW1vdmUgaScgYWNjKVxuICAgICAgICAgICAgIHwgUiBpIC0+XG4gICAgICAgICAgICAgICB1cGRhdGVfaWR4X2FmdGVyIGkgKC0pIChJbnRTZXQucmVtb3ZlIGkgYWNjKVxuICAgICAgICAgICAgIHwgSSAoaSwgdikgLT5cbiAgICAgICAgICAgICAgIGxldCBhY2MgPSB1cGRhdGVfaWR4X2FmdGVyIGkgKCspIGFjYyBpblxuICAgICAgICAgICAgICAgbWF5YmVfdXBkYXRlIGFjYyBpIHZcbiAgICAgICAgICAgICB8IFUgKGksIHYpIC0+XG4gICAgICAgICAgICAgICBtYXliZV91cGRhdGUgKEludFNldC5yZW1vdmUgaSBhY2MpIGkgdilcbiAgICAgICAgICBhY2NcbiAgICAgICAgICB1cGRhdGVzXG4gICAgaW5cbiAgICBSZWFjdC5TLmZvbGQgZiAoaW5pdCAodmFsdWUgZGF0YSkpIChldmVudCBkYXRhKVxuICAgIHw+IFJlYWN0LlMubWFwIEludFNldC5pc19lbXB0eVxuXG5lbmRcblxubW9kdWxlIFJNYXAoTSA6IE1hcC5TKSA9IHN0cnVjdFxuXG4gIG1vZHVsZSBEYXRhID0gc3RydWN0XG5cbiAgICB0eXBlICdhIGRhdGEgPSAnYSBNLnRcblxuICAgIHR5cGUgJ2EgcCA9IFtgQWRkIG9mIChNLmtleSAqICdhKSB8IGBEZWwgb2YgTS5rZXldXG5cbiAgICB0eXBlICdhIHBhdGNoID0gJ2EgcCBsaXN0XG5cbiAgICBsZXQgbWVyZ2VfcCBwIHMgPVxuICAgICAgbWF0Y2ggcCB3aXRoXG4gICAgICB8IGBBZGQgKGssYSkgLT4gTS5hZGQgayBhIHNcbiAgICAgIHwgYERlbCBrIC0+IE0ucmVtb3ZlIGsgc1xuXG4gICAgbGV0IG1lcmdlIHAgYWNjID0gTGlzdC5mb2xkX2xlZnQgKGZ1biBhY2MgcCAtPiBtZXJnZV9wIHAgYWNjKSBhY2MgcFxuXG4gICAgbGV0IG1hcF9wIGYgPSBmdW5jdGlvblxuICAgICAgfCBgQWRkIChrLGEpIC0+IGBBZGQgKGssZiBhKVxuICAgICAgfCBgRGVsIGsgLT4gYERlbCBrXG5cbiAgICBsZXQgbWFwX3BhdGNoIGYgPSBMaXN0Lm1hcCAobWFwX3AgZilcblxuICAgIGxldCBtYXBfZGF0YSBmIGQgPSBNLm1hcCBmIGRcblxuICAgIGxldCBlbXB0eSA9IE0uZW1wdHlcblxuICAgIGxldCBlcXVhbCBmID0gTS5lcXVhbCBmXG5cbiAgICBsZXQgZGlmZiB+ZXEgeCB5ID1cbiAgICAgIGxldCBtID1cbiAgICAgICAgbGV0IGcgX2tleSB2IHcgPVxuICAgICAgICAgIG1hdGNoIHYsIHcgd2l0aFxuICAgICAgICAgIHwgU29tZSB2LCBTb21lIHcgd2hlbiBlcSB2IHcgLT5cbiAgICAgICAgICAgIE5vbmVcbiAgICAgICAgICB8IFNvbWUgXywgU29tZSB3IC0+XG4gICAgICAgICAgICBTb21lIChgVSB3KVxuICAgICAgICAgIHwgU29tZSBfLCBOb25lIC0+XG4gICAgICAgICAgICBTb21lIGBEXG4gICAgICAgICAgfCBOb25lLCBTb21lIHYgLT5cbiAgICAgICAgICAgIFNvbWUgKGBBIHYpXG4gICAgICAgICAgfCBOb25lLCBOb25lIC0+XG4gICAgICAgICAgICBOb25lXG4gICAgICAgIGluXG4gICAgICAgIE0ubWVyZ2UgZyB4IHlcbiAgICAgIGFuZCBnIGtleSB4IGFjYyA9XG4gICAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgICB8IGBVIHYgLT5cbiAgICAgICAgICBgRGVsIGtleSA6OiBgQWRkIChrZXksIHYpIDo6IGFjY1xuICAgICAgICB8IGBEIC0+XG4gICAgICAgICAgYERlbCBrZXkgOjogYWNjXG4gICAgICAgIHwgYEEgdiAtPlxuICAgICAgICAgIGBBZGQgKGtleSwgdikgOjogYWNjXG4gICAgICBhbmQgYWNjID0gW10gaW5cbiAgICAgIExpc3QucmV2IChNLmZvbGQgZyBtIGFjYylcblxuICBlbmRcblxuICBpbmNsdWRlIE1ha2UoRGF0YSlcblxuICBsZXQgZmlsdGVyIHByZWQgbSA9XG5cbiAgICBsZXQgY29udmVydF9wID0gZnVuY3Rpb25cbiAgICAgIHwgYEFkZCAoayx2KSAtPlxuICAgICAgICAgaWYgcHJlZCBrIHZcbiAgICAgICAgIHRoZW4gW2BBZGQgKGssdildXG4gICAgICAgICBlbHNlIFtdXG4gICAgICB8IGBEZWwgayAtPiBbYERlbCBrXVxuICAgIGluXG5cbiAgICBsZXQgZmlsdGVyX2UgPSBmdW5jdGlvblxuICAgICAgfCBTZXQgbSAtPiBTZXQgKE0uZmlsdGVyIHByZWQgbSlcbiAgICAgIHwgUGF0Y2ggcCAtPiBQYXRjaCAoTGlzdC5jb25jYXQgKExpc3QubWFwIGNvbnZlcnRfcCBwKSlcbiAgICBpblxuXG4gICAgbGV0IGUgPSBSZWFjdC5FLm1hcCBmaWx0ZXJfZSAoZXZlbnQgbSkgaW5cbiAgICBmcm9tX2V2ZW50IChNLmZpbHRlciBwcmVkICh2YWx1ZSBtKSkgZVxuZW5kXG4iXX0=
