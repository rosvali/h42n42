// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Ocsigen_lib_base
//# unitInfo: Requires: CamlinternalLazy, Lwt, Stdlib, Stdlib__List, Stdlib__Map, Stdlib__Set, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$5 = "",
    cst$6 = "..",
    cst$7 = "/",
    caml_equal = runtime.caml_equal,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$4 = cst$7,
    cst$3 = cst$7,
    cst$2 = cst$5,
    cst$0 = cst$5,
    cst$1 = ":",
    cst = cst$5,
    advert =
      "Page generated by OCaml with Ocsigen.\nSee http://ocsigen.org/ and http://caml.inria.fr/ for information",
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Lwt = global_data.Lwt,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Map = global_data.Stdlib__Map,
    Stdlib_Set = global_data.Stdlib__Set,
    Ocsigen_Internal_Error =
      [248, "Ocsigen_lib_base.Ocsigen_Internal_Error", caml_fresh_oo_id(0)],
    Input_is_too_large =
      [248, "Ocsigen_lib_base.Input_is_too_large", caml_fresh_oo_id(0)],
    Ocsigen_Bad_Request =
      [248, "Ocsigen_lib_base.Ocsigen_Bad_Request", caml_fresh_oo_id(0)],
    Ocsigen_Request_too_long =
      [248, "Ocsigen_lib_base.Ocsigen_Request_too_long", caml_fresh_oo_id(0)],
    symbol_bind = Lwt[6],
    symbol = Lwt[71],
    _c_ = [0, cst$5, 0],
    _f_ = [0, cst$5, 0],
    _g_ = [0, cst$5, 0],
    _h_ = [0, cst$5, 0],
    _i_ = [0, cst$5, 0],
    _j_ = [0, cst$6, [0, cst$5, 0]],
    _k_ = [0, cst$5, 0],
    _e_ = [0, cst$5, 0],
    _d_ = [0, cst$5, 0],
    _b_ = [0, cst$5, 0],
    cst_https = "https://",
    cst_http = "http://",
    cst_Clist_value = "Clist.value",
    _a_ = [0, 0, 0];
   function symbol$0(_ab_){
    var _ac_ = runtime.caml_obj_tag(_ab_);
    return 250 === _ac_
            ? _ab_[1]
            : 246 === _ac_ ? caml_call1(CamlinternalLazy[2], _ab_) : _ab_;
   }
   function symbol$1(x, f){return caml_call1(f, x);}
   function symbol$2(f, x){return caml_call1(f, x);}
   function comp(f, g, x){return caml_call1(f, caml_call1(g, x));}
   function curry(f, x, y){return caml_call1(f, [0, x, y]);}
   function uncurry(f, param){
    var y = param[2], x = param[1];
    return caml_call2(f, x, y);
   }
   function fst(param){var a = param[1]; return a;}
   function snd(param){var a = param[2]; return a;}
   function thd(param){var a = param[3]; return a;}
   var Tuple3 = [0, fst, snd, thd];
   function map(f, param){
    if(! param) return 0;
    var x = param[1];
    return [0, caml_call1(f, x)];
   }
   function get(f, param){
    if(! param) return caml_call1(f, 0);
    var x = param[1];
    return x;
   }
   function get$0(a, param){if(! param) return a; var x = param[1]; return x;}
   function iter(f, param){
    if(! param) return 0;
    var x = param[1];
    return caml_call1(f, x);
   }
   function return$0(x){return [0, x];}
   function bind(opt, k){
    if(! opt) return 0;
    var x = opt[1];
    return caml_call1(k, x);
   }
   function to_list(param){
    if(! param) return 0;
    var v = param[1];
    return [0, v, 0];
   }
   function map$0(f, param){
    if(! param) return caml_call1(Lwt[4], 0);
    var x = param[1];
    function _aa_(v){return caml_call1(Lwt[4], [0, v]);}
    return caml_call2(symbol_bind, caml_call1(f, x), _aa_);
   }
   function get$1(f, param){
    if(! param) return caml_call1(f, 0);
    var x = param[1];
    return caml_call1(Lwt[4], x);
   }
   function get$2(a, param){
    if(! param) return a;
    var x = param[1];
    return caml_call1(Lwt[4], x);
   }
   function iter$0(f, param){
    if(! param) return caml_call1(Lwt[4], 0);
    var x = param[1];
    return caml_call1(f, x);
   }
   function bind$0(opt, k){
    if(! opt) return caml_call1(Lwt[4], 0);
    var x = opt[1];
    return caml_call1(k, x);
   }
   var
    Lwt$0 = [0, map$0, get$1, get$2, iter$0, bind$0],
    Option = [0, map, get, get$0, iter, return$0, bind, to_list, Lwt$0],
    length = Stdlib_List[1],
    compare_lengths = Stdlib_List[2],
    compare_length_with = Stdlib_List[3],
    cons = Stdlib_List[4],
    hd = Stdlib_List[5],
    tl = Stdlib_List[6],
    nth = Stdlib_List[7],
    nth_opt = Stdlib_List[8],
    rev = Stdlib_List[9],
    init = Stdlib_List[10],
    append = Stdlib_List[11],
    rev_append = Stdlib_List[12],
    concat = Stdlib_List[13],
    flatten = Stdlib_List[14],
    equal = Stdlib_List[15],
    compare = Stdlib_List[16],
    iter$1 = Stdlib_List[17],
    iteri = Stdlib_List[18],
    map$1 = Stdlib_List[19],
    mapi = Stdlib_List[20],
    rev_map = Stdlib_List[21],
    filter_map = Stdlib_List[22],
    concat_map = Stdlib_List[23],
    fold_left_map = Stdlib_List[24],
    fold_left = Stdlib_List[25],
    fold_right = Stdlib_List[26],
    iter2 = Stdlib_List[27],
    map2 = Stdlib_List[28],
    rev_map2 = Stdlib_List[29],
    fold_left2 = Stdlib_List[30],
    fold_right2 = Stdlib_List[31],
    for_all = Stdlib_List[32],
    exists = Stdlib_List[33],
    for_all2 = Stdlib_List[34],
    exists2 = Stdlib_List[35],
    mem = Stdlib_List[36],
    memq = Stdlib_List[37],
    find = Stdlib_List[38],
    find_opt = Stdlib_List[39],
    find_map = Stdlib_List[40],
    filter = Stdlib_List[41],
    find_all = Stdlib_List[42],
    filteri = Stdlib_List[43],
    partition = Stdlib_List[44],
    partition_map = Stdlib_List[45],
    assoc = Stdlib_List[46],
    assoc_opt = Stdlib_List[47],
    assq = Stdlib_List[48],
    assq_opt = Stdlib_List[49],
    mem_assoc = Stdlib_List[50],
    mem_assq = Stdlib_List[51],
    remove_assoc = Stdlib_List[52],
    remove_assq = Stdlib_List[53],
    split = Stdlib_List[54],
    combine = Stdlib_List[55],
    sort = Stdlib_List[56],
    stable_sort = Stdlib_List[57],
    fast_sort = Stdlib_List[58],
    sort_uniq = Stdlib_List[59],
    merge = Stdlib_List[60],
    to_seq = Stdlib_List[61],
    of_seq = Stdlib_List[62];
   function map_filter(f, l){
    var acc = 0, param = l;
    for(;;){
     if(! param) return caml_call1(Stdlib_List[9], acc);
     var q = param[2], t = param[1], match = caml_call1(f, t);
     if(match)
      var r = match[1], acc$0 = [0, r, acc], acc = acc$0, param = q;
     else
      var param = q;
    }
   }
   function remove_first_if_any(a, param){
    if(! param) return 0;
    var b = param[1], l = param[2];
    if(caml_equal(a, b)) return l;
    var l$0 = param[2];
    return [0, b, remove_first_if_any(a, l$0)];
   }
   function remove_first_if_any_q(a, param){
    if(! param) return 0;
    var b = param[1], l = param[2];
    if(a === b) return l;
    var l$0 = param[2];
    return [0, b, remove_first_if_any_q(a, l$0)];
   }
   function remove_first(a, param){
    if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var b = param[1], l = param[2];
    if(caml_equal(a, b)) return l;
    var l$0 = param[2];
    return [0, b, remove_first(a, l$0)];
   }
   function remove_first_q(a, param){
    if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var b = param[1], l = param[2];
    if(a === b) return l;
    var l$0 = param[2];
    return [0, b, remove_first_q(a, l$0)];
   }
   function remove_all(a, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var b = param$0[1], l = param$0[2];
     if(! caml_equal(a, b)){
      var l$0 = param$0[2];
      return [0, b, remove_all(a, l$0)];
     }
     var param$0 = l;
    }
   }
   function remove_all_q(a, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var b = param$0[1], l = param$0[2];
     if(a !== b){var l$0 = param$0[2]; return [0, b, remove_all_q(a, l$0)];}
     var param$0 = l;
    }
   }
   function remove_all_assoc(a, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var _$_ = param$0[1], l = param$0[2], b = _$_[1];
     if(! caml_equal(a, b)){
      var l$0 = param$0[2];
      return [0, _$_, remove_all_assoc(a, l$0)];
     }
     var param$0 = l;
    }
   }
   function remove_all_assoc_q(a, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var ___ = param$0[1], l = param$0[2], b = ___[1];
     if(a !== b){
      var l$0 = param$0[2];
      return [0, ___, remove_all_assoc_q(a, l$0)];
     }
     var param$0 = l;
    }
   }
   function last(param){
    var param$0 = param;
    for(;;){
     if(! param$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var b = param$0[1];
     if(! param$0[2]) return b;
     var l = param$0[2], param$0 = l;
    }
   }
   function assoc_remove(a, param){
    if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var _Z_ = param[1], l = param[2], c = _Z_[2], b = _Z_[1];
    if(caml_equal(a, b)) return [0, c, l];
    var
     l$0 = param[2],
     match = assoc_remove(a, l$0),
     ll = match[2],
     v = match[1];
    return [0, v, [0, _Z_, ll]];
   }
   function is_prefix(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(! l1$0) return 1;
     if(l2$0){
      var ll2 = l2$0[2], b = l2$0[1], ll1 = l1$0[2], a = l1$0[1];
      if(caml_equal(a, b)){var l1$0 = ll1, l2$0 = ll2; continue;}
     }
     return 0;
    }
   }
   function chop(n, xs){
    var n$0 = n, xs$0 = xs;
    for(;;){
     if(0 >= n$0) return xs$0;
     if(! xs$0) return 0;
     var xs$1 = xs$0[2], n$1 = n$0 - 1 | 0, n$0 = n$1, xs$0 = xs$1;
    }
   }
   function split_at(n, xs){
    if(0 >= n) return [0, 0, xs];
    if(! xs) return _a_;
    var
     xs$0 = xs[2],
     x = xs[1],
     match = split_at(n - 1 | 0, xs$0),
     r = match[2],
     l = match[1];
    return [0, [0, x, l], r];
   }
   function make(c){
    var x = [];
    runtime.caml_update_dummy(x, [0, c, x, x]);
    return x;
   }
   function make$0(c){return make([0, c]);}
   function create(param){return make(0);}
   function insert(p, x){
    var n = p[3];
    p[3] = x;
    x[2] = p;
    x[3] = n;
    n[2] = x;
    return 0;
   }
   function remove(x){
    var p = x[2], n = x[3];
    p[3] = n;
    n[2] = p;
    x[3] = x;
    x[2] = x;
    return 0;
   }
   function in_list(x){return x[3] !== x ? 1 : 0;}
   function is_empty(set){return set[3] === set ? 1 : 0;}
   function value(c){
    var match = c[1];
    if(! match) return caml_call1(Stdlib[2], cst_Clist_value);
    var c$0 = match[1];
    return c$0;
   }
   function iter$2(f, node){
    var node$0 = node;
    for(;;){
     var match = node$0[3][1];
     if(! match) return 0;
     var c = match[1];
     caml_call1(f, c);
     var node$1 = node$0[3], node$0 = node$1;
    }
   }
   function fold_left$0(f, a, node){
    var a$0 = a, node$0 = node;
    for(;;){
     var match = node$0[3][1];
     if(! match) return a$0;
     var
      c = match[1],
      node$1 = node$0[3],
      a$1 = caml_call2(f, a$0, c),
      a$0 = a$1,
      node$0 = node$1;
    }
   }
   var
    Clist =
      [0,
       make$0,
       create,
       insert,
       remove,
       value,
       in_list,
       is_empty,
       iter$2,
       fold_left$0],
    compare$0 = runtime.caml_compare,
    Table = caml_call1(Stdlib_Map[1], [0, compare$0]),
    Int = [0, Table],
    make$1 = Stdlib_String[1],
    init$0 = Stdlib_String[2],
    empty = Stdlib_String[3],
    of_bytes = Stdlib_String[4],
    to_bytes = Stdlib_String[5],
    concat$0 = Stdlib_String[6],
    cat = Stdlib_String[7],
    equal$0 = Stdlib_String[8],
    compare$1 = Stdlib_String[9],
    starts_with = Stdlib_String[10],
    ends_with = Stdlib_String[11],
    contains_from = Stdlib_String[12],
    rcontains_from = Stdlib_String[13],
    contains = Stdlib_String[14],
    sub = Stdlib_String[15],
    split_on_char = Stdlib_String[16],
    map$2 = Stdlib_String[17],
    mapi$0 = Stdlib_String[18],
    fold_left$1 = Stdlib_String[19],
    fold_right$0 = Stdlib_String[20],
    for_all$0 = Stdlib_String[21],
    exists$0 = Stdlib_String[22],
    trim = Stdlib_String[23],
    escaped = Stdlib_String[24],
    uppercase_ascii = Stdlib_String[25],
    lowercase_ascii = Stdlib_String[26],
    capitalize_ascii = Stdlib_String[27],
    uncapitalize_ascii = Stdlib_String[28],
    iter$3 = Stdlib_String[29],
    iteri$0 = Stdlib_String[30],
    index_from = Stdlib_String[31],
    index_from_opt = Stdlib_String[32],
    rindex_from = Stdlib_String[33],
    rindex_from_opt = Stdlib_String[34],
    index = Stdlib_String[35],
    index_opt = Stdlib_String[36],
    rindex = Stdlib_String[37],
    rindex_opt = Stdlib_String[38],
    to_seq$0 = Stdlib_String[39],
    to_seqi = Stdlib_String[40],
    of_seq$0 = Stdlib_String[41],
    get_utf_8_uchar = Stdlib_String[42],
    is_valid_utf_8 = Stdlib_String[43],
    get_utf_16be_uchar = Stdlib_String[44],
    is_valid_utf_16be = Stdlib_String[45],
    get_utf_16le_uchar = Stdlib_String[46],
    is_valid_utf_16le = Stdlib_String[47],
    blit = Stdlib_String[48],
    copy = Stdlib_String[49],
    fill = Stdlib_String[50],
    uppercase = Stdlib_String[51],
    lowercase = Stdlib_String[52],
    capitalize = Stdlib_String[53],
    uncapitalize = Stdlib_String[54],
    get_uint8 = Stdlib_String[55],
    get_int8 = Stdlib_String[56],
    get_uint16_ne = Stdlib_String[57],
    get_uint16_be = Stdlib_String[58],
    get_uint16_le = Stdlib_String[59],
    get_int16_ne = Stdlib_String[60],
    get_int16_be = Stdlib_String[61],
    get_int16_le = Stdlib_String[62],
    get_int32_ne = Stdlib_String[63],
    get_int32_be = Stdlib_String[64],
    get_int32_le = Stdlib_String[65],
    get_int64_ne = Stdlib_String[66],
    get_int64_be = Stdlib_String[67],
    get_int64_le = Stdlib_String[68];
   function remove_spaces(s, beg, endd){
    function find_not_space(s, i, step){
     var i$0 = i;
     for(;;){
      if(endd >= i$0 && i$0 >= beg){
       if(32 !== caml_string_get(s, i$0)) return i$0;
       var i$1 = i$0 + step | 0, i$0 = i$1;
       continue;
      }
      return i$0;
     }
    }
    var first = find_not_space(s, beg, 1), last = find_not_space(s, endd, -1);
    return first <= last
            ? caml_call3
              (Stdlib_String[15], s, first, (1 + last | 0) - first | 0)
            : cst;
   }
   function basic_sep(char$0, s){
    try{
     var
      seppos = caml_call2(Stdlib_String[35], s, char$0),
      _W_ =
        caml_call3
         (Stdlib_String[15],
          s,
          seppos + 1 | 0,
          (caml_ml_string_length(s) - seppos | 0) - 1 | 0),
      _X_ = [0, caml_call3(Stdlib_String[15], s, 0, seppos), _W_];
     return _X_;
    }
    catch(_Y_){
     var _V_ = caml_wrap_exception(_Y_);
     if(_V_[1] === Stdlib[6]) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     throw caml_maybe_attach_backtrace(_V_, 0);
    }
   }
   function sep(char$0, s){
    var
     len = caml_ml_string_length(s),
     seppos = caml_call2(Stdlib_String[35], s, char$0),
     _U_ = remove_spaces(s, seppos + 1 | 0, len - 1 | 0);
    return [0, remove_spaces(s, 0, seppos - 1 | 0), _U_];
   }
   function split$0(opt, char$0, s){
    if(opt) var sth = opt[1], multisep = sth; else var multisep = 0;
    var longueur = caml_ml_string_length(s);
    function aux(deb){
     if(longueur <= deb) return 0;
     try{
      var firstsep = caml_call3(Stdlib_String[31], s, deb, char$0);
      a:
      {
       if(multisep && firstsep === deb){var _R_ = aux(deb + 1 | 0); break a;}
       var
        _S_ = aux(firstsep + 1 | 0),
        _R_ = [0, remove_spaces(s, deb, firstsep - 1 | 0), _S_];
      }
      return _R_;
     }
     catch(_T_){
      var _Q_ = caml_wrap_exception(_T_);
      if(_Q_ === Stdlib[8])
       return [0, remove_spaces(s, deb, longueur - 1 | 0), 0];
      throw caml_maybe_attach_backtrace(_Q_, 0);
     }
    }
    return aux(0);
   }
   function may_append(s1, sep, s2){
    if(! caml_string_notequal(s2, cst$5)) return s1;
    var _P_ = caml_call2(Stdlib[28], sep, s2);
    return caml_call2(Stdlib[28], s1, _P_);
   }
   function may_concat(s1, sep, s2){
    return caml_string_notequal(s2, cst$5)
            ? caml_string_notequal
               (s1, cst$5)
              ? caml_call2(Stdlib_String[6], sep, [0, s1, [0, s2, 0]])
              : s2
            : s1;
   }
   function first_diff(s1, s2, n, last){
    try{
     var
      _M_ = caml_string_get(s2, n),
      _N_ =
        caml_string_get(s1, n) === _M_
         ? n === last ? last + 1 | 0 : first_diff(s1, s2, n + 1 | 0, last)
         : n;
     return _N_;
    }
    catch(_O_){
     var _L_ = caml_wrap_exception(_O_);
     if(_L_[1] === Stdlib[6]) return n;
     throw caml_maybe_attach_backtrace(_L_, 0);
    }
   }
   var
    Table$0 = caml_call1(Stdlib_Map[1], [0, Stdlib_String[9]]),
    Set = caml_call1(Stdlib_Set[1], [0, Stdlib_String[9]]),
    Map = caml_call1(Stdlib_Map[1], [0, Stdlib_String[9]]),
    String_base =
      [0,
       make$1,
       init$0,
       empty,
       of_bytes,
       to_bytes,
       concat$0,
       cat,
       equal$0,
       compare$1,
       starts_with,
       ends_with,
       contains_from,
       rcontains_from,
       contains,
       sub,
       split_on_char,
       map$2,
       mapi$0,
       fold_left$1,
       fold_right$0,
       for_all$0,
       exists$0,
       trim,
       escaped,
       uppercase_ascii,
       lowercase_ascii,
       capitalize_ascii,
       uncapitalize_ascii,
       iter$3,
       iteri$0,
       index_from,
       index_from_opt,
       rindex_from,
       rindex_from_opt,
       index,
       index_opt,
       rindex,
       rindex_opt,
       to_seq$0,
       to_seqi,
       of_seq$0,
       get_utf_8_uchar,
       is_valid_utf_8,
       get_utf_16be_uchar,
       is_valid_utf_16be,
       get_utf_16le_uchar,
       is_valid_utf_16le,
       blit,
       copy,
       fill,
       uppercase,
       lowercase,
       capitalize,
       uncapitalize,
       get_uint8,
       get_int8,
       get_uint16_ne,
       get_uint16_be,
       get_uint16_le,
       get_int16_ne,
       get_int16_be,
       get_int16_le,
       get_int32_ne,
       get_int32_be,
       get_int32_le,
       get_int64_ne,
       get_int64_be,
       get_int64_le,
       remove_spaces,
       basic_sep,
       sep,
       split$0,
       may_append,
       may_concat,
       first_diff,
       Table$0,
       Set,
       Map];
   function make_absolute_url(https, host, port, uri){
    a:
    {
     b:
     {
      if(80 === port && ! https) break b;
      if(https && 443 === port) break b;
      var
       _K_ = caml_call1(Stdlib[33], port),
       _G_ = caml_call2(Stdlib[28], cst$1, _K_);
      break a;
     }
     var _G_ = cst$0;
    }
    var
     _H_ = caml_call2(Stdlib[28], _G_, uri),
     _I_ = caml_call2(Stdlib[28], host, _H_),
     _J_ = https ? cst_https : cst_http;
    return caml_call2(Stdlib[28], _J_, _I_);
   }
   function aux(l){
    var l$0 = l;
    for(;;){
     if(! l$0) return 0;
     var a = l$0[1];
     if(caml_string_notequal(a, cst$5)){
      if(! caml_string_notequal(a, cst$6)){
       var l$2 = l$0[2], l$0 = l$2;
       continue;
      }
     }
     else if(! l$0[2]) return l$0;
     var l$1 = l$0[2];
     return [0, a, aux(l$1)];
    }
   }
   function remove_dotdot(l){
    if(! l) return 0;
    if(caml_string_notequal(l[1], cst$5)) return aux(l);
    var l$0 = l[2];
    return [0, cst$2, aux(l$0)];
   }
   function remove_end_slash(s){
    try{
     var
      _E_ =
        47 === caml_string_get(s, caml_ml_string_length(s) - 1 | 0)
         ? caml_call3
           (Stdlib_String[15], s, 0, caml_ml_string_length(s) - 1 | 0)
         : s;
     return _E_;
    }
    catch(_F_){
     var _D_ = caml_wrap_exception(_F_);
     if(_D_[1] === Stdlib[6]) return s;
     throw caml_maybe_attach_backtrace(_D_, 0);
    }
   }
   function remove_internal_slash(u){
    function aux(param){
     var param$0 = param;
     for(;;){
      if(! param$0) return 0;
      var a = param$0[1];
      if(! param$0[2]) return [0, a, 0];
      if(caml_string_notequal(a, cst$5)){
       var l = param$0[2];
       return [0, a, aux(l)];
      }
      var l$0 = param$0[2], param$0 = l$0;
     }
    }
    if(! u) return 0;
    var l = u[2], a = u[1];
    return [0, a, aux(l)];
   }
   function change_empty_list(l){return l ? l : _b_;}
   function add_end_slash_if_missing(a){
    if(! a) return _c_;
    var a$0 = a[1];
    if(! caml_string_notequal(a$0, cst$5) && ! a[2]) return a;
    var l = a[2];
    return [0, a$0, add_end_slash_if_missing(l)];
   }
   function remove_slash_at_end(param){
    a:
    if(param){
     var a = param[1];
     if(! caml_string_notequal(a, cst$5) && ! param[2]) break a;
     var l = param[2];
     return [0, a, remove_slash_at_end(l)];
    }
    return 0;
   }
   function remove_slash_at_beginning(l){
    if(! l) return 0;
    if(caml_string_notequal(l[1], cst$5)) return l;
    var l$0 = l[2];
    return l$0 ? l$0 : _d_;
   }
   function is_prefix_skip_end_slash(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     a:
     if(l1$0){
      var a = l1$0[1];
      if(! caml_string_notequal(a, cst$5) && ! l1$0[2]) break a;
      if(l2$0){
       var ll2 = l2$0[2], b = l2$0[1], ll1 = l1$0[2];
       if(runtime.caml_string_equal(a, b)){
        var l1$0 = ll1, l2$0 = ll2;
        continue;
       }
      }
      return 0;
     }
     return 1;
    }
   }
   function split_fragment(s){
    try{
     var
      pos = caml_call2(Stdlib_String[35], s, 35),
      _A_ =
        [0,
         caml_call3
          (Stdlib_String[15],
           s,
           pos + 1 | 0,
           (caml_ml_string_length(s) - 1 | 0) - pos | 0)],
      _B_ = [0, caml_call3(Stdlib_String[15], s, 0, pos), _A_];
     return _B_;
    }
    catch(_C_){
     var _z_ = caml_wrap_exception(_C_);
     if(_z_ === Stdlib[8]) return [0, s, 0];
     throw caml_maybe_attach_backtrace(_z_, 0);
    }
   }
   function join_path(l){
    if(l && ! caml_string_notequal(l[1], cst$5) && ! l[2]) return cst$4;
    return caml_call2(Stdlib_String[6], cst$3, l);
   }
   function split_path(s){
    var l = caml_ml_string_length(s);
    function collect_words(k){
     try{var _x_ = caml_call3(Stdlib_String[31], s, k, 47), k$0 = _x_;}
     catch(_y_){
      var _w_ = caml_wrap_exception(_y_);
      if(_w_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_w_, 0);
      var k$0 = l;
     }
     var word = caml_call3(Stdlib_String[15], s, k, k$0 - k | 0);
     return l <= k$0 ? [0, word, 0] : [0, word, collect_words(k$0 + 1 | 0)];
    }
    var other = collect_words(0);
    if(other && ! caml_string_notequal(other[1], cst$5)){
     var _v_ = other[2];
     if(! _v_) return 0;
     if(! caml_string_notequal(_v_[1], cst$5) && ! _v_[2]) return _e_;
    }
    return other;
   }
   function norm_path(l){
    function remove_slash_slash(l, first){
     var l$0 = l, first$0 = first;
     for(;;){
      if(! l$0) return 0;
      var x = l$0[1];
      if(! caml_string_notequal(x, cst$5)){
       var l$2 = l$0[2];
       if(! l$2) return _g_;
       if(! caml_string_notequal(l$2[1], cst$5) && ! l$2[2] && first$0)
        return _f_;
       if(! first$0){var l$0 = l$2, first$0 = 0; continue;}
      }
      var l$1 = l$0[2];
      return [0, x, remove_slash_slash(l$1, 0)];
     }
    }
    function remove_dot(l, first){
     var l$0 = l, first$0 = first;
     for(;;){
      if(! l$0) return 0;
      var x = l$0[1];
      if(caml_string_notequal(x, ".")){
       var l$1 = l$0[2];
       return [0, x, remove_dot(l$1, 0)];
      }
      var match = l$0[2];
      a:
      if(match){
       var x$0 = match[1];
       if(! caml_string_notequal(x$0, cst$5) && ! match[2]) break a;
       var l$2 = match[2], l$3 = [0, x$0, l$2], l$0 = l$3, first$0 = 0;
       continue;
      }
      return first$0 ? 0 : _h_;
     }
    }
    function remove_dot_dot_once(l, first){
     if(! l) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var x = l[1], _u_ = l[2];
     if(_u_ && ! caml_string_notequal(_u_[1], cst$6)){
      var l$1 = _u_[2];
      if
       (!
        l$1
        &&
         caml_string_notequal(x, cst$5)
         && caml_string_notequal(x, cst$6) && ! first)
       return _i_;
      if(caml_string_notequal(x, cst$5) && caml_string_notequal(x, cst$6))
       return l$1;
     }
     var l$0 = l[2];
     return [0, x, remove_dot_dot_once(l$0, 0)];
    }
    function remove_dot_dot(l){
     try{
      var l$0 = remove_dot_dot_once(l, 1), _s_ = remove_dot_dot(l$0);
      return _s_;
     }
     catch(_t_){
      var _r_ = caml_wrap_exception(_t_);
      if(_r_ === Stdlib[8]) return l;
      throw caml_maybe_attach_backtrace(_r_, 0);
     }
    }
    var l$0 = remove_dot_dot(remove_dot(remove_slash_slash(l, 1), 1));
    if(l$0){
     var _p_ = l$0[1];
     if(caml_string_notequal(_p_, cst$5)){
      if(! caml_string_notequal(_p_, cst$6) && ! l$0[2]) return _j_;
     }
     else{
      var _q_ = l$0[2];
      if(_q_ && ! caml_string_notequal(_q_[1], cst$5) && ! _q_[2]) return _k_;
     }
    }
    return l$0;
   }
   var
    Url_base =
      [0,
       make_absolute_url,
       remove_dotdot,
       remove_end_slash,
       remove_internal_slash,
       change_empty_list,
       add_end_slash_if_missing,
       remove_slash_at_end,
       remove_slash_at_beginning,
       is_prefix_skip_end_slash,
       split_fragment,
       join_path,
       split_path,
       norm_path],
    debug = Stdlib[53],
    _l_ =
      [0,
       length,
       compare_lengths,
       compare_length_with,
       cons,
       hd,
       tl,
       nth,
       nth_opt,
       rev,
       init,
       append,
       rev_append,
       concat,
       flatten,
       equal,
       compare,
       iter$1,
       iteri,
       map$1,
       mapi,
       rev_map,
       filter_map,
       concat_map,
       fold_left_map,
       fold_left,
       fold_right,
       iter2,
       map2,
       rev_map2,
       fold_left2,
       fold_right2,
       for_all,
       exists,
       for_all2,
       exists2,
       mem,
       memq,
       find,
       find_opt,
       find_map,
       filter,
       find_all,
       filteri,
       partition,
       partition_map,
       assoc,
       assoc_opt,
       assq,
       assq_opt,
       mem_assoc,
       mem_assq,
       remove_assoc,
       remove_assq,
       split,
       combine,
       sort,
       stable_sort,
       fast_sort,
       sort_uniq,
       merge,
       to_seq,
       of_seq,
       map_filter,
       last,
       assoc_remove,
       remove_first_if_any,
       remove_first_if_any_q,
       remove_first,
       remove_first_q,
       remove_all,
       remove_all_q,
       remove_all_assoc,
       remove_all_assoc_q,
       is_prefix,
       chop,
       split_at];
   function _m_(_o_){return _o_;}
   var
    Ocsigen_lib_base =
      [0,
       Ocsigen_Internal_Error,
       Input_is_too_large,
       Ocsigen_Bad_Request,
       Ocsigen_Request_too_long,
       symbol_bind,
       symbol,
       symbol$0,
       symbol$1,
       symbol$2,
       comp,
       curry,
       uncurry,
       Tuple3,
       function(_n_){return _n_;},
       _m_,
       advert,
       Option,
       _l_,
       Clist,
       Int,
       String_base,
       Url_base,
       debug];
   runtime.caml_register_global(58, Ocsigen_lib_base, "Ocsigen_lib_base");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJvY3NpZ2VuX2xpYl9iYXNlLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJhZHZlcnQiLCJzeW1ib2xfYmluZCIsInN5bWJvbCIsInN5bWJvbCQwIiwic3ltYm9sJDEiLCJ4IiwiZiIsInN5bWJvbCQyIiwiY29tcCIsImciLCJjdXJyeSIsInkiLCJ1bmN1cnJ5IiwiZnN0IiwiYSIsInNuZCIsInRoZCIsIm1hcCIsImdldCIsImdldCQwIiwiaXRlciIsInJldHVybiQwIiwiYmluZCIsIm9wdCIsImsiLCJ0b19saXN0IiwidiIsIm1hcCQwIiwiZ2V0JDEiLCJnZXQkMiIsIml0ZXIkMCIsImJpbmQkMCIsIm1hcF9maWx0ZXIiLCJsIiwiYWNjIiwicSIsInQiLCJyIiwicmVtb3ZlX2ZpcnN0X2lmX2FueSIsImIiLCJsJDAiLCJyZW1vdmVfZmlyc3RfaWZfYW55X3EiLCJyZW1vdmVfZmlyc3QiLCJyZW1vdmVfZmlyc3RfcSIsInJlbW92ZV9hbGwiLCJyZW1vdmVfYWxsX3EiLCJyZW1vdmVfYWxsX2Fzc29jIiwicmVtb3ZlX2FsbF9hc3NvY19xIiwibGFzdCIsImFzc29jX3JlbW92ZSIsImMiLCJsbCIsImlzX3ByZWZpeCIsImwxIiwibDIiLCJsMSQwIiwibDIkMCIsImxsMiIsImxsMSIsImNob3AiLCJuIiwieHMiLCJuJDAiLCJ4cyQwIiwieHMkMSIsIm4kMSIsInNwbGl0X2F0IiwibWFrZSIsIm1ha2UkMCIsImNyZWF0ZSIsImluc2VydCIsInAiLCJyZW1vdmUiLCJpbl9saXN0IiwiaXNfZW1wdHkiLCJzZXQiLCJ2YWx1ZSIsImMkMCIsIml0ZXIkMiIsIm5vZGUiLCJub2RlJDAiLCJub2RlJDEiLCJmb2xkX2xlZnQkMCIsImEkMCIsImEkMSIsImNvbXBhcmUkMCIsInJlbW92ZV9zcGFjZXMiLCJzIiwiYmVnIiwiZW5kZCIsImZpbmRfbm90X3NwYWNlIiwiaSIsInN0ZXAiLCJpJDAiLCJpJDEiLCJmaXJzdCIsImJhc2ljX3NlcCIsImNoYXIkMCIsInNlcHBvcyIsInNlcCIsImxlbiIsInNwbGl0JDAiLCJzdGgiLCJtdWx0aXNlcCIsImxvbmd1ZXVyIiwiYXV4IiwiZGViIiwiZmlyc3RzZXAiLCJtYXlfYXBwZW5kIiwiczEiLCJzMiIsIm1heV9jb25jYXQiLCJmaXJzdF9kaWZmIiwibWFrZV9hYnNvbHV0ZV91cmwiLCJodHRwcyIsImhvc3QiLCJwb3J0IiwidXJpIiwibCQyIiwibCQxIiwicmVtb3ZlX2RvdGRvdCIsInJlbW92ZV9lbmRfc2xhc2giLCJyZW1vdmVfaW50ZXJuYWxfc2xhc2giLCJ1IiwiY2hhbmdlX2VtcHR5X2xpc3QiLCJhZGRfZW5kX3NsYXNoX2lmX21pc3NpbmciLCJyZW1vdmVfc2xhc2hfYXRfZW5kIiwicmVtb3ZlX3NsYXNoX2F0X2JlZ2lubmluZyIsImlzX3ByZWZpeF9za2lwX2VuZF9zbGFzaCIsInNwbGl0X2ZyYWdtZW50IiwicG9zIiwiam9pbl9wYXRoIiwic3BsaXRfcGF0aCIsImNvbGxlY3Rfd29yZHMiLCJrJDAiLCJ3b3JkIiwib3RoZXIiLCJub3JtX3BhdGgiLCJyZW1vdmVfc2xhc2hfc2xhc2giLCJmaXJzdCQwIiwicmVtb3ZlX2RvdCIsIngkMCIsImwkMyIsInJlbW92ZV9kb3RfZG90X29uY2UiLCJyZW1vdmVfZG90X2RvdCIsImRlYnVnIl0sInNvdXJjZXMiOlsiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9vY3NpZ2Vuc2VydmVyL2Jhc2VsaWIvYmFzZS9vY3NpZ2VuX2xpYl9iYXNlLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHQWtCQTs7Ozs7Ozs7SUE4QklBOzs7Ozs7Ozs7SUE5Qko7O0lBQ0E7O0lBQ0E7O0lBQ0E7O0lBSUlDO0lBQ0FDOzs7Ozs7Ozs7Ozs7Ozs7WUFDQUM7Ozs7OztZQUNBQyxTQUFPQyxHQUFFQyxHQUFJLE9BQUEsV0FBSkEsR0FBRkQsR0FBUztZQUNoQkUsU0FBT0QsR0FBRUQsR0FBSSxPQUFBLFdBQU5DLEdBQUVELEdBQU87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RTs7cUI7O09BZ0JBWjs7Ozs7OztPQTRYQWlKOzs7RSIsInNvdXJjZXNDb250ZW50IjpbIigqIE9jc2lnZW5cbiAqIENvcHlyaWdodCAoQykgMjAwNS0yMDA4IFZpbmNlbnQgQmFsYXQsIFN0w6lwaGFuZSBHbG9uZHVcbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yIG1vZGlmeVxuICogaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5XG4gKiB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoIGxpbmtpbmcgZXhjZXB0aW9uO1xuICogZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXQgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuICpcbiAqIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICogYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAqIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGVcbiAqIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuICpcbiAqIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZVxuICogYWxvbmcgd2l0aCB0aGlzIHByb2dyYW07IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAqIEZvdW5kYXRpb24sIEluYy4sIDU5IFRlbXBsZSBQbGFjZSAtIFN1aXRlIDMzMCwgQm9zdG9uLCBNQSAwMjExMS0xMzA3LCBVU0EuXG4gKilcblxuZXhjZXB0aW9uIE9jc2lnZW5fSW50ZXJuYWxfRXJyb3Igb2Ygc3RyaW5nXG5leGNlcHRpb24gSW5wdXRfaXNfdG9vX2xhcmdlXG5leGNlcHRpb24gT2NzaWdlbl9CYWRfUmVxdWVzdFxuZXhjZXB0aW9uIE9jc2lnZW5fUmVxdWVzdF90b29fbG9uZ1xuXG5leHRlcm5hbCBpZCA6ICdhIC0+ICdhID0gXCIlaWRlbnRpdHlcIlxuXG5sZXQgKCA+Pj0gKSA9IEx3dC5iaW5kXG5sZXQgKCA+fD0gKSA9IEx3dC4oID58PSApXG5sZXQgKCAhISApID0gTGF6eS5mb3JjZVxubGV0ICggfD4gKSB4IGYgPSBmIHhcbmxldCAoIEBAICkgZiB4ID0gZiB4XG5sZXQgY29tcCBmIGcgeCA9IGYgKGcgeClcbmxldCBjdXJyeSBmIHggeSA9IGYgKHgsIHkpXG5sZXQgdW5jdXJyeSBmICh4LCB5KSA9IGYgeCB5XG5cbnR5cGUgcG9seVxuXG5leHRlcm5hbCB0b19wb2x5IDogJ2EgLT4gcG9seSA9IFwiJWlkZW50aXR5XCJcbmV4dGVybmFsIGZyb21fcG9seSA6IHBvbHkgLT4gJ2EgPSBcIiVpZGVudGl0eVwiXG5cbm1vZHVsZSBUdXBsZTMgPSBzdHJ1Y3RcbiAgbGV0IGZzdCAoYSwgXywgXykgPSBhXG4gIGxldCBzbmQgKF8sIGEsIF8pID0gYVxuICBsZXQgdGhkIChfLCBfLCBhKSA9IGFcbmVuZFxuXG50eXBlIHllc25vbWF5YmUgPSBZZXMgfCBObyB8IE1heWJlXG50eXBlICgnYSwgJ2IpIGxlZnRyaWdodCA9IExlZnQgb2YgJ2EgfCBSaWdodCBvZiAnYlxuXG5sZXQgYWR2ZXJ0ID1cbiAgXCJQYWdlIGdlbmVyYXRlZCBieSBPQ2FtbCB3aXRoIE9jc2lnZW4uXG5TZWUgaHR0cDovL29jc2lnZW4ub3JnLyBhbmQgaHR0cDovL2NhbWwuaW5yaWEuZnIvIGZvciBpbmZvcm1hdGlvblwiXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubW9kdWxlIE9wdGlvbiA9IHN0cnVjdFxuICB0eXBlICdhIHQgPSAnYSBvcHRpb25cblxuICBsZXQgbWFwIGYgPSBmdW5jdGlvbiBTb21lIHggLT4gU29tZSAoZiB4KSB8IE5vbmUgLT4gTm9uZVxuICBsZXQgZ2V0IGYgPSBmdW5jdGlvbiBTb21lIHggLT4geCB8IE5vbmUgLT4gZiAoKVxuICBsZXQgZ2V0JyBhID0gZnVuY3Rpb24gU29tZSB4IC0+IHggfCBOb25lIC0+IGFcbiAgbGV0IGl0ZXIgZiA9IGZ1bmN0aW9uIFNvbWUgeCAtPiBmIHggfCBOb25lIC0+ICgpXG4gIGxldCByZXR1cm4geCA9IFNvbWUgeFxuICBsZXQgYmluZCBvcHQgayA9IG1hdGNoIG9wdCB3aXRoIFNvbWUgeCAtPiBrIHggfCBOb25lIC0+IE5vbmVcbiAgbGV0IHRvX2xpc3QgPSBmdW5jdGlvbiBOb25lIC0+IFtdIHwgU29tZSB2IC0+IFt2XVxuXG4gIG1vZHVsZSBMd3QgPSBzdHJ1Y3RcbiAgICBsZXQgbWFwIGYgPSBmdW5jdGlvblxuICAgICAgfCBTb21lIHggLT4gZiB4ID4+PSBmdW4gdiAtPiBMd3QucmV0dXJuIChTb21lIHYpXG4gICAgICB8IE5vbmUgLT4gTHd0LnJldHVybiBOb25lXG5cbiAgICBsZXQgZ2V0IGYgPSBmdW5jdGlvbiBTb21lIHggLT4gTHd0LnJldHVybiB4IHwgTm9uZSAtPiBmICgpXG4gICAgbGV0IGdldCcgYSA9IGZ1bmN0aW9uIFNvbWUgeCAtPiBMd3QucmV0dXJuIHggfCBOb25lIC0+IGFcbiAgICBsZXQgaXRlciBmID0gZnVuY3Rpb24gU29tZSB4IC0+IGYgeCB8IE5vbmUgLT4gTHd0LnJldHVybiAoKVxuICAgIGxldCBiaW5kIG9wdCBrID0gbWF0Y2ggb3B0IHdpdGggU29tZSB4IC0+IGsgeCB8IE5vbmUgLT4gTHd0LnJldHVybiBOb25lXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBMaXN0ID0gc3RydWN0XG4gIGluY2x1ZGUgTGlzdFxuXG4gIGxldCBtYXBfZmlsdGVyIGYgbCA9XG4gICAgbGV0IHJlYyBhdXggYWNjID0gZnVuY3Rpb25cbiAgICAgIHwgW10gLT4gYWNjXG4gICAgICB8IHQgOjogcSAtPiAoXG4gICAgICAgIG1hdGNoIGYgdCB3aXRoIE5vbmUgLT4gYXV4IGFjYyBxIHwgU29tZSByIC0+IGF1eCAociA6OiBhY2MpIHEpXG4gICAgaW5cbiAgICBMaXN0LnJldiAoYXV4IFtdIGwpXG5cbiAgbGV0IHJlYyByZW1vdmVfZmlyc3RfaWZfYW55IGEgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IGIgOjogbCB3aGVuIGEgPSBiIC0+IGxcbiAgICB8IGIgOjogbCAtPiBiIDo6IHJlbW92ZV9maXJzdF9pZl9hbnkgYSBsXG5cbiAgbGV0IHJlYyByZW1vdmVfZmlyc3RfaWZfYW55X3EgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgYiA6OiBsIHdoZW4gYSA9PSBiIC0+IGxcbiAgICB8IGIgOjogbCAtPiBiIDo6IHJlbW92ZV9maXJzdF9pZl9hbnlfcSBhIGxcblxuICBsZXQgcmVjIHJlbW92ZV9maXJzdCBhID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgIHwgYiA6OiBsIHdoZW4gYSA9IGIgLT4gbFxuICAgIHwgYiA6OiBsIC0+IGIgOjogcmVtb3ZlX2ZpcnN0IGEgbFxuXG4gIGxldCByZWMgcmVtb3ZlX2ZpcnN0X3EgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICB8IGIgOjogbCB3aGVuIGEgPT0gYiAtPiBsXG4gICAgfCBiIDo6IGwgLT4gYiA6OiByZW1vdmVfZmlyc3RfcSBhIGxcblxuICBsZXQgcmVjIHJlbW92ZV9hbGwgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgYiA6OiBsIHdoZW4gYSA9IGIgLT4gcmVtb3ZlX2FsbCBhIGxcbiAgICB8IGIgOjogbCAtPiBiIDo6IHJlbW92ZV9hbGwgYSBsXG5cbiAgbGV0IHJlYyByZW1vdmVfYWxsX3EgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgYiA6OiBsIHdoZW4gYSA9PSBiIC0+IHJlbW92ZV9hbGxfcSBhIGxcbiAgICB8IGIgOjogbCAtPiBiIDo6IHJlbW92ZV9hbGxfcSBhIGxcblxuICBsZXQgcmVjIHJlbW92ZV9hbGxfYXNzb2MgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXVxuICAgIHwgKGIsIF8pIDo6IGwgd2hlbiBhID0gYiAtPiByZW1vdmVfYWxsX2Fzc29jIGEgbFxuICAgIHwgYiA6OiBsIC0+IGIgOjogcmVtb3ZlX2FsbF9hc3NvYyBhIGxcblxuICBsZXQgcmVjIHJlbW92ZV9hbGxfYXNzb2NfcSBhID0gZnVuY3Rpb25cbiAgICB8IFtdIC0+IFtdXG4gICAgfCAoYiwgXykgOjogbCB3aGVuIGEgPT0gYiAtPiByZW1vdmVfYWxsX2Fzc29jX3EgYSBsXG4gICAgfCBiIDo6IGwgLT4gYiA6OiByZW1vdmVfYWxsX2Fzc29jX3EgYSBsXG5cbiAgbGV0IHJlYyBsYXN0ID0gZnVuY3Rpb24gW10gLT4gcmFpc2UgTm90X2ZvdW5kIHwgW2JdIC0+IGIgfCBfIDo6IGwgLT4gbGFzdCBsXG5cbiAgbGV0IHJlYyBhc3NvY19yZW1vdmUgYSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICB8IChiLCBjKSA6OiBsIHdoZW4gYSA9IGIgLT4gYywgbFxuICAgIHwgYiA6OiBsIC0+XG4gICAgICAgIGxldCB2LCBsbCA9IGFzc29jX3JlbW92ZSBhIGwgaW5cbiAgICAgICAgdiwgYiA6OiBsbFxuXG4gIGxldCByZWMgaXNfcHJlZml4IGwxIGwyID1cbiAgICBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgW10sIF8gLT4gdHJ1ZVxuICAgIHwgYSA6OiBsbDEsIGIgOjogbGwyIHdoZW4gYSA9IGIgLT4gaXNfcHJlZml4IGxsMSBsbDJcbiAgICB8IF8gLT4gZmFsc2VcblxuICBsZXQgcmVjIGNob3AgbiB4cyA9XG4gICAgaWYgbiA8PSAwXG4gICAgdGhlbiB4c1xuICAgIGVsc2UgbWF0Y2ggeHMgd2l0aCBbXSAtPiBbXSB8IF94IDo6IHhzIC0+IGNob3AgKG4gLSAxKSB4c1xuXG4gIGxldCByZWMgc3BsaXRfYXQgbiB4cyA9XG4gICAgaWYgbiA8PSAwXG4gICAgdGhlbiBbXSwgeHNcbiAgICBlbHNlXG4gICAgICBtYXRjaCB4cyB3aXRoXG4gICAgICB8IFtdIC0+IFtdLCBbXVxuICAgICAgfCB4IDo6IHhzIC0+XG4gICAgICAgICAgbGV0IGwsIHIgPSBzcGxpdF9hdCAobiAtIDEpIHhzIGluXG4gICAgICAgICAgeCA6OiBsLCByXG5lbmRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG4oKiBjaXJjdWxhciBsaXN0cyAqKVxubW9kdWxlIENsaXN0IDogc2lnXG4gIHR5cGUgJ2EgdFxuICB0eXBlICdhIG5vZGVcblxuICB2YWwgbWFrZSA6ICdhIC0+ICdhIG5vZGVcbiAgdmFsIGNyZWF0ZSA6IHVuaXQgLT4gJ2EgdFxuICB2YWwgaW5zZXJ0IDogJ2EgdCAtPiAnYSBub2RlIC0+IHVuaXRcbiAgdmFsIHJlbW92ZSA6ICdhIG5vZGUgLT4gdW5pdFxuICB2YWwgdmFsdWUgOiAnYSBub2RlIC0+ICdhXG4gIHZhbCBpbl9saXN0IDogJ2Egbm9kZSAtPiBib29sXG4gIHZhbCBpc19lbXB0eSA6ICdhIHQgLT4gYm9vbFxuICB2YWwgaXRlciA6ICgnYSAtPiB1bml0KSAtPiAnYSB0IC0+IHVuaXRcbiAgdmFsIGZvbGRfbGVmdCA6ICgnYSAtPiAnYiAtPiAnYSkgLT4gJ2EgLT4gJ2IgdCAtPiAnYVxuZW5kID0gc3RydWN0XG4gIHR5cGUgJ2Egbm9kZSA9XG4gICAge2NvbnRlbnQgOiAnYSBvcHRpb247IG11dGFibGUgcHJldiA6ICdhIG5vZGU7IG11dGFibGUgbmV4dCA6ICdhIG5vZGV9XG5cbiAgdHlwZSAnYSB0ID0gJ2Egbm9kZVxuXG4gIGxldCBtYWtlJyBjID1cbiAgICBsZXQgcmVjIHggPSB7Y29udGVudCA9IGM7IHByZXYgPSB4OyBuZXh0ID0geH0gaW5cbiAgICB4XG5cbiAgbGV0IG1ha2UgYyA9IG1ha2UnIChTb21lIGMpXG4gIGxldCBjcmVhdGUgKCkgPSBtYWtlJyBOb25lXG5cbiAgbGV0IGluc2VydCBwIHggPVxuICAgIGxldCBuID0gcC5uZXh0IGluXG4gICAgcC5uZXh0IDwtIHg7XG4gICAgeC5wcmV2IDwtIHA7XG4gICAgeC5uZXh0IDwtIG47XG4gICAgbi5wcmV2IDwtIHhcblxuICBsZXQgcmVtb3ZlIHggPVxuICAgIGxldCBwID0geC5wcmV2IGluXG4gICAgbGV0IG4gPSB4Lm5leHQgaW5cbiAgICBwLm5leHQgPC0gbjtcbiAgICBuLnByZXYgPC0gcDtcbiAgICB4Lm5leHQgPC0geDtcbiAgICB4LnByZXYgPC0geFxuXG4gIGxldCBpbl9saXN0IHggPSB4Lm5leHQgIT0geFxuICBsZXQgaXNfZW1wdHkgc2V0ID0gc2V0Lm5leHQgPT0gc2V0XG5cbiAgbGV0IHZhbHVlIGMgPVxuICAgIG1hdGNoIGMuY29udGVudCB3aXRoIE5vbmUgLT4gZmFpbHdpdGggXCJDbGlzdC52YWx1ZVwiIHwgU29tZSBjIC0+IGNcblxuICBsZXQgcmVjIGl0ZXIgZiAobm9kZSA6ICdhIHQpID1cbiAgICBtYXRjaCBub2RlLm5leHQuY29udGVudCB3aXRoIFNvbWUgYyAtPiBmIGM7IGl0ZXIgZiBub2RlLm5leHQgfCBOb25lIC0+ICgpXG5cbiAgbGV0IHJlYyBmb2xkX2xlZnQgZiBhIChub2RlIDogJ2EgdCkgPVxuICAgIG1hdGNoIG5vZGUubmV4dC5jb250ZW50IHdpdGhcbiAgICB8IFNvbWUgYyAtPiBmb2xkX2xlZnQgZiAoZiBhIGMpIG5vZGUubmV4dFxuICAgIHwgTm9uZSAtPiBhXG5lbmRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgSW50ID0gc3RydWN0XG4gIG1vZHVsZSBUYWJsZSA9IE1hcC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnRcblxuICAgIGxldCBjb21wYXJlID0gY29tcGFyZVxuICBlbmQpXG5lbmRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgU3RyaW5nX2Jhc2UgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBTdHJpbmdcblxuICAoKiBSZXR1cm5zIGEgY29weSBvZiB0aGUgc3RyaW5nIGZyb20gYmVnIHRvIGVuZGQsXG4gICAgIHJlbW92aW5nIHNwYWNlcyBhdCB0aGUgYmVnaW5uaW5nIGFuZCBhdCB0aGUgZW5kICopXG4gIGxldCByZW1vdmVfc3BhY2VzIHMgYmVnIGVuZGQgPVxuICAgIGxldCByZWMgZmluZF9ub3Rfc3BhY2UgcyBpIHN0ZXAgPVxuICAgICAgaWYgaSA+IGVuZGQgfHwgYmVnID4gaVxuICAgICAgdGhlbiBpXG4gICAgICBlbHNlIGlmIHMuW2ldID0gJyAnXG4gICAgICB0aGVuIGZpbmRfbm90X3NwYWNlIHMgKGkgKyBzdGVwKSBzdGVwXG4gICAgICBlbHNlIGlcbiAgICBpblxuICAgIGxldCBmaXJzdCA9IGZpbmRfbm90X3NwYWNlIHMgYmVnIDEgaW5cbiAgICBsZXQgbGFzdCA9IGZpbmRfbm90X3NwYWNlIHMgZW5kZCAoLTEpIGluXG4gICAgaWYgbGFzdCA+PSBmaXJzdCB0aGVuIFN0cmluZy5zdWIgcyBmaXJzdCAoMSArIGxhc3QgLSBmaXJzdCkgZWxzZSBcIlwiXG5cbiAgKCogQ3V0IGEgc3RyaW5nIHRvIHRoZSBuZXh0IHNlcGFyYXRvciAqKVxuICBsZXQgYmFzaWNfc2VwIGNoYXIgcyA9XG4gICAgdHJ5XG4gICAgICBsZXQgc2VwcG9zID0gU3RyaW5nLmluZGV4IHMgY2hhciBpblxuICAgICAgKCBTdHJpbmcuc3ViIHMgMCBzZXBwb3NcbiAgICAgICwgU3RyaW5nLnN1YiBzIChzZXBwb3MgKyAxKSAoU3RyaW5nLmxlbmd0aCBzIC0gc2VwcG9zIC0gMSkgKVxuICAgIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IHJhaXNlIE5vdF9mb3VuZFxuXG4gICgqIEN1dCBhIHN0cmluZyB0byB0aGUgbmV4dCBzZXBhcmF0b3IsIHJlbW92aW5nIHNwYWNlcy5cbiAgICAgUmFpc2VzIE5vdF9mb3VuZCBpZiB0aGUgc2VwYXJhdG9yIGNhbm5vdCBiZSBmb3VuZC5cbiAgKilcbiAgbGV0IHNlcCBjaGFyIHMgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgc2VwcG9zID0gU3RyaW5nLmluZGV4IHMgY2hhciBpblxuICAgIHJlbW92ZV9zcGFjZXMgcyAwIChzZXBwb3MgLSAxKSwgcmVtb3ZlX3NwYWNlcyBzIChzZXBwb3MgKyAxKSAobGVuIC0gMSlcblxuICAoKiBzcGxpdHMgYSBzdHJpbmcsIGZvciBleCBcImF6ZXJ0LCAgIHNkZm1sc2tkZiwgICAgZGZkc2ZzXCIgKilcbiAgbGV0IHNwbGl0ID8obXVsdGlzZXAgPSBmYWxzZSkgY2hhciBzID1cbiAgICBsZXQgbG9uZ3VldXIgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgICBsZXQgcmVjIGF1eCBkZWIgPVxuICAgICAgaWYgZGViID49IGxvbmd1ZXVyXG4gICAgICB0aGVuIFtdXG4gICAgICBlbHNlXG4gICAgICAgIHRyeVxuICAgICAgICAgIGxldCBmaXJzdHNlcCA9IFN0cmluZy5pbmRleF9mcm9tIHMgZGViIGNoYXIgaW5cbiAgICAgICAgICBpZiBtdWx0aXNlcCAmJiBmaXJzdHNlcCA9IGRlYlxuICAgICAgICAgIHRoZW4gYXV4IChkZWIgKyAxKVxuICAgICAgICAgIGVsc2UgcmVtb3ZlX3NwYWNlcyBzIGRlYiAoZmlyc3RzZXAgLSAxKSA6OiBhdXggKGZpcnN0c2VwICsgMSlcbiAgICAgICAgd2l0aCBOb3RfZm91bmQgLT4gW3JlbW92ZV9zcGFjZXMgcyBkZWIgKGxvbmd1ZXVyIC0gMSldXG4gICAgaW5cbiAgICBhdXggMFxuXG4gIGxldCBtYXlfYXBwZW5kIHMxIH5zZXAgPSBmdW5jdGlvbiBcIlwiIC0+IHMxIHwgczIgLT4gczEgXiBzZXAgXiBzMlxuXG4gIGxldCBtYXlfY29uY2F0IHMxIH5zZXAgczIgPVxuICAgIG1hdGNoIHMxLCBzMiB3aXRoXG4gICAgfCBfLCBcIlwiIC0+IHMxXG4gICAgfCBcIlwiLCBfIC0+IHMyXG4gICAgfCBfIC0+IFN0cmluZy5jb25jYXQgc2VwIFtzMTsgczJdXG5cbiAgKCogcmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRpZmZlcmVuY2UgYmV0d2VlbiBzMSBhbmQgczIsXG4gICAgIHN0YXJ0aW5nIGZyb20gbiBhbmQgZW5kaW5nIGF0IGxhc3QuXG4gICAgIHJldHVybnMgKGxhc3QgKyAxKSBpZiBubyBkaWZmZXJlbmNlIGlzIGZvdW5kLlxuICAqKVxuICBsZXQgcmVjIGZpcnN0X2RpZmYgczEgczIgbiBsYXN0ID1cbiAgICB0cnlcbiAgICAgIGlmIHMxLltuXSA9IHMyLltuXVxuICAgICAgdGhlbiBpZiBuID0gbGFzdCB0aGVuIGxhc3QgKyAxIGVsc2UgZmlyc3RfZGlmZiBzMSBzMiAobiArIDEpIGxhc3RcbiAgICAgIGVsc2UgblxuICAgIHdpdGggSW52YWxpZF9hcmd1bWVudCBfIC0+IG5cblxuICBtb2R1bGUgVGFibGUgPSBNYXAuTWFrZSAoU3RyaW5nKVxuICBtb2R1bGUgU2V0ID0gU2V0Lk1ha2UgKFN0cmluZylcbiAgbW9kdWxlIE1hcCA9IE1hcC5NYWtlIChTdHJpbmcpXG5lbmRcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKVxuXG5tb2R1bGUgVXJsX2Jhc2UgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0gc3RyaW5nXG4gIHR5cGUgdXJpID0gc3RyaW5nXG4gIHR5cGUgcGF0aCA9IHN0cmluZyBsaXN0XG5cbiAgbGV0IG1ha2VfYWJzb2x1dGVfdXJsIH5odHRwcyB+aG9zdCB+cG9ydCB1cmkgPVxuICAgIChpZiBodHRwcyB0aGVuIFwiaHR0cHM6Ly9cIiBlbHNlIFwiaHR0cDovL1wiKVxuICAgIF4gaG9zdFxuICAgIF4gKGlmIChwb3J0ID0gODAgJiYgbm90IGh0dHBzKSB8fCAoaHR0cHMgJiYgcG9ydCA9IDQ0MylcbiAgICAgIHRoZW4gXCJcIlxuICAgICAgZWxzZSBcIjpcIiBeIHN0cmluZ19vZl9pbnQgcG9ydClcbiAgICBeIHVyaVxuXG4gIGxldCByZW1vdmVfZG90ZG90ID1cbiAgICAoKiByZW1vdmVzIFwiLi4vXCIgKilcbiAgICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IFtdXG4gICAgICB8IFtcIlwiXSBhcyBsIC0+XG4gICAgICAgICAgbFxuICAgICAgICAgICgqICAgIHwgXCJcIjo6bCAtPiBhdXggbCAqKVxuICAgICAgICAgICgqIHdlIGRvIG5vdCByZW1vdmUgXCIvL1wiIGFueSBtb3JlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiZWNhdXNlIG9mIG9wdGlvbmFsIHN1ZmZpeGVzIGluIEVsaW9tICopXG4gICAgICB8IFwiLi5cIiA6OiBsIC0+IGF1eCBsXG4gICAgICB8IGEgOjogbCAtPiBhIDo6IGF1eCBsXG4gICAgaW5cbiAgICBmdW5jdGlvbiBbXSAtPiBbXSB8IFwiXCIgOjogbCAtPiBcIlwiIDo6IGF1eCBsIHwgbCAtPiBhdXggbFxuXG4gIGxldCByZW1vdmVfZW5kX3NsYXNoIHMgPVxuICAgIHRyeVxuICAgICAgaWYgcy5bU3RyaW5nLmxlbmd0aCBzIC0gMV0gPSAnLydcbiAgICAgIHRoZW4gU3RyaW5nLnN1YiBzIDAgKFN0cmluZy5sZW5ndGggcyAtIDEpXG4gICAgICBlbHNlIHNcbiAgICB3aXRoIEludmFsaWRfYXJndW1lbnQgXyAtPiBzXG5cbiAgbGV0IHJlbW92ZV9pbnRlcm5hbF9zbGFzaCB1ID1cbiAgICBsZXQgcmVjIGF1eCA9IGZ1bmN0aW9uXG4gICAgICB8IFtdIC0+IFtdXG4gICAgICB8IFthXSAtPiBbYV1cbiAgICAgIHwgXCJcIiA6OiBsIC0+IGF1eCBsXG4gICAgICB8IGEgOjogbCAtPiBhIDo6IGF1eCBsXG4gICAgaW5cbiAgICBtYXRjaCB1IHdpdGggW10gLT4gW10gfCBhIDo6IGwgLT4gYSA6OiBhdXggbFxuXG4gIGxldCBjaGFuZ2VfZW1wdHlfbGlzdCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXCJcIl0gKCogSXQgaXMgbm90IHBvc3NpYmxlIHRvIHJlZ2lzdGVyIGFuIGVtcHR5IFVSTCAqKVxuICAgIHwgbCAtPiBsXG5cbiAgbGV0IHJlYyBhZGRfZW5kX3NsYXNoX2lmX21pc3NpbmcgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW1wiXCJdXG4gICAgfCBbXCJcIl0gYXMgYSAtPiBhXG4gICAgfCBhIDo6IGwgLT4gYSA6OiBhZGRfZW5kX3NsYXNoX2lmX21pc3NpbmcgbFxuXG4gIGxldCByZWMgcmVtb3ZlX3NsYXNoX2F0X2VuZCA9IGZ1bmN0aW9uXG4gICAgfCBbXSB8IFtcIlwiXSAtPiBbXVxuICAgIHwgYSA6OiBsIC0+IGEgOjogcmVtb3ZlX3NsYXNoX2F0X2VuZCBsXG5cbiAgbGV0IHJlbW92ZV9zbGFzaF9hdF9iZWdpbm5pbmcgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gW11cbiAgICB8IFtcIlwiXSAtPiBbXCJcIl1cbiAgICB8IFwiXCIgOjogbCAtPiBsXG4gICAgfCBsIC0+IGxcblxuICBsZXQgcmVjIGlzX3ByZWZpeF9za2lwX2VuZF9zbGFzaCBsMSBsMiA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtcIlwiXSwgXyB8IFtdLCBfIC0+IHRydWVcbiAgICB8IGEgOjogbGwxLCBiIDo6IGxsMiB3aGVuIGEgPSBiIC0+IGlzX3ByZWZpeF9za2lwX2VuZF9zbGFzaCBsbDEgbGwyXG4gICAgfCBfIC0+IGZhbHNlXG5cbiAgbGV0IHNwbGl0X2ZyYWdtZW50IHMgPVxuICAgIHRyeVxuICAgICAgbGV0IHBvcyA9IFN0cmluZy5pbmRleCBzICcjJyBpblxuICAgICAgKCBTdHJpbmcuc3ViIHMgMCBwb3NcbiAgICAgICwgU29tZSAoU3RyaW5nLnN1YiBzIChwb3MgKyAxKSAoU3RyaW5nLmxlbmd0aCBzIC0gMSAtIHBvcykpIClcbiAgICB3aXRoIE5vdF9mb3VuZCAtPiBzLCBOb25lXG5cbiAgbGV0IGpvaW5fcGF0aCA9IGZ1bmN0aW9uIFtcIlwiXSAtPiBcIi9cIiB8IGwgLT4gU3RyaW5nLmNvbmNhdCBcIi9cIiBsXG5cbiAgKCogVGFrZW4gZnJvbSBPY2FtbG5ldCA0LjEuMiAqKVxuICBsZXQgc3BsaXRfcGF0aCBzID1cbiAgICBsZXQgbCA9IFN0cmluZy5sZW5ndGggcyBpblxuICAgIGxldCByZWMgY29sbGVjdF93b3JkcyBrID1cbiAgICAgIGxldCBrJyA9IHRyeSBTdHJpbmcuaW5kZXhfZnJvbSBzIGsgJy8nIHdpdGggTm90X2ZvdW5kIC0+IGwgaW5cbiAgICAgIGxldCB3b3JkID0gU3RyaW5nLnN1YiBzIGsgKGsnIC0gaykgaW5cbiAgICAgIGlmIGsnID49IGwgdGhlbiBbd29yZF0gZWxzZSB3b3JkIDo6IGNvbGxlY3Rfd29yZHMgKGsnICsgMSlcbiAgICBpblxuICAgIG1hdGNoIGNvbGxlY3Rfd29yZHMgMCB3aXRoIFtcIlwiXSAtPiBbXSB8IFtcIlwiOyBcIlwiXSAtPiBbXCJcIl0gfCBvdGhlciAtPiBvdGhlclxuXG4gICgqIFRha2VuIGZyb20gT2NhbWxuZXQgNC4xLjIgKilcbiAgbGV0IG5vcm1fcGF0aCBsID1cbiAgICBsZXQgcmVjIHJlbW92ZV9zbGFzaF9zbGFzaCBsIGZpcnN0ID1cbiAgICAgIG1hdGNoIGwgd2l0aFxuICAgICAgfCBbXCJcIl0gLT4gW1wiXCJdXG4gICAgICB8IFtcIlwiOyBcIlwiXSB3aGVuIGZpcnN0IC0+IFtcIlwiXVxuICAgICAgfCBcIlwiIDo6IGwnIHdoZW4gbm90IGZpcnN0IC0+IHJlbW92ZV9zbGFzaF9zbGFzaCBsJyBmYWxzZVxuICAgICAgfCB4IDo6IGwnIC0+IHggOjogcmVtb3ZlX3NsYXNoX3NsYXNoIGwnIGZhbHNlXG4gICAgICB8IFtdIC0+IFtdXG4gICAgaW5cbiAgICBsZXQgcmVjIHJlbW92ZV9kb3QgbCBmaXJzdCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW1wiLlwiXSB8IFtcIi5cIjsgXCJcIl0gLT4gaWYgZmlyc3QgdGhlbiBbXSBlbHNlIFtcIlwiXVxuICAgICAgfCBcIi5cIiA6OiB4IDo6IGwnIC0+IHJlbW92ZV9kb3QgKHggOjogbCcpIGZhbHNlXG4gICAgICB8IHggOjogbCcgLT4geCA6OiByZW1vdmVfZG90IGwnIGZhbHNlXG4gICAgICB8IFtdIC0+IFtdXG4gICAgaW5cbiAgICBsZXQgcmVjIHJlbW92ZV9kb3RfZG90X29uY2UgbCBmaXJzdCA9XG4gICAgICBtYXRjaCBsIHdpdGhcbiAgICAgIHwgW3g7IFwiLi5cIl0gd2hlbiB4IDw+IFwiXCIgJiYgeCA8PiBcIi4uXCIgJiYgbm90IGZpcnN0IC0+IFtcIlwiXVxuICAgICAgfCB4IDo6IFwiLi5cIiA6OiBsJyB3aGVuIHggPD4gXCJcIiAmJiB4IDw+IFwiLi5cIiAtPiBsJ1xuICAgICAgfCB4IDo6IGwnIC0+IHggOjogcmVtb3ZlX2RvdF9kb3Rfb25jZSBsJyBmYWxzZVxuICAgICAgfCBbXSAtPiByYWlzZSBOb3RfZm91bmRcbiAgICBpblxuICAgIGxldCByZWMgcmVtb3ZlX2RvdF9kb3QgbCA9XG4gICAgICB0cnlcbiAgICAgICAgbGV0IGwnID0gcmVtb3ZlX2RvdF9kb3Rfb25jZSBsIHRydWUgaW5cbiAgICAgICAgcmVtb3ZlX2RvdF9kb3QgbCdcbiAgICAgIHdpdGggTm90X2ZvdW5kIC0+IGxcbiAgICBpblxuICAgIGxldCBsJyA9IHJlbW92ZV9kb3RfZG90IChyZW1vdmVfZG90IChyZW1vdmVfc2xhc2hfc2xhc2ggbCB0cnVlKSB0cnVlKSBpblxuICAgIG1hdGNoIGwnIHdpdGggW1wiLi5cIl0gLT4gW1wiLi5cIjsgXCJcIl0gfCBbXCJcIjsgXCJcIl0gLT4gW1wiXCJdIHwgXyAtPiBsJ1xuZW5kXG5cbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxubGV0IGRlYnVnID0gcHJlcnJfZW5kbGluZVxuIl19
