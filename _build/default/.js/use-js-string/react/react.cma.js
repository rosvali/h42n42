// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: React
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__List, Stdlib__Weak
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_src_react_ml = "src/react.ml",
    caml_equal = runtime.caml_equal,
    caml_int_compare = runtime.caml_int_compare,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    err_max_rank = "maximal rank exceeded",
    err_sig_undef = "signal value undefined yet",
    err_fix = "trying to fix a delayed value",
    err_retain_never = "E.never cannot retain a closure",
    err_retain_cst_sig = "constant signals cannot retain a closure",
    err_step_executed = "step already executed",
    err_event_scheduled = "event already scheduled on a step",
    err_signal_scheduled = "signal already scheduled on a step",
    one = [0, 1],
    zero = [0, 0],
    zero$0 = [0, 0],
    one$0 = [0, 1],
    minus_one = [0, -1],
    zero$1 = [0, 0.],
    one$1 = [0, 1.],
    minus_one$0 = [0, -1.],
    none = [0, 0],
    Assert_failure = global_data.Assert_failure,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Weak = global_data.Stdlib__Weak,
    _i_ = [0, cst_src_react_ml, 1526, 17],
    _h_ = [0, cst_src_react_ml, 1112, 18],
    _g_ = [0, cst_src_react_ml, 994, 36],
    _f_ = [0, cst_src_react_ml, 760, 45],
    _e_ = [0, cst_src_react_ml, 731, 53],
    _d_ = [0, cst_src_react_ml, 701, 19],
    _c_ = [0, 1],
    _b_ = [0, cst_src_react_ml, 421, 51],
    _a_ = [0, cst_src_react_ml, 410, 54];
   function create(size){return [0, caml_call1(Stdlib_Weak[1], size), 0];}
   function clear(a){
    a[1] = caml_call1(Stdlib_Weak[1], 0);
    a[2] = 0;
    return 0;
   }
   function get(a, i){return caml_call2(Stdlib_Weak[4], a[1], i);}
   function swap(a, i$0, i){
    var v = caml_call2(Stdlib_Weak[4], a[1], i);
    caml_call5(Stdlib_Weak[8], a[1], i$0, a[1], i, 1);
    return caml_call3(Stdlib_Weak[3], a[1], i$0, v);
   }
   function add(a, v){
    var _cR_ = caml_call1(Stdlib_Weak[2], a[1]);
    if(a[2] === _cR_){
     var arr = caml_call1(Stdlib_Weak[1], 2 * (a[2] + 1 | 0) | 0);
     caml_call5(Stdlib_Weak[8], a[1], 0, arr, 0, a[2]);
     a[1] = arr;
    }
    caml_call3(Stdlib_Weak[3], a[1], a[2], [0, v]);
    a[2] = a[2] + 1 | 0;
    return 0;
   }
   function rem_last(a){
    var l = a[2] - 1 | 0;
    a[2] = l;
    return caml_call3(Stdlib_Weak[3], a[1], l, 0);
   }
   function fold(f, acc, a){
    var acc$0 = [0, acc], _cP_ = a[2] - 1 | 0, _cO_ = 0;
    if(_cP_ >= 0){
     var i = _cO_;
     for(;;){
      var match = caml_call2(Stdlib_Weak[4], a[1], i);
      if(match){var v = match[1]; acc$0[1] = caml_call2(f, acc$0[1], v);}
      var _cQ_ = i + 1 | 0;
      if(_cP_ === i) break;
      var i = _cQ_;
     }
    }
    return acc$0[1];
   }
   function compare_down(h, i$0, i){
    var match = get(h, i$0), match$0 = get(h, i);
    if(! match) return match$0 ? -1 : 0;
    var n = match[1];
    if(! match$0) return 1;
    var n$0 = match$0[1];
    return caml_int_compare(n[1], n$0[1]);
   }
   function down(h, i){
    var i$0 = i;
    for(;;){
     var
      last = h[2] - 1 | 0,
      start = 2 * i$0 | 0,
      l = start + 1 | 0,
      r = start + 2 | 0;
     if(last < l) return 0;
     var
      child = last < r ? l : 0 <= compare_down(h, l, r) ? r : l,
      _cN_ = 0 < compare_down(h, i$0, child) ? 1 : 0;
     if(! _cN_) return _cN_;
     swap(h, i$0, child);
     var i$0 = child;
    }
   }
   var delayed_rank = Stdlib[19], nil = [0, 1, create(0), 0, 0];
   function create$0(param){var h = create(11); return [0, 0, h, 0, 0];}
   function add$0(c, n$1){
    if(n$1[2] === c) return 0;
    n$1[2] = c;
    var h = c[2];
    add(h, n$1);
    var i$0 = h[2] - 1 | 0, i = i$0, last_none = 0;
    for(;;){
     if(0 === i) return last_none ? down(h, 0) : last_none;
     var p = (i - 1 | 0) / 2 | 0, match = get(h, i), match$0 = get(h, p);
     if(! match) return 0;
     var n = match[1];
     if(match$0){
      var n$0 = match$0[1];
      if(0 <= caml_int_compare(n[1], n$0[1]))
       return last_none ? down(h, i) : last_none;
      swap(h, i, p);
      var i = p, last_none = 0;
     }
     else{swap(h, i, p); var i = p, last_none = 1;}
    }
   }
   function add_deps(c, n){
    var a = n[6], _cL_ = a[2] - 1 | 0, _cK_ = 0;
    if(_cL_ >= 0){
     var i = _cK_;
     for(;;){
      var match = caml_call2(Stdlib_Weak[4], a[1], i);
      if(match){var v = match[1]; add$0(c, v);}
      var _cM_ = i + 1 | 0;
      if(_cL_ === i) break;
      var i = _cM_;
     }
    }
    return 0;
   }
   function add_eop(c, op){c[3] = [0, op, c[3]]; return 0;}
   function allow_reschedule(n){n[2] = nil; return;}
   function rebuild(c){
    var h = c[2], _cI_ = (h[2] - 2 | 0) / 2 | 0;
    if(_cI_ >= 0){
     var i = _cI_;
     for(;;){
      down(h, i);
      var _cJ_ = i - 1 | 0;
      if(0 === i) break;
      var i = _cJ_;
     }
    }
    return 0;
   }
   function execute(c$1){
    if(c$1[1]) return caml_call1(Stdlib[1], err_step_executed);
    var c = c$1;
    for(;;){
     var
      eops =
        function(c){
         var _cG_ = c[3];
         function _cH_(op){return caml_call1(op, 0);}
         caml_call2(Stdlib_List[17], _cH_, _cG_);
         c[3] = 0;
         return;
        },
      cops =
        function(c){
         var _cE_ = c[4];
         function _cF_(op){return caml_call1(op, 0);}
         caml_call2(Stdlib_List[17], _cF_, _cE_);
         c[4] = 0;
         return;
        },
      finish = function(c){c[1] = 1; c[2] = create(0); return 0;};
     for(;;){
      var a = c[2];
      a:
      {
       b:
       {
        for(;;){
         var s = a[2];
         if(0 === s) break b;
         var v = get(a, 0);
         if(1 < s){
          var _cB_ = get(a, s - 1 | 0);
          caml_call1(caml_call2(Stdlib_Weak[3], a[1], 0), _cB_);
          rem_last(a);
          down(a, 0);
         }
         else
          rem_last(a);
         if(v) break;
        }
        var match = v;
        break a;
       }
       var match = 0;
      }
      if(! match){eops(c); cops(c); return finish(c);}
      var n = match[1];
      if(n[1] === delayed_rank) break;
      caml_call1(n[5], c);
     }
     var c$0 = create$0(0);
     eops(c);
     var
      h = c[2],
      _cA_ = 0,
      _cC_ = [0, n, fold(function(acc, e){return [0, e, acc];}, _cA_, h)],
      _cD_ =
        function(c){return function(n){return caml_call1(n[5], c);};}(c$0);
     caml_call2(Stdlib_List[17], _cD_, _cC_);
     cops(c);
     finish(c);
     var c = c$0;
    }
   }
   function find_unfinished(nl){
    var next = 0, param = [0, nl, 0];
    for(;;)
     if(param){
      var nl$0 = param[1];
      if(nl$0){
       var todo = param[2], next$0 = next, param$0 = nl$0;
       for(;;){
        if(! param$0) break;
        var nl$1 = param$0[2], n = param$0[1];
        if(! n[2][1]) return n[2];
        var
         next$1 = [0, caml_call1(n[4], 0), next$0],
         next$0 = next$1,
         param$0 = nl$1;
       }
       var next = next$0, param = todo;
      }
      else
       var todo$0 = param[2], param = todo$0;
     }
     else{if(0 === next) return nil; var param = next, next = 0;}
   }
   var min_rank = Stdlib[20], max_rank = delayed_rank - 1 | 0;
   function nop(param){return 0;}
   function no_producers(param){return 0;}
   function create$1(r){
    return [0, r, nil, nop, no_producers, nop, create(0)];
   }
   function rem_dep(n$0, n){
    var a = n$0[6];
    try{
     var _cx_ = a[2] - 1 | 0, _cw_ = 0;
     if(_cx_ >= 0){
      var i = _cw_;
      for(;;){
       var match = caml_call2(Stdlib_Weak[4], a[1], i);
       if(match){
        var v = match[1];
        if(n === v){
         caml_call3(Stdlib_Weak[3], a[1], i, 0);
         throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        }
       }
       var _cy_ = i + 1 | 0;
       if(_cx_ === i) break;
       var i = _cy_;
      }
     }
     return;
    }
    catch(_cz_){
     var _cv_ = caml_wrap_exception(_cz_);
     if(_cv_ === Stdlib[3]) return;
     throw caml_maybe_attach_backtrace(_cv_, 0);
    }
   }
   function add_dep(n$0, n){
    var a = n$0[6];
    try{
     var _cr_ = a[2] - 1 | 0, _cq_ = 0;
     if(_cr_ >= 0){
      var i = _cq_;
      for(;;){
       if(! caml_call2(Stdlib_Weak[4], a[1], i)){
        caml_call3(Stdlib_Weak[3], a[1], i, [0, n]);
        throw caml_maybe_attach_backtrace(Stdlib[3], 1);
       }
       var _ct_ = i + 1 | 0;
       if(_cr_ === i) break;
       var i = _ct_;
      }
     }
     var _cs_ = add(a, n);
     return _cs_;
    }
    catch(_cu_){
     var _cp_ = caml_wrap_exception(_cu_);
     if(_cp_ === Stdlib[3]) return 0;
     throw caml_maybe_attach_backtrace(_cp_, 0);
    }
   }
   function deps(n){
    var _cn_ = n[6], _co_ = 0;
    return fold(function(acc, d){return [0, d, acc];}, _co_, _cn_);
   }
   function bind(n, p, u){n[4] = p; n[5] = u; return 0;}
   function stop(opt, to_rem){
    if(opt) var sth = opt[1], strong = sth; else var strong = 0;
    if(! strong){
     to_rem[4] = no_producers;
     to_rem[5] = nop;
     return clear(to_rem[6]);
    }
    var producers = caml_call1(to_rem[4], 0);
    to_rem[4] = no_producers;
    to_rem[5] = nop;
    clear(to_rem[6]);
    var next = 0, to_rem$0 = to_rem, param = producers;
    for(;;)
     if(param){
      var todo = param[2], n = param[1];
      rem_dep(n, to_rem$0);
      if(n[1] !== min_rank){
       var a = n[6];
       try{
        var _ci_ = a[2] - 1 | 0, _ch_ = 0;
        if(_ci_ >= 0){
         var i = _ch_;
         for(;;){
          if(caml_call2(Stdlib_Weak[6], a[1], i))
           throw caml_maybe_attach_backtrace(Stdlib[3], 1);
          var _ck_ = i + 1 | 0;
          if(_ci_ === i) break;
          var i = _ck_;
         }
        }
        var _cj_ = 1, _cl_ = _cj_;
       }
       catch(_cm_){
        var _cg_ = caml_wrap_exception(_cm_);
        if(_cg_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_cg_, 0);
        var _cl_ = 0;
       }
       if(! (1 - _cl_)){
        var prods = caml_call1(n[4], 0);
        n[4] = no_producers;
        n[5] = nop;
        clear(n[6]);
        var next$0 = [0, [0, n, prods], next], next = next$0, param = todo;
        continue;
       }
      }
      var param = todo;
     }
     else{
      if(! next) return 0;
      var
       next$1 = next[2],
       match = next[1],
       prods$0 = match[2],
       to_rem$1 = match[1],
       next = next$1,
       to_rem$0 = to_rem$1,
       param = prods$0;
     }
   }
   var rmin = create$1(min_rank);
   function rmax(n$0, n){return n[1] < n$0[1] ? n$0 : n;}
   function rsucc(n){
    return n[1] === delayed_rank
            ? min_rank
            : n
               [1]
              < max_rank
              ? n[1] + 1 | 0
              : caml_call1(Stdlib[1], err_max_rank);
   }
   function rsucc2(n$0, n){
    var r = rsucc(n$0), r$0 = rsucc(n);
    return r$0 < r ? r : r$0;
   }
   function update_rank(n, r){
    if(n[1] >= r) return 0;
    n[1] = r;
    var param = [0, n, 0];
    for(;;){
     if(! param) return 1;
     var
      todo = param[2],
      n$0 = param[1],
      update$0 =
        function(n){
         function update(todo, d){
          if(n[1] >= d[1] && n[1] !== delayed_rank){d[1] = rsucc(n); return [0, d, todo];}
          return todo;
         }
         return update;
        },
      update = update$0(n$0),
      param = fold(update, todo, n$0[6]);
    }
   }
   function eval$0(m){
    var match = m[1][1];
    if(! match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
    var v = match[1];
    return v;
   }
   function emut(rank){return [0, [0, 0], create$1(rank)];}
   function event(m, p, u){bind(m[2], p, u); return [0, m];}
   function eupdate(v, m, c){
    m[1][1] = [0, v];
    var v$0 = m[1];
    function op(_cf_){v$0[1] = 0; return 0;}
    c[4] = [0, op, c[4]];
    return add_deps(c, m[2]);
   }
   function sval(m){
    var match = m[1];
    if(! match)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
    var v = match[1];
    return v;
   }
   function smut(rank, eq){return [0, 0, eq, create$1(rank)];}
   function signal(i, m, p, u){
    bind(m[3], p, u);
    if(i) m[1] = i;
    var c = find_unfinished(caml_call1(m[3][4], 0));
    if(c === nil) caml_call1(m[3][5], nil); else add$0(c, m[3]);
    return [1, m];
   }
   function supdate(v, m, c){
    var match = m[1];
    if(! match){m[1] = [0, v]; return 0;}
    var v$0 = match[1];
    if(caml_call2(m[2], v, v$0)) return 0;
    m[1] = [0, v];
    var _ce_ = c !== nil ? 1 : 0;
    return _ce_ ? add_deps(c, m[3]) : _ce_;
   }
   function add_dep$0(m, n){
    add_dep(m[2], n);
    var _cd_ = 0 !== m[1][1] ? 1 : 0;
    return _cd_ ? add$0(m[2][2], n) : _cd_;
   }
   var never = 0;
   function create$2(param){
    var m = emut(min_rank);
    return [0,
            [0, m],
            function(step, v){
             if(! step){
              var c$0 = create$0(0);
              m[2][2] = c$0;
              eupdate(v, m, c$0);
              return execute(c$0);
             }
             var c = step[1];
             if(c[1])
              caml_call1(Stdlib[1], err_step_executed);
             else if(m[2][2][1])
              m[2][2] = c;
             else
              caml_call1(Stdlib[1], err_event_scheduled);
             return eupdate(v, m, c);
            }];
   }
   function retain(e, c){
    if(! e) return caml_call1(Stdlib[1], err_retain_never);
    var m = e[1], c$0 = m[2][3];
    m[2][3] = c;
    return [0, 82, c$0];
   }
   function stop$0(strong, param){
    if(! param) return 0;
    var m = param[1];
    return stop(strong, m[2]);
   }
   function equal(e$0, e){
    if(e$0){
     if(e){var m = e[1], m$0 = e$0[1]; return m$0 === m ? 1 : 0;}
    }
    else if(! e) return 1;
    return 0;
   }
   function trace(opt, t, e){
    if(opt) var sth = opt[1], iff = sth; else var iff = _c_;
    if(0 === iff[0]){
     if(! iff[1]) return e;
     if(! e) return e;
     var
      m = e[1],
      m$0 = emut(rsucc(m[2])),
      p = function(param){return [0, m[2], 0];},
      u =
        function(c){
         var v = eval$0(m);
         caml_call1(t, v);
         return eupdate(v, m$0, c);
        };
     add_dep$0(m, m$0[2]);
     return event(m$0, p, u);
    }
    var mc = iff[1];
    if(! e) return 0;
    var m$1 = e[1], m$2 = emut(rsucc2(mc[3], m$1[2]));
    function p$0(param){return [0, mc[3], [0, m$1[2], 0]];}
    function u$0(c){
     var match = m$1[1][1];
     if(! match) return 0;
     var v = match[1];
     if(sval(mc)) caml_call1(t, v);
     return eupdate(v, m$2, c);
    }
    add_dep(mc[3], m$2[2]);
    add_dep$0(m$1, m$2[2]);
    return event(m$2, p$0, u$0);
   }
   function once(param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){
     rem_dep(m[2], m$0[2]);
     eupdate(eval$0(m), m$0, c);
     return stop(0, m$0[2]);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function drop_once(param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){
     function u(c){return eupdate(eval$0(m), m$0, c);}
     return bind(m$0[2], p, u);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function app(ef, param){
    if(! param) return 0;
    var m = param[1];
    if(! ef) return 0;
    var mf = ef[1], m$0 = emut(rsucc2(m[2], mf[2]));
    function p(param){return [0, m[2], [0, mf[2], 0]];}
    function u(c){
     var _cc_ = mf[1][1], match = m[1][1];
     if(_cc_ && match){
      var v = match[1], f = _cc_[1];
      return eupdate(caml_call1(f, v), m$0, c);
     }
     return 0;
    }
    add_dep$0(m, m$0[2]);
    add_dep$0(mf, m$0[2]);
    return event(m$0, p, u);
   }
   function map(f, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){return eupdate(caml_call1(f, eval$0(m)), m$0, c);}
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function stamp(e, v){
    if(! e) return 0;
    var m = e[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){return eupdate(v, m$0, c);}
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function filter(pred, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){
     var v = eval$0(m);
     return caml_call1(pred, v) ? eupdate(v, m$0, c) : 0;
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function fmap(fm, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2]));
    function p(param){return [0, m[2], 0];}
    function u(c){
     var match = caml_call1(fm, eval$0(m));
     if(! match) return 0;
     var v = match[1];
     return eupdate(v, m$0, c);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function diff(d, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2])), last = [0, 0];
    function p(param){return [0, m[2], 0];}
    function u(c){
     var v = eval$0(m), match = last[1];
     if(match){
      var v$0 = match[1];
      last[1] = [0, v];
      return eupdate(caml_call2(d, v, v$0), m$0, c);
     }
     last[1] = [0, v];
     return 0;
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function changes(opt, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2])), last = [0, 0];
    function p(param){return [0, m[2], 0];}
    function u(c){
     var v = eval$0(m), match = last[1];
     if(match){
      var v$0 = match[1];
      last[1] = [0, v];
      return caml_call2(eq, v, v$0) ? 0 : eupdate(v, m$0, c);
     }
     last[1] = [0, v];
     return eupdate(v, m$0, c);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function on(c, e){
    if(! e) return 0;
    var m = e[1];
    if(0 === c[0]) return c[1] ? e : 0;
    var mc = c[1], m$0 = emut(rsucc2(m[2], mc[3]));
    function p(param){return [0, m[2], [0, mc[3], 0]];}
    function u(c){
     return m[1][1] ? sval(mc) ? eupdate(eval$0(m), m$0, c) : 0 : 0;
    }
    add_dep$0(m, m$0[2]);
    add_dep(mc[3], m$0[2]);
    return event(m$0, p, u);
   }
   function dismiss(c, e){
    if(! e) return 0;
    var m = e[1];
    if(! c) return e;
    var mc = c[1], m$0 = emut(rsucc2(mc[2], m[2]));
    function p(param){return [0, mc[2], [0, m[2], 0]];}
    function u(c){return mc[1][1] ? 0 : eupdate(eval$0(m), m$0, c);}
    add_dep$0(mc, m$0[2]);
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function until(c, e){
    if(! e) return 0;
    var m = e[1];
    if(! c) return e;
    var mc = c[1], m$0 = emut(rsucc2(m[2], mc[2]));
    function p(param){return [0, m[2], [0, mc[2], 0]];}
    function u(c){
     return mc[1][1]
             ? (rem_dep
                (m[2], m$0[2]),
               rem_dep(mc[2], m$0[2]),
               stop(0, m$0[2]))
             : eupdate(eval$0(m), m$0, c);
    }
    add_dep$0(m, m$0[2]);
    add_dep$0(mc, m$0[2]);
    return event(m$0, p, u);
   }
   function accum(ef, i){
    if(! ef) return 0;
    var m = ef[1], m$0 = emut(rsucc(m[2])), acc = [0, i];
    function p(param){return [0, m[2], 0];}
    function u(c){
     var _cb_ = acc[1];
     acc[1] = caml_call1(eval$0(m), _cb_);
     return eupdate(acc[1], m$0, c);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function fold$0(f, i, param){
    if(! param) return 0;
    var m = param[1], m$0 = emut(rsucc(m[2])), acc = [0, i];
    function p(param){return [0, m[2], 0];}
    function u(c){
     var _ca_ = eval$0(m);
     acc[1] = caml_call2(f, acc[1], _ca_);
     return eupdate(acc[1], m$0, c);
    }
    add_dep$0(m, m$0[2]);
    return event(m$0, p, u);
   }
   function occurs(m){return 0 !== m[1][1] ? 1 : 0;}
   function find_muts_and_next_rank(el){
    var acc = 0, max = rmin, param = el;
    for(;;){
     if(! param){
      var _b$_ = rsucc(max);
      return [0, caml_call1(Stdlib_List[9], acc), _b$_];
     }
     var match = param[1];
     if(match)
      var
       l = param[2],
       m = match[1],
       max$0 = rmax(max, m[2]),
       acc$0 = [0, m, acc],
       acc = acc$0,
       max = max$0,
       param = l;
     else
      var l$0 = param[2], param = l$0;
    }
   }
   function select(el){
    var
     match = find_muts_and_next_rank(el),
     r = match[2],
     emuts = match[1],
     m = emut(r);
    function p(param){
     function _b__(m){return m[2];}
     return caml_call2(Stdlib_List[21], _b__, emuts);
    }
    function u(c){
     try{
      var
       _b8_ =
         eupdate(eval$0(caml_call2(Stdlib_List[38], occurs, emuts)), m, c);
      return _b8_;
     }
     catch(_b9_){
      var _b7_ = caml_wrap_exception(_b9_);
      if(_b7_ === Stdlib[8])
       throw caml_maybe_attach_backtrace([0, Assert_failure, _d_], 1);
      throw caml_maybe_attach_backtrace(_b7_, 0);
     }
    }
    function _b6_(m$0){return add_dep$0(m$0, m[2]);}
    caml_call2(Stdlib_List[17], _b6_, emuts);
    return event(m, p, u);
   }
   function merge(f, acc, el){
    var
     match = find_muts_and_next_rank(el),
     r = match[2],
     emuts = match[1],
     m = emut(r);
    function p(param){
     function _b5_(m){return m[2];}
     return caml_call2(Stdlib_List[21], _b5_, emuts);
    }
    function u(c){
     var acc$0 = acc, param = emuts;
     for(;;){
      if(! param) return eupdate(acc$0, m, c);
      var m$0 = param[1], l = param[2];
      if(occurs(m$0))
       var
        acc$1 = caml_call2(f, acc$0, eval$0(m$0)),
        acc$0 = acc$1,
        param = l;
      else
       var l$0 = param[2], param = l$0;
     }
    }
    function _b4_(m$0){return add_dep$0(m$0, m[2]);}
    caml_call2(Stdlib_List[17], _b4_, emuts);
    return event(m, p, u);
   }
   function switch$0(e, param){
    if(! param) return e;
    var ms = param[1];
    if(e) var m = e[1], r = rsucc2(m[2], ms[2]); else var r = rsucc(ms[2]);
    var m$0 = emut(r), src = [0, e];
    function p(param){
     var match = src[1];
     if(! match) return [0, ms[2], 0];
     var m = match[1];
     return [0, m[2], [0, ms[2], 0]];
    }
    function u(c){
     var match = ms[1][1];
     if(! match){
      var match$2 = src[1];
      if(! match$2)
       throw caml_maybe_attach_backtrace([0, Assert_failure, _e_], 1);
      var m$2 = match$2[1];
      return eupdate(eval$0(m$2), m$0, c);
     }
     var e = match[1], match$0 = src[1];
     if(match$0){var m = match$0[1]; rem_dep(m[2], m$0[2]);}
     src[1] = e;
     if(! e){var _b3_ = rsucc(ms[2]); update_rank(m$0[2], _b3_); return 0;}
     var m$1 = e[1];
     add_dep(m$1[2], m$0[2]);
     var _b2_ = rsucc2(m$1[2], ms[2]);
     if(update_rank(m$0[2], _b2_)){
      allow_reschedule(m$0[2]);
      return rebuild(c);
     }
     var match$1 = m$1[1][1];
     if(! match$1) return 0;
     var v = match$1[1];
     return eupdate(v, m$0, c);
    }
    if(e){var m$1 = e[1]; add_dep$0(m$1, m$0[2]);}
    add_dep$0(ms, m$0[2]);
    return event(m$0, p, u);
   }
   function fix(f){
    var m = emut(delayed_rank);
    function _bY_(param){
     throw caml_maybe_attach_backtrace([0, Assert_failure, _f_], 1);
    }
    var
     e = event(m, function(param){return 0;}, _bY_),
     _bZ_ = caml_call1(f, e),
     match = _bZ_[1];
    if(! match){var r$0 = _bZ_[2]; return r$0;}
    var r = _bZ_[2], m$0 = match[1];
    if(m$0[2][1] === delayed_rank) caml_call1(Stdlib[1], err_fix);
    function p(param){return 0;}
    function u(c){
     var _b0_ = [0, eval$0(m$0)];
     m[1][1] = _b0_;
     var v = m[1];
     add_eop(c, function(_b1_){v[1] = 0; return 0;});
     return add_deps(c, m[2]);
    }
    bind(m[2], p, u);
    add_dep$0(m$0, m[2]);
    return r;
   }
   function l2(f, e0, e1){
    if(! e0) return 0;
    if(! e1) return 0;
    var m1 = e1[1], m0 = e0[1], r = rsucc2(m0[2], m1[2]), m = emut(r);
    function p(param){return [0, m0[2], [0, m1[2], 0]];}
    function u(c){
     var _bX_ = m0[1][1], match = m1[1][1];
     if(_bX_ && match){
      var v1 = match[1], v0 = _bX_[1];
      return eupdate(caml_call2(f, v0, v1), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    return event(m, p, u);
   }
   function l3(f, e0, e1, e2){
    if(! e0) return 0;
    if(! e1) return 0;
    if(! e2) return 0;
    var
     m2 = e2[1],
     m1 = e1[1],
     m0 = e0[1],
     _bU_ = m2[2],
     r = rsucc(rmax(rmax(m0[2], m1[2]), _bU_)),
     m = emut(r);
    function p(param){return [0, m0[2], [0, m1[2], [0, m2[2], 0]]];}
    function u(c){
     var _bV_ = m0[1][1], _bW_ = m1[1][1], match = m2[1][1];
     if(_bV_ && _bW_ && match){
      var v2 = match[1], v1 = _bW_[1], v0 = _bV_[1];
      return eupdate(caml_call3(f, v0, v1, v2), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    add_dep$0(m2, m[2]);
    return event(m, p, u);
   }
   function l4(f, e0, e1, e2, e3){
    if(! e0) return 0;
    if(! e1) return 0;
    if(! e2) return 0;
    if(! e3) return 0;
    var
     m3 = e3[1],
     m2 = e2[1],
     m1 = e1[1],
     m0 = e0[1],
     _bQ_ = rmax(m2[2], m3[2]),
     r = rsucc(rmax(rmax(m0[2], m1[2]), _bQ_)),
     m = emut(r);
    function p(param){
     return [0, m0[2], [0, m1[2], [0, m2[2], [0, m3[2], 0]]]];
    }
    function u(c){
     var _bR_ = m0[1][1], _bS_ = m1[1][1], _bT_ = m2[1][1], match = m3[1][1];
     if(_bR_ && _bS_ && _bT_ && match){
      var v3 = match[1], v2 = _bT_[1], v1 = _bS_[1], v0 = _bR_[1];
      return eupdate(caml_call4(f, v0, v1, v2, v3), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    add_dep$0(m2, m[2]);
    add_dep$0(m3, m[2]);
    return event(m, p, u);
   }
   function l5(f, e0, e1, e2, e3, e4){
    if(! e0) return 0;
    if(! e1) return 0;
    if(! e2) return 0;
    if(! e3) return 0;
    if(! e4) return 0;
    var
     m4 = e4[1],
     m3 = e3[1],
     m2 = e2[1],
     m1 = e1[1],
     m0 = e0[1],
     _bK_ = m4[2],
     _bL_ = rmax(m2[2], m3[2]),
     r = rsucc(rmax(rmax(rmax(m0[2], m1[2]), _bL_), _bK_)),
     m = emut(r);
    function p(param){
     return [0, m0[2], [0, m1[2], [0, m2[2], [0, m3[2], [0, m4[2], 0]]]]];
    }
    function u(c){
     var
      _bM_ = m0[1][1],
      _bN_ = m1[1][1],
      _bO_ = m2[1][1],
      _bP_ = m3[1][1],
      match = m4[1][1];
     if(_bM_ && _bN_ && _bO_ && _bP_ && match){
      var
       v4 = match[1],
       v3 = _bP_[1],
       v2 = _bO_[1],
       v1 = _bN_[1],
       v0 = _bM_[1];
      return eupdate(caml_call5(f, v0, v1, v2, v3, v4), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    add_dep$0(m2, m[2]);
    add_dep$0(m3, m[2]);
    add_dep$0(m4, m[2]);
    return event(m, p, u);
   }
   function l6(f, e0, e1, e2, e3, e4, e5){
    if(! e0) return 0;
    if(! e1) return 0;
    if(! e2) return 0;
    if(! e3) return 0;
    if(! e4) return 0;
    if(! e5) return 0;
    var
     m5 = e5[1],
     m4 = e4[1],
     m3 = e3[1],
     m2 = e2[1],
     m1 = e1[1],
     m0 = e0[1],
     _bD_ = rmax(m4[2], m5[2]),
     _bE_ = rmax(m2[2], m3[2]),
     r = rsucc(rmax(rmax(rmax(m0[2], m1[2]), _bE_), _bD_)),
     m = emut(r);
    function p(param){
     return [0,
             m0[2],
             [0, m1[2], [0, m2[2], [0, m3[2], [0, m4[2], [0, m5[2], 0]]]]]];
    }
    function u(c){
     var
      _bF_ = m0[1][1],
      _bG_ = m1[1][1],
      _bH_ = m2[1][1],
      _bI_ = m3[1][1],
      _bJ_ = m4[1][1],
      match = m5[1][1];
     if(_bF_ && _bG_ && _bH_ && _bI_ && _bJ_ && match){
      var
       v5 = match[1],
       v4 = _bJ_[1],
       v3 = _bI_[1],
       v2 = _bH_[1],
       v1 = _bG_[1],
       v0 = _bF_[1];
      return eupdate(caml_call6(f, v0, v1, v2, v3, v4, v5), m, c);
     }
     return 0;
    }
    add_dep$0(m0, m[2]);
    add_dep$0(m1, m[2]);
    add_dep$0(m2, m[2]);
    add_dep$0(m3, m[2]);
    add_dep$0(m4, m[2]);
    add_dep$0(m5, m[2]);
    return event(m, p, u);
   }
   function some(e){return map(function(v){return [0, v];}, e);}
   function value(default$0, e){
    if(! default$0) return fmap(function(v){return v;}, e);
    var match = default$0[1];
    if(0 === match[0]){
     var dv = match[1];
     return map
             (function(param){
               if(! param) return dv;
               var v = param[1];
               return v;
              },
              e);
    }
    var ms = match[1];
    if(! e) return 0;
    var m = e[1], m$0 = emut(rsucc2(m[2], ms[3]));
    function p(param){return [0, m[2], [0, ms[3], 0]];}
    function u(c){
     var _bC_ = m[1][1];
     if(! _bC_) return 0;
     var match = _bC_[1];
     if(! match) return eupdate(sval(ms), m$0, c);
     var v = match[1];
     return eupdate(v, m$0, c);
    }
    add_dep$0(m, m$0[2]);
    add_dep(ms[3], m$0[2]);
    return event(m$0, p, u);
   }
   var Option = [0, some, value];
   function end_of_step_add_dep(opt, stop_if_stopped, m$0, m){
    if(opt)
     var sth = opt[1], post_add_op = sth;
    else
     var post_add_op = function(param){return 0;};
    var c = find_unfinished(caml_call1(m$0[3][4], 0));
    if(c === nil){add_dep(m$0[3], m[2]); return caml_call1(post_add_op, 0);}
    function add_dep$0(param){
     if(m$0[3][5] === nop)
      return stop_if_stopped ? stop(0, m[2]) : stop_if_stopped;
     var _bB_ = rsucc(m$0[3]);
     update_rank(m[2], _bB_);
     add_dep(m$0[3], m[2]);
     return caml_call1(post_add_op, 0);
    }
    return add_eop(c, add_dep$0);
   }
   function const$0(v){return [0, v];}
   function create$3(opt, v){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    var m = smut(min_rank, eq);
    m[1] = [0, v];
    return [0,
            [1, m],
            function(step, v){
             var _bA_ = sval(m);
             if(caml_call2(m[2], _bA_, v)) return 0;
             if(! step){
              var c$0 = create$0(0);
              m[3][2] = c$0;
              m[1] = [0, v];
              add_deps(c$0, m[3]);
              return execute(c$0);
             }
             var c = step[1];
             if(c[1])
              caml_call1(Stdlib[1], err_step_executed);
             else if(m[3][2][1])
              m[3][2] = c;
             else
              caml_call1(Stdlib[1], err_signal_scheduled);
             m[1] = [0, v];
             return add_deps(c, m[3]);
            }];
   }
   function retain$0(s, c){
    if(0 === s[0]) return caml_call1(Stdlib[1], err_retain_cst_sig);
    var m = s[1], c$0 = m[3][3];
    m[3][3] = c;
    return [0, 82, c$0];
   }
   function eq_fun(param){
    if(0 === param[0]) return 0;
    var m = param[1];
    return [0, m[2]];
   }
   function value$0(param){
    if(0 === param[0])
     var v = param[1];
    else{
     var _bz_ = param[1][1];
     if(! _bz_) return caml_call1(Stdlib[2], err_sig_undef);
     var v = _bz_[1];
    }
    return v;
   }
   function stop$1(strong, param){
    if(0 === param[0]) return 0;
    var m = param[1];
    if(m[1]) return stop(strong, m[3]);
    var c = find_unfinished(caml_call1(m[3][4], 0));
    if(c === nil)
     throw caml_maybe_attach_backtrace([0, Assert_failure, _g_], 1);
    function stop$0(param){return stop(strong, m[3]);}
    return add_eop(c, stop$0);
   }
   function equal$0(opt, s$0, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s$0[0]){
     var v = s$0[1];
     if(0 === s[0]){var v$0 = s[1]; return caml_call2(eq, v, v$0);}
    }
    else{
     var m = s$0[1];
     if(0 !== s[0]){var m$0 = s[1]; return m === m$0 ? 1 : 0;}
    }
    return 0;
   }
   function trace$0(opt, t, s){
    if(opt) var sth = opt[1], iff = sth; else var iff = [0, 1];
    if(0 === iff[0]){
     if(! iff[1]) return s;
     if(0 === s[0]){var v = s[1]; caml_call1(t, v); return s;}
     var
      m = s[1],
      _bx_ = m[2],
      m$0 = smut(rsucc(m[3]), _bx_),
      p = function(param){return [0, m[3], 0];},
      u =
        function(c){
         var v = sval(m);
         caml_call1(t, v);
         return supdate(v, m$0, c);
        };
     add_dep(m[3], m$0[3]);
     return signal(0, m$0, p, u);
    }
    var mc = iff[1];
    if(0 === s[0]){
     var
      v$0 = s[1],
      m$1 = smut(rsucc(mc[3]), caml_equal),
      p$0 = function(param){return [0, mc[3], 0];},
      u$0 =
        function(c){
         if(sval(mc)) caml_call1(t, v$0);
         rem_dep(mc[3], m$1[3]);
         return stop(0, m$1[3]);
        };
     add_dep(mc[3], m$1[3]);
     return signal([0, v$0], m$1, p$0, u$0);
    }
    var m$2 = s[1], _by_ = m$2[2], m$3 = smut(rsucc2(mc[3], m$2[3]), _by_);
    function p$1(param){return [0, mc[3], [0, m$2[3], 0]];}
    function u$1(c){
     var v = sval(m$2), match = m$3[1];
     if(match){var v$0 = match[1]; if(caml_call2(m$3[2], v, v$0)) return 0;}
     if(sval(mc)) caml_call1(t, v);
     return supdate(v, m$3, c);
    }
    add_dep(mc[3], m$3[3]);
    add_dep(m$2[3], m$3[3]);
    return signal(0, m$3, p$1, u$1);
   }
   function hold(opt, i, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! param) return [0, i];
    var m = param[1], m$0 = smut(rsucc(m[2]), eq);
    function p(param){return [0, m[2], 0];}
    function u(c){
     var match = m[1][1];
     if(! match) return 0;
     var v = match[1];
     return supdate(v, m$0, c);
    }
    add_dep$0(m, m$0[3]);
    return signal([0, i], m$0, p, u);
   }
   function map$0(opt, f, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === param[0]){var v = param[1]; return [0, caml_call1(f, v)];}
    var m = param[1], m$0 = smut(rsucc(m[3]), eq);
    function p(param){return [0, m[3], 0];}
    function u(c){return supdate(caml_call1(f, sval(m)), m$0, c);}
    add_dep(m[3], m$0[3]);
    return signal(0, m$0, p, u);
   }
   function app$0(opt, sf, sv){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === sf[0]){
     var f = sf[1];
     if(0 !== sv[0]) return map$0([0, eq], f, sv);
     var v = sv[1];
     return [0, caml_call1(f, v)];
    }
    var mf = sf[1];
    if(0 === sv[0]){
     var
      v$0 = sv[1],
      m = smut(rsucc(mf[3]), eq),
      p = function(param){return [0, mf[3], 0];},
      u = function(c){return supdate(caml_call1(sval(mf), v$0), m, c);};
     add_dep(mf[3], m[3]);
     return signal(0, m, p, u);
    }
    var mv = sv[1], m$0 = smut(rsucc2(mf[3], mv[3]), eq);
    function p$0(param){return [0, mf[3], [0, mv[3], 0]];}
    function u$0(c){
     var _bw_ = sval(mv);
     return supdate(caml_call1(sval(mf), _bw_), m$0, c);
    }
    add_dep(mf[3], m$0[3]);
    add_dep(mv[3], m$0[3]);
    return signal(0, m$0, p$0, u$0);
   }
   function filter$0(opt, pred, i, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s[0]){var v = s[1]; return caml_call1(pred, v) ? s : [0, i];}
    var m = s[1], m$0 = smut(rsucc(m[3]), eq);
    function p(param){return [0, m[3], 0];}
    function u(c){
     var v = sval(m);
     return caml_call1(pred, v) ? supdate(v, m$0, c) : 0;
    }
    add_dep(m[3], m$0[3]);
    return signal([0, i], m$0, p, u);
   }
   function fmap$0(opt, fm, i, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 !== param[0]){
     var
      m = param[1],
      m$0 = smut(rsucc(m[3]), eq),
      p = function(param){return [0, m[3], 0];},
      u =
        function(c){
         var match = caml_call1(fm, sval(m));
         if(! match) return 0;
         var v = match[1];
         return supdate(v, m$0, c);
        };
     add_dep(m[3], m$0[3]);
     return signal([0, i], m$0, p, u);
    }
    var v = param[1], match = caml_call1(fm, v);
    if(! match) return [0, i];
    var v$0 = match[1];
    return [0, v$0];
   }
   function diff$0(d, param){
    if(0 === param[0]) return 0;
    var m = param[1], m$0 = emut(rsucc(m[3])), last = [0, 0];
    function p(param){return [0, m[3], 0];}
    function u(c){
     var v = sval(m), match = last[1];
     if(! match)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _h_], 1);
     var v$0 = match[1];
     last[1] = [0, v];
     return eupdate(caml_call2(d, v, v$0), m$0, c);
    }
    function post_add_op(param){last[1] = [0, sval(m)]; return 0;}
    end_of_step_add_dep([0, post_add_op], 1, m, m$0);
    return event(m$0, p, u);
   }
   function changes$0(param){
    if(0 === param[0]) return 0;
    var m = param[1], m$0 = emut(rsucc(m[3]));
    function p(param){return [0, m[3], 0];}
    function u(c){return eupdate(sval(m), m$0, c);}
    end_of_step_add_dep(0, 1, m, m$0);
    return event(m$0, p, u);
   }
   function sample(f, e, param){
    if(0 === param[0]){
     var v = param[1];
     return map(function(ev){return caml_call2(f, ev, v);}, e);
    }
    var ms = param[1];
    if(! e) return 0;
    var me = e[1], m = emut(rsucc2(me[2], ms[3]));
    function p(param){return [0, me[2], [0, ms[3], 0]];}
    function u(c){
     var match = me[1][1];
     if(! match) return 0;
     var v = match[1];
     return eupdate(caml_call2(f, v, sval(ms)), m, c);
    }
    add_dep$0(me, m[2]);
    add_dep(ms[3], m[2]);
    return event(m, p, u);
   }
   function on$0(opt, c, i, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === c[0]) return c[1] ? s : [0, i];
    var mc = c[1];
    if(0 === s[0]){
     var
      v = s[1],
      m = smut(rsucc(mc[3]), eq),
      p = function(param){return [0, mc[3], 0];},
      u = function(c){return sval(mc) ? supdate(v, m, c) : 0;};
     add_dep(mc[3], m[3]);
     return signal([0, i], m, p, u);
    }
    var ms = s[1], m$0 = smut(rsucc2(mc[3], ms[3]), eq);
    function p$0(param){return [0, mc[3], [0, ms[3], 0]];}
    function u$0(c){return sval(mc) ? supdate(sval(ms), m$0, c) : 0;}
    add_dep(mc[3], m$0[3]);
    add_dep(ms[3], m$0[3]);
    return signal([0, i], m$0, p$0, u$0);
   }
   function dismiss$0(opt, c, i, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! c) return s;
    var mc = c[1];
    if(0 === s[0]){
     var
      v = s[1],
      m = smut(rsucc(mc[2]), eq),
      p = function(param){return [0, mc[2], 0];},
      u = function(c){return mc[1][1] ? 0 : supdate(v, m, c);};
     add_dep(mc[2], m[3]);
     return signal([0, i], m, p, u);
    }
    var ms = s[1], m$0 = smut(rsucc2(mc[2], ms[3]), eq);
    function p$0(param){return [0, mc[2], [0, ms[3], 0]];}
    function u$0(c){return mc[1][1] ? 0 : supdate(sval(ms), m$0, c);}
    add_dep(mc[2], m$0[3]);
    add_dep(ms[3], m$0[3]);
    return signal([0, i], m$0, p$0, u$0);
   }
   function accum$0(opt, ef, i){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! ef) return [0, i];
    var m = ef[1], m$0 = smut(rsucc(m[2]), eq);
    function p(param){return [0, m[2], 0];}
    function u(c){
     var match = m[1][1];
     if(! match) return 0;
     var v = match[1];
     return supdate(caml_call1(v, sval(m$0)), m$0, c);
    }
    add_dep$0(m, m$0[3]);
    return signal([0, i], m$0, p, u);
   }
   function fold$1(opt, f, i, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(! param) return [0, i];
    var m = param[1], m$0 = smut(rsucc(m[2]), eq);
    function p(param){return [0, m[2], 0];}
    function u(c){
     var match = m[1][1];
     if(! match) return 0;
     var v = match[1];
     return supdate(caml_call2(f, sval(m$0), v), m$0, c);
    }
    add_dep$0(m, m$0[3]);
    return signal([0, i], m$0, p, u);
   }
   function merge$0(opt, f, a, sl){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    function rmax$0(acc, param){
     if(0 === param[0]) return acc;
     var m = param[1];
     return rmax(acc, m[3]);
    }
    function nodes(acc, param){
     if(0 === param[0]) return acc;
     var m = param[1];
     return [0, m[3], acc];
    }
    var m = smut(rsucc(caml_call3(Stdlib_List[25], rmax$0, rmin, sl)), eq);
    function p(param){return caml_call3(Stdlib_List[25], nodes, 0, sl);}
    function u(c){
     function _bv_(a, param){
      if(0 === param[0]){var v = param[1]; return caml_call2(f, a, v);}
      var m = param[1];
      return caml_call2(f, a, sval(m));
     }
     return supdate(caml_call3(Stdlib_List[25], _bv_, a, sl), m, c);
    }
    function dep(param){
     if(0 === param[0]) return 0;
     var m$0 = param[1];
     return add_dep(m$0[3], m[3]);
    }
    caml_call2(Stdlib_List[17], dep, sl);
    return signal(0, m, p, u);
   }
   function switch$1(opt, param){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === param[0]){var s = param[1]; return s;}
    var
     mss = param[1],
     dummy = smut(min_rank, eq),
     src = [0, [1, dummy]],
     m = smut(rsucc(mss[3]), eq);
    function p(param){
     var match = src[1];
     if(0 === match[0]) return [0, mss[3], 0];
     var m = match[1];
     return [0, mss[3], [0, m[3], 0]];
    }
    function u(c){
     var _br_ = src[1];
     if(sval(mss) === _br_){
      var match = src[1];
      if(0 === match[0]) return 0;
      var m$0 = match[1];
      return supdate(sval(m$0), m, c);
     }
     var match$0 = src[1];
     if(0 !== match$0[0]){var m$2 = match$0[1]; rem_dep(m$2[3], m[3]);}
     var new_src = sval(mss);
     src[1] = new_src;
     if(0 === new_src[0]){
      var v = new_src[1], _bs_ = rsucc(mss[3]);
      update_rank(m[3], _bs_);
      return supdate(v, m, c);
     }
     var m$1 = new_src[1];
     add_dep(m$1[3], m[3]);
     if(c === nil){
      var _bt_ = rsucc2(m$1[3], mss[3]);
      update_rank(m[3], _bt_);
      var c$0 = find_unfinished([0, m$1[3], 0]);
      return c$0 === nil ? supdate(sval(m$1), m, c$0) : add$0(c$0, m[3]);
     }
     var _bu_ = rsucc2(m$1[3], mss[3]);
     return update_rank(m[3], _bu_)
             ? (allow_reschedule(m[3]), rebuild(c), add$0(c, m[3]))
             : supdate(sval(m$1), m, c);
    }
    add_dep(mss[3], m[3]);
    add_dep(dummy[3], m[3]);
    return signal(0, m, p, u);
   }
   function bind$0(eq, s, sf){
    return switch$1
            (eq,
             map$0
              ([0, function(_bq_, _bp_){return _bq_ === _bp_ ? 1 : 0;}],
               sf,
               s));
   }
   function fix$0(opt, i, f){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    function update_delayed(n, p, u, nl){
     bind(n, p, u);
     var c = find_unfinished(nl);
     if(c !== nil) return add$0(c, n);
     var c$0 = create$0(0);
     caml_call1(n[5], c$0);
     return execute(c$0);
    }
    var m = smut(delayed_rank, eq);
    function _bl_(param){return 0;}
    var
     s = signal([0, i], m, function(param){return 0;}, _bl_),
     _bm_ = caml_call1(f, s),
     match = _bm_[1];
    if(0 === match[0]){
     var
      r = _bm_[2],
      v = match[1],
      p = function(param){return 0;},
      u = function(c){return supdate(v, m, c);},
      _bn_ = deps(m[3]);
     update_delayed(m[3], p, u, _bn_);
     return r;
    }
    var r$0 = _bm_[2], m$0 = match[1];
    if(m$0[3][1] === delayed_rank) caml_call1(Stdlib[1], err_fix);
    function p$0(param){return 0;}
    function u$0(c){return supdate(sval(m$0), m, c);}
    add_dep(m$0[3], m[3]);
    var _bo_ = deps(m[3]);
    update_delayed(m[3], p$0, u$0, [0, m$0[3], _bo_]);
    return r$0;
   }
   function l2$0(opt, f, s$0, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s$0[0]){
     var v = s$0[1];
     if(0 === s[0]){var v$0 = s[1]; return [0, caml_call2(f, v, v$0)];}
     var
      m = s[1],
      m$0 = smut(rsucc(m[3]), eq),
      p = function(param){return [0, m[3], 0];},
      u = function(c){return supdate(caml_call2(f, v, sval(m)), m$0, c);};
     add_dep(m[3], m$0[3]);
     return signal(0, m$0, p, u);
    }
    var m0 = s$0[1];
    if(0 === s[0]){
     var
      v$1 = s[1],
      m$1 = smut(rsucc(m0[3]), eq),
      p$0 = function(param){return [0, m0[3], 0];},
      u$0 = function(c){return supdate(caml_call2(f, sval(m0), v$1), m$1, c);};
     add_dep(m0[3], m$1[3]);
     return signal(0, m$1, p$0, u$0);
    }
    var m1 = s[1], m$2 = smut(rsucc2(m0[3], m1[3]), eq);
    function p$1(param){return [0, m0[3], [0, m1[3], 0]];}
    function u$1(c){
     var _bk_ = sval(m1);
     return supdate(caml_call2(f, sval(m0), _bk_), m$2, c);
    }
    add_dep(m0[3], m$2[3]);
    add_dep(m1[3], m$2[3]);
    return signal(0, m$2, p$1, u$1);
   }
   function l3$0(opt, f, s0, s1, s2){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s0[0]){
     var v0 = s0[1];
     if(0 === s1[0]){
      var v1 = s1[1];
      if(0 === s2[0]){var v2 = s2[1]; return [0, caml_call3(f, v0, v1, v2)];}
     }
    }
    else{
     var m0 = s0[1];
     if(0 !== s1[0]){
      var m1 = s1[1];
      if(0 !== s2[0]){
       var
        m2 = s2[1],
        _bf_ = m2[3],
        r = rsucc(rmax(rmax(m0[3], m1[3]), _bf_)),
        m = smut(r, eq),
        p = function(param){return [0, m0[3], [0, m1[3], [0, m2[3], 0]]];},
        u =
          function(c){
           var _bi_ = sval(m2), _bj_ = sval(m1);
           return supdate(caml_call3(f, sval(m0), _bj_, _bi_), m, c);
          };
       add_dep(m0[3], m[3]);
       add_dep(m1[3], m[3]);
       add_dep(m2[3], m[3]);
       return signal(0, m, p, u);
      }
     }
    }
    return app$0
            ([0, eq],
             l2$0
              ([0, function(_bh_, _bg_){return _bh_ === _bg_ ? 1 : 0;}],
               f,
               s0,
               s1),
             s2);
   }
   function l4$0(opt, f, s0, s1, s2, s3){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s0[0]){
     var v0 = s0[1];
     if(0 === s1[0]){
      var v1 = s1[1];
      if(0 === s2[0]){
       var v2 = s2[1];
       if(0 === s3[0]){
        var v3 = s3[1];
        return [0, caml_call4(f, v0, v1, v2, v3)];
       }
      }
     }
    }
    else{
     var m0 = s0[1];
     if(0 !== s1[0]){
      var m1 = s1[1];
      if(0 !== s2[0]){
       var m2 = s2[1];
       if(0 !== s3[0]){
        var
         m3 = s3[1],
         _a$_ = rmax(m2[3], m3[3]),
         r = rsucc(rmax(rmax(m0[3], m1[3]), _a$_)),
         m = smut(r, eq),
         p =
           function(param){
            return [0, m0[3], [0, m1[3], [0, m2[3], [0, m3[3], 0]]]];
           },
         u =
           function(c){
            var _bc_ = sval(m3), _bd_ = sval(m2), _be_ = sval(m1);
            return supdate(caml_call4(f, sval(m0), _be_, _bd_, _bc_), m, c);
           };
        add_dep(m0[3], m[3]);
        add_dep(m1[3], m[3]);
        add_dep(m2[3], m[3]);
        add_dep(m3[3], m[3]);
        return signal(0, m, p, u);
       }
      }
     }
    }
    return app$0
            ([0, eq],
             l3$0
              ([0, function(_bb_, _ba_){return _bb_ === _ba_ ? 1 : 0;}],
               f,
               s0,
               s1,
               s2),
             s3);
   }
   function l5$0(opt, f, s0, s1, s2, s3, s4){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s0[0]){
     var v0 = s0[1];
     if(0 === s1[0]){
      var v1 = s1[1];
      if(0 === s2[0]){
       var v2 = s2[1];
       if(0 === s3[0]){
        var v3 = s3[1];
        if(0 === s4[0]){
         var v4 = s4[1];
         return [0, caml_call5(f, v0, v1, v2, v3, v4)];
        }
       }
      }
     }
    }
    else{
     var m0 = s0[1];
     if(0 !== s1[0]){
      var m1 = s1[1];
      if(0 !== s2[0]){
       var m2 = s2[1];
       if(0 !== s3[0]){
        var m3 = s3[1];
        if(0 !== s4[0]){
         var
          m4 = s4[1],
          _a3_ = rmax(m3[3], m4[3]),
          _a4_ = rmax(m2[3], _a3_),
          r = rsucc(rmax(rmax(m0[3], m1[3]), _a4_)),
          m = smut(r, eq),
          p =
            function(param){
             return [0,
                     m0[3],
                     [0, m1[3], [0, m2[3], [0, m3[3], [0, m4[3], 0]]]]];
            },
          u =
            function(c){
             var
              _a7_ = sval(m4),
              _a8_ = sval(m3),
              _a9_ = sval(m2),
              _a__ = sval(m1),
              v = caml_call5(f, sval(m0), _a__, _a9_, _a8_, _a7_);
             return supdate(v, m, c);
            };
         add_dep(m0[3], m[3]);
         add_dep(m1[3], m[3]);
         add_dep(m2[3], m[3]);
         add_dep(m3[3], m[3]);
         add_dep(m4[3], m[3]);
         return signal(0, m, p, u);
        }
       }
      }
     }
    }
    return app$0
            ([0, eq],
             l4$0
              ([0, function(_a6_, _a5_){return _a6_ === _a5_ ? 1 : 0;}],
               f,
               s0,
               s1,
               s2,
               s3),
             s4);
   }
   function l6$0(opt, f, s0, s1, s2, s3, s4, s5){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s0[0]){
     var v0 = s0[1];
     if(0 === s1[0]){
      var v1 = s1[1];
      if(0 === s2[0]){
       var v2 = s2[1];
       if(0 === s3[0]){
        var v3 = s3[1];
        if(0 === s4[0]){
         var v4 = s4[1];
         if(0 === s5[0]){
          var v5 = s5[1];
          return [0, caml_call6(f, v0, v1, v2, v3, v4, v5)];
         }
        }
       }
      }
     }
    }
    else{
     var m0 = s0[1];
     if(0 !== s1[0]){
      var m1 = s1[1];
      if(0 !== s2[0]){
       var m2 = s2[1];
       if(0 !== s3[0]){
        var m3 = s3[1];
        if(0 !== s4[0]){
         var m4 = s4[1];
         if(0 !== s5[0]){
          var
           m5 = s5[1],
           _aT_ = rmax(m4[3], m5[3]),
           _aU_ = rmax(m3[3], _aT_),
           _aV_ = rmax(m1[3], m2[3]),
           m = rmax(rmax(m0[3], _aV_), _aU_),
           m$0 = smut(rsucc(m), eq),
           p =
             function(param){
              return [0,
                      m0[3],
                      [0,
                       m1[3],
                       [0, m2[3], [0, m3[3], [0, m4[3], [0, m5[3], 0]]]]]];
             },
           u =
             function(c){
              var
               _aY_ = sval(m5),
               _aZ_ = sval(m4),
               _a0_ = sval(m3),
               _a1_ = sval(m2),
               _a2_ = sval(m1),
               v = caml_call6(f, sval(m0), _a2_, _a1_, _a0_, _aZ_, _aY_);
              return supdate(v, m$0, c);
             };
          add_dep(m0[3], m$0[3]);
          add_dep(m1[3], m$0[3]);
          add_dep(m2[3], m$0[3]);
          add_dep(m3[3], m$0[3]);
          add_dep(m4[3], m$0[3]);
          add_dep(m5[3], m$0[3]);
          return signal(0, m$0, p, u);
         }
        }
       }
      }
     }
    }
    return app$0
            ([0, eq],
             l5$0
              ([0, function(_aX_, _aW_){return _aX_ === _aW_ ? 1 : 0;}],
               f,
               s0,
               s1,
               s2,
               s3,
               s4),
             s5);
   }
   function stdlib_not(_aS_){return 1 - _aS_;}
   function equal$1(_aR_, _aQ_){return _aR_ === _aQ_ ? 1 : 0;}
   function not(s){return map$0([0, equal$1], stdlib_not, s);}
   function symbol(s$0, s){
    return l2$0
            ([0, equal$1],
             function(_aO_, _aN_){var _aP_ = _aO_ ? _aN_ : _aO_; return _aP_;},
             s$0,
             s);
   }
   function symbol$0(s$0, s){
    return l2$0
            ([0, equal$1],
             function(_aL_, _aK_){var _aM_ = _aL_ || _aK_; return _aM_;},
             s$0,
             s);
   }
   function edge(s){return changes$0(s);}
   function edge_detect(edge, param){
    if(0 === param[0]) return 0;
    var m = param[1], m$0 = emut(rsucc(m[3]));
    function p(param){return [0, m[3], 0];}
    function u(c){
     var _aJ_ = caml_equal(sval(m), edge);
     return _aJ_ ? eupdate(0, m$0, c) : _aJ_;
    }
    end_of_step_add_dep(0, 1, m, m$0);
    return event(m$0, p, u);
   }
   function rise(s){return edge_detect(1, s);}
   function fall(s){return edge_detect(0, s);}
   function flip(b, param){
    if(! param) return [0, b];
    var m = param[1];
    function _aG_(_aI_, _aH_){return _aI_ === _aH_ ? 1 : 0;}
    var m$0 = smut(rsucc(m[2]), _aG_);
    function p(param){return [0, m[2], 0];}
    function u(c){return m[1][1] ? supdate(1 - sval(m$0), m$0, c) : 0;}
    add_dep$0(m, m$0[3]);
    return signal([0, b], m$0, p, u);
   }
   function equal$2(_aF_, _aE_){return _aF_ === _aE_ ? 1 : 0;}
   function symbol$1(s){
    return map$0([0, equal$2], function(_aD_){return - _aD_ | 0;}, s);
   }
   function succ(s){
    return map$0([0, equal$2], function(_aC_){return _aC_ + 1 | 0;}, s);
   }
   function pred(s){
    return map$0([0, equal$2], function(_aB_){return _aB_ - 1 | 0;}, s);
   }
   function symbol$2(s$0, s){
    return l2$0
            ([0, equal$2],
             function(_aA_, _az_){return _aA_ + _az_ | 0;},
             s$0,
             s);
   }
   function symbol$3(s$0, s){
    return l2$0
            ([0, equal$2],
             function(_ay_, _ax_){return _ay_ - _ax_ | 0;},
             s$0,
             s);
   }
   function symbol$4(s$0, s){
    return l2$0([0, equal$2], runtime.caml_mul, s$0, s);
   }
   function mod(s$0, s){return l2$0([0, equal$2], runtime.caml_mod, s$0, s);}
   function abs(s){return map$0([0, equal$2], Stdlib[18], s);}
   var max_int = [0, Stdlib[19]], min_int = [0, Stdlib[20]];
   function land(s$0, s){
    return l2$0
            ([0, equal$2], function(_aw_, _av_){return _aw_ & _av_;}, s$0, s);
   }
   function lor(s$0, s){
    return l2$0
            ([0, equal$2], function(_au_, _at_){return _au_ | _at_;}, s$0, s);
   }
   function lxor(s$0, s){
    return l2$0
            ([0, equal$2], function(_as_, _ar_){return _as_ ^ _ar_;}, s$0, s);
   }
   function lnot(s){return map$0([0, equal$2], Stdlib[21], s);}
   function lsl(s$0, s){
    return l2$0
            ([0, equal$2], function(_aq_, _ap_){return _aq_ << _ap_;}, s$0, s);
   }
   function lsr(s$0, s){
    return l2$0
            ([0, equal$2],
             function(_ao_, _an_){return _ao_ >>> _an_ | 0;},
             s$0,
             s);
   }
   function asr(s$0, s){
    return l2$0
            ([0, equal$2], function(_am_, _al_){return _am_ >> _al_;}, s$0, s);
   }
   function equal$3(_ak_, _aj_){return _ak_ == _aj_ ? 1 : 0;}
   function symbol$5(s){
    return map$0([0, equal$3], function(_ai_){return - _ai_;}, s);
   }
   function symbol$6(s$0, s){
    return l2$0
            ([0, equal$3], function(_ah_, _ag_){return _ah_ + _ag_;}, s$0, s);
   }
   function symbol$7(s$0, s){
    return l2$0
            ([0, equal$3], function(_af_, _ae_){return _af_ - _ae_;}, s$0, s);
   }
   function symbol$8(s$0, s){
    return l2$0
            ([0, equal$3], function(_ad_, _ac_){return _ad_ * _ac_;}, s$0, s);
   }
   function symbol$9(s$0, s){
    return l2$0
            ([0, equal$3], function(_ab_, _aa_){return _ab_ / _aa_;}, s$0, s);
   }
   function symbol$10(s$0, s){
    return l2$0
            ([0, equal$3],
             function(_$_, ___){return Math.pow(_$_, ___);},
             s$0,
             s);
   }
   function sqrt(s){
    return map$0([0, equal$3], function(_Z_){return Math.sqrt(_Z_);}, s);
   }
   function exp(s){
    return map$0([0, equal$3], function(_Y_){return Math.exp(_Y_);}, s);
   }
   function log(s){
    return map$0([0, equal$3], function(_X_){return Math.log(_X_);}, s);
   }
   function log10(s){return map$0([0, equal$3], runtime.caml_log10_float, s);}
   function cos(s){
    return map$0([0, equal$3], function(_W_){return Math.cos(_W_);}, s);
   }
   function sin(s){
    return map$0([0, equal$3], function(_V_){return Math.sin(_V_);}, s);
   }
   function tan(s){
    return map$0([0, equal$3], function(_U_){return Math.tan(_U_);}, s);
   }
   function acos(s){
    return map$0([0, equal$3], function(_T_){return Math.acos(_T_);}, s);
   }
   function asin(s){
    return map$0([0, equal$3], function(_S_){return Math.asin(_S_);}, s);
   }
   function atan(s){
    return map$0([0, equal$3], function(_R_){return Math.atan(_R_);}, s);
   }
   function atan2(s$0, s){
    return l2$0
            ([0, equal$3],
             function(_Q_, _P_){return Math.atan2(_Q_, _P_);},
             s$0,
             s);
   }
   function cosh(s){return map$0([0, equal$3], runtime.caml_cosh_float, s);}
   function sinh(s){return map$0([0, equal$3], runtime.caml_sinh_float, s);}
   function tanh(s){return map$0([0, equal$3], runtime.caml_tanh_float, s);}
   function ceil(s){
    return map$0([0, equal$3], function(_O_){return Math.ceil(_O_);}, s);
   }
   function floor(s){
    return map$0([0, equal$3], function(_N_){return Math.floor(_N_);}, s);
   }
   function abs_float(s){
    return map$0([0, equal$3], function(_M_){return Math.abs(_M_);}, s);
   }
   function mod_float(s$0, s){
    return l2$0([0, equal$3], function(_L_, _K_){return _L_ % _K_;}, s$0, s);
   }
   function frexp(s){
    return map$0([0, caml_equal], runtime.caml_frexp_float, s);
   }
   function ldexp(s$0, s){
    return l2$0([0, equal$3], runtime.caml_ldexp_float, s$0, s);
   }
   function modf(s){
    return map$0([0, caml_equal], runtime.caml_modf_float, s);
   }
   function float$0(s){
    return map$0([0, equal$3], function(_J_){return _J_;}, s);
   }
   function float_of_int(s){
    return map$0([0, equal$3], function(_I_){return _I_;}, s);
   }
   function truncate(s){
    return map$0([0, equal$2], function(_H_){return _H_ | 0;}, s);
   }
   function int_of_float(s){
    return map$0([0, equal$2], function(_G_){return _G_ | 0;}, s);
   }
   var
    infinity = [0, Stdlib[22]],
    neg_infinity = [0, Stdlib[23]],
    nan = [0, Stdlib[24]],
    max_float = [0, Stdlib[25]],
    min_float = [0, Stdlib[26]],
    epsilon_float = [0, Stdlib[27]];
   function classify_float(s){
    var _D_ = runtime.caml_classify_float;
    return map$0([0, function(_F_, _E_){return _F_ === _E_ ? 1 : 0;}], _D_, s);
   }
   function pair(eq, s$0, s){
    return l2$0(eq, function(x, y){return [0, x, y];}, s$0, s);
   }
   function fst(eq, s){return map$0(eq, function(_C_){return _C_[1];}, s);}
   function snd(eq, s){return map$0(eq, function(_B_){return _B_[2];}, s);}
   var Pair = [0, pair, fst, snd];
   function some$0(s){
    var match = eq_fun(s);
    if(match)
     var
      eq = match[1],
      eq$0 =
        function(v$0, v){
         if(v$0 && v){
          var v$1 = v[1], v$2 = v$0[1];
          return caml_call2(eq, v$2, v$1);
         }
         throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
        },
      eq$1 = [0, eq$0];
    else
     var eq$1 = 0;
    return map$0(eq$1, function(v){return [0, v];}, s);
   }
   function value$1(opt, default$0, s){
    if(opt) var sth = opt[1], eq = sth; else var eq = caml_equal;
    if(0 === s[0]){
     var match = s[1];
     if(match){var v = match[1]; return [0, v];}
     if(815032112 > default$0[1]){var d$1 = default$0[2]; return d$1;}
     var d = default$0[2];
     if(0 === d[0]){var d$0 = d[1]; return [0, d$0];}
     var md = d[1], c = find_unfinished([0, md[3], 0]);
     if(c === nil) return [0, sval(md)];
     var
      m = smut(rsucc(md[3]), eq),
      p = function(param){return [0, md[3], 0];},
      u =
        function(c){
         rem_dep(md[3], m[3]);
         supdate(sval(md), m, c);
         return stop(0, m[3]);
        };
     add_dep(md[3], m[3]);
     return signal(0, m, p, u);
    }
    var m$0 = s[1];
    if(815032112 <= default$0[1]){
     var match$0 = default$0[2];
     if(0 === match$0[0]){
      var d$2 = match$0[1];
      return fmap$0([0, eq], function(v){return v;}, d$2, s);
     }
     var md$0 = match$0[1], c$0 = find_unfinished([0, md$0[3], 0]);
     if(c$0 === nil){
      var
       m$1 = smut(rsucc(m$0[3]), eq),
       p$0 = function(param){return [0, m$0[3], 0];},
       u$0 =
         function(c){
          var match = sval(m$0);
          if(! match) return 0;
          var v = match[1];
          return supdate(v, m$1, c);
         };
      add_dep(m$0[3], m$1[3]);
      return signal([0, sval(md$0)], m$1, p$0, u$0);
     }
     var
      m$2 = smut(rsucc2(m$0[3], md$0[3]), eq),
      p$1 = function(param){return [0, m$0[3], 0];},
      u$1 =
        function(c){
         var match = sval(m$0);
         if(! match) return 0;
         var v = match[1];
         return supdate(v, m$2, c);
        },
      p_first = function(param){return [0, m$0[3], [0, md$0[3], 0]];},
      u_first =
        function(c){
         rem_dep(md$0[3], m$2[3]);
         var match = sval(m$0);
         if(match){
          var v = match[1];
          supdate(v, m$2, c);
         }
         else
          supdate(sval(md$0), m$2, c);
         return bind(m$2[3], p$1, u$1);
        };
     add_dep(m$0[3], m$2[3]);
     add_dep(md$0[3], m$2[3]);
     return signal(0, m$2, p_first, u_first);
    }
    var match$1 = default$0[2];
    if(0 === match$1[0]){
     var d$3 = match$1[1];
     return map$0
             ([0, eq],
              function(param){
               if(! param) return d$3;
               var v = param[1];
               return v;
              },
              s);
    }
    var md$1 = match$1[1], m$3 = smut(rsucc2(m$0[3], md$1[3]), eq);
    function p$2(param){return [0, m$0[3], [0, md$1[3], 0]];}
    function u$2(c){
     var match = sval(m$0);
     if(! match) return supdate(sval(md$1), m$3, c);
     var v = match[1];
     return supdate(v, m$3, c);
    }
    add_dep(m$0[3], m$3[3]);
    add_dep(md$1[3], m$3[3]);
    return signal(0, m$3, p$2, u$2);
   }
   var Option$0 = [0, none, some$0, value$1];
   function symbol$11(s$0, s){return l2$0([0, equal$1], caml_equal, s$0, s);}
   function symbol$12(s$0, s){
    return l2$0([0, equal$1], runtime.caml_notequal, s$0, s);
   }
   function symbol$13(s$0, s){
    return l2$0([0, equal$1], runtime.caml_lessthan, s$0, s);
   }
   function symbol$14(s$0, s){
    return l2$0([0, equal$1], runtime.caml_greaterthan, s$0, s);
   }
   function symbol$15(s$0, s){
    return l2$0([0, equal$1], runtime.caml_lessequal, s$0, s);
   }
   function symbol$16(s$0, s){
    return l2$0([0, equal$1], runtime.caml_greaterequal, s$0, s);
   }
   function compare(s$0, s){
    return l2$0([0, equal$2], runtime.caml_compare, s$0, s);
   }
   function symbol$17(s$0, s){
    return l2$0
            ([0, equal$1],
             function(_A_, _z_){return _A_ === _z_ ? 1 : 0;},
             s$0,
             s);
   }
   function symbol$18(s$0, s){
    return l2$0
            ([0, equal$1],
             function(_y_, _x_){return _y_ !== _x_ ? 1 : 0;},
             s$0,
             s);
   }
   function Make(Eq){
    var eq = Eq[1];
    function create(v){return create$3([0, eq], v);}
    function equal(s$0, s){return equal$0([0, eq], s$0, s);}
    function hold$0(v, e){return hold([0, eq], v, e);}
    function app(sf, sv){return app$0([0, eq], sf, sv);}
    function map(f, s){return map$0([0, eq], f, s);}
    function filter(pred, i){
     var _v_ = [0, eq];
     return function(_w_){return filter$0(_v_, pred, i, _w_);};
    }
    function fmap(fm, i){
     var _t_ = [0, eq];
     return function(_u_){return fmap$0(_t_, fm, i, _u_);};
    }
    function when(c, i, s){return on$0([0, eq], c, i, s);}
    function dismiss(c, s){
     var _r_ = [0, eq];
     return function(_s_){return dismiss$0(_r_, c, s, _s_);};
    }
    function accum(ef, i){return accum$0([0, eq], ef, i);}
    function fold(f, i){
     var _p_ = [0, eq];
     return function(_q_){return fold$1(_p_, f, i, _q_);};
    }
    function merge(f, a, sl){return merge$0([0, eq], f, a, sl);}
    function switch$0(s){return switch$1([0, eq], s);}
    function bind(s, sf){return bind$0([0, eq], s, sf);}
    function fix(f){
     var _n_ = [0, eq];
     return function(_o_){return fix$0(_n_, f, _o_);};
    }
    function l2(f, s$0, s){return l2$0([0, eq], f, s$0, s);}
    function l3(f, s0, s1, s2){return l3$0([0, eq], f, s0, s1, s2);}
    function l4(f, s0, s1, s2, s3){return l4$0([0, eq], f, s0, s1, s2, s3);}
    function l5(f, s0, s1, s2, s3, s4){
     return l5$0([0, eq], f, s0, s1, s2, s3, s4);
    }
    function l6(f, s0, s1, s2, s3, s4, s5){
     return l6$0([0, eq], f, s0, s1, s2, s3, s4, s5);
    }
    return [0,
            ,
            create,
            equal,
            hold$0,
            app,
            map,
            filter,
            fmap,
            when,
            dismiss,
            accum,
            fold,
            merge,
            switch$0,
            bind,
            fix,
            map,
            l2,
            l3,
            l4,
            l5,
            l6];
   }
   var
    Sb = Make([0, equal$1]),
    Si = Make([0, equal$2]),
    Sf = Make([0, equal$3]),
    _j_ = [0, create$0, execute],
    _k_ =
      [0,
       [0,
        Sb[2],
        Sb[3],
        Sb[4],
        Sb[5],
        Sb[6],
        Sb[7],
        Sb[8],
        Sb[9],
        Sb[10],
        Sb[11],
        Sb[12],
        Sb[13],
        Sb[14],
        Sb[15],
        Sb[16],
        Sb[17],
        Sb[18],
        Sb[19],
        Sb[20],
        Sb[21],
        Sb[22]],
       [0,
        Si[2],
        Si[3],
        Si[4],
        Si[5],
        Si[6],
        Si[7],
        Si[8],
        Si[9],
        Si[10],
        Si[11],
        Si[12],
        Si[13],
        Si[14],
        Si[15],
        Si[16],
        Si[17],
        Si[18],
        Si[19],
        Si[20],
        Si[21],
        Si[22]],
       [0,
        Sf[2],
        Sf[3],
        Sf[4],
        Sf[5],
        Sf[6],
        Sf[7],
        Sf[8],
        Sf[9],
        Sf[10],
        Sf[11],
        Sf[12],
        Sf[13],
        Sf[14],
        Sf[15],
        Sf[16],
        Sf[17],
        Sf[18],
        Sf[19],
        Sf[20],
        Sf[21],
        Sf[22]]],
    React =
      [0,
       [0,
        never,
        create$2,
        retain,
        stop$0,
        equal,
        trace,
        once,
        drop_once,
        app,
        map,
        stamp,
        filter,
        fmap,
        diff,
        changes,
        on,
        on,
        dismiss,
        until,
        accum,
        fold$0,
        select,
        merge,
        switch$0,
        fix,
        map,
        l2,
        l3,
        l4,
        l5,
        l6,
        Option],
       [0,
        const$0,
        create$3,
        value$0,
        retain$0,
        eq_fun,
        stop$1,
        equal$0,
        trace$0,
        hold,
        app$0,
        map$0,
        filter$0,
        fmap$0,
        diff$0,
        changes$0,
        sample,
        on$0,
        on$0,
        dismiss$0,
        accum$0,
        fold$1,
        merge$0,
        switch$1,
        bind$0,
        fix$0,
        map$0,
        l2$0,
        l3$0,
        l4$0,
        l5$0,
        l6$0,
        [0, zero, one, not, symbol, symbol$0, edge, rise, fall, flip],
        [0,
         zero$0,
         one$0,
         minus_one,
         symbol$1,
         succ,
         pred,
         symbol$2,
         symbol$3,
         symbol$4,
         mod,
         abs,
         max_int,
         min_int,
         land,
         lor,
         lxor,
         lnot,
         lsl,
         lsr,
         asr],
        [0,
         zero$1,
         one$1,
         minus_one$0,
         symbol$5,
         symbol$6,
         symbol$7,
         symbol$8,
         symbol$9,
         symbol$10,
         sqrt,
         exp,
         log,
         log10,
         cos,
         sin,
         tan,
         acos,
         asin,
         atan,
         atan2,
         cosh,
         sinh,
         tanh,
         ceil,
         floor,
         abs_float,
         mod_float,
         frexp,
         ldexp,
         modf,
         float$0,
         float_of_int,
         truncate,
         int_of_float,
         infinity,
         neg_infinity,
         nan,
         max_float,
         min_float,
         epsilon_float,
         classify_float],
        Pair,
        Option$0,
        [0,
         symbol$11,
         symbol$12,
         symbol$13,
         symbol$14,
         symbol$15,
         symbol$16,
         compare,
         symbol$17,
         symbol$18],
        function(_l_){
         var _m_ = Make(_l_);
         return [0,
                 _m_[2],
                 _m_[3],
                 _m_[4],
                 _m_[5],
                 _m_[6],
                 _m_[7],
                 _m_[8],
                 _m_[9],
                 _m_[10],
                 _m_[11],
                 _m_[12],
                 _m_[13],
                 _m_[14],
                 _m_[15],
                 _m_[16],
                 _m_[17],
                 _m_[18],
                 _m_[19],
                 _m_[20],
                 _m_[21],
                 _m_[22]];
        },
        _k_],
       _j_];
   runtime.caml_register_global(30, React, "React");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJyZWFjdC5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOltdLCJzb3VyY2VzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7OztHOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5QixXLHFDOztJLE87OztHO3NCLE8sb0M7O0ksUTtJO0ksTztHOztJLFc7O0ssVTtLOzs7STs7O0c7O0k7O0ksTztHOztJLEksdUM7Ozs7TSxZOzZDO007Ozs7OztHOztJLEkscUI7OztrQjs7O0c7O0k7STtLO007O007TTtrQjs7Ozs7Szs7O0c7RywrQjs0QixvQix1Qjs7SSxpQjs7O0k7SSxJO0k7O0ssNkIsbUI7aUI7Ozs7OztNOzs7VTs7Rzs7SSxtQzs7OztNLFk7O007Ozs7OztHOzJCLCtCO2dDLG1COztJOzs7O007TTs7Ozs7O0c7O0k7O0k7SztNOztTOzJCLE8sa0I7Uzs7O1E7TTs7UzsyQixPLGtCO1M7OztRO00scUIscUM7Szs7Ozs7O1E7UztTO1M7UztVO1UsVztVO1U7OztVOzs7Ozs7OztrQixTLFM7OztNOztLO0s7Szs7O00sb0MsbUI7O29CLG1CLE8sb0I7SztLO0s7OztHOztJOzs7Ozs7Ozs7O1E7UyxhOzs7Ozs7Ozs7O0c7O3VCLFM7Z0MsUzs7STtHOztJO0k7Ozs7O08sWTs7OztTO1MsTTs7Ozs7Ozs7Ozs7OzRCOzs7Rzs7STtJOzs7OztZO1E7USxNOzs7Ozs7O0s7Szs7Ozs0Qjs7O0c7O0k7SSw2QixtQjtHOzBCLDZCOztJO0k7Ozs7O0ksZ0I7OztJOzs7OztNOzs7Tzs7Ozs7VSxHO1csTTs7Ozs7O1EsSTs7Ozs7OztPO1EsWTs7O1E7USxJOzs7Ozs7O2lCOzs7Ozs7Ozs7O0c7Rzt5QiwrQjs7STs7Ozs7OztHOztJLEksZ0I7O0c7O0ksYzs7O0k7aUI7Ozs7Ozs7VSwyRDtVO1M7Ozs7OztHOztJOztLLE07O0k7Rzt1QixtQzsyQixrQixjOztJOztJLGtCOzs7Rzs7STs7SyxNOztJO0c7MkIsa0M7O0k7O0ksd0I7a0IsK0I7STtHOztJOzs7SSxHLDBCOzs7O0c7O0k7OztHOzs7STtJOzs7YTtjOztjO2M7Ozs7Yzs7OztjO2E7O0c7O0k7OztJO0c7O0ksWTs7STs7O0k7OztpQjtJO0c7O0k7STtrQjthO0s7O007MEIsb0I7OztTO1M7UztRO0s7Szs7O0ksUTtJLGdCO3dCLGtDOztLO2lCOztLLGE7SztJO0k7STtJO0c7O0ksWTtJLGtCO3NCLG9COztLO0s7O0k7STtJO0c7O0ksWTtJLGtCO3NCLG9COzttQixrQztLO0k7STtJO0c7O0ksWTs7SSxTO0ksZ0I7c0IsZ0M7O0s7OztNLGU7O0s7STtJO0k7STs7O0ksWTtJLGtCO3NCLG9CO2tCLGUsa0M7STtJOzs7SSxRO0ksYztzQixvQjtrQiwwQjtJO0k7Rzs7SSxZO0ksa0I7c0Isb0I7O0s7SyxPO0k7STtJOzs7SSxZO0ksa0I7c0Isb0I7O0ssWTtpQjs7SztJO0k7STs7O0ksWTtJLGtCLHlCO3NCLG9COztLLEksZTs7OztNLGU7Ozs7STtJO0k7OztJO0ksWTtJLGtCLHlCO3NCLG9COztLLEksZTs7OztNLE87OztLO0k7STtJOzs7SSxROztJO0ksZTtzQixnQzs7SztJO0k7STtJOzs7SSxROztJLFE7SSxlO3NCLGdDO2tCLGlEO0k7STtJOzs7SSxROztJLFE7SSxlO3NCLGdDOztLOzs7Ozs7STtJO0k7STs7O0ksUztJLGUseUI7c0Isb0I7O0s7YztLO0k7STtJO0c7O0ksWTtJLGtCLHlCO3NCLG9COztLO2M7SztJO0k7STs7c0IsNkI7O0k7OztNO00sVzs7OztNOzs7TztPOzs7Ozs7O0c7O0k7Szs7O0s7O3NCLFk7SyxPO0k7O0s7TTs7d0I7TTs7Ozs7TyxNOzs7STt1Qiw0QjtJO0k7Rzs7STtLOzs7Szs7c0IsWTtLLE87STs7Szs7a0I7O007TztRLFE7Ozs7OztJO3VCLDRCO0k7STtHOztJLFk7O0k7SSxJLGU7O0s7aUI7O0s7STs7Szs7OztPLE07O007O0ssa0I7cUM7O2EseUIsMkI7O0s7SztLO007TTs7O21COztLO0k7MEI7STtJOzs7STtJO0ssTTtJO0k7Syw2QixTO0ssTzs7bUM7O21DO3NCLFM7O0s7OztLLDBCOztJO0k7STtJO0c7O0ksUzthO0ksNEIsMEI7c0IsaUM7O0s7OztNLGU7O0s7STtJO0k7STtHOztJLFM7YTthO0k7Ozs7SztLO0s7c0IsNkM7O0s7OztNLGU7O0s7STtJO0k7STtJO0c7O0ksUzthO2E7YTtJOzs7OztLO0s7Szs7SztJOztLOzs7TSxlOztLO0k7STtJO0k7STtJO0c7O0ksUzthO2E7YTthO0k7Ozs7OztLO0s7SztLOztLO0k7O0s7Ozs7Ozs7Ozs7Ozs7TSxlOztLO0k7STtJO0k7STtJO0k7Rzs7SSxTO2E7YTthO2E7YTtJOzs7Ozs7O0s7SztLO0s7O0s7OztJOztLOzs7Ozs7Ozs7Ozs7Ozs7TSxlOztLO0k7STtJO0k7STtJO0k7STtHO29CLHVCLGMsTTs7SSxnQix3QixTOzs7O0s7O2UsWTs7ZTtjOzs7O0ksUTtJLGM7c0IsZ0M7O0s7Z0I7O2lCOztLO0k7STtJO0k7RztHOztJOzs7dUMsUztJLHdCO2tCLHVCLE87O0s7O0s7SztLO0ssTztJO0k7Rzt1QixjOztJO0k7O0k7OzthO2EsRywyQjs7Yzs7O2M7Yzs7OztjOzs7O2M7Ozs7Rzs7STs7O0k7Rzs7SSxtQjs7STtHOztJOzs7O2dCLE87OztJO0c7O0ksbUI7OztJLHdCOztLLE07MkIsMEI7STs7O0k7STs7b0MsTzs7Ozs7O0k7Rzs7STtJO2tCO2tDLGtCO0s7O007TTtNLG9CLG9COzs7UztTO1M7UTtLO0s7OztJO0s7O007NEIscUI7OztTLGE7Uzs7UTtLO0s7O0ksZ0IsZTt3QixrQzs7SyxJLGU7bUMsRyw0QjtLLGE7SztJO0k7STtJO0c7O0k7SSxZO0ksa0I7c0Isb0I7O0s7aUI7O0s7STtJO0k7OztJO0kscUMsVztJLGtCO3NCLG9CO2tCLGUsZ0M7STtJOzs7STtJOztxQjs7SyxXOzs7O0s7O007MEIscUI7c0IsZSxpQztLO0s7O0ksZ0I7d0IsaUM7O0s7SyxlO0k7STtJO0k7Rzs7STtJLDZCLE87SSxjO3NCLG9COztLO0ssTztJO0k7STtHOztJO0k7Szs7TTswQixvQjs7O1MsWTtxQjs7UztRO0s7Szs7SSxrQixRO2dCOztJOzs7SSxtQjtJLGtCLHlCO3NCLG9COztLLEksYTs7TSxNOzs7SyxlO0k7Z0MsaUM7STtJOzs7SSxtQjtJLGtCO3NCLG9CO2tCLGdDO0k7STtHOztJOztLLHdCLE8scUI7OztJLFE7SSxlO3NCLGlDOztLO2lCOztLLGU7STtJO0k7STs7O0k7STs7STtLOztNOzBCLHFCO3NCLHVDO0s7Szs7SSxlO3dCLGlDO29CLGdEO0k7STtJO0c7O0k7SSxROztJO0s7O007MEIscUI7c0IsdUM7SztLOztJLGU7d0IsaUM7b0IsZ0Q7STtJO0k7Rzs7STtJLFM7SSxlO3NCLG9COztLO2lCOztLLGU7STtJO0k7Rzs7STtJLFk7SSxrQjtzQixvQjs7SztpQjs7SyxlO0k7STtJOzs7STtJO0ssbUI7O0s7O0k7SyxtQjs7Szs7SSxtQjtzQixpRDs7SztNLHFDLE87O00sTzs7SyxlO0k7O0ssbUI7O0s7STtJO0k7Rzs7STtJLHFDO0k7O0s7SztLOztLO3dCOztLO0k7O0s7Ozt5Qjs7TTs7O2dEO0s7OztNLG9CO007TTs7O0s7O007TTtNOzs7SztLOzs7STtJO0k7STs7O0k7Ozt3Qzs7O0c7O0k7O0s7SzttQjtLO0s7SztJO0k7eUIsUztJO0ssc0MsUztLLE87OztLOzs7MEIsUztzQix3QjtNO0s7Szs7O21DO3dCLFM7b0IsZ0M7STtJO0k7STtHOztJO0k7O29DLFc7Szs7TTswQixvQjtzQixlLG1DO0s7Szs7OztLOztNOzRCLHFCO3dCLGUsc0M7SztLOztJLGU7d0IsaUM7O0s7SyxlO0k7STtJO0k7Rzs7STtJOzs7O3NDLFc7Ozs7Ozs7O087O1E7UTtROzRCLDZDOzs7VyxJLGlCO1csZTtVO087TztPO087Ozs7STs7O3dDOzs7OztHOztJO0k7Ozs7Ozs7O1EsVzs7Ozs7Ozs7Ozs7O1E7O1M7UztTOzs7WTtXOzs7WSxJLGlCLGlCO1ksZTtXO1E7UTtRO1E7UTs7Ozs7STs7O3dDOzs7Ozs7Rzs7STtJOzs7Ozs7Ozs7O1MsVzs7Ozs7Ozs7Ozs7Ozs7O1M7O1U7VTtVO1U7OzthOzs7WTs7O2E7YztjO2M7YztjLEk7YTtZO1M7UztTO1M7UztTOzs7Ozs7STs7O3dDOzs7Ozs7O0c7O0k7STs7Ozs7Ozs7Ozs7O1UsVzs7Ozs7Ozs7Ozs7Ozs7Ozs7O1U7O1c7VztXO1c7Vzs7O2M7Ozs7O2E7OztjO2U7ZTtlO2U7ZTtlLEk7YzthO1U7VTtVO1U7VTtVO1U7Ozs7Ozs7STs7O3dDOzs7Ozs7OztHOzZCO2dDO21CLDBDOztJOzs7OztHOztJOzs7OztHO29CLG9COztJLG1CO0ksa0I7c0Isb0I7O0ssVztLO0k7STtJOztvQix5QjtvQix5Qjs7SSxZOztJLDBCO0k7c0Isb0I7a0Isb0Q7STtJOztnQzs7SSwwQztHOztJLDBDO0c7O0ksMEM7Rzs7STs7a0M7OztHOztJOztrQzs7O0c7O0k7Rzt3QixvRDttQiwwQztHLEksMkI7O0k7Z0Q7Rzs7STtnRDtHOztJO2dEO0c7b0IsMEM7O0k7Z0Q7Rzs7STs7a0M7OztHOztJO2dEO0c7Z0M7O0ksMEM7Rzs7STtnRDtHOztJO2dEO0c7O0k7Z0Q7Rzs7STtnRDtHOztJOztnQzs7O0c7O0kseUM7Rzs7SSx5QztHOztJLHlDO0c7cUIsd0Q7O0kseUM7Rzs7SSx5QztHOztJLHlDO0c7O0kseUM7Rzs7SSx5QztHOztJLHlDO0c7O0k7O2dDOzs7RztvQix1RDtvQix1RDtvQix1RDs7SSx5QztHOztJLHlDO0c7O0kseUM7Rzs7SSw2QztHOztJO0c7O0k7Rzs7STtHOztJLHlDO0c7O0kseUM7Rzs7SSx5QztHOztJLHlDO0c7RztJO0k7STtJO0k7STs7STtJLG9DO0c7O0ksK0IsaUI7Rzt1QiwrQixvQjt1QiwrQixvQjtHOztJOztLOztNOztTOztVLE87O1MsTTtROzs7O0ksK0IsYztHOztJO0k7O2lDOzBEOztLLCtCO0ssZTttQjtLO007MEIscUI7OztTO1M7O1E7SztLOzs7Ozs7O00sbUMsUzs7Syx1Qjs7TTtPOzZCLHNCOzs7VTtzQjs7VTtTO007TTs7SztNO00sc0Isc0I7OztTO3FCOztTO1E7Z0Msb0M7OztTO1M7OztVOzs7VTtTO1E7SztLO0s7Ozs7O0s7OztlLFk7O2U7Yzs7O0ksdUI7d0Isb0M7O0s7aUI7O0s7STtJO0k7STtHO0c7OEIsOEM7O0k7Rzs7STtHOztJO0c7O0k7Rzs7STtHOztJO0c7O0k7O2dDOzs7Rzs7STs7Z0M7OztHOzs7dUIsNEI7MkIsZ0M7MEIsMkI7eUIsOEI7dUIsNEI7O0s7SyxxQjtJOztLO0sscUI7STsyQiw4Qjs7SztLLHFCO0k7MEIsK0I7O0s7SyxxQjtJOzZCLGtDO3lCLDRCO3lCLDhCOztLO0sscUI7STsyQixnQzsrQixvQzttQyx3Qzs7SztJOztLO0k7STs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RSIsInNvdXJjZXNDb250ZW50IjpbXX0=
