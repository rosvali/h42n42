// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Lwt_sequence
//# unitInfo: Requires: Stdlib
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Empty = [248, "Lwt_sequence.Empty", runtime.caml_fresh_oo_id(0)];
   function get(node){return node[3];}
   function set(node, data){node[3] = data; return 0;}
   function remove(node){
    var
     _k_ = node[4],
     _l_ =
       _k_
        ? (node[4] = 0, node[1][2] = node[2], node[2][1] = node[1], 0)
        : _k_;
    return _l_;
   }
   function create(param){
    var seq = [];
    runtime.caml_update_dummy(seq, [0, seq, seq]);
    return seq;
   }
   function clear(seq){seq[1] = seq; seq[2] = seq; return 0;}
   function is_empty(seq){return seq[2] === seq ? 1 : 0;}
   function length(seq){
    var curr$1 = seq[2], curr = curr$1, len = 0;
    for(;;){
     if(curr === seq) return len;
     var len$0 = len + 1 | 0, curr$0 = curr[2], curr = curr$0, len = len$0;
    }
   }
   function add_l(data, seq){
    var node = [0, seq, seq[2], data, 1];
    seq[2][1] = node;
    seq[2] = node;
    return node;
   }
   function add_r(data, seq){
    var node = [0, seq[1], seq, data, 1];
    seq[1][2] = node;
    seq[1] = node;
    return node;
   }
   function take_l(seq){
    if(is_empty(seq)) throw caml_maybe_attach_backtrace(Empty, 1);
    var node = seq[2];
    remove(node);
    return node[3];
   }
   function take_r(seq){
    if(is_empty(seq)) throw caml_maybe_attach_backtrace(Empty, 1);
    var node = seq[1];
    remove(node);
    return node[3];
   }
   function take_opt_l(seq){
    if(is_empty(seq)) return 0;
    var node = seq[2];
    remove(node);
    return [0, node[3]];
   }
   function take_opt_r(seq){
    if(is_empty(seq)) return 0;
    var node = seq[1];
    remove(node);
    return [0, node[3]];
   }
   function transfer_l(s1, s2){
    s2[2][1] = s1[1];
    s1[1][2] = s2[2];
    s2[2] = s1[2];
    s1[2][1] = s2;
    s1[1] = s1;
    s1[2] = s1;
    return 0;
   }
   function transfer_r(s1, s2){
    s2[1][2] = s1[2];
    s1[2][1] = s2[1];
    s2[1] = s1[1];
    s1[1][2] = s2;
    s1[1] = s1;
    s1[2] = s1;
    return 0;
   }
   function iter_l(f, seq){
    var curr$1 = seq[2], curr = curr$1;
    for(;;){
     var _j_ = curr !== seq ? 1 : 0;
     if(! _j_) return _j_;
     if(curr[4]) caml_call1(f, curr[3]);
     var curr$0 = curr[2], curr = curr$0;
    }
   }
   function iter_r(f, seq){
    var curr$1 = seq[1], curr = curr$1;
    for(;;){
     var _i_ = curr !== seq ? 1 : 0;
     if(! _i_) return _i_;
     if(curr[4]) caml_call1(f, curr[3]);
     var curr$0 = curr[1], curr = curr$0;
    }
   }
   function iter_node_l(f, seq){
    var curr$1 = seq[2], curr = curr$1;
    for(;;){
     var _h_ = curr !== seq ? 1 : 0;
     if(! _h_) return _h_;
     if(curr[4]) caml_call1(f, curr);
     var curr$0 = curr[2], curr = curr$0;
    }
   }
   function iter_node_r(f, seq){
    var curr$1 = seq[1], curr = curr$1;
    for(;;){
     var _g_ = curr !== seq ? 1 : 0;
     if(! _g_) return _g_;
     if(curr[4]) caml_call1(f, curr);
     var curr$0 = curr[1], curr = curr$0;
    }
   }
   function fold_l(f, seq, acc){
    var curr$2 = seq[2], curr = curr$2, acc$0 = acc;
    for(;;){
     if(curr === seq) return acc$0;
     if(curr[4])
      var
       acc$1 = caml_call2(f, curr[3], acc$0),
       curr$0 = curr[2],
       curr = curr$0,
       acc$0 = acc$1;
     else
      var curr$1 = curr[2], curr = curr$1;
    }
   }
   function fold_r(f, seq, acc){
    var curr$2 = seq[1], curr = curr$2, acc$0 = acc;
    for(;;){
     if(curr === seq) return acc$0;
     if(curr[4])
      var
       acc$1 = caml_call2(f, curr[3], acc$0),
       curr$0 = curr[1],
       curr = curr$0,
       acc$0 = acc$1;
     else
      var curr$1 = curr[1], curr = curr$1;
    }
   }
   function find_node_l(f, seq){
    var curr$2 = seq[2], curr = curr$2;
    for(;;){
     if(curr === seq) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(curr[4]){
      if(caml_call1(f, curr[3])) return curr;
      var curr$0 = curr[2], curr = curr$0;
     }
     else
      var curr$1 = curr[2], curr = curr$1;
    }
   }
   function find_node_r(f, seq){
    var curr$2 = seq[1], curr = curr$2;
    for(;;){
     if(curr === seq) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     if(curr[4]){
      if(caml_call1(f, curr[3])) return curr;
      var curr$0 = curr[1], curr = curr$0;
     }
     else
      var curr$1 = curr[1], curr = curr$1;
    }
   }
   function find_node_opt_l(f, seq){
    try{var _e_ = [0, find_node_l(f, seq)]; return _e_;}
    catch(_f_){
     var _d_ = caml_wrap_exception(_f_);
     if(_d_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_d_, 0);
    }
   }
   function find_node_opt_r(f, seq){
    try{var _b_ = [0, find_node_r(f, seq)]; return _b_;}
    catch(_c_){
     var _a_ = caml_wrap_exception(_c_);
     if(_a_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_a_, 0);
    }
   }
   var
    Lwt_sequence =
      [0,
       get,
       set,
       remove,
       create,
       clear,
       is_empty,
       length,
       add_l,
       add_r,
       Empty,
       take_l,
       take_r,
       take_opt_l,
       take_opt_r,
       transfer_l,
       transfer_r,
       iter_l,
       iter_r,
       iter_node_l,
       iter_node_r,
       fold_l,
       fold_r,
       find_node_opt_l,
       find_node_opt_r,
       find_node_l,
       find_node_r];
   runtime.caml_register_global(2, Lwt_sequence, "Lwt_sequence");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt
//# unitInfo: Requires: Assert_failure, CamlinternalLazy, Lwt_sequence, Stdlib, Stdlib__Array, Stdlib__List, Stdlib__Map, Stdlib__Printexc, Stdlib__Printf, Stdlib__Queue, Stdlib__Random
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Lwt = "Lwt.",
    cst_Lwt_s = "Lwt.%s",
    cst_src_core_lwt_ml = "src/core/lwt.ml",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return,
    caml_update_dummy = runtime.caml_update_dummy,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call6(f, a0, a1, a2, a3, a4, a5){
    return (f.l >= 0 ? f.l : f.l = f.length) == 6
            ? f(a0, a1, a2, a3, a4, a5)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Random = global_data.Stdlib__Random,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Stdlib_Printexc = global_data.Stdlib__Printexc,
    Stdlib_Map = global_data.Stdlib__Map,
    compare = runtime.caml_compare,
    Storage_map = caml_call1(Stdlib_Map[1], [0, compare]),
    _O_ = [0, cst_src_core_lwt_ml, 2709, 6],
    _P_ = [0, cst_src_core_lwt_ml, 2729, 6],
    _U_ = [0, 0],
    _V_ = [0, 0],
    cst_Lwt_nchoose_split_would_re =
      "Lwt.nchoose_split [] would return a promise that is pending forever",
    _T_ = [0, 0],
    cst_Lwt_npick_would_return_a_p =
      "Lwt.npick [] would return a promise that is pending forever",
    _S_ = [0, 0],
    cst_Lwt_nchoose_would_return_a =
      "Lwt.nchoose [] would return a promise that is pending forever",
    _R_ = [0, 0],
    cst_Lwt_pick_would_return_a_pr =
      "Lwt.pick [] would return a promise that is pending forever",
    _Q_ = [0, 0],
    cst_Lwt_choose_would_return_a_ =
      "Lwt.choose [] would return a promise that is pending forever",
    _N_ = [0, cst_src_core_lwt_ml, 2670, 24],
    _M_ = [0, cst_src_core_lwt_ml, 2651, 13],
    _L_ = [0, 0],
    _K_ = [0, 0],
    _I_ = [0, 1],
    _J_ = [0, 1],
    _G_ = [0, 1],
    _H_ = [0, 1],
    _F_ = [0, 1],
    _E_ = [0, 1],
    _C_ = [0, 0],
    _D_ = [0, 1],
    _A_ = [0, 1],
    _B_ = [0, 1],
    _y_ = [0, 1],
    _z_ = [0, 1],
    _w_ = [0, 0],
    _x_ = [0, 1],
    _u_ = [0, 0],
    _v_ = [0, 1],
    _r_ = [0, 0],
    _s_ = [0, 0],
    _t_ = [0, 1],
    _p_ = [0, 0],
    _q_ = [0, 1],
    _n_ = [0, 0],
    _o_ = [0, 1],
    _l_ = [0, 0],
    _m_ = [0, 0],
    _k_ = [0, 0],
    _j_ = [0, 0],
    _i_ = [0, 0],
    cst_wakeup_later_exn = "wakeup_later_exn",
    cst_wakeup_later = "wakeup_later",
    cst_wakeup_later_result = "wakeup_later_result",
    _f_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _g_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _h_ = [0, 1],
    cst_wakeup_exn = "wakeup_exn",
    cst_wakeup = "wakeup",
    cst_wakeup_result = "wakeup_result",
    _c_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _d_ = [0, [11, cst_Lwt, [2, 0, 0]], cst_Lwt_s],
    _e_ = [0, 0],
    cst_Fatal_error_exception = "Fatal error: exception ",
    _a_ = [0, cst_src_core_lwt_ml, 980, 23],
    _b_ = [0, cst_src_core_lwt_ml, 981, 22],
    cst_Lwt_Resolution_loop_Cancel = "Lwt.Resolution_loop.Canceled";
   function state_of_result(param){
    if(0 === param[0]){var x = param[1]; return [0, x];}
    var exn = param[1];
    return [1, exn];
   }
   function underlying(p){
    var match = p[1];
    switch(match[0]){
      case 0:
       return p;
      case 1:
       return p;
      case 2:
       return p;
      default:
       var p$0 = match[1], p$1 = underlying(p$0);
       if(1 - (p$1 === p$0 ? 1 : 0)) p[1] = [3, p$1];
       return p$1;
    }
   }
   function set_promise_state(p, state){p[1] = state; return p;}
   function handle_all(param){return 1;}
   function handle_all_except_runtime(param){
    return param === Stdlib[9] ? 0 : param === Stdlib[10] ? 0 : 1;
   }
   var v = [0, handle_all];
   function set(f){v[1] = f; return 0;}
   function run(e){return caml_call1(v[1], e);}
   var next_key_id = [0, 0];
   function new_key(param){
    var id = next_key_id[1];
    next_key_id[1] = id + 1 | 0;
    return [0, id, 0];
   }
   var current_storage = [0, Storage_map[1]];
   function get(key){
    if(! caml_call2(Storage_map[3], key[1], current_storage[1])) return 0;
    var refresh = caml_call2(Storage_map[28], key[1], current_storage[1]);
    caml_call1(refresh, 0);
    var value = key[2];
    key[2] = 0;
    return value;
   }
   function with_value(key, value, f){
    if(value)
     var
      refresh = function(param){key[2] = value; return 0;},
      new_storage =
        caml_call3(Storage_map[4], key[1], refresh, current_storage[1]);
    else
     var new_storage = caml_call2(Storage_map[7], key[1], current_storage[1]);
    var saved_storage = current_storage[1];
    current_storage[1] = new_storage;
    try{
     var result = caml_call1(f, 0);
     current_storage[1] = saved_storage;
     return result;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     current_storage[1] = saved_storage;
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function concat_regular_callbacks(l1, l2){
    return typeof l1 === "number"
            ? l2
            : typeof l2 === "number" ? l1 : [0, l1, l2];
   }
   function clean_up_callback_cells(callbacks){
    if(typeof callbacks !== "number")
     switch(callbacks[0]){
       case 0:
        var
         l2 = callbacks[2],
         l1 = callbacks[1],
         l1$0 = clean_up_callback_cells(l1),
         l2$0 = clean_up_callback_cells(l2);
        return concat_regular_callbacks(l1$0, l2$0);
       case 2:
        if(! callbacks[1][1]) return 0; break;
     }
    return callbacks;
   }
   function clear_explicitly_removable_cal(cell, ps){
    cell[1] = 0;
    function _bo_(p){
     var match = underlying(p)[1];
     switch(match[0]){
       case 1:
        return 0;
       case 2:
        var callbacks = match[1], _bp_ = callbacks[1];
        if(typeof _bp_ !== "number" && 2 === _bp_[0]){callbacks[1] = 0; return 0;}
        var cleanups_deferred = callbacks[4] + 1 | 0;
        return 42 < cleanups_deferred
                ? (callbacks
                   [4]
                  = 0,
                  callbacks[1] = clean_up_callback_cells(callbacks[1]),
                  0)
                : (callbacks[4] = cleanups_deferred, 0);
       default: return 0;
     }
    }
    return caml_call1(caml_call1(Stdlib_List[17], _bo_), ps);
   }
   function add_regular_callback_list_node(callbacks, node){
    var
     existing = callbacks[1],
     node$0 = typeof existing === "number" ? node : [0, node, existing];
    callbacks[1] = node$0;
    return 0;
   }
   function add_implicitly_removed_callbac(callbacks, f){
    return add_regular_callback_list_node(callbacks, [1, f]);
   }
   function add_explicitly_removable_callb(ps, f){
    var
     cell = [],
     self_removing_callback_wrapper =
       function _bn_(_bm_){return _bn_.fun(_bm_);};
    caml_update_dummy(cell, [0, [0, self_removing_callback_wrapper]]);
    caml_update_dummy
     (self_removing_callback_wrapper,
      function(result){
       clear_explicitly_removable_cal(cell, ps);
       return caml_call1(f, result);
      });
    var node = [2, cell];
    function _bl_(p){
     var match = underlying(p)[1];
     switch(match[0]){
       case 1:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _b_], 1);
       case 2:
        var callbacks = match[1];
        return add_regular_callback_list_node(callbacks, node);
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     }
    }
    caml_call1(caml_call1(Stdlib_List[17], _bl_), ps);
    return cell;
   }
   function add_explicitly_removable_callb$0(ps, f){add_explicitly_removable_callb(ps, f); return;
   }
   function add_cancel_callback(callbacks, f){
    var
     node = [1, current_storage[1], f],
     node$0 =
       typeof callbacks[2] === "number" ? node : [0, node, callbacks[2]];
    callbacks[2] = node$0;
    return 0;
   }
   var
    async_exception_hook =
      [0,
       function(exn){
        caml_call1(Stdlib[49], cst_Fatal_error_exception);
        var _bk_ = caml_call1(Stdlib_Printexc[1], exn);
        caml_call1(Stdlib[49], _bk_);
        caml_call1(Stdlib[48], 10);
        caml_call1(Stdlib_Printexc[5], Stdlib[40]);
        caml_call1(Stdlib[63], Stdlib[40]);
        return caml_call1(Stdlib[99], 2);
       }];
   function handle_with_async_exception_ho(f, v){
    try{var _bj_ = caml_call1(f, v); return _bj_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return caml_call1(async_exception_hook[1], exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var
    Canceled =
      [248, cst_Lwt_Resolution_loop_Cancel, runtime.caml_fresh_oo_id(0)];
   function run_callbacks(callbacks, result){
    if(1 === result[0])
     var _bi_ = result[1] === Canceled ? 1 : 0, is_canceled = _bi_;
    else
     var is_canceled = 0;
    if(is_canceled){
     var
      fs = callbacks[2],
      iter_callback_list$2 =
        function(counter, fs, rest){
         var fs$0 = fs, rest$0 = rest;
         for(;;){
          if(typeof fs$0 === "number"){
           if(counter >= 50)
            return caml_trampoline_return(iter_list$0, [0, rest$0]);
           var counter$0 = counter + 1 | 0;
           return iter_list$0(counter$0, rest$0);
          }
          switch(fs$0[0]){
            case 0:
             var
              fs$1 = fs$0[2],
              fs$2 = fs$0[1],
              rest$1 = [0, fs$1, rest$0],
              fs$0 = fs$2,
              rest$0 = rest$1;
             break;
            case 1:
             var f = fs$0[2], storage = fs$0[1];
             current_storage[1] = storage;
             handle_with_async_exception_ho(f, 0);
             if(counter >= 50)
              return caml_trampoline_return(iter_list$0, [0, rest$0]);
             var counter$1 = counter + 1 | 0;
             return iter_list$0(counter$1, rest$0);
            default:
             var node = fs$0[1];
             caml_call1(Lwt_sequence[3], node);
             if(counter >= 50)
              return caml_trampoline_return(iter_list$0, [0, rest$0]);
             var counter$2 = counter + 1 | 0;
             return iter_list$0(counter$2, rest$0);
          }
         }
        },
      iter_list$0 =
        function(counter, rest){
         if(! rest) return;
         var rest$0 = rest[2], fs = rest[1];
         if(counter >= 50)
          return caml_trampoline_return(iter_callback_list$2, [0, fs, rest$0]);
         var counter$0 = counter + 1 | 0;
         return iter_callback_list$2(counter$0, fs, rest$0);
        },
      iter_callback_list =
        function(fs, rest){
         return caml_trampoline(iter_callback_list$2(0, fs, rest));
        };
     iter_callback_list(fs, 0);
    }
    var fs$0 = callbacks[1];
    function iter_callback_list$1(counter, fs, rest){
     var fs$0 = fs, rest$0 = rest;
     for(;;){
      if(typeof fs$0 === "number"){
       if(counter >= 50)
        return caml_trampoline_return(iter_list, [0, rest$0]);
       var counter$0 = counter + 1 | 0;
       return iter_list(counter$0, rest$0);
      }
      switch(fs$0[0]){
        case 0:
         var
          fs$1 = fs$0[2],
          fs$2 = fs$0[1],
          rest$1 = [0, fs$1, rest$0],
          fs$0 = fs$2,
          rest$0 = rest$1;
         break;
        case 1:
         var f = fs$0[1];
         caml_call1(f, result);
         if(counter >= 50)
          return caml_trampoline_return(iter_list, [0, rest$0]);
         var counter$1 = counter + 1 | 0;
         return iter_list(counter$1, rest$0);
        default:
         var match = fs$0[1][1];
         if(match){
          var f$0 = match[1];
          caml_call1(f$0, result);
          if(counter >= 50)
           return caml_trampoline_return(iter_list, [0, rest$0]);
          var counter$2 = counter + 1 | 0;
          return iter_list(counter$2, rest$0);
         }
         if(counter >= 50)
          return caml_trampoline_return(iter_list, [0, rest$0]);
         var counter$3 = counter + 1 | 0;
         return iter_list(counter$3, rest$0);
      }
     }
    }
    function iter_list(counter, rest){
     if(! rest) return 0;
     var rest$0 = rest[2], fs = rest[1];
     if(counter >= 50)
      return caml_trampoline_return(iter_callback_list$1, [0, fs, rest$0]);
     var counter$0 = counter + 1 | 0;
     return iter_callback_list$1(counter$0, fs, rest$0);
    }
    function iter_callback_list$0(fs, rest){
     return caml_trampoline(iter_callback_list$1(0, fs, rest));
    }
    return iter_callback_list$0(fs$0, 0);
   }
   var
    current_callback_nesting_depth = [0, 0],
    deferred_callbacks = caml_call1(Stdlib_Queue[2], 0),
    default_maximum_callback_nesti = 42;
   function leave_resolution_loop(storage_snapshot){
    if(1 === current_callback_nesting_depth[1])
     for(;;){
      if(caml_call1(Stdlib_Queue[13], deferred_callbacks)) break;
      var
       match = caml_call1(Stdlib_Queue[7], deferred_callbacks),
       result = match[2],
       callbacks = match[1];
      run_callbacks(callbacks, result);
     }
    current_callback_nesting_depth[1] =
     current_callback_nesting_depth[1] - 1 | 0;
    current_storage[1] = storage_snapshot;
    return 0;
   }
   function run_in_resolution_loop(f){
    current_callback_nesting_depth[1] =
     current_callback_nesting_depth[1] + 1 | 0;
    var storage_snapshot = current_storage[1], result = caml_call1(f, 0);
    leave_resolution_loop(storage_snapshot);
    return result;
   }
   function abandon_wakeups(param){
    var _bh_ = 0 !== current_callback_nesting_depth[1] ? 1 : 0;
    return _bh_ ? leave_resolution_loop(Storage_map[1]) : _bh_;
   }
   function run_callbacks_or_defer_them(opt, _bg_, callbacks, result){
    if(opt)
     var sth = opt[1], allow_deferring = sth;
    else
     var allow_deferring = 1;
    if(_bg_)
     var sth$0 = _bg_[1], maximum_callback_nesting_depth = sth$0;
    else
     var maximum_callback_nesting_depth = default_maximum_callback_nesti;
    var
     should_defer =
       allow_deferring
        ? maximum_callback_nesting_depth
          <= current_callback_nesting_depth[1]
          ? 1
          : 0
        : allow_deferring;
    return should_defer
            ? caml_call2
              (Stdlib_Queue[4], [0, callbacks, result], deferred_callbacks)
            : run_in_resolution_loop
              (function(param){return run_callbacks(callbacks, result);});
   }
   function resolve
   (allow_deferring, maximum_callback_nesting_depth, p, result){
    var callbacks = p[1][1];
    set_promise_state(p, result);
    run_callbacks_or_defer_them
     (allow_deferring, maximum_callback_nesting_depth, callbacks, result);
    return;
   }
   function run_callback_or_defer_it(opt, f, if_deferred){
    if(opt)
     var sth = opt[1], run_immediately_and_ensure_tai = sth;
    else
     var run_immediately_and_ensure_tai = 0;
    if(run_immediately_and_ensure_tai) return caml_call1(f, 0);
    var should_defer = 42 <= current_callback_nesting_depth[1] ? 1 : 0;
    if(! should_defer)
     return run_in_resolution_loop(function(param){return caml_call1(f, 0);});
    var
     match = caml_call1(if_deferred, 0),
     deferred_result = match[3],
     deferred_callback = match[2],
     immediate_result = match[1],
     deferred_record = [0, [1, deferred_callback], 0, 0, 0];
    caml_call2
     (Stdlib_Queue[4],
      [0, deferred_record, deferred_result],
      deferred_callbacks);
    return immediate_result;
   }
   function wakeup_general(api_function_name, r, result){
    var p = underlying(r), _bf_ = p[1];
    switch(_bf_[0]){
      case 1:
       return _bf_[1] === Canceled
               ? 0
               : caml_call3
                 (Stdlib_Printf[10], Stdlib[1], _d_, api_function_name);
      case 2:
       var result$0 = state_of_result(result);
       resolve(_e_, 0, p, result$0);
       return 0;
      default:
       return caml_call3(Stdlib_Printf[10], Stdlib[1], _c_, api_function_name);
    }
   }
   function wakeup_result(r, result){
    return wakeup_general(cst_wakeup_result, r, result);
   }
   function wakeup(r, v){return wakeup_general(cst_wakeup, r, [0, v]);}
   function wakeup_exn(r, exn){
    return wakeup_general(cst_wakeup_exn, r, [1, exn]);
   }
   function wakeup_later_general(api_function_name, r, result){
    var p = underlying(r), _be_ = p[1];
    switch(_be_[0]){
      case 1:
       return _be_[1] === Canceled
               ? 0
               : caml_call3
                 (Stdlib_Printf[10], Stdlib[1], _g_, api_function_name);
      case 2:
       var result$0 = state_of_result(result);
       resolve(0, _h_, p, result$0);
       return 0;
      default:
       return caml_call3(Stdlib_Printf[10], Stdlib[1], _f_, api_function_name);
    }
   }
   function wakeup_later_result(r, result){
    return wakeup_later_general(cst_wakeup_later_result, r, result);
   }
   function wakeup_later(r, v){
    return wakeup_later_general(cst_wakeup_later, r, [0, v]);
   }
   function wakeup_later_exn(r, exn){
    return wakeup_later_general(cst_wakeup_later_exn, r, [1, exn]);
   }
   function cancel(p){
    var canceled_result = [1, Canceled];
    function cancel_and_collect_callbacks(callbacks_accumulator, p){
     var p$0 = p;
     for(;;){
      var p$1 = underlying(p$0), match = p$1[1];
      switch(match[0]){
        case 1:
         return callbacks_accumulator;
        case 2:
         var callbacks = match[1], match$0 = callbacks[3];
         if(typeof match$0 === "number")
          return 0 === match$0
                  ? callbacks_accumulator
                  : (set_promise_state
                     (p$1, canceled_result),
                    [0, callbacks, callbacks_accumulator]);
         if(0 !== match$0[0]){
          var ps = match$0[1];
          return caml_call3
                  (Stdlib_List[25],
                   cancel_and_collect_callbacks,
                   callbacks_accumulator,
                   ps);
         }
         var p$2 = match$0[1], p$0 = p$2;
         break;
        default: return callbacks_accumulator;
      }
     }
    }
    var callbacks = cancel_and_collect_callbacks(0, p);
    function _bd_(param){
     return run_callbacks_or_defer_them(_i_, 0, param, canceled_result);
    }
    return caml_call1(caml_call1(Stdlib_List[17], _bd_), callbacks);
   }
   function return$0(v){return [0, [0, v]];}
   function of_result(result){return [0, state_of_result(result)];}
   function fail(exn){return [0, [1, exn]];}
   var return_unit = return$0(0), return_none = return$0(0);
   function return_some(x){return return$0([0, x]);}
   var
    return_nil = return$0(0),
    return_true = return$0(1),
    return_false = return$0(0);
   function return_ok(x){return return$0([0, x]);}
   function return_error(x){return return$0([1, x]);}
   function fail_with(msg){return [0, [1, [0, Stdlib[7], msg]]];}
   function fail_invalid_arg(msg){return [0, [1, [0, Stdlib[6], msg]]];}
   function new_pending(how_to_cancel){
    var state = [2, [0, 0, 0, how_to_cancel, 0]];
    return [0, state];
   }
   function wait(param){var p = new_pending(0); return [0, p, p];}
   function task(param){var p = new_pending(1); return [0, p, p];}
   function add_task_r(sequence){
    var
     p = new_pending(1),
     node = caml_call2(Lwt_sequence[9], p, sequence),
     callbacks = p[1][1];
    callbacks[2] = [2, node];
    return p;
   }
   function add_task_l(sequence){
    var
     p = new_pending(1),
     node = caml_call2(Lwt_sequence[8], p, sequence),
     callbacks = p[1][1];
    callbacks[2] = [2, node];
    return p;
   }
   function protected$0(p_internal){
    switch(underlying(p_internal)[1][0]){
      case 1:
       return p_internal;
      case 2:
       var
        p = new_pending(1),
        callback =
          function(p_result){
           var p$0 = underlying(p);
           resolve(_j_, 0, p$0, p_result);
           return 0;
          },
        ps = [0, p_internal, 0],
        cell = add_explicitly_removable_callb(ps, callback),
        remove_the_callback =
          function(param){return clear_explicitly_removable_cal(cell, ps);},
        p_callbacks = p[1][1];
       add_cancel_callback(p_callbacks, remove_the_callback);
       return p;
      default: return p_internal;
    }
   }
   function no_cancel(p_internal){
    var match = underlying(p_internal)[1];
    switch(match[0]){
      case 1:
       return p_internal;
      case 2:
       var
        p_callbacks = match[1],
        p = new_pending(0),
        callback =
          function(p_result){
           var p$0 = underlying(p);
           resolve(_k_, 0, p$0, p_result);
           return 0;
          };
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p;
      default: return p_internal;
    }
   }
   function make_into_proxy(outer_promise, user_provided_promise){
    var p = underlying(user_provided_promise);
    if(p === outer_promise) return p;
    var match = p[1];
    switch(match[0]){
      case 1:
       return resolve(_m_, 0, outer_promise, p[1]);
      case 2:
       var
        p_callbacks = match[1],
        outer_callbacks = outer_promise[1][1],
        regular_callbacks =
          concat_regular_callbacks(outer_callbacks[1], p_callbacks[1]),
        cleanups_deferred = outer_callbacks[4] + p_callbacks[4] | 0;
       if(42 < cleanups_deferred)
        var
         cleanups_deferred$0 = 0,
         regular_callbacks$0 = clean_up_callback_cells(regular_callbacks);
       else
        var
         cleanups_deferred$0 = cleanups_deferred,
         regular_callbacks$0 = regular_callbacks;
       var
        l2 = p_callbacks[2],
        l1 = outer_callbacks[2],
        cancel_callbacks =
          typeof l1 === "number"
           ? l2
           : typeof l2 === "number" ? l1 : [0, l1, l2];
       outer_callbacks[1] = regular_callbacks$0;
       outer_callbacks[2] = cancel_callbacks;
       outer_callbacks[4] = cleanups_deferred$0;
       outer_callbacks[3] = p_callbacks[3];
       set_promise_state(p, [3, outer_promise]);
       return outer_promise;
      default: return resolve(_l_, 0, outer_promise, p[1]);
    }
   }
   function symbol_bind(p, f){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var p$2 = underlying(p);
       resolve(_n_, 0, p$2, p_result);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _bc_ = caml_call1(f, v), p$0 = _bc_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(exn);
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var result = p$0[1];
    switch(result[0]){
      case 1:
       return [0, result];
      case 2:
       var
        p_callbacks = result[1],
        match = create_result_promise_and_call(0),
        callback = match[2],
        p$1 = match[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var
        v = result[1],
        _bb_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_o_, function(param){return caml_call1(f, v);}, _bb_);
    }
   }
   function backtrace_bind(add_loc, p, f){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1], p$2 = underlying(p);
       resolve(_p_, 0, p$2, [1, caml_call1(add_loc, exn$0)]);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _ba_ = caml_call1(f, v), p$0 = _ba_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(caml_call1(add_loc, exn));
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; return [0, [1, caml_call1(add_loc, exn)]];
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var
        v = match[1],
        _a$_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_q_, function(param){return caml_call1(f, v);}, _a$_);
    }
   }
   function symbol(f, p){
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var p$1 = underlying(p);
       resolve(_s_, 0, p$1, p_result);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _a__ = [0, caml_call1(f, v)], p_result$0 = _a__;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p_result$0 = [1, exn];
      }
      var p$0 = underlying(p);
      resolve(_r_, 0, p$0, p_result$0);
      return 0;
     }
     return [0, p, callback];
    }
    var result = p$0[1];
    switch(result[0]){
      case 1:
       return [0, result];
      case 2:
       var
        p_callbacks = result[1],
        match = create_result_promise_and_call(0),
        callback = match[2],
        p$1 = match[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var
        v = result[1],
        _a7_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_t_,
                function(param){
                 try{var _a9_ = [0, caml_call1(f, v)], _a8_ = _a9_;}
                 catch(exn$0){
                  var exn = caml_wrap_exception(exn$0);
                  if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
                  var _a8_ = [1, exn];
                 }
                 return [0, _a8_];
                },
                _a7_);
    }
   }
   function catch$0(f, h){
    try{var _a5_ = caml_call1(f, 0), p = _a5_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 !== p_result[0]){
       var p$0 = underlying(p);
       resolve(_u_, 0, p$0, p_result);
       return 0;
      }
      var exn = p_result[1];
      current_storage[1] = saved_storage;
      try{var _a6_ = caml_call1(h, exn), p$1 = _a6_;}
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(! run(exn$0)) throw caml_maybe_attach_backtrace(exn$0, 0);
       var p$1 = fail(exn$0);
      }
      var p$2 = underlying(p);
      make_into_proxy(p$2, p$1);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        exn$0 = match[1],
        _a4_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_v_, function(param){return caml_call1(h, exn$0);}, _a4_);
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default: return p$0;
    }
   }
   function backtrace_catch(add_loc, f, h){
    try{var _a2_ = caml_call1(f, 0), p = _a2_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 !== p_result[0]){
       var p$0 = underlying(p);
       resolve(_w_, 0, p$0, p_result);
       return 0;
      }
      var exn = p_result[1];
      current_storage[1] = saved_storage;
      try{var _a3_ = caml_call1(h, exn), p$1 = _a3_;}
      catch(exn){
       var exn$0 = caml_wrap_exception(exn);
       if(! run(exn$0)) throw caml_maybe_attach_backtrace(exn$0, 0);
       var p$1 = fail(caml_call1(add_loc, exn$0));
      }
      var p$2 = underlying(p);
      make_into_proxy(p$2, p$1);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        exn$0 = match[1],
        _a1_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_x_,
                function(param){
                 return caml_call1(h, caml_call1(add_loc, exn$0));
                },
                _a1_);
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default: return p$0;
    }
   }
   function try_bind(f$0, f, h){
    try{var _aY_ = caml_call1(f$0, 0), p = _aY_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1];
       current_storage[1] = saved_storage;
       try{var _a0_ = caml_call1(h, exn$0), p$2 = _a0_;}
       catch(exn){
        var exn$1 = caml_wrap_exception(exn);
        if(! run(exn$1)) throw caml_maybe_attach_backtrace(exn$1, 0);
        var p$2 = fail(exn$1);
       }
       var p$3 = underlying(p);
       make_into_proxy(p$3, p$2);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aZ_ = caml_call1(f, v), p$0 = _aZ_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(exn);
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        exn$0 = match[1],
        _aX_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_z_, function(param){return caml_call1(h, exn$0);}, _aX_);
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var
        v = match[1],
        _aW_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_y_, function(param){return caml_call1(f, v);}, _aW_);
    }
   }
   function backtrace_try_bind(add_loc, f$0, f, h){
    try{var _aT_ = caml_call1(f$0, 0), p = _aT_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var p$0 = underlying(p);
    function create_result_promise_and_call(param){
     var p = new_pending([0, p$0]), saved_storage = current_storage[1];
     function callback(p_result){
      if(1 === p_result[0]){
       var exn$0 = p_result[1];
       current_storage[1] = saved_storage;
       try{var _aV_ = caml_call1(h, exn$0), p$2 = _aV_;}
       catch(exn){
        var exn$1 = caml_wrap_exception(exn);
        if(! run(exn$1)) throw caml_maybe_attach_backtrace(exn$1, 0);
        var p$2 = fail(caml_call1(add_loc, exn$1));
       }
       var p$3 = underlying(p);
       make_into_proxy(p$3, p$2);
       return 0;
      }
      var v = p_result[1];
      current_storage[1] = saved_storage;
      try{var _aU_ = caml_call1(f, v), p$0 = _aU_;}
      catch(exn$0){
       var exn = caml_wrap_exception(exn$0);
       if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
       var p$0 = fail(caml_call1(add_loc, exn));
      }
      var p$1 = underlying(p);
      make_into_proxy(p$1, p$0);
      return 0;
     }
     return [0, p, callback];
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        exn$0 = match[1],
        _aS_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_B_,
                function(param){
                 return caml_call1(h, caml_call1(add_loc, exn$0));
                },
                _aS_);
      case 2:
       var
        p_callbacks = match[1],
        match$0 = create_result_promise_and_call(0),
        callback = match$0[2],
        p$1 = match$0[1];
       add_implicitly_removed_callbac(p_callbacks, callback);
       return p$1;
      default:
       var
        v = match[1],
        _aR_ =
          function(param){
           var
            match = create_result_promise_and_call(0),
            callback = match[2],
            p = match[1];
           return [0, p, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_A_, function(param){return caml_call1(f, v);}, _aR_);
    }
   }
   function finalize(f$0, f){
    function _aO_(e){
     function _aQ_(param){return fail(e);}
     return symbol_bind(caml_call1(f, 0), _aQ_);
    }
    return try_bind
            (f$0,
             function(x){
              function _aP_(param){return return$0(x);}
              return symbol_bind(caml_call1(f, 0), _aP_);
             },
             _aO_);
   }
   function backtrace_finalize(add_loc, f$0, f){
    function _aL_(e){
     function _aN_(param){return fail(caml_call1(add_loc, e));}
     return symbol_bind(caml_call1(f, 0), _aN_);
    }
    return backtrace_try_bind
            (add_loc,
             f$0,
             function(x){
              function _aM_(param){return return$0(x);}
              return symbol_bind(caml_call1(f, 0), _aM_);
             },
             _aL_);
   }
   function on_cancel(p, f){
    var p$0 = underlying(p), match = p$0[1];
    switch(match[0]){
      case 1:
       if(match[1] !== Canceled) return 0;
       var
        _aK_ =
          function(param){
           return [0,
                   0,
                   function(param){
                    return handle_with_async_exception_ho(f, 0);
                   },
                   _C_];
          };
       return run_callback_or_defer_it
               (_D_,
                function(param){return handle_with_async_exception_ho(f, 0);},
                _aK_);
      case 2:
       var callbacks = match[1]; return add_cancel_callback(callbacks, f);
      default: return 0;
    }
   }
   function on_success(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 === result[0]) return 0;
      var v = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, v);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       return 0;
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       var
        v = match[1],
        _aJ_ =
          function(param){
           var callback = callback_if_deferred(0);
           return [0, 0, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_E_,
                function(param){return handle_with_async_exception_ho(f, v);},
                _aJ_);
    }
   }
   function on_failure(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 !== result[0]) return 0;
      var exn = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, exn);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        exn = match[1],
        _aI_ =
          function(param){
           var callback = callback_if_deferred(0);
           return [0, 0, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_F_,
                function(param){
                 return handle_with_async_exception_ho(f, exn);
                },
                _aI_);
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function on_termination(p, f){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, 0);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        _aH_ =
          function(param){
           var callback = callback_if_deferred(0);
           return [0, 0, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_H_,
                function(param){return handle_with_async_exception_ho(f, 0);},
                _aH_);
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       var
        _aG_ =
          function(param){
           var callback = callback_if_deferred(0);
           return [0, 0, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_G_,
                function(param){return handle_with_async_exception_ho(f, 0);},
                _aG_);
    }
   }
   function on_any(p, f, g){
    var p$0 = underlying(p);
    function callback_if_deferred(param){
     var saved_storage = current_storage[1];
     return function(result){
      if(1 === result[0]){
       var exn = result[1];
       current_storage[1] = saved_storage;
       return handle_with_async_exception_ho(g, exn);
      }
      var v = result[1];
      current_storage[1] = saved_storage;
      return handle_with_async_exception_ho(f, v);};
    }
    var match = p$0[1];
    switch(match[0]){
      case 1:
       var
        exn = match[1],
        _aF_ =
          function(param){
           var callback = callback_if_deferred(0);
           return [0, 0, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_J_,
                function(param){
                 return handle_with_async_exception_ho(g, exn);
                },
                _aF_);
      case 2:
       var p_callbacks = match[1], callback = callback_if_deferred(0);
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default:
       var
        v = match[1],
        _aE_ =
          function(param){
           var callback = callback_if_deferred(0);
           return [0, 0, callback, p$0[1]];
          };
       return run_callback_or_defer_it
               (_I_,
                function(param){return handle_with_async_exception_ho(f, v);},
                _aE_);
    }
   }
   function wrap_in_cancelable(p_internal){
    var p_underlying = underlying(p_internal);
    switch(p_underlying[1][0]){
      case 1:
       return p_internal;
      case 2:
       var match = task(0), r = match[2], p = match[1];
       on_cancel(p, function(param){return cancel(p_internal);});
       var _aB_ = function(_aD_){return wakeup_exn(r, _aD_);};
       on_any(p_internal, function(_aC_){return wakeup(r, _aC_);}, _aB_);
       return p;
      default: return p_internal;
    }
   }
   function dont_wait(f, h){
    try{var _aA_ = caml_call1(f, 0), p = _aA_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1]; return caml_call1(h, exn$0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(h, exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function async(f){
    try{var _az_ = caml_call1(f, 0), p = _az_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(! run(exn)) throw caml_maybe_attach_backtrace(exn, 0);
     var p = fail(exn);
    }
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn$0 = match[1];
       return caml_call1(async_exception_hook[1], exn$0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(async_exception_hook[1], exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function ignore_result(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; throw caml_maybe_attach_backtrace(exn, 0);
      case 2:
       var
        p_callbacks = match[1],
        callback =
          function(result){
           if(1 !== result[0]) return 0;
           var exn = result[1];
           return caml_call1(async_exception_hook[1], exn);
          };
       return add_implicitly_removed_callbac(p_callbacks, callback);
      default: return 0;
    }
   }
   function join(ps){
    var
     p = new_pending([1, ps]),
     number_pending_in_ps = [0, 0],
     join_result = [0, _K_];
    function callback(new_result){
     if(1 === new_result[0] && 1 !== join_result[1][0])
      join_result[1] = new_result;
     number_pending_in_ps[1] = number_pending_in_ps[1] - 1 | 0;
     var _aw_ = 0 === number_pending_in_ps[1] ? 1 : 0;
     if(_aw_){
      var p$0 = underlying(p), _ax_ = join_result[1];
      resolve(_L_, 0, underlying(p$0), _ax_);
      var _ay_ = 0;
     }
     else
      var _ay_ = _aw_;
     return _ay_;
    }
    var ps$0 = ps;
    for(;;){
     if(! ps$0)
      return 0 === number_pending_in_ps[1] ? [0, join_result[1]] : p;
     var ps$1 = ps$0[2], p$0 = ps$0[1], p_result = underlying(p$0)[1];
     switch(p_result[0]){
       case 1:
        if(1 !== join_result[1][0]) join_result[1] = p_result;
        var ps$0 = ps$1;
        break;
       case 2:
        var p_callbacks = p_result[1];
        number_pending_in_ps[1] = number_pending_in_ps[1] + 1 | 0;
        add_implicitly_removed_callbac(p_callbacks, callback);
        var ps$0 = ps$1;
        break;
       default: var ps$0 = ps$1;
     }
    }
   }
   function both(p1, p2){
    var
     pair = [0, 0, 0],
     p1$0 =
       symbol_bind(p1, function(v){pair[1] = [0, v]; return return_unit;}),
     p2$0 =
       symbol_bind(p2, function(v){pair[2] = [0, v]; return return_unit;}),
     _au_ = join([0, p1$0, [0, p2$0, 0]]);
    return symbol
            (function(param){
              var _av_ = pair[1], match = pair[2];
              if(_av_ && match){
               var v2 = match[1], v1 = _av_[1];
               return [0, v1, v2];
              }
              throw caml_maybe_attach_backtrace([0, Assert_failure, _M_], 1);
             },
             _au_);
   }
   function all(ps){
    if(! ps) return return_nil;
    var _aq_ = ps[2], x = ps[1];
    if(! _aq_) return symbol(function(y){return [0, y, 0];}, x);
    if(_aq_[2]){
     var
      vs = runtime.caml_make_vect(caml_call1(Stdlib_List[1], ps), 0),
      _ar_ =
        function(index, p){
         return symbol_bind
                 (p,
                  function(v){
                   runtime.caml_check_bound(vs, index)[1 + index] = [0, v];
                   return return_unit;
                  });
        },
      _as_ = join(caml_call1(caml_call1(Stdlib_List[20], _ar_), ps));
     return symbol
             (function(param){
               var i$1 = vs.length - 1 - 1 | 0, i = i$1, acc = 0;
               for(;;){
                if(0 > i) return acc;
                var match = vs[1 + i];
                if(! match)
                 throw caml_maybe_attach_backtrace
                        ([0, Assert_failure, _N_], 1);
                var
                 x = match[1],
                 acc$0 = [0, x, acc],
                 i$0 = i - 1 | 0,
                 i = i$0,
                 acc = acc$0;
               }
              },
              _as_);
    }
    var y = _aq_[1], _at_ = both(x, y);
    return symbol
            (function(param){
              var y = param[2], x = param[1];
              return [0, x, [0, y, 0]];
             },
             _at_);
   }
   function count_resolved_promises_in(ps){
    var total$1 = 0, ps$2 = ps;
    a:
    for(;;){
     if(! ps$2) return [0, total$1];
     var ps$3 = ps$2[2], p$0 = ps$2[1];
     switch(underlying(p$0)[1][0]){
       case 1:
        break a;
       case 2:
        var ps$2 = ps$3; break;
       default: var total$2 = total$1 + 1 | 0, total$1 = total$2, ps$2 = ps$3;
     }
    }
    var
     rejected$1 = [0, p$0, 0],
     total = 1,
     rejected = rejected$1,
     ps$0 = ps$3;
    for(;;){
     if(! ps$0) return [1, [0, total, rejected]];
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        var
         rejected$0 = [0, p, rejected],
         total$0 = total + 1 | 0,
         total = total$0,
         rejected = rejected$0,
         ps$0 = ps$1;
        break;
       case 2:
        var ps$0 = ps$1; break;
       default: var ps$0 = ps$1;
     }
    }
   }
   function nth_resolved(ps, n){
    var ps$0 = ps, n$0 = n;
    for(;;){
     if(! ps$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _O_], 1);
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        if(0 >= n$0) return p;
        var n$2 = n$0 - 1 | 0, ps$0 = ps$1, n$0 = n$2;
        break;
       case 2:
        var ps$0 = ps$1; break;
       default:
        if(0 >= n$0) return p; var n$1 = n$0 - 1 | 0, ps$0 = ps$1, n$0 = n$1;
     }
    }
   }
   function nth_resolved_and_cancel_pendin(ps, n){
    var ps$0 = ps, n$0 = n;
    for(;;){
     if(! ps$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _P_], 1);
     var ps$1 = ps$0[2], p = ps$0[1];
     switch(underlying(p)[1][0]){
       case 1:
        if(0 >= n$0){caml_call2(Stdlib_List[17], cancel, ps$1); return p;}
        var n$2 = n$0 - 1 | 0, ps$0 = ps$1, n$0 = n$2;
        break;
       case 2:
        cancel(p); var ps$0 = ps$1; break;
       default:
        if(0 >= n$0){caml_call2(Stdlib_List[17], cancel, ps$1); return p;}
        var n$1 = n$0 - 1 | 0, ps$0 = ps$1, n$0 = n$1;
     }
    }
   }
   var
    prng =
      [246, function(_ap_){return caml_call1(Stdlib_Random[15][1], [0]);}];
   function choose(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_choose_would_return_a_);
    var match = count_resolved_promises_in(ps);
    if(0 !== match[0]){
     var
      match$0 = match[1],
      ps$0 = match$0[2],
      n$0 = match$0[1],
      _an_ = caml_obj_tag(prng),
      _ao_ =
        250 === _an_
         ? prng[1]
         : 246 === _an_ ? caml_call1(CamlinternalLazy[2], prng) : prng;
     return nth_resolved(ps$0, caml_call2(Stdlib_Random[15][5], _ao_, n$0));
    }
    var n = match[1];
    if(0 === n){
     var
      p = new_pending([1, ps]),
      callback =
        function(result){
         var p$0 = underlying(p);
         resolve(_Q_, 0, p$0, result);
         return 0;
        };
     add_explicitly_removable_callb$0(ps, callback);
     return p;
    }
    if(1 === n) return nth_resolved(ps, 0);
    var
     _al_ = caml_obj_tag(prng),
     _am_ =
       250 === _al_
        ? prng[1]
        : 246 === _al_ ? caml_call1(CamlinternalLazy[2], prng) : prng;
    return nth_resolved(ps, caml_call2(Stdlib_Random[15][5], _am_, n));
   }
   function pick(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_pick_would_return_a_pr);
    var match = count_resolved_promises_in(ps);
    if(0 !== match[0]){
     var match$0 = match[1], qs = match$0[2], n$0 = match$0[1];
     caml_call2(Stdlib_List[17], cancel, ps);
     var
      _aj_ = caml_obj_tag(prng),
      _ak_ =
        250 === _aj_
         ? prng[1]
         : 246 === _aj_ ? caml_call1(CamlinternalLazy[2], prng) : prng;
     return nth_resolved(qs, caml_call2(Stdlib_Random[15][5], _ak_, n$0));
    }
    var n = match[1];
    if(0 === n){
     var
      p = new_pending([1, ps]),
      callback =
        function(result){
         caml_call2(Stdlib_List[17], cancel, ps);
         var p$0 = underlying(p);
         resolve(_R_, 0, p$0, result);
         return 0;
        };
     add_explicitly_removable_callb$0(ps, callback);
     return p;
    }
    if(1 === n) return nth_resolved_and_cancel_pendin(ps, 0);
    var
     _ah_ = caml_obj_tag(prng),
     _ai_ =
       250 === _ah_
        ? prng[1]
        : 246 === _ah_ ? caml_call1(CamlinternalLazy[2], prng) : prng;
    return nth_resolved_and_cancel_pendin
            (ps, caml_call2(Stdlib_Random[15][5], _ai_, n));
   }
   function collect_fulfilled_promises_aft(results, ps){
    var results$0 = results, ps$0 = ps;
    for(;;){
     if(! ps$0) return [0, caml_call1(Stdlib_List[9], results$0)];
     var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
     switch(result[0]){
       case 1:
        return result;
       case 2:
        var ps$0 = ps$1; break;
       default:
        var
         v = result[1],
         results$1 = [0, v, results$0],
         results$0 = results$1,
         ps$0 = ps$1;
     }
    }
   }
   function nchoose(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_nchoose_would_return_a);
    var ps$2 = ps;
    a:
    for(;;){
     if(! ps$2){
      var
       p$1 = new_pending([1, ps]),
       callback =
         function(result){
          var
           p = underlying(p$1),
           result$0 = collect_fulfilled_promises_aft(0, ps);
          resolve(_S_, 0, p, result$0);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      return p$1;
     }
     var ps$3 = ps$2[2], p$0 = ps$2[1], result$0 = underlying(p$0)[1];
     switch(result$0[0]){
       case 1:
        return [0, result$0];
       case 2:
        var ps$2 = ps$3; break;
       default: break a;
     }
    }
    var v$0 = result$0[1], acc$1 = [0, v$0, 0], acc = acc$1, ps$0 = ps$3;
    for(;;){
     if(! ps$0) return return$0(caml_call1(Stdlib_List[9], acc));
     var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
     switch(result[0]){
       case 1:
        return [0, result];
       case 2:
        var ps$0 = ps$1; break;
       default:
        var v = result[1], acc$0 = [0, v, acc], acc = acc$0, ps$0 = ps$1;
     }
    }
   }
   function npick(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_npick_would_return_a_p);
    var ps$2 = ps;
    a:
    for(;;){
     if(! ps$2){
      var
       p$1 = new_pending([1, ps]),
       callback =
         function(result){
          var
           p = underlying(p$1),
           result$0 = collect_fulfilled_promises_aft(0, ps);
          caml_call2(Stdlib_List[17], cancel, ps);
          resolve(_T_, 0, p, result$0);
          return 0;
         };
      add_explicitly_removable_callb$0(ps, callback);
      return p$1;
     }
     var ps$3 = ps$2[2], p$0 = ps$2[1], result$0 = underlying(p$0)[1];
     switch(result$0[0]){
       case 1:
        caml_call2(Stdlib_List[17], cancel, ps); return [0, result$0];
       case 2:
        var ps$2 = ps$3; break;
       default: break a;
     }
    }
    var v$0 = result$0[1], acc$1 = [0, v$0, 0], acc = acc$1, ps$0 = ps$3;
    for(;;){
     if(! ps$0){
      caml_call2(Stdlib_List[17], cancel, ps);
      return return$0(caml_call1(Stdlib_List[9], acc));
     }
     var ps$1 = ps$0[2], p = ps$0[1], result = underlying(p)[1];
     switch(result[0]){
       case 1:
        caml_call2(Stdlib_List[17], cancel, ps); return [0, result];
       case 2:
        var ps$0 = ps$1; break;
       default:
        var v = result[1], acc$0 = [0, v, acc], acc = acc$0, ps$0 = ps$1;
     }
    }
   }
   function nchoose_split(ps){
    if(0 === ps) caml_call1(Stdlib[1], cst_Lwt_nchoose_split_would_re);
    var pending_acc = 0, ps$2 = ps;
    a:
    for(;;){
     if(! ps$2){
      var
       p = new_pending([1, ps]),
       callback =
         function(result$0){
          var
           to_resolve = underlying(p),
           fulfilled = 0,
           pending = 0,
           ps$0 = ps;
          for(;;){
           if(ps$0){
            var
             ps$1 = ps$0[2],
             p_internal = ps$0[1],
             result = underlying(p_internal)[1];
            switch(result[0]){
              case 1:
               resolve(_U_, 0, to_resolve, result); break;
              case 2:
               var
                pending$0 = [0, p_internal, pending],
                pending = pending$0,
                ps$0 = ps$1;
               continue;
              default:
               var
                v = result[1],
                fulfilled$0 = [0, v, fulfilled],
                fulfilled = fulfilled$0,
                ps$0 = ps$1;
               continue;
            }
           }
           else{
            var _ag_ = caml_call1(Stdlib_List[9], pending);
            resolve
             (_V_,
              0,
              to_resolve,
              [0, [0, caml_call1(Stdlib_List[9], fulfilled), _ag_]]);
           }
           return 0;
          }
         };
      add_explicitly_removable_callb$0(ps, callback);
      return p;
     }
     var
      ps$3 = ps$2[2],
      p_internal$0 = ps$2[1],
      result$0 = underlying(p_internal$0)[1];
     switch(result$0[0]){
       case 1:
        return [0, result$0];
       case 2:
        var
         pending_acc$0 = [0, p_internal$0, pending_acc],
         pending_acc = pending_acc$0,
         ps$2 = ps$3;
        break;
       default: break a;
     }
    }
    var
     v$0 = result$0[1],
     results$1 = [0, v$0, 0],
     results = results$1,
     pending = pending_acc,
     ps$0 = ps$3;
    for(;;){
     if(! ps$0)
      return return$0([0, caml_call1(Stdlib_List[9], results), pending]);
     var
      ps$1 = ps$0[2],
      p_internal = ps$0[1],
      result = underlying(p_internal)[1];
     switch(result[0]){
       case 1:
        return [0, result];
       case 2:
        var
         pending$0 = [0, p_internal, pending],
         pending = pending$0,
         ps$0 = ps$1;
        break;
       default:
        var
         v = result[1],
         results$0 = [0, v, results],
         results = results$0,
         ps$0 = ps$1;
     }
    }
   }
   function state(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var exn = match[1]; return [1, exn];
      case 2:
       return 0;
      default: var v = match[1]; return [0, v];
    }
   }
   function debug_state_is(expected_state, p){
    return return$0(runtime.caml_equal(state(p), expected_state));
   }
   function is_sleeping(p){
    switch(underlying(p)[1][0]){
      case 1:
       return 0;
      case 2:
       return 1;
      default: return 0;
    }
   }
   function poll(p){
    var match = underlying(p)[1];
    switch(match[0]){
      case 1:
       var e = match[1]; throw caml_maybe_attach_backtrace(e, 0);
      case 2:
       return 0;
      default: var v = match[1]; return [0, v];
    }
   }
   function apply(f, x){
    try{var _af_ = caml_call1(f, x); return _af_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap(f){
    try{var _ae_ = return$0(caml_call1(f, 0)); return _ae_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap1(f, x1){
    try{var _ad_ = return$0(caml_call1(f, x1)); return _ad_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap2(f, x1, x2){
    try{var _ac_ = return$0(caml_call2(f, x1, x2)); return _ac_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap3(f, x1, x2, x3){
    try{var _ab_ = return$0(caml_call3(f, x1, x2, x3)); return _ab_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap4(f, x1, x2, x3, x4){
    try{var _aa_ = return$0(caml_call4(f, x1, x2, x3, x4)); return _aa_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap5(f, x1, x2, x3, x4, x5){
    try{var _$_ = return$0(caml_call5(f, x1, x2, x3, x4, x5)); return _$_;}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap6(f, x1, x2, x3, x4, x5, x6){
    try{var ___ = return$0(caml_call6(f, x1, x2, x3, x4, x5, x6)); return ___;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   function wrap7(f, x1, x2, x3, x4, x5, x6, x7){
    try{
     var _Z_ = return$0(caml_call7(f, x1, x2, x3, x4, x5, x6, x7));
     return _Z_;
    }
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(run(exn)) return fail(exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
   }
   var
    pause_hook = [0, function(_Y_){return;}],
    paused = caml_call1(Lwt_sequence[4], 0),
    _W_ = [0, 0];
   function pause(param){
    var p = add_task_r(paused);
    _W_[1]++;
    caml_call1(pause_hook[1], _W_[1]);
    return p;
   }
   function wakeup_paused(param){
    if(caml_call1(Lwt_sequence[6], paused)){_W_[1] = 0; return 0;}
    var tmp = caml_call1(Lwt_sequence[4], 0);
    caml_call2(Lwt_sequence[16], paused, tmp);
    _W_[1] = 0;
    function _X_(r){return wakeup(r, 0);}
    return caml_call2(Lwt_sequence[17], _X_, tmp);
   }
   function register_pause_notifier(f){pause_hook[1] = f; return 0;}
   function abandon_paused(param){
    caml_call1(Lwt_sequence[5], paused);
    _W_[1] = 0;
    return 0;
   }
   function paused_count(param){return _W_[1];}
   function map(t, f){return symbol(f, t);}
   function bind(t, f){return symbol_bind(t, f);}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, map, bind, both, Open_on_rhs],
    Let_syntax$0 = [0, Let_syntax];
   function symbol$0(f, p){return symbol_bind(p, f);}
   function symbol$1(p, f){return symbol(f, p);}
   function symbol$2(p$0, p){return join([0, p$0, [0, p, 0]]);}
   function symbol$3(p$0, p){return choose([0, p$0, [0, p, 0]]);}
   var Let_syntax$1 = Let_syntax$0[1];
   function let$0(x, f){return symbol(f, x);}
   var
    Syntax = [0, symbol_bind, both, let$0, both],
    Lwt =
      [0,
       wait,
       wakeup_later,
       wakeup_later_exn,
       return$0,
       fail,
       symbol_bind,
       catch$0,
       finalize,
       try_bind,
       dont_wait,
       async,
       async_exception_hook,
       both,
       join,
       all,
       pick,
       choose,
       npick,
       nchoose,
       nchoose_split,
       Canceled,
       task,
       cancel,
       on_cancel,
       protected$0,
       no_cancel,
       wrap_in_cancelable,
       symbol,
       on_success,
       on_failure,
       on_termination,
       on_any,
       [0,
        symbol_bind,
        symbol$1,
        symbol$2,
        symbol$3,
        symbol$0,
        symbol,
        Let_syntax$1],
       Let_syntax$0,
       Syntax,
       return_unit,
       return_none,
       return_nil,
       return_true,
       return_false,
       return_some,
       return_ok,
       return_error,
       fail_with,
       fail_invalid_arg,
       of_result,
       wakeup_later_result,
       state,
       new_key,
       get,
       with_value,
       wakeup,
       wakeup_exn,
       wakeup_result,
       add_task_r,
       add_task_l,
       pause,
       wakeup_paused,
       paused_count,
       register_pause_notifier,
       abandon_paused,
       wrap,
       wrap1,
       wrap2,
       wrap3,
       wrap4,
       wrap5,
       wrap6,
       wrap7,
       symbol_bind,
       symbol$1,
       symbol$3,
       symbol$2,
       symbol$0,
       symbol,
       is_sleeping,
       ignore_result,
       [0, handle_all, handle_all_except_runtime, set, run],
       poll,
       apply,
       backtrace_bind,
       backtrace_catch,
       backtrace_finalize,
       backtrace_try_bind,
       abandon_wakeups,
       debug_state_is];
   runtime.caml_register_global(71, Lwt, "Lwt");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_switch
//# unitInfo: Requires: Lwt, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Off = [248, "Lwt_switch.Off", runtime.caml_fresh_oo_id(0)];
   function create(param){return [0, [0, [0, 0]]];}
   function is_on(switch$0){return switch$0[1] ? 1 : 0;}
   function check(param){
    if(param && ! param[1][1]) throw caml_maybe_attach_backtrace(Off, 1);
    return 0;
   }
   function add_hook(switch$0, hook){
    if(! switch$0) return 0;
    var match = switch$0[1][1];
    if(! match) throw caml_maybe_attach_backtrace(Off, 1);
    var os = match[1];
    os[1] = [0, hook, os[1]];
    return 0;
   }
   function add_hook_or_exec(switch$0, hook){
    if(! switch$0) return Lwt[36];
    var match = switch$0[1][1];
    if(! match) return caml_call1(hook, 0);
    var os = match[1];
    os[1] = [0, hook, os[1]];
    return Lwt[36];
   }
   function turn_off(switch$0){
    var _c_ = switch$0[1];
    if(! _c_) return Lwt[36];
    var hooks = _c_[1][1];
    switch$0[1] = 0;
    function _d_(hook){return caml_call2(Lwt[80], hook, 0);}
    var _e_ = caml_call2(Stdlib_List[19], _d_, hooks);
    return caml_call1(Lwt[14], _e_);
   }
   function with_switch(fn){
    var switch$0 = create(0);
    function _a_(param){return turn_off(switch$0);}
    function _b_(param){return caml_call1(fn, switch$0);}
    return caml_call2(Lwt[8], _b_, _a_);
   }
   var
    Lwt_switch =
      [0,
       create,
       with_switch,
       is_on,
       turn_off,
       Off,
       check,
       add_hook,
       add_hook_or_exec];
   runtime.caml_register_global(3, Lwt_switch, "Lwt_switch");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_seq
//# unitInfo: Requires: Lwt, Stdlib, Stdlib__List, Stdlib__Printf
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    return_nil = caml_call1(Lwt[4], 0),
    _h_ =
      [0,
       [11,
        "Lwt_seq.iter_n: max_concurrency must be > 0, ",
        [4, 0, 0, 0, [11, " given", 0]]],
       "Lwt_seq.iter_n: max_concurrency must be > 0, %d given"];
   function empty(param){return return_nil;}
   function return$0(x, param){return caml_call1(Lwt[4], [0, x, empty]);}
   function return_lwt(x, param){
    function _bA_(x){return [0, x, empty];}
    return caml_call2(Lwt[35][3], x, _bA_);
   }
   function cons(x, t, param){return caml_call1(Lwt[4], [0, x, t]);}
   function cons_lwt(x, t, param){
    function _bz_(x){return [0, x, t];}
    return caml_call2(Lwt[35][3], x, _bz_);
   }
   function _a_(seq1, seq2, param){
    function _bv_(param){
     if(! param) return caml_call1(seq2, 0);
     var
      next = param[2],
      x = param[1],
      _bx_ = [0, x, function(_by_){return _a_(next, seq2, _by_);}];
     return caml_call1(Lwt[4], _bx_);
    }
    var _bw_ = caml_call1(seq1, 0);
    return caml_call2(Lwt[33][1], _bw_, _bv_);
   }
   function append(seq1, seq2, param){
    function _br_(param){
     if(! param) return caml_call1(seq2, 0);
     var
      next = param[2],
      x = param[1],
      _bt_ = [0, x, function(_bu_){return _a_(next, seq2, _bu_);}];
     return caml_call1(Lwt[4], _bt_);
    }
    var _bs_ = caml_call2(Lwt[80], seq1, 0);
    return caml_call2(Lwt[33][1], _bs_, _br_);
   }
   function _b_(f, seq, param){
    function _bo_(param){
     if(! param) return 0;
     var next = param[2], x = param[1], x$0 = caml_call1(f, x);
     return [0, x$0, function(_bq_){return _b_(f, next, _bq_);}];
    }
    var _bp_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][2], _bp_, _bo_);
   }
   function map(f, seq, param){
    function _bl_(param){
     if(! param) return 0;
     var next = param[2], x = param[1], x$0 = caml_call1(f, x);
     return [0, x$0, function(_bn_){return _b_(f, next, _bn_);}];
    }
    var _bm_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][2], _bm_, _bl_);
   }
   function _c_(f, seq, param){
    function _bg_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     function _bi_(x){
      return [0, x, function(_bk_){return _c_(f, next, _bk_);}];
     }
     var _bj_ = caml_call1(f, x);
     return caml_call2(Lwt[35][3], _bj_, _bi_);
    }
    var _bh_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][1], _bh_, _bg_);
   }
   function map_s(f, seq, param){
    function _bb_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     function _bd_(x){
      return [0, x, function(_bf_){return _c_(f, next, _bf_);}];
     }
     var _be_ = caml_call1(f, x);
     return caml_call2(Lwt[35][3], _be_, _bd_);
    }
    var _bc_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _bc_, _bb_);
   }
   function _d_(f, seq, param){
    function _a9_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1], x$0 = caml_call1(f, x);
     if(! x$0) return _d_(f, next, 0);
     var
      y = x$0[1],
      _a$_ = [0, y, function(_ba_){return _d_(f, next, _ba_);}];
     return caml_call1(Lwt[4], _a$_);
    }
    var _a__ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][1], _a__, _a9_);
   }
   function filter_map(f, seq, param){
    function _a5_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1], x$0 = caml_call1(f, x);
     if(! x$0) return _d_(f, next, 0);
     var
      y = x$0[1],
      _a7_ = [0, y, function(_a8_){return _d_(f, next, _a8_);}];
     return caml_call1(Lwt[4], _a7_);
    }
    var _a6_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _a6_, _a5_);
   }
   function _e_(f, seq, param){
    function _aZ_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     function _a1_(x){
      if(! x) return _e_(f, next, 0);
      var y = x[1], _a3_ = [0, y, function(_a4_){return _e_(f, next, _a4_);}];
      return caml_call1(Lwt[4], _a3_);
     }
     var _a2_ = caml_call1(f, x);
     return caml_call2(Lwt[35][1], _a2_, _a1_);
    }
    var _a0_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][1], _a0_, _aZ_);
   }
   function filter_map_s(f, seq, param){
    function _aT_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     function _aV_(x){
      if(! x) return _e_(f, next, 0);
      var y = x[1], _aX_ = [0, y, function(_aY_){return _e_(f, next, _aY_);}];
      return caml_call1(Lwt[4], _aX_);
     }
     var _aW_ = caml_call1(f, x);
     return caml_call2(Lwt[35][1], _aW_, _aV_);
    }
    var _aU_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _aU_, _aT_);
   }
   function _f_(f, seq, param){
    function _aP_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1], ok = caml_call1(f, x);
     if(! ok) return _f_(f, next, 0);
     var _aR_ = [0, x, function(_aS_){return _f_(f, next, _aS_);}];
     return caml_call1(Lwt[4], _aR_);
    }
    var _aQ_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][1], _aQ_, _aP_);
   }
   function filter(f, seq, param){
    function _aL_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1], ok = caml_call1(f, x);
     if(! ok) return _f_(f, next, 0);
     var _aN_ = [0, x, function(_aO_){return _f_(f, next, _aO_);}];
     return caml_call1(Lwt[4], _aN_);
    }
    var _aM_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _aM_, _aL_);
   }
   function _g_(f, seq, param){
    function _aF_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     function _aH_(ok){
      if(! ok) return _g_(f, next, 0);
      var _aJ_ = [0, x, function(_aK_){return _g_(f, next, _aK_);}];
      return caml_call1(Lwt[4], _aJ_);
     }
     var _aI_ = caml_call1(f, x);
     return caml_call2(Lwt[35][1], _aI_, _aH_);
    }
    var _aG_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][1], _aG_, _aF_);
   }
   function filter_s(f, seq, param){
    function _az_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     function _aB_(ok){
      if(! ok) return _g_(f, next, 0);
      var _aD_ = [0, x, function(_aE_){return _g_(f, next, _aE_);}];
      return caml_call1(Lwt[4], _aD_);
     }
     var _aC_ = caml_call1(f, x);
     return caml_call2(Lwt[35][1], _aC_, _aB_);
    }
    var _aA_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _aA_, _az_);
   }
   function flat_map_app(f, seq, tail, param){
    function _at_(param){
     if(param){
      var
       next = param[2],
       x = param[1],
       _ax_ =
         [0, x, function(_ay_){return flat_map_app(f, next, tail, _ay_);}];
      return caml_call1(Lwt[4], _ax_);
     }
     function _av_(param){
      if(! param) return return_nil;
      var next = param[2], x = param[1];
      return flat_map_app(f, caml_call1(f, x), next, 0);
     }
     var _aw_ = caml_call1(tail, 0);
     return caml_call2(Lwt[33][1], _aw_, _av_);
    }
    var _au_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][1], _au_, _at_);
   }
   function flat_map(f, seq, param){
    function _ar_(param){
     if(! param) return return_nil;
     var next = param[2], x = param[1];
     return flat_map_app(f, caml_call1(f, x), next, 0);
    }
    var _as_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _as_, _ar_);
   }
   function fold_left(f, acc, seq){
    function aux(f, acc, seq){
     function _ap_(param){
      if(! param) return caml_call1(Lwt[4], acc);
      var next = param[2], x = param[1], acc$0 = caml_call2(f, acc, x);
      return aux(f, acc$0, next);
     }
     var _aq_ = caml_call1(seq, 0);
     return caml_call2(Lwt[33][1], _aq_, _ap_);
    }
    function _an_(param){
     if(! param) return caml_call1(Lwt[4], acc);
     var next = param[2], x = param[1], acc$0 = caml_call2(f, acc, x);
     return aux(f, acc$0, next);
    }
    var _ao_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _ao_, _an_);
   }
   function fold_left_s(f, acc, seq){
    function aux(f, acc, seq){
     function _aj_(param){
      if(! param) return caml_call1(Lwt[4], acc);
      var next = param[2], x = param[1];
      function _al_(acc){return aux(f, acc, next);}
      var _am_ = caml_call2(f, acc, x);
      return caml_call2(Lwt[35][1], _am_, _al_);
     }
     var _ak_ = caml_call1(seq, 0);
     return caml_call2(Lwt[33][1], _ak_, _aj_);
    }
    function _af_(param){
     if(! param) return caml_call1(Lwt[4], acc);
     var next = param[2], x = param[1];
     function _ah_(acc){return aux(f, acc, next);}
     var _ai_ = caml_call2(f, acc, x);
     return caml_call2(Lwt[35][1], _ai_, _ah_);
    }
    var _ag_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _ag_, _af_);
   }
   function iter(f, seq){
    function aux(seq){
     function _ad_(param){
      if(! param) return Lwt[36];
      var next = param[2], x = param[1];
      caml_call1(f, x);
      return aux(next);
     }
     var _ae_ = caml_call1(seq, 0);
     return caml_call2(Lwt[33][1], _ae_, _ad_);
    }
    function _ab_(param){
     if(! param) return Lwt[36];
     var next = param[2], x = param[1];
     caml_call1(f, x);
     return aux(next);
    }
    var _ac_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _ac_, _ab_);
   }
   function iter_s(f, seq){
    function aux(seq){
     function _Z_(param){
      if(! param) return Lwt[36];
      var next = param[2], x = param[1];
      function _$_(param){return aux(next);}
      var _aa_ = caml_call1(f, x);
      return caml_call2(Lwt[35][1], _aa_, _$_);
     }
     var ___ = caml_call1(seq, 0);
     return caml_call2(Lwt[33][1], ___, _Z_);
    }
    function _V_(param){
     if(! param) return Lwt[36];
     var next = param[2], x = param[1];
     function _X_(param){return aux(next);}
     var _Y_ = caml_call1(f, x);
     return caml_call2(Lwt[35][1], _Y_, _X_);
    }
    var _W_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _W_, _V_);
   }
   function iter_p(f, seq){
    function aux(acc, seq){
     function _T_(param){
      if(! param) return caml_call1(Lwt[14], acc);
      var next = param[2], x = param[1], p = caml_call1(f, x);
      return aux([0, p, acc], next);
     }
     var _U_ = caml_call1(seq, 0);
     return caml_call2(Lwt[33][1], _U_, _T_);
    }
    var acc = 0;
    function _R_(param){
     if(! param) return caml_call1(Lwt[14], acc);
     var next = param[2], x = param[1], p = caml_call1(f, x);
     return aux([0, p, acc], next);
    }
    var _S_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _S_, _R_);
   }
   function iter_n(opt, f, seq){
    if(opt)
     var sth = opt[1], max_concurrency = sth;
    else
     var max_concurrency = 1;
    if(max_concurrency <= 0){
     var message = caml_call2(Stdlib_Printf[4], _h_, max_concurrency);
     caml_call1(Stdlib[1], message);
    }
    function loop(running, available, seq){
     function _K_(param){
      var available = param[2], running = param[1];
      function _P_(param){
       if(! param) return caml_call1(Lwt[14], running);
       var seq = param[2], elt = param[1];
       return loop([0, caml_call1(f, elt), running], available - 1 | 0, seq);
      }
      var _Q_ = caml_call1(seq, 0);
      return caml_call2(Lwt[33][1], _Q_, _P_);
     }
     if(0 < available)
      var _L_ = caml_call1(Lwt[4], [0, running, available]);
     else
      var
       _M_ =
         function(param){
          var
           running = param[2],
           complete = param[1],
           _O_ =
             [0,
              running,
              available + caml_call1(Stdlib_List[1], complete) | 0];
          return caml_call1(Lwt[4], _O_);
         },
       _N_ = caml_call1(Lwt[20], running),
       _L_ = caml_call2(Lwt[33][1], _N_, _M_);
     return caml_call2(Lwt[33][1], _L_, _K_);
    }
    return loop
            (0,
             max_concurrency,
             function(param){return caml_call2(Lwt[80], seq, 0);});
   }
   function unfold(f, u, param){
    try{var val = caml_call1(f, u);}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0);
     if(caml_call1(Lwt[78][4], exc)) return caml_call1(Lwt[5], exc);
     throw caml_maybe_attach_backtrace(exc, 0);
    }
    if(! val) return return_nil;
    var
     match = val[1],
     u$0 = match[2],
     x = match[1],
     _I_ = [0, x, function(_J_){return unfold(f, u$0, _J_);}];
    return caml_call1(Lwt[4], _I_);
   }
   function _i_(f, u, param){
    function _E_(x){
     if(! x) return return_nil;
     var
      match = x[1],
      u = match[2],
      x$0 = match[1],
      _G_ = [0, x$0, function(_H_){return _i_(f, u, _H_);}];
     return caml_call1(Lwt[4], _G_);
    }
    var _F_ = caml_call1(f, u);
    return caml_call2(Lwt[35][1], _F_, _E_);
   }
   function unfold_lwt(f, u, param){
    function _A_(x){
     if(! x) return return_nil;
     var
      match = x[1],
      u = match[2],
      x$0 = match[1],
      _C_ = [0, x$0, function(_D_){return _i_(f, u, _D_);}];
     return caml_call1(Lwt[4], _C_);
    }
    var _B_ = caml_call2(Lwt[80], f, u);
    return caml_call2(Lwt[35][1], _B_, _A_);
   }
   function of_list(param){
    if(! param) return empty;
    var t = param[2], h = param[1], _y_ = of_list(t);
    return function(_z_){return cons(h, _y_, _z_);};
   }
   function to_list(seq){
    function _u_(param){
     if(! param) return Lwt[38];
     var next = param[2], x = param[1];
     function _w_(l){return [0, x, l];}
     var _x_ = to_list(next);
     return caml_call2(Lwt[35][3], _x_, _w_);
    }
    var _v_ = caml_call1(seq, 0);
    return caml_call2(Lwt[33][1], _v_, _u_);
   }
   function to_list$0(seq){
    function _q_(param){
     if(! param) return Lwt[38];
     var next = param[2], x = param[1];
     function _s_(l){return [0, x, l];}
     var _t_ = to_list(next);
     return caml_call2(Lwt[35][3], _t_, _s_);
    }
    var _r_ = caml_call2(Lwt[80], seq, 0);
    return caml_call2(Lwt[33][1], _r_, _q_);
   }
   function of_seq(seq, param){
    try{var val = caml_call1(seq, 0);}
    catch(exn$0){
     var exn = caml_wrap_exception(exn$0);
     if(caml_call1(Lwt[78][4], exn)) return caml_call1(Lwt[5], exn);
     throw caml_maybe_attach_backtrace(exn, 0);
    }
    if(! val) return return_nil;
    var
     next = val[2],
     x = val[1],
     _o_ = [0, x, function(_p_){return of_seq(next, _p_);}];
    return caml_call1(Lwt[4], _o_);
   }
   function _j_(seq, param){
    var match = caml_call1(seq, 0);
    if(! match) return return_nil;
    var next = match[2], x = match[1];
    function _m_(x){
     function next$0(_n_){return _j_(next, _n_);}
     return [0, x, next$0];
    }
    return caml_call2(Lwt[35][3], x, _m_);
   }
   function of_seq_lwt(seq, param){
    try{var val = caml_call1(seq, 0);}
    catch(exc$0){
     var exc = caml_wrap_exception(exc$0);
     if(caml_call1(Lwt[78][4], exc)) return caml_call1(Lwt[5], exc);
     throw caml_maybe_attach_backtrace(exc, 0);
    }
    if(! val) return return_nil;
    var next = val[2], x = val[1];
    function _k_(x){
     function next$0(_l_){return _j_(next, _l_);}
     return [0, x, next$0];
    }
    return caml_call2(Lwt[35][3], x, _k_);
   }
   var
    Lwt_seq =
      [0,
       empty,
       return$0,
       return_lwt,
       cons,
       cons_lwt,
       append,
       map,
       map_s,
       filter,
       filter_s,
       filter_map,
       filter_map_s,
       flat_map,
       fold_left,
       fold_left_s,
       iter,
       iter_s,
       iter_p,
       iter_n,
       unfold,
       unfold_lwt,
       to_list$0,
       of_list,
       of_seq,
       of_seq_lwt];
   runtime.caml_register_global(5, Lwt_seq, "Lwt_seq");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_stream
//# unitInfo: Requires: CamlinternalOO, Lwt, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__List, Stdlib__Printf, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$6 = "",
    cst_blocked = "blocked",
    cst_close = "close",
    cst_closed = "closed",
    cst_count = "count",
    cst_push = "push",
    cst_resize = "resize",
    cst_set_reference = "set_reference",
    cst_size = "size",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$3 = "    ",
    cst$4 = "   ",
    cst$5 = " |",
    cst = cst$6,
    cst$0 = cst$6,
    cst$1 = cst$6,
    cst$2 = cst$6,
    shared =
      [0,
       cst_size,
       cst_set_reference,
       cst_resize,
       cst_push,
       cst_count,
       cst_closed,
       cst_close,
       cst_blocked],
    Lwt = global_data.Lwt,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Stdlib = global_data.Stdlib,
    CamlinternalOO = global_data.CamlinternalOO,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Array = global_data.Stdlib__Array,
    Closed = [248, "Lwt_stream.Closed", caml_fresh_oo_id(0)],
    Full = [248, "Lwt_stream.Full", caml_fresh_oo_id(0)],
    Empty = [248, "Lwt_stream.Empty", caml_fresh_oo_id(0)],
    _f_ = [0, [4, 6, [0, 2, 2], 0, [12, 32, 0]], "%02x "],
    _e_ = [0, [4, 6, [0, 2, 8], 0, [11, "|  ", 0]], "%08x|  "],
    cst_Lwt_stream_parse = "Lwt_stream.parse",
    _d_ =
      [0,
       [11,
        "Lwt_stream.iter_n: max_concurrency must be > 0, ",
        [4, 0, 0, 0, [11, " given", 0]]],
       "Lwt_stream.iter_n: max_concurrency must be > 0, %d given"],
    cst_Lwt_stream_create_bounded = "Lwt_stream.create_bounded",
    cst_Lwt_stream_bounded_push_re = "Lwt_stream.bounded_push#resize",
    cst_Lwt_stream_clone = "Lwt_stream.clone",
    _a_ =
      [0,
       cst_blocked,
       cst_close,
       cst_push,
       cst_count,
       cst_size,
       cst_set_reference,
       cst_resize,
       cst_closed],
    _b_ = [0, cst_closed];
   function new_node(param){
    var node = [];
    runtime.caml_update_dummy(node, [0, node, 0]);
    return node;
   }
   function clone(s){
    if(3 === s[1][0]) caml_call1(Stdlib[1], cst_Lwt_stream_clone);
    return [0, s[1], s[2], s[3], s[4], s[5]];
   }
   function from_source(source){
    var
     node = new_node(0),
     match = caml_call1(Lwt[1], 0),
     close = match[2],
     closed = match[1];
    return [0, source, close, closed, node, [0, node]];
   }
   function from(f){return from_source([0, [0, f, Lwt[36]]]);}
   function from_direct(f){return from_source([1, f]);}
   function closed(s){return s[3];}
   function is_closed(s){return 1 - caml_call1(Lwt[76], s[3]);}
   function enqueue(e, last){
    var node = last[1], new_last = new_node(0);
    node[2] = e;
    node[1] = new_last;
    last[1] = new_last;
    return;
   }
   function enqueue$0(e, s){return enqueue(e, s[5]);}
   function create_with_reference(param){
    var
     match = caml_call1(Lwt[1], 0),
     push_signal_resolver = match[2],
     push_signal = match[1],
     push_signal_resolver$0 = [0, push_signal_resolver],
     source = [0, push_signal, 0, 0],
     t = from_source([2, source]),
     close = t[2],
     closed = t[3],
     last = t[5];
    function push(x){
     if(1 - caml_call1(Lwt[76], closed))
      throw caml_maybe_attach_backtrace(Closed, 1);
     enqueue(x, last);
     if(source[2]){
      source[2] = 0;
      var
       old_push_signal_resolver = push_signal_resolver$0[1],
       match = caml_call1(Lwt[1], 0),
       new_push_signal_resolver = match[2],
       new_waiter = match[1];
      source[1] = new_waiter;
      push_signal_resolver$0[1] = new_push_signal_resolver;
      caml_call2(Lwt[2], old_push_signal_resolver, 0);
     }
     var _bZ_ = 0 === x ? 1 : 0;
     return _bZ_ ? caml_call2(Lwt[52], close, 0) : _bZ_;
    }
    return [0, t, push, function(x){source[3] = x; return 0;}];
   }
   function return$0(a){
    var match = create_with_reference(0), push = match[2], stream = match[1];
    caml_call1(push, [0, a]);
    caml_call1(push, 0);
    return stream;
   }
   function return_lwt(a){
    var match = create_with_reference(0), push = match[2], source = match[1];
    function _bW_(exc){return caml_call1(push, 0);}
    function _bX_(param){
     function _bY_(x){
      caml_call1(push, [0, x]);
      caml_call1(push, 0);
      return Lwt[36];
     }
     return caml_call2(Lwt[6], a, _bY_);
    }
    caml_call2(Lwt[10], _bX_, _bW_);
    return source;
   }
   function of_seq(s){
    var s$0 = [0, s];
    function get(param){
     var match = caml_call1(s$0[1], 0);
     if(! match) return 0;
     var s = match[2], elt = match[1];
     s$0[1] = s;
     return [0, elt];
    }
    return from_direct(get);
   }
   function of_lwt_seq(s){
    var s$0 = [0, s];
    function get(param){
     function _bU_(param){
      if(! param) return 0;
      var s = param[2], elt = param[1];
      s$0[1] = s;
      return [0, elt];
     }
     var _bV_ = caml_call1(s$0[1], 0);
     return caml_call2(Lwt[33][2], _bV_, _bU_);
    }
    return from(get);
   }
   function create(param){
    var match = create_with_reference(0), push = match[2], source = match[1];
    return [0, source, push];
   }
   function of_iter(iter, i){
    var match = create(0), push = match[2], stream = match[1];
    caml_call2(iter, function(x){return caml_call1(push, [0, x]);}, i);
    caml_call1(push, 0);
    return stream;
   }
   function of_list(l){return of_iter(Stdlib_List[17], l);}
   function of_array(a){return of_iter(Stdlib_Array[13], a);}
   function of_string(s){return of_iter(Stdlib_String[29], s);}
   function notify_pusher(info, last){
    enqueue(info[5], last);
    info[5] = 0;
    var
     old_wakener = info[7],
     match = caml_call1(Lwt[22], 0),
     wakener = match[2],
     waiter = match[1];
    info[6] = waiter;
    info[7] = wakener;
    return caml_call2(Lwt[2], old_wakener, 0);
   }
   function _c_(_bl_){
    var
     _bm_ = caml_call2(CamlinternalOO[3], _bl_, cst),
     _bn_ = caml_call2(CamlinternalOO[3], _bl_, cst$0),
     _bo_ = caml_call2(CamlinternalOO[3], _bl_, cst$1),
     _bp_ = caml_call2(CamlinternalOO[3], _bl_, cst$2),
     _bq_ = caml_call3(CamlinternalOO[4], _bl_, shared, _b_),
     _bz_ = _bq_[9],
     _br_ = _bq_[1],
     _bs_ = _bq_[2],
     _bt_ = _bq_[3],
     _bu_ = _bq_[4],
     _bv_ = _bq_[5],
     _bw_ = _bq_[6],
     _bx_ = _bq_[7],
     _by_ = _bq_[8];
    function _bA_(self_1, x){self_1[1 + _bm_][8] = x; return 0;}
    function _bB_(self_1){return self_1[1 + _bz_];}
    function _bC_(self_1){return 0 !== self_1[1 + _bm_][5] ? 1 : 0;}
    function _bD_(self_1){return self_1[1 + _bm_][4];}
    function _bE_(self_1){
     var _bT_ = 1 - self_1[1 + _bz_];
     if(! _bT_) return _bT_;
     self_1[1 + _bz_] = 1;
     var node = self_1[1 + _bo_][1], new_last = new_node(0);
     node[2] = 0;
     node[1] = new_last;
     self_1[1 + _bo_][1] = new_last;
     if(0 !== self_1[1 + _bm_][5]){
      self_1[1 + _bm_][5] = 0;
      caml_call2(Lwt[3], self_1[1 + _bm_][7], Closed);
     }
     if(self_1[1 + _bm_][2]){
      self_1[1 + _bm_][2] = 0;
      var old_wakener = self_1[1 + _bn_][1];
      caml_call2(Lwt[2], old_wakener, 0);
     }
     return caml_call2(Lwt[52], self_1[1 + _bp_], 0);
    }
    function _bF_(self_1, x){
     if(self_1[1 + _bz_]) return caml_call1(Lwt[5], Closed);
     if(0 !== self_1[1 + _bm_][5]) return caml_call1(Lwt[5], Full);
     if(self_1[1 + _bm_][3] <= self_1[1 + _bm_][4]){
      self_1[1 + _bm_][5] = [0, x];
      var
       _bR_ =
         function(exn){
          if(exn !== Lwt[21]) return caml_call1(Lwt[5], exn);
          self_1[1 + _bm_][5] = 0;
          var
           match = caml_call1(Lwt[22], 0),
           wakener = match[2],
           waiter = match[1];
          self_1[1 + _bm_][6] = waiter;
          self_1[1 + _bm_][7] = wakener;
          return caml_call1(Lwt[5], exn);
         },
       _bS_ = function(param){return self_1[1 + _bm_][6];};
      return caml_call2(Lwt[7], _bS_, _bR_);
     }
     enqueue([0, x], self_1[1 + _bo_]);
     self_1[1 + _bm_][4] = self_1[1 + _bm_][4] + 1 | 0;
     if(self_1[1 + _bm_][2]){
      self_1[1 + _bm_][2] = 0;
      var
       old_wakener = self_1[1 + _bn_][1],
       match = caml_call1(Lwt[1], 0),
       new_wakener = match[2],
       new_waiter = match[1];
      self_1[1 + _bm_][1] = new_waiter;
      self_1[1 + _bn_][1] = new_wakener;
      caml_call2(Lwt[2], old_wakener, 0);
     }
     return Lwt[36];
    }
    function _bG_(self_1, size){
     if(size < 0) caml_call1(Stdlib[1], cst_Lwt_stream_bounded_push_re);
     self_1[1 + _bm_][3] = size;
     var
      _bP_ = self_1[1 + _bm_][4] < self_1[1 + _bm_][3] ? 1 : 0,
      _bQ_ = _bP_ ? 0 !== self_1[1 + _bm_][5] ? 1 : 0 : _bP_;
     return _bQ_
             ? (self_1
                 [1 + _bm_]
                [4]
               = self_1[1 + _bm_][4] + 1 | 0,
               notify_pusher(self_1[1 + _bm_], self_1[1 + _bo_]))
             : _bQ_;
    }
    var
     _bH_ =
       [0,
        _br_,
        function(self_1){return self_1[1 + _bm_][3];},
        _bt_,
        _bG_,
        _bu_,
        _bF_,
        _bx_,
        _bE_,
        _bv_,
        _bD_,
        _by_,
        _bC_,
        _bw_,
        _bB_,
        _bs_,
        _bA_];
    caml_call2(CamlinternalOO[11], _bl_, _bH_);
    return function(_bN_, _bM_, _bL_, _bK_, _bJ_, _bI_){
     var _bO_ = caml_call2(CamlinternalOO[24], _bM_, _bl_);
     _bO_[1 + _bp_] = _bI_;
     _bO_[1 + _bo_] = _bJ_;
     _bO_[1 + _bn_] = _bK_;
     _bO_[1 + _bm_] = _bL_;
     _bO_[1 + _bz_] = 0;
     return _bO_;};
   }
   var bounded_push_impl = caml_call2(CamlinternalOO[19], _a_, _c_);
   function create_bounded(size){
    if(size < 0) caml_call1(Stdlib[1], cst_Lwt_stream_create_bounded);
    var
     match = caml_call1(Lwt[1], 0),
     wakener = match[2],
     waiter = match[1],
     match$0 = caml_call1(Lwt[22], 0),
     push_wakener = match$0[2],
     push_waiter = match$0[1],
     wakener_cell = [0, wakener],
     info = [0, waiter, 0, size, 0, 0, push_waiter, push_wakener, 0],
     t = from_source([3, info]);
    return [0,
            t,
            caml_call5
             (bounded_push_impl[1], 0, info, wakener_cell, t[5], t[2])];
   }
   function feed(s){
    var match = s[1];
    switch(match[0]){
      case 0:
       var from = match[1];
       if(caml_call1(Lwt[76], from[2])) return caml_call1(Lwt[25], from[2]);
       var
        _bj_ =
          function(x){
           enqueue$0(x, s);
           if(0 === x) caml_call2(Lwt[52], s[2], 0);
           return Lwt[36];
          },
        _bk_ = caml_call1(from[1], 0),
        thread = caml_call2(Lwt[33][1], _bk_, _bj_);
       from[2] = thread;
       return caml_call1(Lwt[25], thread);
      case 1:
       var f = match[1], x = caml_call1(f, 0);
       enqueue$0(x, s);
       if(0 === x) caml_call2(Lwt[52], s[2], 0);
       return Lwt[36];
      case 2:
       var push = match[1]; push[2] = 1; return caml_call1(Lwt[25], push[1]);
      default:
       var push$0 = match[1];
       push$0[2] = 1;
       return caml_call1(Lwt[25], push$0[1]);
    }
   }
   function consume(s, node){
    var _bi_ = node === s[4] ? 1 : 0;
    if(! _bi_) return _bi_;
    s[4] = node[1];
    var match = s[1];
    if(3 !== match[0]) return;
    var info = match[1];
    if(0 !== info[5]) return notify_pusher(info, s[5]);
    info[4] = info[4] - 1 | 0;
    return;
   }
   function peek_rec(s, node){
    if(node !== s[5][1]) return caml_call1(Lwt[4], node[2]);
    function _bg_(param){return peek_rec(s, node);}
    var _bh_ = feed(s);
    return caml_call2(Lwt[33][1], _bh_, _bg_);
   }
   function peek(s){return peek_rec(s, s[4]);}
   function npeek_rec(node, acc, n, s){
    var node$0 = node, acc$0 = acc, n$0 = n;
    for(;;){
     if(0 >= n$0){
      var _bf_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _bf_);
     }
     if(node$0 === s[5][1]){
      var
       _bc_ = function(param){return npeek_rec(node$0, acc$0, n$0, s);},
       _bd_ = feed(s);
      return caml_call2(Lwt[33][1], _bd_, _bc_);
     }
     var match = node$0[2];
     if(! match){
      var _be_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _be_);
     }
     var
      x = match[1],
      n$1 = n$0 - 1 | 0,
      acc$1 = [0, x, acc$0],
      node$1 = node$0[1],
      node$0 = node$1,
      acc$0 = acc$1,
      n$0 = n$1;
    }
   }
   function npeek(n, s){return npeek_rec(s[4], 0, n, s);}
   function get_rec(s, node){
    if(node === s[5][1]){
     var _ba_ = function(param){return get_rec(s, node);}, _bb_ = feed(s);
     return caml_call2(Lwt[33][1], _bb_, _ba_);
    }
    if(0 !== node[2]) consume(s, node);
    return caml_call1(Lwt[4], node[2]);
   }
   function get(s){return get_rec(s, s[4]);}
   function get_exn_rec(s, node){
    if(node === s[5][1]){
     var
      _a9_ = function(exn){return caml_call1(Lwt[4], [0, [1, exn]]);},
      _a__ = function(param){return get_exn_rec(s, node);},
      _a$_ = function(param){return feed(s);};
     return caml_call3(Lwt[9], _a$_, _a__, _a9_);
    }
    var match = node[2];
    if(! match) return Lwt[37];
    var value = match[1];
    consume(s, node);
    return caml_call1(Lwt[4], [0, [0, value]]);
   }
   function wrap_exn(s){
    return from(function(param){return get_exn_rec(s, s[4]);});
   }
   function nget_rec(node, acc, n, s){
    var node$0 = node, acc$0 = acc, n$0 = n;
    for(;;){
     if(0 >= n$0){
      var _a8_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _a8_);
     }
     if(node$0 === s[5][1]){
      var
       _a5_ = function(param){return nget_rec(node$0, acc$0, n$0, s);},
       _a6_ = feed(s);
      return caml_call2(Lwt[33][1], _a6_, _a5_);
     }
     var match = s[4][2];
     if(! match){
      var _a7_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _a7_);
     }
     var x = match[1];
     consume(s, node$0);
     var
      n$1 = n$0 - 1 | 0,
      acc$1 = [0, x, acc$0],
      node$1 = node$0[1],
      node$0 = node$1,
      acc$0 = acc$1,
      n$0 = n$1;
    }
   }
   function nget(n, s){return nget_rec(s[4], 0, n, s);}
   function get_while_rec(node, acc, f, s){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _a1_ = function(param){return get_while_rec(node$0, acc$0, f, s);},
       _a2_ = feed(s);
      return caml_call2(Lwt[33][1], _a2_, _a1_);
     }
     var match = node$0[2];
     if(! match){
      var _a4_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _a4_);
     }
     var x = match[1], test = caml_call1(f, x);
     if(! test){
      var _a3_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _a3_);
     }
     consume(s, node$0);
     var
      acc$1 = [0, x, acc$0],
      node$1 = node$0[1],
      node$0 = node$1,
      acc$0 = acc$1;
    }
   }
   function get_while(f, s){return get_while_rec(s[4], 0, f, s);}
   function get_while_s_rec(node, acc, f, s){
    if(node === s[5][1]){
     var
      _aV_ = function(param){return get_while_s_rec(node, acc, f, s);},
      _aW_ = feed(s);
     return caml_call2(Lwt[33][1], _aW_, _aV_);
    }
    var match = node[2];
    if(match){
     var
      x = match[1],
      _aX_ =
        function(param){
         if(param){
          consume(s, node);
          return get_while_s_rec(node[1], [0, x, acc], f, s);
         }
         var _a0_ = caml_call1(Stdlib_List[9], acc);
         return caml_call1(Lwt[4], _a0_);
        },
      _aY_ = caml_call1(f, x);
     return caml_call2(Lwt[33][1], _aY_, _aX_);
    }
    var _aZ_ = caml_call1(Stdlib_List[9], acc);
    return caml_call1(Lwt[4], _aZ_);
   }
   function get_while_s(f, s){return get_while_s_rec(s[4], 0, f, s);}
   function next_rec(s, node){
    if(node === s[5][1]){
     var _aT_ = function(param){return next_rec(s, node);}, _aU_ = feed(s);
     return caml_call2(Lwt[33][1], _aU_, _aT_);
    }
    var match = node[2];
    if(! match) return caml_call1(Lwt[5], Empty);
    var x = match[1];
    consume(s, node);
    return caml_call1(Lwt[4], x);
   }
   function next(s){return next_rec(s, s[4]);}
   function last_new_rec(node, x, s){
    var node$0 = node, x$0 = x;
    for(;;)
     if(node$0 === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Lwt[4], x$0);
      if(0 !== match[0]){var exn = match[1]; return caml_call1(Lwt[5], exn);}
     }
     else{
      var match$0 = node$0[2];
      if(! match$0) return caml_call1(Lwt[4], x$0);
      var x$1 = match$0[1];
      consume(s, node$0);
      var node$1 = node$0[1], node$0 = node$1, x$0 = x$1;
     }
   }
   function last_new(s){
    var node = s[4];
    if(node !== s[5][1]){
     var match$0 = node[2];
     if(! match$0) return caml_call1(Lwt[5], Empty);
     var x$0 = match$0[1];
     consume(s, node);
     return last_new_rec(node[1], x$0, s);
    }
    var thread = next(s), match = caml_call1(Lwt[48], thread);
    if(typeof match !== "number" && 0 === match[0]){
     var x = match[1];
     return last_new_rec(node, x, s);
    }
    return thread;
   }
   function to_list_rec(node, acc, s){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _aQ_ = function(param){return to_list_rec(node$0, acc$0, s);},
       _aR_ = feed(s);
      return caml_call2(Lwt[33][1], _aR_, _aQ_);
     }
     var match = node$0[2];
     if(! match){
      var _aS_ = caml_call1(Stdlib_List[9], acc$0);
      return caml_call1(Lwt[4], _aS_);
     }
     var x = match[1];
     consume(s, node$0);
     var
      acc$1 = [0, x, acc$0],
      node$1 = node$0[1],
      node$0 = node$1,
      acc$0 = acc$1;
    }
   }
   function to_list(s){return to_list_rec(s[4], 0, s);}
   function to_string_rec(node, buf, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _aN_ = function(param){return to_string_rec(node$0, buf, s);},
       _aO_ = feed(s);
      return caml_call2(Lwt[33][1], _aO_, _aN_);
     }
     var match = node$0[2];
     if(! match){
      var _aP_ = caml_call1(Stdlib_Buffer[2], buf);
      return caml_call1(Lwt[4], _aP_);
     }
     var x = match[1];
     consume(s, node$0);
     caml_call2(Stdlib_Buffer[12], buf, x);
     var node$1 = node$0[1], node$0 = node$1;
    }
   }
   function to_string(s){
    var _aM_ = caml_call1(Stdlib_Buffer[1], 128);
    return to_string_rec(s[4], _aM_, s);
   }
   function junk(s){
    var node = s[4];
    if(node === s[5][1]){
     var
      _aK_ =
        function(param){if(0 !== node[2]) consume(s, node); return Lwt[36];},
      _aL_ = feed(s);
     return caml_call2(Lwt[33][1], _aL_, _aK_);
    }
    if(0 !== node[2]) consume(s, node);
    return Lwt[36];
   }
   function njunk_rec(node, n, s){
    var node$0 = node, n$0 = n;
    for(;;){
     if(0 >= n$0) return Lwt[36];
     if(node$0 === s[5][1]){
      var
       _aI_ = function(param){return njunk_rec(node$0, n$0, s);},
       _aJ_ = feed(s);
      return caml_call2(Lwt[33][1], _aJ_, _aI_);
     }
     if(! node$0[2]) return Lwt[36];
     consume(s, node$0);
     var n$1 = n$0 - 1 | 0, node$1 = node$0[1], node$0 = node$1, n$0 = n$1;
    }
   }
   function njunk(n, s){return njunk_rec(s[4], n, s);}
   function junk_while_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _aG_ = function(param){return junk_while_rec(node$0, f, s);},
       _aH_ = feed(s);
      return caml_call2(Lwt[33][1], _aH_, _aG_);
     }
     var match = node$0[2];
     if(! match) return Lwt[36];
     var x = match[1], test = caml_call1(f, x);
     if(! test) return Lwt[36];
     consume(s, node$0);
     var node$1 = node$0[1], node$0 = node$1;
    }
   }
   function junk_while(f, s){return junk_while_rec(s[4], f, s);}
   function junk_while_s_rec(node, f, s){
    if(node === s[5][1]){
     var
      _aC_ = function(param){return junk_while_s_rec(node, f, s);},
      _aD_ = feed(s);
     return caml_call2(Lwt[33][1], _aD_, _aC_);
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1];
    function _aE_(param){
     return param
             ? (consume(s, node), junk_while_s_rec(node[1], f, s))
             : Lwt[36];
    }
    var _aF_ = caml_call1(f, x);
    return caml_call2(Lwt[33][1], _aF_, _aE_);
   }
   function junk_while_s(f, s){return junk_while_s_rec(s[4], f, s);}
   function junk_old(s){
    var node$1 = s[4], node = node$1;
    for(;;)
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return Lwt[36];
      if(0 !== match[0]){var exn = match[1]; return caml_call1(Lwt[5], exn);}
     }
     else{
      if(! node[2]) return Lwt[36];
      consume(s, node);
      var node$0 = node[1], node = node$0;
     }
   }
   function get_available(s){
    var node$1 = s[4], node = node$1, acc = 0;
    for(;;)
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Stdlib_List[9], acc);
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      var match$0 = node[2];
      if(! match$0) return caml_call1(Stdlib_List[9], acc);
      var x = match$0[1];
      consume(s, node);
      var acc$0 = [0, x, acc], node$0 = node[1], node = node$0, acc = acc$0;
     }
   }
   function get_available_up_to(n$1, s){
    var node$1 = s[4], node = node$1, acc = 0, n = n$1;
    for(;;){
     if(0 >= n) return caml_call1(Stdlib_List[9], acc);
     if(node === s[5][1]){
      var thread = feed(s), match = caml_call1(Lwt[48], thread);
      if(typeof match === "number") return caml_call1(Stdlib_List[9], acc);
      if(0 !== match[0]){
       var exn = match[1];
       throw caml_maybe_attach_backtrace(exn, 1);
      }
     }
     else{
      var match$0 = s[4][2];
      if(! match$0) return caml_call1(Stdlib_List[9], acc);
      var x = match$0[1];
      consume(s, node);
      var
       n$0 = n - 1 | 0,
       acc$0 = [0, x, acc],
       node$0 = node[1],
       node = node$0,
       acc = acc$0,
       n = n$0;
     }
    }
   }
   function is_empty(s){
    if(s[4] !== s[5][1]) return caml_call1(Lwt[4], 0 === s[4][2] ? 1 : 0);
    function _aA_(param){return is_empty(s);}
    var _aB_ = feed(s);
    return caml_call2(Lwt[33][1], _aB_, _aA_);
   }
   function map(f, s){
    return from
            (function(param){
              function _ay_(param){
               if(! param) return 0;
               var x = param[1], x$0 = caml_call1(f, x);
               return [0, x$0];
              }
              var _az_ = get(s);
              return caml_call2(Lwt[33][2], _az_, _ay_);
             });
   }
   function map_s(f, s){
    return from
            (function(param){
              function _au_(param){
               if(! param) return Lwt[37];
               var x = param[1];
               function _aw_(x){return [0, x];}
               var _ax_ = caml_call1(f, x);
               return caml_call2(Lwt[33][2], _ax_, _aw_);
              }
              var _av_ = get(s);
              return caml_call2(Lwt[33][1], _av_, _au_);
             });
   }
   function filter(f, s){
    function next(param){
     var t = get(s);
     function _at_(param){
      if(! param) return Lwt[37];
      var x = param[1], test = caml_call1(f, x);
      return test ? t : next(0);
     }
     return caml_call2(Lwt[33][1], t, _at_);
    }
    return from(next);
   }
   function filter_s(f, s){
    function next(param){
     var t = get(s);
     function _aq_(param){
      if(! param) return t;
      var x = param[1];
      function _ar_(param){return param ? t : next(0);}
      var _as_ = caml_call1(f, x);
      return caml_call2(Lwt[33][1], _as_, _ar_);
     }
     return caml_call2(Lwt[33][1], t, _aq_);
    }
    return from(next);
   }
   function filter_map(f, s){
    function next(param){
     function _ao_(param){
      if(! param) return Lwt[37];
      var x = param[1], x$0 = caml_call1(f, x);
      return x$0 ? caml_call1(Lwt[4], x$0) : next(0);
     }
     var _ap_ = get(s);
     return caml_call2(Lwt[33][1], _ap_, _ao_);
    }
    return from(next);
   }
   function filter_map_s(f, s){
    function next(param){
     function _al_(param){
      if(! param) return Lwt[37];
      var x = param[1], t = caml_call1(f, x);
      function _an_(param){return param ? t : next(0);}
      return caml_call2(Lwt[33][1], t, _an_);
     }
     var _am_ = get(s);
     return caml_call2(Lwt[33][1], _am_, _al_);
    }
    return from(next);
   }
   function map_list(f, s){
    var pendings = [0, 0];
    function next(param){
     var match = pendings[1];
     if(match){
      var l = match[2], x = match[1];
      pendings[1] = l;
      return caml_call1(Lwt[4], [0, x]);
     }
     function _aj_(param){
      if(! param) return Lwt[37];
      var x = param[1], l = caml_call1(f, x);
      pendings[1] = l;
      return next(0);
     }
     var _ak_ = get(s);
     return caml_call2(Lwt[33][1], _ak_, _aj_);
    }
    return from(next);
   }
   function map_list_s(f, s){
    var pendings = [0, 0];
    function next(param){
     var match = pendings[1];
     if(match){
      var l = match[2], x = match[1];
      pendings[1] = l;
      return caml_call1(Lwt[4], [0, x]);
     }
     function _af_(param){
      if(! param) return Lwt[37];
      var x = param[1];
      function _ah_(l){pendings[1] = l; return next(0);}
      var _ai_ = caml_call1(f, x);
      return caml_call2(Lwt[33][1], _ai_, _ah_);
     }
     var _ag_ = get(s);
     return caml_call2(Lwt[33][1], _ag_, _af_);
    }
    return from(next);
   }
   function flatten(s){return map_list(function(l){return l;}, s);}
   function fold_rec(node, f, s, acc){
    var node$0 = node, acc$0 = acc;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _ad_ = function(param){return fold_rec(node$0, f, s, acc$0);},
       _ae_ = feed(s);
      return caml_call2(Lwt[33][1], _ae_, _ad_);
     }
     var match = node$0[2];
     if(! match) return caml_call1(Lwt[4], acc$0);
     var x = match[1];
     consume(s, node$0);
     var
      acc$1 = caml_call2(f, x, acc$0),
      node$1 = node$0[1],
      node$0 = node$1,
      acc$0 = acc$1;
    }
   }
   function fold(f, s, acc){return fold_rec(s[4], f, s, acc);}
   function fold_s_rec(node, f, s, acc){
    if(node === s[5][1]){
     var
      _$_ = function(param){return fold_s_rec(node, f, s, acc);},
      _aa_ = feed(s);
     return caml_call2(Lwt[33][1], _aa_, _$_);
    }
    var match = node[2];
    if(! match) return caml_call1(Lwt[4], acc);
    var x = match[1];
    consume(s, node);
    function _ab_(acc){return fold_s_rec(node[1], f, s, acc);}
    var _ac_ = caml_call2(f, x, acc);
    return caml_call2(Lwt[33][1], _ac_, _ab_);
   }
   function fold_s(f, s, acc){return fold_s_rec(s[4], f, s, acc);}
   function iter_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _Z_ = function(param){return iter_rec(node$0, f, s);},
       ___ = feed(s);
      return caml_call2(Lwt[33][1], ___, _Z_);
     }
     var match = node$0[2];
     if(! match) return Lwt[36];
     var x = match[1];
     consume(s, node$0);
     caml_call1(f, x);
     var node$1 = node$0[1], node$0 = node$1;
    }
   }
   function iter(f, s){return iter_rec(s[4], f, s);}
   function iter_s_rec(node, f, s){
    if(node === s[5][1]){
     var _V_ = function(param){return iter_s_rec(node, f, s);}, _W_ = feed(s);
     return caml_call2(Lwt[33][1], _W_, _V_);
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1];
    consume(s, node);
    function _X_(param){return iter_s_rec(node[1], f, s);}
    var _Y_ = caml_call1(f, x);
    return caml_call2(Lwt[33][1], _Y_, _X_);
   }
   function iter_s(f, s){return iter_s_rec(s[4], f, s);}
   function iter_p_rec(node, f, s){
    if(node === s[5][1]){
     var _S_ = function(param){return iter_p_rec(node, f, s);}, _T_ = feed(s);
     return caml_call2(Lwt[33][1], _T_, _S_);
    }
    var match = node[2];
    if(! match) return Lwt[36];
    var x = match[1];
    consume(s, node);
    var res = caml_call1(f, x), rest = iter_p_rec(node[1], f, s);
    function _U_(param){return rest;}
    return caml_call2(Lwt[33][1], res, _U_);
   }
   function iter_p(f, s){return iter_p_rec(s[4], f, s);}
   function iter_n(opt, f, stream){
    if(opt)
     var sth = opt[1], max_concurrency = sth;
    else
     var max_concurrency = 1;
    if(max_concurrency <= 0){
     var message = caml_call2(Stdlib_Printf[4], _d_, max_concurrency);
     caml_call1(Stdlib[1], message);
    }
    function loop(running, available){
     function _L_(param){
      var available = param[2], running = param[1];
      function _Q_(param){
       if(! param) return caml_call1(Lwt[14], running);
       var elt = param[1];
       return loop([0, caml_call1(f, elt), running], available - 1 | 0);
      }
      var _R_ = get(stream);
      return caml_call2(Lwt[33][1], _R_, _Q_);
     }
     if(0 < available)
      var _M_ = caml_call1(Lwt[4], [0, running, available]);
     else
      var
       _N_ =
         function(param){
          var
           running = param[2],
           complete = param[1],
           _P_ =
             [0,
              running,
              available + caml_call1(Stdlib_List[1], complete) | 0];
          return caml_call1(Lwt[4], _P_);
         },
       _O_ = caml_call1(Lwt[20], running),
       _M_ = caml_call2(Lwt[33][1], _O_, _N_);
     return caml_call2(Lwt[33][1], _M_, _L_);
    }
    return loop(0, max_concurrency);
   }
   function find_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _J_ = function(param){return find_rec(node$0, f, s);},
       _K_ = feed(s);
      return caml_call2(Lwt[33][1], _K_, _J_);
     }
     var opt = node$0[2];
     if(! opt) return Lwt[37];
     var x = opt[1];
     consume(s, node$0);
     var test = caml_call1(f, x);
     if(test) return caml_call1(Lwt[4], opt);
     var node$1 = node$0[1], node$0 = node$1;
    }
   }
   function find(f, s){return find_rec(s[4], f, s);}
   function find_s_rec(node, f, s){
    if(node === s[5][1]){
     var _F_ = function(param){return find_s_rec(node, f, s);}, _G_ = feed(s);
     return caml_call2(Lwt[33][1], _G_, _F_);
    }
    var opt = node[2];
    if(! opt) return Lwt[37];
    var x = opt[1];
    consume(s, node);
    function _H_(param){
     return param ? caml_call1(Lwt[4], opt) : find_s_rec(node[1], f, s);
    }
    var _I_ = caml_call1(f, x);
    return caml_call2(Lwt[33][1], _I_, _H_);
   }
   function find_s(f, s){return find_s_rec(s[4], f, s);}
   function find_map_rec(node, f, s){
    var node$0 = node;
    for(;;){
     if(node$0 === s[5][1]){
      var
       _D_ = function(param){return find_map_rec(node$0, f, s);},
       _E_ = feed(s);
      return caml_call2(Lwt[33][1], _E_, _D_);
     }
     var match = node$0[2];
     if(! match) return Lwt[37];
     var x = match[1];
     consume(s, node$0);
     var x$0 = caml_call1(f, x);
     if(0 !== x$0) return caml_call1(Lwt[4], x$0);
     var node$1 = node$0[1], node$0 = node$1;
    }
   }
   function find_map(f, s){return find_map_rec(s[4], f, s);}
   function find_map_s_rec(node, f, s){
    if(node === s[5][1]){
     var
      _A_ = function(param){return find_map_s_rec(node, f, s);},
      _B_ = feed(s);
     return caml_call2(Lwt[33][1], _B_, _A_);
    }
    var match = node[2];
    if(! match) return Lwt[37];
    var x = match[1];
    consume(s, node);
    var t = caml_call1(f, x);
    function _C_(param){return param ? t : find_map_s_rec(node[1], f, s);}
    return caml_call2(Lwt[33][1], t, _C_);
   }
   function find_map_s(f, s){return find_map_s_rec(s[4], f, s);}
   function combine(s1, s2){
    function next(param){
     var t1 = get(s1), t2 = get(s2);
     function _y_(n1){
      function _z_(n2){
       if(n1 && n2){
        var x2 = n2[1], x1 = n1[1];
        return caml_call1(Lwt[4], [0, [0, x1, x2]]);
       }
       return Lwt[37];
      }
      return caml_call2(Lwt[33][1], t2, _z_);
     }
     return caml_call2(Lwt[33][1], t1, _y_);
    }
    return from(next);
   }
   function append(s1, s2){
    var current_s = [0, s1];
    function next(param){
     var t = get(current_s[1]);
     function _x_(param){
      return param
              ? t
              : current_s[1] === s2 ? Lwt[37] : (current_s[1] = s2, next(0));
     }
     return caml_call2(Lwt[33][1], t, _x_);
    }
    return from(next);
   }
   function concat(s_top){
    var current_s = [0, from(function(param){return Lwt[37];})];
    function next(param){
     var t = get(current_s[1]);
     function _u_(param){
      if(param) return t;
      function _v_(param){
       if(! param) return Lwt[37];
       var s = param[1];
       current_s[1] = s;
       return next(0);
      }
      var _w_ = get(s_top);
      return caml_call2(Lwt[33][1], _w_, _v_);
     }
     return caml_call2(Lwt[33][1], t, _u_);
    }
    return from(next);
   }
   function choose(streams){
    function source(s){
     function _s_(x){return [0, s, x];}
     var _t_ = get(s);
     return [0, s, caml_call2(Lwt[33][2], _t_, _s_)];
    }
    var streams$0 = [0, caml_call2(Stdlib_List[19], source, streams)];
    function next(param){
     var l = streams$0[1];
     if(! l) return Lwt[37];
     function _n_(param){
      var x = param[2], s = param[1], l$0 = caml_call2(Stdlib_List[53], s, l);
      return x
              ? (streams$0[1] = [0, source(s), l$0], caml_call1(Lwt[4], x))
              : (streams$0[1] = l$0, next(0));
     }
     function _o_(_r_){return _r_[2];}
     var
      _p_ = caml_call2(Stdlib_List[19], _o_, l),
      _q_ = caml_call1(Lwt[17], _p_);
     return caml_call2(Lwt[33][1], _q_, _n_);
    }
    return from(next);
   }
   function parse(s, f){
    if(3 === s[1][0]) caml_call1(Stdlib[1], cst_Lwt_stream_parse);
    var node = s[4];
    function _l_(exn){s[4] = node; return caml_call1(Lwt[5], exn);}
    function _m_(param){return caml_call1(f, s);}
    return caml_call2(Lwt[7], _m_, _l_);
   }
   function hexdump(stream){
    var buf = caml_call1(Stdlib_Buffer[1], 80), num = [0, 0];
    return from
            (function(param){
              function _g_(l){
               if(! l) return Lwt[37];
               caml_call1(Stdlib_Buffer[8], buf);
               caml_call3(Stdlib_Printf[5], buf, _e_, num[1]);
               num[1] = num[1] + 16 | 0;
               var pos = 0, param = l;
               for(;;){
                if(! param) break;
                var l$0 = param[2], x = param[1];
                if(8 === pos) caml_call2(Stdlib_Buffer[12], buf, 32);
                caml_call3(Stdlib_Printf[5], buf, _f_, x);
                var pos$0 = pos + 1 | 0, pos = pos$0, param = l$0;
               }
               var pos$1 = pos;
               for(;;){
                if(pos$1 >= 16){
                 caml_call2(Stdlib_Buffer[16], buf, cst$5);
                 var
                  _i_ =
                    function(ch){
                     a:
                     {
                      if(32 <= ch && 126 >= ch){var _k_ = ch; break a;}
                      var _k_ = 46;
                     }
                     return caml_call2(Stdlib_Buffer[12], buf, _k_);
                    };
                 caml_call2(Stdlib_List[17], _i_, l);
                 caml_call2(Stdlib_Buffer[12], buf, 124);
                 var _j_ = [0, caml_call1(Stdlib_Buffer[2], buf)];
                 return caml_call1(Lwt[4], _j_);
                }
                if(8 === pos$1)
                 caml_call2(Stdlib_Buffer[16], buf, cst$3);
                else
                 caml_call2(Stdlib_Buffer[16], buf, cst$4);
                var pos$2 = pos$1 + 1 | 0, pos$1 = pos$2;
               }
              }
              var _h_ = nget(16, stream);
              return caml_call2(Lwt[33][1], _h_, _g_);
             });
   }
   var
    Lwt_stream =
      [0,
       from,
       from_direct,
       Closed,
       create,
       create_with_reference,
       Full,
       create_bounded,
       return$0,
       return_lwt,
       of_seq,
       of_lwt_seq,
       of_list,
       of_array,
       of_string,
       clone,
       to_list,
       to_string,
       Empty,
       peek,
       npeek,
       get,
       nget,
       get_while,
       get_while_s,
       next,
       last_new,
       junk,
       njunk,
       junk_while,
       junk_while_s,
       junk_old,
       get_available,
       get_available_up_to,
       is_empty,
       is_closed,
       closed,
       choose,
       map,
       map_s,
       filter,
       filter_s,
       filter_map,
       filter_map_s,
       map_list,
       map_list_s,
       fold,
       fold_s,
       iter,
       iter_p,
       iter_s,
       iter_n,
       find,
       find_s,
       find_map,
       find_map_s,
       combine,
       append,
       concat,
       flatten,
       wrap_exn,
       parse,
       hexdump];
   runtime.caml_register_global(28, Lwt_stream, "Lwt_stream");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_result
//# unitInfo: Requires: Assert_failure, Lwt
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Assert_failure = global_data.Assert_failure,
    _a_ = [0, "src/core/lwt_result.ml", 84, 14];
   function return$0(x){return caml_call1(Lwt[4], [0, x]);}
   function fail(e){return caml_call1(Lwt[4], [1, e]);}
   var lift = Lwt[4];
   function ok(x){
    function _r_(y){return [0, y];}
    return caml_call2(Lwt[28], _r_, x);
   }
   function error(x){
    function _q_(y){return [1, y];}
    return caml_call2(Lwt[28], _q_, x);
   }
   function map(f, e){
    function _p_(param){
     if(0 === param[0]){var x = param[1]; return [0, caml_call1(f, x)];}
     var e = param[1];
     return [1, e];
    }
    return caml_call2(Lwt[28], _p_, e);
   }
   function map_error(f, e){
    function _o_(param){
     if(0 === param[0]){var x = param[1]; return [0, x];}
     var e = param[1];
     return [1, caml_call1(f, e)];
    }
    return caml_call2(Lwt[28], _o_, e);
   }
   function map_err(f, e){return map_error(f, e);}
   function catch$0(e){
    function _n_(param){return ok(caml_call1(e, 0));}
    return caml_call2(Lwt[7], _n_, fail);
   }
   function get_exn(e){
    function _m_(param){
     if(0 === param[0]){var x = param[1]; return caml_call1(Lwt[4], x);}
     var e = param[1];
     return caml_call1(Lwt[5], e);
    }
    return caml_call2(Lwt[6], e, _m_);
   }
   function symbol_bind(e, f){
    function _l_(param){
     if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
     var e = param[1];
     return caml_call1(Lwt[4], [1, e]);
    }
    return caml_call2(Lwt[6], e, _l_);
   }
   function bind_error(e, f){
    function _k_(param){
     if(0 === param[0]){var x = param[1]; return caml_call1(Lwt[4], [0, x]);}
     var e = param[1];
     return caml_call1(f, e);
    }
    return caml_call2(Lwt[6], e, _k_);
   }
   function bind_lwt(e, f){
    function _j_(param){
     if(0 === param[0]){var x = param[1]; return ok(caml_call1(f, x));}
     var e = param[1];
     return fail(e);
    }
    return caml_call2(Lwt[6], e, _j_);
   }
   function bind_result(e, f){
    function _i_(param){
     if(0 === param[0]){var x = param[1]; return caml_call1(f, x);}
     var e = param[1];
     return [1, e];
    }
    return caml_call2(Lwt[28], _i_, e);
   }
   function bind_lwt_error(e, f){
    function _g_(param){
     if(0 === param[0]){var x = param[1]; return return$0(x);}
     var e = param[1], _h_ = caml_call1(f, e);
     return caml_call2(Lwt[6], _h_, fail);
    }
    return caml_call2(Lwt[6], e, _g_);
   }
   function bind_lwt_err(e, f){return bind_lwt_error(e, f);}
   function both(a, b){
    var s = [0, 0];
    function set_once(e){return s[1] ? 0 : (s[1] = [0, e], 0);}
    var
     b$0 = map_error(set_once, b),
     a$0 = map_error(set_once, a),
     _d_ = caml_call2(Lwt[13], a$0, b$0);
    function _e_(param){
     var _f_ = param[1];
     if(0 === _f_[0]){
      var match = param[2], x = _f_[1];
      if(0 === match[0]){var y = match[1]; return [0, [0, x, y]];}
     }
     var param$0 = s[1];
     if(! param$0)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var e = param$0[1];
     return [1, e];
    }
    return caml_call2(Lwt[28], _e_, _d_);
   }
   function iter(f, r){
    function _c_(param){
     if(0 !== param[0]) return Lwt[36];
     var x = param[1];
     return caml_call1(f, x);
    }
    return caml_call2(Lwt[6], r, _c_);
   }
   function iter_error(f, r){
    function _b_(param){
     if(0 === param[0]) return Lwt[36];
     var e = param[1];
     return caml_call1(f, e);
    }
    return caml_call2(Lwt[6], r, _b_);
   }
   function symbol(e, f){return map(f, e);}
   function map$0(t, f){return map(f, t);}
   function bind(t, f){return symbol_bind(t, f);}
   var
    Open_on_rhs = [0],
    Let_syntax = [0, return$0, map$0, bind, both, Open_on_rhs],
    Let_syntax$0 = [0, Let_syntax];
   function let$0(x, f){return map(f, x);}
   var
    Syntax = [0, symbol_bind, both, let$0, both],
    Lwt_result =
      [0,
       return$0,
       fail,
       lift,
       ok,
       error,
       catch$0,
       get_exn,
       map,
       map_error,
       symbol_bind,
       bind_error,
       bind_lwt,
       bind_lwt_error,
       bind_result,
       both,
       iter,
       iter_error,
       [0, symbol, symbol_bind],
       Let_syntax$0,
       Syntax,
       symbol,
       symbol_bind,
       map_err,
       bind_lwt_err];
   runtime.caml_register_global(3, Lwt_result, "Lwt_result");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_pqueue
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    _a_ = [0, "src/core/lwt_pqueue.ml", 81, 15];
   function Make(Ord){
    function link(t1, t2){
     var
      c2 = t2[3],
      r2 = t2[2],
      x2 = t2[1],
      c1 = t1[3],
      r1 = t1[2],
      x1 = t1[1],
      c = caml_call2(Ord[1], x1, x2);
     return 0 < c
             ? [0, x2, r2 + 1 | 0, [0, t1, c2]]
             : [0, x1, r1 + 1 | 0, [0, t2, c1]];
    }
    function ins(t, ts){
     var t$0 = t, ts$0 = ts;
     for(;;){
      if(! ts$0) return [0, t$0, 0];
      var t$1 = ts$0[1];
      if(t$0[2] < t$1[2]) return [0, t$0, ts$0];
      var ts$1 = ts$0[2], t$2 = link(t$0, t$1), t$0 = t$2, ts$0 = ts$1;
     }
    }
    var empty = 0;
    function is_empty(ts){return 0 === ts ? 1 : 0;}
    function add(x, ts){return ins([0, x, 0, 0], ts);}
    function union(ts$0, ts){
     if(! ts$0) return ts;
     if(! ts) return ts$0;
     var ts2 = ts[2], t2 = ts[1], ts1 = ts$0[2], t1 = ts$0[1];
     if(t1[2] < t2[2]) return [0, t1, union(ts1, [0, t2, ts2])];
     if(t2[2] < t1[2]) return [0, t2, union([0, t1, ts1], ts2)];
     var _e_ = union(ts1, ts2);
     return ins(link(t1, t2), _e_);
    }
    function find_min(param){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var t = param[1];
     if(! param[2]) return t[1];
     var ts = param[2], x = find_min(ts), c = caml_call2(Ord[1], t[1], x);
     return 0 <= c ? x : t[1];
    }
    function lookup_min(param){
     if(! param) return 0;
     var t = param[1];
     if(! param[2]) return [0, t[1]];
     var ts = param[2], result = lookup_min(ts);
     if(! result) return 0;
     var x = result[1], c = caml_call2(Ord[1], t[1], x);
     return 0 <= c ? result : [0, t[1]];
    }
    function get_min(param){
     if(! param)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _a_], 1);
     var t = param[1];
     if(! param[2]) return [0, t, 0];
     var
      ts = param[2],
      match = get_min(ts),
      ts$0 = match[2],
      t$0 = match[1],
      c = caml_call2(Ord[1], t[1], t$0[1]);
     return 0 <= c ? [0, t$0, [0, t, ts$0]] : [0, t, ts];
    }
    function remove_min(ts){
     if(! ts) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var _d_ = get_min(ts), ts$0 = _d_[2], c = _d_[1][3];
     return union(caml_call1(Stdlib_List[9], c), ts$0);
    }
    function size(l){
     var _b_ = 0;
     function _c_(s, t){var tl = t[3]; return s + (1 + size(tl) | 0) | 0;}
     return caml_call3(Stdlib_List[25], _c_, _b_, l);
    }
    return [0,
            empty,
            is_empty,
            add,
            union,
            find_min,
            lookup_min,
            remove_min,
            size];
   }
   var Lwt_pqueue = [0, Make];
   runtime.caml_register_global(4, Lwt_pqueue, "Lwt_pqueue");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_list
//# unitInfo: Requires: Lwt, Stdlib, Stdlib__List
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Stdlib = global_data.Stdlib,
    Stdlib_List = global_data.Stdlib__List;
   function tail_recursive_map(f, l){
    var _an_ = caml_call2(Stdlib_List[21], f, l);
    return caml_call1(Stdlib_List[9], _an_);
   }
   function tail_recursive_mapi_rev(f, l){
    var acc = 0, i = 0, param = l;
    for(;;){
     if(! param) return acc;
     var
      tl = param[2],
      hd = param[1],
      i$0 = i + 1 | 0,
      acc$0 = [0, caml_call2(f, i, hd), acc],
      acc = acc$0,
      i = i$0,
      param = tl;
    }
   }
   function iter_s(f, l){
    if(! l) return Lwt[36];
    var l$0 = l[2], x = l[1];
    function _al_(param){return iter_s(f, l$0);}
    var _am_ = caml_call2(Lwt[80], f, x);
    return caml_call2(Lwt[33][1], _am_, _al_);
   }
   function iter_p(f, l){
    var
     _ak_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[21], _ak_, l);
    return caml_call1(Lwt[14], ts);
   }
   function _a_(i, f, l){
    if(! l) return Lwt[36];
    var l$0 = l[2], x = l[1];
    function _ah_(param){return _a_(i + 1 | 0, f, l$0);}
    var _ai_ = caml_call1(f, i), _aj_ = caml_call2(Lwt[80], _ai_, x);
    return caml_call2(Lwt[33][1], _aj_, _ah_);
   }
   function iteri_s(f, l){return _a_(0, f, l);}
   function iteri_p(f, l){
    function f$0(i){
     var _ag_ = caml_call1(f, i);
     return caml_call1(Lwt[80], _ag_);
    }
    var ts = tail_recursive_mapi_rev(f$0, l);
    return caml_call1(Lwt[14], ts);
   }
   function map_s(f, l){
    function inner(acc, param){
     if(param){
      var
       tl = param[2],
       hd = param[1],
       _ad_ = function(r){return inner([0, r, acc], tl);},
       _ae_ = caml_call2(Lwt[80], f, hd);
      return caml_call2(Lwt[33][1], _ae_, _ad_);
     }
     var _af_ = caml_call1(Stdlib_List[9], acc);
     return caml_call1(Lwt[4], _af_);
    }
    return inner(0, l);
   }
   function collect_rev(acc, param){
    if(! param) return caml_call1(Lwt[4], acc);
    var ts = param[2], t = param[1];
    function _ac_(i){return collect_rev([0, i, acc], ts);}
    return caml_call2(Lwt[33][1], t, _ac_);
   }
   function map_p(f, l){
    var
     _ab_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[21], _ab_, l);
    return collect_rev(0, ts);
   }
   function filter_map_s(f, l){
    function inner(acc, param){
     if(param){
      var
       tl = param[2],
       hd = param[1],
       ___ =
         function(param){
          if(! param) return inner(acc, tl);
          var v = param[1];
          return inner([0, v, acc], tl);
         },
       _$_ = caml_call2(Lwt[80], f, hd);
      return caml_call2(Lwt[33][1], _$_, ___);
     }
     var _aa_ = caml_call1(Stdlib_List[9], acc);
     return caml_call1(Lwt[4], _aa_);
    }
    return inner(0, l);
   }
   function filter_map_p(f, l){
    function collect_optional_rev(acc, param){
     if(! param) return caml_call1(Lwt[4], acc);
     var ts = param[2], t = param[1];
     function _Z_(param){
      if(! param) return collect_optional_rev(acc, ts);
      var v = param[1];
      return collect_optional_rev([0, v, acc], ts);
     }
     return caml_call2(Lwt[33][1], t, _Z_);
    }
    var
     _Y_ = caml_call1(Lwt[80], f),
     ts = caml_call2(Stdlib_List[21], _Y_, l);
    return collect_optional_rev(0, ts);
   }
   function mapi_s(f, l){
    function inner(acc, i, param){
     if(param){
      var
       tl = param[2],
       hd = param[1],
       _U_ = function(v){return inner([0, v, acc], i + 1 | 0, tl);},
       _V_ = caml_call1(f, i),
       _W_ = caml_call2(Lwt[80], _V_, hd);
      return caml_call2(Lwt[33][1], _W_, _U_);
     }
     var _X_ = caml_call1(Stdlib_List[9], acc);
     return caml_call1(Lwt[4], _X_);
    }
    return inner(0, 0, l);
   }
   function mapi_p(f, l){
    function f$0(i){
     var _T_ = caml_call1(f, i);
     return caml_call1(Lwt[80], _T_);
    }
    var ts = tail_recursive_mapi_rev(f$0, l);
    return collect_rev(0, ts);
   }
   function rev_map_append_s(acc, f, l){
    if(! l) return caml_call1(Lwt[4], acc);
    var l$0 = l[2], x = l[1];
    function _R_(x){return rev_map_append_s([0, x, acc], f, l$0);}
    var _S_ = caml_call2(Lwt[80], f, x);
    return caml_call2(Lwt[33][1], _S_, _R_);
   }
   function rev_map_s(f, l){return rev_map_append_s(0, f, l);}
   function rev_map_p(f, l$1){
    var acc$1 = Lwt[38], acc = acc$1, l = l$1;
    for(;;){
     if(! l) return acc;
     var
      l$0 = l[2],
      x = l[1],
      _O_ =
        function(acc){
          return function(x){
           function _Q_(l){return [0, x, l];}
           return caml_call2(Lwt[33][2], acc, _Q_);};
         }
         (acc),
      _P_ = caml_call2(Lwt[80], f, x),
      acc$0 = caml_call2(Lwt[33][1], _P_, _O_),
      acc = acc$0,
      l = l$0;
    }
   }
   function fold_left_s(f, acc, l){
    if(! l) return caml_call1(Lwt[4], acc);
    var l$0 = l[2], x = l[1];
    function _L_(acc){return fold_left_s(f, acc, l$0);}
    var _M_ = caml_call1(f, acc), _N_ = caml_call2(Lwt[80], _M_, x);
    return caml_call2(Lwt[33][1], _N_, _L_);
   }
   function fold_right_s(f, l, acc){
    function inner(f, a, param){
     if(! param) return caml_call1(Lwt[4], a);
     var tl = param[2], hd = param[1];
     function _I_(a){return inner(f, a, tl);}
     var _J_ = caml_call1(f, hd), _K_ = caml_call2(Lwt[80], _J_, a);
     return caml_call2(Lwt[33][1], _K_, _I_);
    }
    return inner(f, acc, caml_call1(Stdlib_List[9], l));
   }
   function for_all_s(f, l){
    if(! l) return Lwt[39];
    var l$0 = l[2], x = l[1];
    function _G_(param){return param ? for_all_s(f, l$0) : Lwt[40];}
    var _H_ = caml_call2(Lwt[80], f, x);
    return caml_call2(Lwt[33][1], _H_, _G_);
   }
   function for_all_p(f, l){
    function _C_(bl){
     function _E_(x){return x;}
     var _F_ = caml_call2(Stdlib_List[32], _E_, bl);
     return caml_call1(Lwt[4], _F_);
    }
    var _D_ = map_p(f, l);
    return caml_call2(Lwt[33][1], _D_, _C_);
   }
   function exists_s(f, l){
    if(! l) return Lwt[40];
    var l$0 = l[2], x = l[1];
    function _A_(param){return param ? Lwt[39] : exists_s(f, l$0);}
    var _B_ = caml_call2(Lwt[80], f, x);
    return caml_call2(Lwt[33][1], _B_, _A_);
   }
   function exists_p(f, l){
    function _w_(bl){
     function _y_(x){return x;}
     var _z_ = caml_call2(Stdlib_List[33], _y_, bl);
     return caml_call1(Lwt[4], _z_);
    }
    var _x_ = map_p(f, l);
    return caml_call2(Lwt[33][1], _x_, _w_);
   }
   function find_s(f, l){
    if(! l) return caml_call1(Lwt[5], Stdlib[8]);
    var l$0 = l[2], x = l[1];
    function _u_(param){
     return param ? caml_call1(Lwt[4], x) : find_s(f, l$0);
    }
    var _v_ = caml_call2(Lwt[80], f, x);
    return caml_call2(Lwt[33][1], _v_, _u_);
   }
   function optionalize(f, x){
    function _s_(b){return b ? caml_call1(Lwt[4], [0, x]) : Lwt[37];}
    var _t_ = caml_call1(f, x);
    return caml_call2(Lwt[33][1], _t_, _s_);
   }
   function filter_s(f, l){
    return filter_map_s(function(_r_){return optionalize(f, _r_);}, l);
   }
   function filter_p(f, l){
    return filter_map_p(function(_q_){return optionalize(f, _q_);}, l);
   }
   function partition_s(f, l){
    function inner(acc1, acc2, param){
     if(param){
      var
       tl = param[2],
       hd = param[1],
       _m_ =
         function(b){
          return b
                  ? inner([0, hd, acc1], acc2, tl)
                  : inner(acc1, [0, hd, acc2], tl);
         },
       _n_ = caml_call2(Lwt[80], f, hd);
      return caml_call2(Lwt[33][1], _n_, _m_);
     }
     var
      _o_ = caml_call1(Stdlib_List[9], acc2),
      _p_ = [0, caml_call1(Stdlib_List[9], acc1), _o_];
     return caml_call1(Lwt[4], _p_);
    }
    return inner(0, 0, l);
   }
   function partition_p(f, l){
    function g(x){
     function _k_(b){return caml_call1(Lwt[4], [0, b, x]);}
     var _l_ = caml_call2(Lwt[80], f, x);
     return caml_call2(Lwt[33][1], _l_, _k_);
    }
    function _b_(tl){
     function _d_(_j_){return _j_[1];}
     var
      _e_ = caml_call2(Stdlib_List[41], _d_, tl),
      group1 = tail_recursive_map(function(_i_){return _i_[2];}, _e_);
     function _f_(x){return 1 - x[1];}
     var
      _g_ = caml_call2(Stdlib_List[41], _f_, tl),
      group2 = tail_recursive_map(function(_h_){return _h_[2];}, _g_);
     return caml_call1(Lwt[4], [0, group1, group2]);
    }
    var _c_ = map_p(g, l);
    return caml_call2(Lwt[33][1], _c_, _b_);
   }
   var
    Lwt_list =
      [0,
       iter_s,
       iter_p,
       iteri_s,
       iteri_p,
       map_s,
       map_p,
       mapi_s,
       mapi_p,
       rev_map_s,
       rev_map_p,
       fold_left_s,
       fold_right_s,
       for_all_s,
       for_all_p,
       exists_s,
       exists_p,
       find_s,
       filter_s,
       filter_p,
       filter_map_s,
       filter_map_p,
       partition_s,
       partition_p];
   runtime.caml_register_global(3, Lwt_list, "Lwt_list");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_pool
//# unitInfo: Requires: Lwt, Lwt_list, Lwt_sequence, Stdlib__Queue
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_Queue = global_data.Stdlib__Queue,
    Lwt_list = global_data.Lwt_list,
    Lwt = global_data.Lwt;
   function create(m, opt, _H_, _G_, create){
    if(opt)
     var sth = opt[1], validate = sth;
    else
     var validate = function(param){return Lwt[39];};
    if(_H_)
     var sth$0 = _H_[1], check = sth$0;
    else
     var check = function(param, f){return caml_call1(f, 1);};
    if(_G_)
     var sth$1 = _G_[1], dispose = sth$1;
    else
     var dispose = function(param){return Lwt[36];};
    var _I_ = caml_call1(Lwt_sequence[4], 0);
    return [0,
            create,
            check,
            validate,
            dispose,
            [0, [0, 0]],
            m,
            0,
            caml_call1(Stdlib_Queue[2], 0),
            _I_];
   }
   function create_member(p){
    function _E_(exn){p[7] = p[7] - 1 | 0; return caml_call1(Lwt[5], exn);}
    function _F_(param){p[7] = p[7] + 1 | 0; return caml_call1(p[1], 0);}
    return caml_call2(Lwt[7], _F_, _E_);
   }
   function release(p, c){
    var match = caml_call1(Lwt_sequence[13], p[9]);
    if(! match) return caml_call2(Stdlib_Queue[4], c, p[8]);
    var wakener = match[1];
    return caml_call2(Lwt[2], wakener, c);
   }
   function dispose(p, c){
    function _C_(param){p[7] = p[7] - 1 | 0; return Lwt[36];}
    var _D_ = caml_call1(p[4], c);
    return caml_call2(Lwt[33][1], _D_, _C_);
   }
   function validate_and_return(p, c){
    function _s_(e){
     function _x_(param){
      var match = caml_call1(Lwt_sequence[13], p[9]);
      if(match){
       var
        wakener = match[1],
        _z_ = function(exn){return caml_call2(Lwt[3], wakener, exn);},
        _A_ = function(c){return caml_call2(Lwt[2], wakener, c);},
        _B_ = caml_call2(Lwt[80], p[1], 0);
       caml_call3(Lwt[32], _B_, _A_, _z_);
      }
      return caml_call1(Lwt[5], e);
     }
     var _y_ = dispose(p, c);
     return caml_call2(Lwt[33][1], _y_, _x_);
    }
    function _t_(param){
     if(param) return caml_call1(Lwt[4], c);
     function _v_(param){return create_member(p);}
     var _w_ = dispose(p, c);
     return caml_call2(Lwt[33][1], _w_, _v_);
    }
    function _u_(param){return caml_call1(p[3], c);}
    return caml_call3(Lwt[9], _u_, _t_, _s_);
   }
   function use(p, f){
    function _h_(c){
     var cleared = p[5][1];
     function _k_(e){
      function _q_(param){return caml_call1(Lwt[5], e);}
      var cleared$0 = cleared[1], ok = [0, 0];
      function _p_(result){ok[1] = result; return 0;}
      caml_call2(p[2], c, _p_);
      a:
      {
       if(! cleared$0 && ok[1]){release(p, c); var _r_ = Lwt[36]; break a;}
       var _r_ = dispose(p, c);
      }
      return caml_call2(Lwt[33][1], _r_, _q_);
     }
     function _l_(param){return caml_call1(f, c);}
     var promise = caml_call2(Lwt[7], _l_, _k_);
     function _m_(param){
      if(cleared[1]){
       var _n_ = function(param){return promise;}, _o_ = dispose(p, c);
       return caml_call2(Lwt[33][1], _o_, _n_);
      }
      release(p, c);
      return promise;
     }
     return caml_call2(Lwt[33][1], promise, _m_);
    }
    if(caml_call1(Stdlib_Queue[13], p[8]))
     if(p[7] < p[6])
      var _i_ = create_member(p);
     else
      var
       _f_ = function(_j_){return validate_and_return(p, _j_);},
       _g_ = caml_call1(Lwt[55], p[9]),
       _i_ = caml_call2(Lwt[33][1], _g_, _f_);
    else
     var
      c = caml_call1(Stdlib_Queue[5], p[8]),
      _i_ = validate_and_return(p, c);
    return caml_call2(Lwt[33][1], _i_, _h_);
   }
   function clear(p){
    var _a_ = p[8], _b_ = 0;
    function _c_(l, element){return [0, element, l];}
    var elements = caml_call3(Stdlib_Queue[16], _c_, _b_, _a_);
    caml_call1(Stdlib_Queue[11], p[8]);
    var old_cleared = p[5][1];
    old_cleared[1] = 1;
    p[5][1] = [0, 0];
    function _d_(_e_){return dispose(p, _e_);}
    return caml_call2(Lwt_list[1], _d_, elements);
   }
   function wait_queue_length(p){return caml_call1(Lwt_sequence[7], p[9]);}
   var Lwt_pool = [0, create, use, clear, wait_queue_length];
   runtime.caml_register_global(4, Lwt_pool, "Lwt_pool");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_mvar
//# unitInfo: Requires: Lwt, Lwt_sequence
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Lwt_sequence = global_data.Lwt_sequence;
   function create_empty(param){
    var _c_ = caml_call1(Lwt_sequence[4], 0);
    return [0, 0, caml_call1(Lwt_sequence[4], 0), _c_];
   }
   function create(v){
    var _b_ = caml_call1(Lwt_sequence[4], 0);
    return [0, [0, v], caml_call1(Lwt_sequence[4], 0), _b_];
   }
   function put(mvar, v){
    if(mvar[1]){
     var
      match = caml_call1(Lwt[22], 0),
      w = match[2],
      res = match[1],
      node = caml_call2(Lwt_sequence[9], [0, v, w], mvar[2]),
      _a_ = function(param){return caml_call1(Lwt_sequence[3], node);};
     caml_call2(Lwt[24], res, _a_);
     return res;
    }
    var match$0 = caml_call1(Lwt_sequence[13], mvar[3]);
    if(match$0){
     var w$0 = match$0[1];
     caml_call2(Lwt[2], w$0, v);
    }
    else
     mvar[1] = [0, v];
    return Lwt[36];
   }
   function take_available(mvar){
    var match$1 = mvar[1];
    if(! match$1) return 0;
    var v$0 = match$1[1], match = caml_call1(Lwt_sequence[13], mvar[2]);
    if(match){
     var match$0 = match[1], w = match$0[2], v = match$0[1];
     mvar[1] = [0, v];
     caml_call2(Lwt[2], w, 0);
    }
    else
     mvar[1] = 0;
    return [0, v$0];
   }
   function take(mvar){
    var match = take_available(mvar);
    if(! match) return caml_call1(Lwt[55], mvar[3]);
    var v = match[1];
    return caml_call1(Lwt[4], v);
   }
   function is_empty(mvar){return mvar[1] ? 0 : 1;}
   var
    Lwt_mvar = [0, create, create_empty, put, take, take_available, is_empty];
   runtime.caml_register_global(2, Lwt_mvar, "Lwt_mvar");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_mutex
//# unitInfo: Requires: Lwt, Lwt_sequence
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt_sequence = global_data.Lwt_sequence,
    Lwt = global_data.Lwt;
   function create(param){return [0, 0, caml_call1(Lwt_sequence[4], 0)];}
   function lock(m){
    return m[1] ? caml_call1(Lwt[55], m[2]) : (m[1] = 1, Lwt[36]);
   }
   function unlock(m){
    var _d_ = m[1];
    if(! _d_) return _d_;
    if(caml_call1(Lwt_sequence[6], m[2])){m[1] = 0; return 0;}
    var _e_ = caml_call1(Lwt_sequence[11], m[2]);
    return caml_call2(Lwt[2], _e_, 0);
   }
   function with_lock(m, f){
    function _a_(param){
     function _c_(param){unlock(m); return Lwt[36];}
     return caml_call2(Lwt[8], f, _c_);
    }
    var _b_ = lock(m);
    return caml_call2(Lwt[33][1], _b_, _a_);
   }
   function is_locked(m){return m[1];}
   function is_empty(m){return caml_call1(Lwt_sequence[6], m[2]);}
   var Lwt_mutex = [0, create, lock, unlock, is_locked, is_empty, with_lock];
   runtime.caml_register_global(2, Lwt_mutex, "Lwt_mutex");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Lwt_condition
//# unitInfo: Requires: Lwt, Lwt_mutex, Lwt_sequence, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Lwt = global_data.Lwt,
    Lwt_sequence = global_data.Lwt_sequence,
    Stdlib_List = global_data.Stdlib__List,
    Lwt_mutex = global_data.Lwt_mutex,
    create = Lwt_sequence[4];
   function wait(mutex, cvar){
    var waiter = caml_call1(Lwt[55], cvar);
    if(mutex){var m = mutex[1]; caml_call1(Lwt_mutex[3], m);}
    function _k_(param){
     if(! mutex) return Lwt[36];
     var m = mutex[1];
     return caml_call1(Lwt_mutex[2], m);
    }
    function _l_(param){return waiter;}
    return caml_call2(Lwt[8], _l_, _k_);
   }
   function signal(cvar, arg){
    try{
     var
      _h_ = caml_call1(Lwt_sequence[11], cvar),
      _i_ = caml_call2(Lwt[2], _h_, arg);
     return _i_;
    }
    catch(_j_){
     var _g_ = caml_wrap_exception(_j_);
     if(_g_ === Lwt_sequence[10]) return 0;
     throw caml_maybe_attach_backtrace(_g_, 0);
    }
   }
   function broadcast(cvar, arg){
    var _d_ = 0;
    function _e_(x, l){return [0, x, l];}
    var wakeners = caml_call3(Lwt_sequence[22], _e_, cvar, _d_);
    caml_call2(Lwt_sequence[19], Lwt_sequence[3], cvar);
    function _f_(wakener){return caml_call2(Lwt[2], wakener, arg);}
    return caml_call2(Stdlib_List[17], _f_, wakeners);
   }
   function broadcast_exn(cvar, exn){
    var _a_ = 0;
    function _b_(x, l){return [0, x, l];}
    var wakeners = caml_call3(Lwt_sequence[22], _b_, cvar, _a_);
    caml_call2(Lwt_sequence[19], Lwt_sequence[3], cvar);
    function _c_(wakener){return caml_call2(Lwt[3], wakener, exn);}
    return caml_call2(Stdlib_List[17], _c_, wakeners);
   }
   var Lwt_condition = [0, create, wait, signal, broadcast, broadcast_exn];
   runtime.caml_register_global(4, Lwt_condition, "Lwt_condition");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJsd3QuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImdldCIsIm5vZGUiLCJzZXQiLCJkYXRhIiwicmVtb3ZlIiwiY3JlYXRlIiwic2VxIiwiY2xlYXIiLCJpc19lbXB0eSIsImxlbmd0aCIsImN1cnIkMSIsImN1cnIiLCJsZW4iLCJsZW4kMCIsImN1cnIkMCIsImFkZF9sIiwiYWRkX3IiLCJ0YWtlX2wiLCJ0YWtlX3IiLCJ0YWtlX29wdF9sIiwidGFrZV9vcHRfciIsInRyYW5zZmVyX2wiLCJzMSIsInMyIiwidHJhbnNmZXJfciIsIml0ZXJfbCIsImYiLCJpdGVyX3IiLCJpdGVyX25vZGVfbCIsIml0ZXJfbm9kZV9yIiwiZm9sZF9sIiwiYWNjIiwiY3VyciQyIiwiYWNjJDAiLCJhY2MkMSIsImZvbGRfciIsImZpbmRfbm9kZV9sIiwiZmluZF9ub2RlX3IiLCJmaW5kX25vZGVfb3B0X2wiLCJmaW5kX25vZGVfb3B0X3IiLCJjb21wYXJlIiwic3RhdGVfb2ZfcmVzdWx0IiwieCIsImV4biIsInVuZGVybHlpbmciLCJwIiwicCQwIiwicCQxIiwic2V0X3Byb21pc2Vfc3RhdGUiLCJzdGF0ZSIsImhhbmRsZV9hbGwiLCJoYW5kbGVfYWxsX2V4Y2VwdF9ydW50aW1lIiwidiIsInJ1biIsImUiLCJuZXh0X2tleV9pZCIsIm5ld19rZXkiLCJpZCIsImN1cnJlbnRfc3RvcmFnZSIsImtleSIsInJlZnJlc2giLCJ2YWx1ZSIsIndpdGhfdmFsdWUiLCJuZXdfc3RvcmFnZSIsInNhdmVkX3N0b3JhZ2UiLCJyZXN1bHQiLCJleG4kMCIsImNvbmNhdF9yZWd1bGFyX2NhbGxiYWNrcyIsImwxIiwibDIiLCJjbGVhbl91cF9jYWxsYmFja19jZWxscyIsImNhbGxiYWNrcyIsImwxJDAiLCJsMiQwIiwiY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsIiwiY2VsbCIsInBzIiwiY2xlYW51cHNfZGVmZXJyZWQiLCJhZGRfcmVndWxhcl9jYWxsYmFja19saXN0X25vZGUiLCJleGlzdGluZyIsIm5vZGUkMCIsImFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhYyIsImFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYiIsInNlbGZfcmVtb3ZpbmdfY2FsbGJhY2tfd3JhcHBlciIsImFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYiQwIiwiYWRkX2NhbmNlbF9jYWxsYmFjayIsImFzeW5jX2V4Y2VwdGlvbl9ob29rIiwiaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvIiwicnVuX2NhbGxiYWNrcyIsImlzX2NhbmNlbGVkIiwiZnMiLCJpdGVyX2NhbGxiYWNrX2xpc3QkMiIsInJlc3QiLCJmcyQwIiwicmVzdCQwIiwiaXRlcl9saXN0JDAiLCJmcyQxIiwiZnMkMiIsInJlc3QkMSIsInN0b3JhZ2UiLCJpdGVyX2NhbGxiYWNrX2xpc3QiLCJpdGVyX2NhbGxiYWNrX2xpc3QkMSIsIml0ZXJfbGlzdCIsImYkMCIsIml0ZXJfY2FsbGJhY2tfbGlzdCQwIiwiY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIiwiZGVmZXJyZWRfY2FsbGJhY2tzIiwiZGVmYXVsdF9tYXhpbXVtX2NhbGxiYWNrX25lc3RpIiwibGVhdmVfcmVzb2x1dGlvbl9sb29wIiwic3RvcmFnZV9zbmFwc2hvdCIsInJ1bl9pbl9yZXNvbHV0aW9uX2xvb3AiLCJhYmFuZG9uX3dha2V1cHMiLCJydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW0iLCJvcHQiLCJzdGgiLCJhbGxvd19kZWZlcnJpbmciLCJzdGgkMCIsIm1heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCIsInNob3VsZF9kZWZlciIsInJlc29sdmUiLCJydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXQiLCJpZl9kZWZlcnJlZCIsInJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaSIsImRlZmVycmVkX3Jlc3VsdCIsImRlZmVycmVkX2NhbGxiYWNrIiwiaW1tZWRpYXRlX3Jlc3VsdCIsImRlZmVycmVkX3JlY29yZCIsIndha2V1cF9nZW5lcmFsIiwiYXBpX2Z1bmN0aW9uX25hbWUiLCJyIiwicmVzdWx0JDAiLCJ3YWtldXBfcmVzdWx0Iiwid2FrZXVwIiwid2FrZXVwX2V4biIsIndha2V1cF9sYXRlcl9nZW5lcmFsIiwid2FrZXVwX2xhdGVyX3Jlc3VsdCIsIndha2V1cF9sYXRlciIsIndha2V1cF9sYXRlcl9leG4iLCJjYW5jZWwiLCJjYW5jZWxlZF9yZXN1bHQiLCJjYW5jZWxfYW5kX2NvbGxlY3RfY2FsbGJhY2tzIiwiY2FsbGJhY2tzX2FjY3VtdWxhdG9yIiwicCQyIiwicGFyYW0iLCJyZXR1cm4kMCIsIm9mX3Jlc3VsdCIsImZhaWwiLCJyZXR1cm5fdW5pdCIsInJldHVybl9ub25lIiwicmV0dXJuX3NvbWUiLCJyZXR1cm5fbmlsIiwicmV0dXJuX3RydWUiLCJyZXR1cm5fZmFsc2UiLCJyZXR1cm5fb2siLCJyZXR1cm5fZXJyb3IiLCJmYWlsX3dpdGgiLCJtc2ciLCJmYWlsX2ludmFsaWRfYXJnIiwibmV3X3BlbmRpbmciLCJob3dfdG9fY2FuY2VsIiwid2FpdCIsInRhc2siLCJhZGRfdGFza19yIiwic2VxdWVuY2UiLCJhZGRfdGFza19sIiwicHJvdGVjdGVkJDAiLCJwX2ludGVybmFsIiwiY2FsbGJhY2siLCJwX3Jlc3VsdCIsInJlbW92ZV90aGVfY2FsbGJhY2siLCJwX2NhbGxiYWNrcyIsIm5vX2NhbmNlbCIsIm1ha2VfaW50b19wcm94eSIsIm91dGVyX3Byb21pc2UiLCJ1c2VyX3Byb3ZpZGVkX3Byb21pc2UiLCJvdXRlcl9jYWxsYmFja3MiLCJyZWd1bGFyX2NhbGxiYWNrcyIsImNsZWFudXBzX2RlZmVycmVkJDAiLCJyZWd1bGFyX2NhbGxiYWNrcyQwIiwiY2FuY2VsX2NhbGxiYWNrcyIsInN5bWJvbF9iaW5kIiwiY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsIiwiYmFja3RyYWNlX2JpbmQiLCJhZGRfbG9jIiwic3ltYm9sIiwicF9yZXN1bHQkMCIsImNhdGNoJDAiLCJoIiwiYmFja3RyYWNlX2NhdGNoIiwidHJ5X2JpbmQiLCJleG4kMSIsInAkMyIsImJhY2t0cmFjZV90cnlfYmluZCIsImZpbmFsaXplIiwiYmFja3RyYWNlX2ZpbmFsaXplIiwib25fY2FuY2VsIiwib25fc3VjY2VzcyIsImNhbGxiYWNrX2lmX2RlZmVycmVkIiwib25fZmFpbHVyZSIsIm9uX3Rlcm1pbmF0aW9uIiwib25fYW55IiwiZyIsIndyYXBfaW5fY2FuY2VsYWJsZSIsInBfdW5kZXJseWluZyIsImRvbnRfd2FpdCIsImFzeW5jIiwiaWdub3JlX3Jlc3VsdCIsImpvaW4iLCJudW1iZXJfcGVuZGluZ19pbl9wcyIsImpvaW5fcmVzdWx0IiwibmV3X3Jlc3VsdCIsInBzJDAiLCJwcyQxIiwiYm90aCIsInAxIiwicDIiLCJwYWlyIiwicDEkMCIsInAyJDAiLCJ2MiIsInYxIiwiYWxsIiwieSIsInZzIiwiaW5kZXgiLCJpJDEiLCJpIiwiaSQwIiwiY291bnRfcmVzb2x2ZWRfcHJvbWlzZXNfaW4iLCJ0b3RhbCQxIiwicHMkMiIsInBzJDMiLCJ0b3RhbCQyIiwicmVqZWN0ZWQkMSIsInRvdGFsIiwicmVqZWN0ZWQiLCJyZWplY3RlZCQwIiwidG90YWwkMCIsIm50aF9yZXNvbHZlZCIsIm4iLCJuJDAiLCJuJDIiLCJuJDEiLCJudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW4iLCJwcm5nIiwiY2hvb3NlIiwicGljayIsInFzIiwiY29sbGVjdF9mdWxmaWxsZWRfcHJvbWlzZXNfYWZ0IiwicmVzdWx0cyIsInJlc3VsdHMkMCIsInJlc3VsdHMkMSIsIm5jaG9vc2UiLCJ2JDAiLCJucGljayIsIm5jaG9vc2Vfc3BsaXQiLCJwZW5kaW5nX2FjYyIsInRvX3Jlc29sdmUiLCJmdWxmaWxsZWQiLCJwZW5kaW5nIiwicGVuZGluZyQwIiwiZnVsZmlsbGVkJDAiLCJwX2ludGVybmFsJDAiLCJwZW5kaW5nX2FjYyQwIiwiZGVidWdfc3RhdGVfaXMiLCJleHBlY3RlZF9zdGF0ZSIsImlzX3NsZWVwaW5nIiwicG9sbCIsImFwcGx5Iiwid3JhcCIsIndyYXAxIiwieDEiLCJ3cmFwMiIsIngyIiwid3JhcDMiLCJ4MyIsIndyYXA0IiwieDQiLCJ3cmFwNSIsIng1Iiwid3JhcDYiLCJ4NiIsIndyYXA3IiwieDciLCJwYXVzZV9ob29rIiwicGF1c2VkIiwicGF1c2UiLCJ3YWtldXBfcGF1c2VkIiwidG1wIiwicmVnaXN0ZXJfcGF1c2Vfbm90aWZpZXIiLCJhYmFuZG9uX3BhdXNlZCIsInBhdXNlZF9jb3VudCIsIm1hcCIsInQiLCJiaW5kIiwic3ltYm9sJDAiLCJzeW1ib2wkMSIsInN5bWJvbCQyIiwic3ltYm9sJDMiLCJsZXQkMCIsImlzX29uIiwic3dpdGNoJDAiLCJjaGVjayIsImFkZF9ob29rIiwiaG9vayIsIm9zIiwiYWRkX2hvb2tfb3JfZXhlYyIsInR1cm5fb2ZmIiwiaG9va3MiLCJ3aXRoX3N3aXRjaCIsImZuIiwiZW1wdHkiLCJyZXR1cm5fbHd0IiwiY29ucyIsImNvbnNfbHd0Iiwic2VxMSIsInNlcTIiLCJuZXh0IiwiYXBwZW5kIiwieCQwIiwibWFwX3MiLCJmaWx0ZXJfbWFwIiwiZmlsdGVyX21hcF9zIiwib2siLCJmaWx0ZXIiLCJmaWx0ZXJfcyIsImZsYXRfbWFwX2FwcCIsInRhaWwiLCJmbGF0X21hcCIsImZvbGRfbGVmdCIsImF1eCIsImZvbGRfbGVmdF9zIiwiaXRlciIsIml0ZXJfcyIsIml0ZXJfcCIsIml0ZXJfbiIsIm1heF9jb25jdXJyZW5jeSIsIm1lc3NhZ2UiLCJsb29wIiwicnVubmluZyIsImF2YWlsYWJsZSIsImVsdCIsImNvbXBsZXRlIiwidW5mb2xkIiwidSIsImV4YyQwIiwiZXhjIiwidSQwIiwidW5mb2xkX2x3dCIsIm9mX2xpc3QiLCJsIiwidG9fbGlzdCQwIiwib2Zfc2VxIiwibmV4dCQwIiwib2Zfc2VxX2x3dCIsIm5ld19ub2RlIiwiY2xvbmUiLCJzIiwiZnJvbV9zb3VyY2UiLCJzb3VyY2UiLCJjbG9zZSIsImNsb3NlZCIsImZyb20iLCJmcm9tX2RpcmVjdCIsImlzX2Nsb3NlZCIsImVucXVldWUiLCJsYXN0IiwibmV3X2xhc3QiLCJlbnF1ZXVlJDAiLCJjcmVhdGVfd2l0aF9yZWZlcmVuY2UiLCJwdXNoX3NpZ25hbF9yZXNvbHZlciIsInB1c2hfc2lnbmFsIiwicHVzaF9zaWduYWxfcmVzb2x2ZXIkMCIsInB1c2giLCJvbGRfcHVzaF9zaWduYWxfcmVzb2x2ZXIiLCJuZXdfcHVzaF9zaWduYWxfcmVzb2x2ZXIiLCJuZXdfd2FpdGVyIiwiYSIsInN0cmVhbSIsInMkMCIsIm9mX2x3dF9zZXEiLCJvZl9pdGVyIiwib2ZfYXJyYXkiLCJvZl9zdHJpbmciLCJub3RpZnlfcHVzaGVyIiwiaW5mbyIsIm9sZF93YWtlbmVyIiwid2FrZW5lciIsIndhaXRlciIsInNlbGZfMSIsIm5ld193YWtlbmVyIiwic2l6ZSIsImNyZWF0ZV9ib3VuZGVkIiwicHVzaF93YWtlbmVyIiwicHVzaF93YWl0ZXIiLCJ3YWtlbmVyX2NlbGwiLCJmZWVkIiwidGhyZWFkIiwicHVzaCQwIiwiY29uc3VtZSIsInBlZWtfcmVjIiwicGVlayIsIm5wZWVrX3JlYyIsIm5vZGUkMSIsIm5wZWVrIiwiZ2V0X3JlYyIsImdldF9leG5fcmVjIiwid3JhcF9leG4iLCJuZ2V0X3JlYyIsIm5nZXQiLCJnZXRfd2hpbGVfcmVjIiwidGVzdCIsImdldF93aGlsZSIsImdldF93aGlsZV9zX3JlYyIsImdldF93aGlsZV9zIiwibmV4dF9yZWMiLCJsYXN0X25ld19yZWMiLCJ4JDEiLCJsYXN0X25ldyIsInRvX2xpc3RfcmVjIiwidG9fbGlzdCIsInRvX3N0cmluZ19yZWMiLCJidWYiLCJ0b19zdHJpbmciLCJqdW5rIiwibmp1bmtfcmVjIiwibmp1bmsiLCJqdW5rX3doaWxlX3JlYyIsImp1bmtfd2hpbGUiLCJqdW5rX3doaWxlX3NfcmVjIiwianVua193aGlsZV9zIiwianVua19vbGQiLCJnZXRfYXZhaWxhYmxlIiwiZ2V0X2F2YWlsYWJsZV91cF90byIsIm1hcF9saXN0IiwicGVuZGluZ3MiLCJtYXBfbGlzdF9zIiwiZmxhdHRlbiIsImZvbGRfcmVjIiwiZm9sZCIsImZvbGRfc19yZWMiLCJmb2xkX3MiLCJpdGVyX3JlYyIsIml0ZXJfc19yZWMiLCJpdGVyX3BfcmVjIiwicmVzIiwiZmluZF9yZWMiLCJmaW5kIiwiZmluZF9zX3JlYyIsImZpbmRfcyIsImZpbmRfbWFwX3JlYyIsImZpbmRfbWFwIiwiZmluZF9tYXBfc19yZWMiLCJmaW5kX21hcF9zIiwiY29tYmluZSIsInQxIiwidDIiLCJuMSIsIm4yIiwiY3VycmVudF9zIiwiY29uY2F0Iiwic190b3AiLCJzdHJlYW1zIiwic3RyZWFtcyQwIiwibCQwIiwicGFyc2UiLCJoZXhkdW1wIiwibnVtIiwicG9zIiwicG9zJDEiLCJjaCIsInBvcyQyIiwibGlmdCIsImVycm9yIiwibWFwX2Vycm9yIiwibWFwX2VyciIsImdldF9leG4iLCJiaW5kX2Vycm9yIiwiYmluZF9sd3QiLCJiaW5kX3Jlc3VsdCIsImJpbmRfbHd0X2Vycm9yIiwiYmluZF9sd3RfZXJyIiwiYiIsInNldF9vbmNlIiwiYiQwIiwiYSQwIiwiaXRlcl9lcnJvciIsIm1hcCQwIiwibGluayIsImMyIiwicjIiLCJjMSIsInIxIiwiYyIsImlucyIsInQkMCIsInRzJDAiLCJ0JDEiLCJ0cyQxIiwidHMiLCJhZGQiLCJ1bmlvbiIsInRzMiIsInRzMSIsImZpbmRfbWluIiwibG9va3VwX21pbiIsImdldF9taW4iLCJyZW1vdmVfbWluIiwidGwiLCJ0YWlsX3JlY3Vyc2l2ZV9tYXAiLCJ0YWlsX3JlY3Vyc2l2ZV9tYXBpX3JldiIsImhkIiwiaXRlcmlfcyIsIml0ZXJpX3AiLCJpbm5lciIsImNvbGxlY3RfcmV2IiwibWFwX3AiLCJmaWx0ZXJfbWFwX3AiLCJjb2xsZWN0X29wdGlvbmFsX3JldiIsIm1hcGlfcyIsIm1hcGlfcCIsInJldl9tYXBfYXBwZW5kX3MiLCJyZXZfbWFwX3MiLCJyZXZfbWFwX3AiLCJsJDEiLCJmb2xkX3JpZ2h0X3MiLCJmb3JfYWxsX3MiLCJmb3JfYWxsX3AiLCJibCIsImV4aXN0c19zIiwiZXhpc3RzX3AiLCJvcHRpb25hbGl6ZSIsImZpbHRlcl9wIiwicGFydGl0aW9uX3MiLCJhY2MxIiwiYWNjMiIsInBhcnRpdGlvbl9wIiwiZ3JvdXAxIiwiZ3JvdXAyIiwibSIsInZhbGlkYXRlIiwic3RoJDEiLCJkaXNwb3NlIiwiY3JlYXRlX21lbWJlciIsInJlbGVhc2UiLCJ2YWxpZGF0ZV9hbmRfcmV0dXJuIiwidXNlIiwiY2xlYXJlZCIsImNsZWFyZWQkMCIsInByb21pc2UiLCJlbGVtZW50IiwiZWxlbWVudHMiLCJvbGRfY2xlYXJlZCIsIndhaXRfcXVldWVfbGVuZ3RoIiwiY3JlYXRlX2VtcHR5IiwicHV0IiwibXZhciIsInciLCJ3JDAiLCJ0YWtlX2F2YWlsYWJsZSIsInRha2UiLCJsb2NrIiwidW5sb2NrIiwid2l0aF9sb2NrIiwiaXNfbG9ja2VkIiwibXV0ZXgiLCJjdmFyIiwic2lnbmFsIiwiYXJnIiwiYnJvYWRjYXN0Iiwid2FrZW5lcnMiLCJicm9hZGNhc3RfZXhuIl0sInNvdXJjZXMiOlsiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9sd3QvbHd0X3NlcXVlbmNlLm1sIiwiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9sd3QvbHd0Lm1sIiwiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9sd3QvbHd0X3N3aXRjaC5tbCIsIi9Vc2Vycy9yb3N2YWxpLy5vcGFtLzQuMTQuMS9saWIvbHd0L2x3dF9zZXEubWwiLCIvVXNlcnMvcm9zdmFsaS8ub3BhbS80LjE0LjEvbGliL2x3dC9sd3Rfc3RyZWFtLm1sIiwiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9sd3QvbHd0X3Jlc3VsdC5tbCIsIi9Vc2Vycy9yb3N2YWxpLy5vcGFtLzQuMTQuMS9saWIvbHd0L2x3dF9wcXVldWUubWwiLCIvVXNlcnMvcm9zdmFsaS8ub3BhbS80LjE0LjEvbGliL2x3dC9sd3RfbGlzdC5tbCIsIi9Vc2Vycy9yb3N2YWxpLy5vcGFtLzQuMTQuMS9saWIvbHd0L2x3dF9wb29sLm1sIiwiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9sd3QvbHd0X212YXIubWwiLCIvVXNlcnMvcm9zdmFsaS8ub3BhbS80LjE0LjEvbGliL2x3dC9sd3RfbXV0ZXgubWwiLCIvVXNlcnMvcm9zdmFsaS8ub3BhbS80LjE0LjEvbGliL2x3dC9sd3RfY29uZGl0aW9uLm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7R0FLQTs7O0lBQUE7WUFxQklBLElBQUlDLE1BQ04sT0FETUEsUUFDUTtZQUVaQyxJQUFJRCxNQUFLRSxNQUFMRixVQUFLRSxlQUNXO1lBRXBCQyxPQUFPSDtJQUNUO1dBRFNBOzs7V0FBQUEsYUFBQUEsYUFBQUEsU0FBQUEsYUFBQUE7OztHQU1OO1lBTURJO0lBQ0YsSUFBUUM7OEJBQUFBLFNBQUFBLEtBQUFBO0lBQ1IsT0FEUUE7R0FDTDtZQUVEQyxNQUFNRCxLQUFBQSxTQUFBQSxLQUFBQSxTQUFBQSxjQUVPO1lBRWJFLFNBQVNGLEtBQU0sT0FBTkEsV0FBQUEsWUFBcUI7WUFFOUJHLE9BQU9IO0lBQ1QsSUFBYUksU0FESkosUUFDSUssT0FBQUQsUUFBS0U7SUFDaEI7UUFEV0QsU0FESkwsS0FHTCxPQUZjTTtLQUlpQixJQUpqQkMsUUFBQUQsYUFBTEUsU0FBQUgsU0FBQUEsT0FBQUcsUUFBS0YsTUFBQUM7O0dBTUg7WUFFYkUsTUFBTVosTUFBS0c7SUFDRixJQUFQTCxXQURTSyxLQUFBQSxRQUFMSDtJQUFLRyxZQUNUTDtJQURTSyxTQUNUTDtJQUdKLE9BSElBO0dBR0E7WUFFRmUsTUFBTWIsTUFBS0c7SUFDRixJQUFQTCxXQURTSyxRQUFBQSxLQUFMSDtJQUFLRyxZQUNUTDtJQURTSyxTQUNUTDtJQUdKLE9BSElBO0dBR0E7WUFFRmdCLE9BQU9YO0lBQ1QsR0F4QkVFLFNBdUJPRixNQUVQLE1BQUE7UUFFSUwsT0FKR0s7SUEzQ1BGLE9BK0NJSDtXQUFBQTtHQUdIO1lBRURpQixPQUFPWjtJQUNULEdBakNFRSxTQWdDT0YsTUFFUCxNQUFBO1FBRUlMLE9BSkdLO0lBcERQRixP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LEtBVkcwQixPQVlPO1NBREgxQixJQVhKMEI7S0FXUyxPQUFBLHlCQUFMMUI7SUFDa0I7d0JBSmpCLE9BUFR2SixPQU9lO0lBQ2pCLE9BQUE7R0FHNkI7WUFFN0JtTCxPQUFPRCxNQUFLRTtJQUNkO0tBQ21CO01BQUEsTUFBQSw2QkFGVkY7TUFFUCxNQUFBLHdCQUZZRTtLQUVaOzs7O2tDQUVBOzs7R0FBRTtZQUVGQyxVQUFVSCxNQUFLRTtJQUNqQjtpQkFBd0M5Z0IsR0FBRW9ULEdBQUssV0FBUHBULEdBQUVvVCxHQUFXO0lBQXRDLElBQVg0TixXQUFXLGtDQURISjtJQUVaLDhDQUZZQTtpQkFHR25MLFNBQVcsMEJBQVhBLFNBSEVxTCxLQUdxQztJQUR0RCxPQUFBLGlDQURJRTtHQUU0RDtZQUU5REMsY0FBY0wsTUFBSzNnQjtJQUNyQjtpQkFBd0NELEdBQUVvVCxHQUFLLFdBQVBwVCxHQUFFb1QsR0FBVztJQUF0QyxJQUFYNE4sV0FBVyxrQ0FEQ0o7SUFFaEIsOENBRmdCQTtpQkFHRG5MLFNBQVcsMEJBQVhBLFNBSE14VixLQUdxQztJQUQxRCxPQUFBLGlDQURJK2dCO0dBRWdFOzJCQTlCbEVyakIsUUFFQTJKLE1BY0F1WixRQU1BRSxXQUtBRTs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbmV4Y2VwdGlvbiBFbXB0eVxuXG50eXBlICdhIHQgPSB7XG4gIG11dGFibGUgcHJldiA6ICdhIHQ7XG4gIG11dGFibGUgbmV4dCA6ICdhIHQ7XG59XG5cbnR5cGUgJ2Egbm9kZSA9IHtcbiAgbm9kZV9wcmV2IDogJ2EgdDtcbiAgbm9kZV9uZXh0IDogJ2EgdDtcbiAgbXV0YWJsZSBub2RlX2RhdGEgOiAnYTtcbiAgbXV0YWJsZSBub2RlX2FjdGl2ZSA6IGJvb2w7XG59XG5cbmV4dGVybmFsIHNlcV9vZl9ub2RlIDogJ2Egbm9kZSAtPiAnYSB0ID0gXCIlaWRlbnRpdHlcIlxuZXh0ZXJuYWwgbm9kZV9vZl9zZXEgOiAnYSB0IC0+ICdhIG5vZGUgPSBcIiVpZGVudGl0eVwiXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgT3BlcmF0aW9ucyBvbiBub2RlcyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxubGV0IGdldCBub2RlID1cbiAgbm9kZS5ub2RlX2RhdGFcblxubGV0IHNldCBub2RlIGRhdGEgPVxuICBub2RlLm5vZGVfZGF0YSA8LSBkYXRhXG5cbmxldCByZW1vdmUgbm9kZSA9XG4gIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlbiBiZWdpblxuICAgIG5vZGUubm9kZV9hY3RpdmUgPC0gZmFsc2U7XG4gICAgbGV0IHNlcSA9IHNlcV9vZl9ub2RlIG5vZGUgaW5cbiAgICBzZXEucHJldi5uZXh0IDwtIHNlcS5uZXh0O1xuICAgIHNlcS5uZXh0LnByZXYgPC0gc2VxLnByZXZcbiAgZW5kXG5cbigqICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLStcbiAgIHwgT3BlcmF0aW9ucyBvbiBzZXF1ZW5jZXMgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHxcbiAgICstLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSsgKilcblxubGV0IGNyZWF0ZSAoKSA9XG4gIGxldCByZWMgc2VxID0geyBwcmV2ID0gc2VxOyBuZXh0ID0gc2VxIH0gaW5cbiAgc2VxXG5cbmxldCBjbGVhciBzZXEgPVxuICBzZXEucHJldiA8LSBzZXE7XG4gIHNlcS5uZXh0IDwtIHNlcVxuXG5sZXQgaXNfZW1wdHkgc2VxID0gc2VxLm5leHQgPT0gc2VxXG5cbmxldCBsZW5ndGggc2VxID1cbiAgbGV0IHJlYyBsb29wIGN1cnIgbGVuID1cbiAgICBpZiBjdXJyID09IHNlcSB0aGVuXG4gICAgICBsZW5cbiAgICBlbHNlXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW4gbG9vcCBub2RlLm5vZGVfbmV4dCAobGVuICsgMSlcbiAgaW5cbiAgbG9vcCBzZXEubmV4dCAwXG5cbmxldCBhZGRfbCBkYXRhIHNlcSA9XG4gIGxldCBub2RlID0geyBub2RlX3ByZXYgPSBzZXE7IG5vZGVfbmV4dCA9IHNlcS5uZXh0OyBub2RlX2RhdGEgPSBkYXRhOyBub2RlX2FjdGl2ZSA9IHRydWUgfSBpblxuICBzZXEubmV4dC5wcmV2IDwtIHNlcV9vZl9ub2RlIG5vZGU7XG4gIHNlcS5uZXh0IDwtIHNlcV9vZl9ub2RlIG5vZGU7XG4gIG5vZGVcblxubGV0IGFkZF9yIGRhdGEgc2VxID1cbiAgbGV0IG5vZGUgPSB7IG5vZGVfcHJldiA9IHNlcS5wcmV2OyBub2RlX25leHQgPSBzZXE7IG5vZGVfZGF0YSA9IGRhdGE7IG5vZGVfYWN0aXZlID0gdHJ1ZSB9IGluXG4gIHNlcS5wcmV2Lm5leHQgPC0gc2VxX29mX25vZGUgbm9kZTtcbiAgc2VxLnByZXYgPC0gc2VxX29mX25vZGUgbm9kZTtcbiAgbm9kZVxuXG5sZXQgdGFrZV9sIHNlcSA9XG4gIGlmIGlzX2VtcHR5IHNlcSB0aGVuXG4gICAgcmFpc2UgRW1wdHlcbiAgZWxzZSBiZWdpblxuICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgc2VxLm5leHQgaW5cbiAgICByZW1vdmUgbm9kZTtcbiAgICBub2RlLm5vZGVfZGF0YVxuICBlbmRcblxubGV0IHRha2VfciBzZXEgPVxuICBpZiBpc19lbXB0eSBzZXEgdGhlblxuICAgIHJhaXNlIEVtcHR5XG4gIGVsc2UgYmVnaW5cbiAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIHNlcS5wcmV2IGluXG4gICAgcmVtb3ZlIG5vZGU7XG4gICAgbm9kZS5ub2RlX2RhdGFcbiAgZW5kXG5cbmxldCB0YWtlX29wdF9sIHNlcSA9XG4gIGlmIGlzX2VtcHR5IHNlcSB0aGVuXG4gICAgTm9uZVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBzZXEubmV4dCBpblxuICAgIHJlbW92ZSBub2RlO1xuICAgIFNvbWUgbm9kZS5ub2RlX2RhdGFcbiAgZW5kXG5cbmxldCB0YWtlX29wdF9yIHNlcSA9XG4gIGlmIGlzX2VtcHR5IHNlcSB0aGVuXG4gICAgTm9uZVxuICBlbHNlIGJlZ2luXG4gICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBzZXEucHJldiBpblxuICAgIHJlbW92ZSBub2RlO1xuICAgIFNvbWUgbm9kZS5ub2RlX2RhdGFcbiAgZW5kXG5cbmxldCB0cmFuc2Zlcl9sIHMxIHMyID1cbiAgczIubmV4dC5wcmV2IDwtIHMxLnByZXY7XG4gIHMxLnByZXYubmV4dCA8LSBzMi5uZXh0O1xuICBzMi5uZXh0IDwtIHMxLm5leHQ7XG4gIHMxLm5leHQucHJldiA8LSBzMjtcbiAgczEucHJldiA8LSBzMTtcbiAgczEubmV4dCA8LSBzMVxuXG5sZXQgdHJhbnNmZXJfciBzMSBzMiA9XG4gIHMyLnByZXYubmV4dCA8LSBzMS5uZXh0O1xuICBzMS5uZXh0LnByZXYgPC0gczIucHJldjtcbiAgczIucHJldiA8LSBzMS5wcmV2O1xuICBzMS5wcmV2Lm5leHQgPC0gczI7XG4gIHMxLnByZXYgPC0gczE7XG4gIHMxLm5leHQgPC0gczFcblxubGV0IGl0ZXJfbCBmIHNlcSA9XG4gIGxldCByZWMgbG9vcCBjdXJyID1cbiAgICBpZiBjdXJyICE9IHNlcSB0aGVuIGJlZ2luXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW5cbiAgICAgIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlbiBmIG5vZGUubm9kZV9kYXRhO1xuICAgICAgbG9vcCBub2RlLm5vZGVfbmV4dFxuICAgIGVuZFxuICBpblxuICBsb29wIHNlcS5uZXh0XG5cbmxldCBpdGVyX3IgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlbiBiZWdpblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gZiBub2RlLm5vZGVfZGF0YTtcbiAgICAgIGxvb3Agbm9kZS5ub2RlX3ByZXZcbiAgICBlbmRcbiAgaW5cbiAgbG9vcCBzZXEucHJldlxuXG5sZXQgaXRlcl9ub2RlX2wgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlbiBiZWdpblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW4gZiBub2RlO1xuICAgICAgbG9vcCBub2RlLm5vZGVfbmV4dFxuICAgIGVuZFxuICBpblxuICBsb29wIHNlcS5uZXh0XG5cbmxldCBpdGVyX25vZGVfciBmIHNlcSA9XG4gIGxldCByZWMgbG9vcCBjdXJyID1cbiAgICBpZiBjdXJyICE9IHNlcSB0aGVuIGJlZ2luXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW5cbiAgICAgIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlbiBmIG5vZGU7XG4gICAgICBsb29wIG5vZGUubm9kZV9wcmV2XG4gICAgZW5kXG4gIGluXG4gIGxvb3Agc2VxLnByZXZcblxubGV0IGZvbGRfbCBmIHNlcSBhY2MgPVxuICBsZXQgcmVjIGxvb3AgY3VyciBhY2MgPVxuICAgIGlmIGN1cnIgPT0gc2VxIHRoZW5cbiAgICAgIGFjY1xuICAgIGVsc2VcbiAgICAgIGxldCBub2RlID0gbm9kZV9vZl9zZXEgY3VyciBpblxuICAgICAgaWYgbm9kZS5ub2RlX2FjdGl2ZSB0aGVuXG4gICAgICAgIGxvb3Agbm9kZS5ub2RlX25leHQgKGYgbm9kZS5ub2RlX2RhdGEgYWNjKVxuICAgICAgZWxzZVxuICAgICAgICBsb29wIG5vZGUubm9kZV9uZXh0IGFjY1xuICBpblxuICBsb29wIHNlcS5uZXh0IGFjY1xuXG5sZXQgZm9sZF9yIGYgc2VxIGFjYyA9XG4gIGxldCByZWMgbG9vcCBjdXJyIGFjYyA9XG4gICAgaWYgY3VyciA9PSBzZXEgdGhlblxuICAgICAgYWNjXG4gICAgZWxzZVxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW5cbiAgICAgICAgbG9vcCBub2RlLm5vZGVfcHJldiAoZiBub2RlLm5vZGVfZGF0YSBhY2MpXG4gICAgICBlbHNlXG4gICAgICAgIGxvb3Agbm9kZS5ub2RlX3ByZXYgYWNjXG4gIGluXG4gIGxvb3Agc2VxLnByZXYgYWNjXG5cbmxldCBmaW5kX25vZGVfbCBmIHNlcSA9XG4gIGxldCByZWMgbG9vcCBjdXJyID1cbiAgICBpZiBjdXJyICE9IHNlcSB0aGVuXG4gICAgICBsZXQgbm9kZSA9IG5vZGVfb2Zfc2VxIGN1cnIgaW5cbiAgICAgIGlmIG5vZGUubm9kZV9hY3RpdmUgdGhlblxuICAgICAgICBpZiBmIG5vZGUubm9kZV9kYXRhIHRoZW5cbiAgICAgICAgICBub2RlXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBsb29wIG5vZGUubm9kZV9uZXh0XG4gICAgICBlbHNlXG4gICAgICAgIGxvb3Agbm9kZS5ub2RlX25leHRcbiAgICBlbHNlXG4gICAgICByYWlzZSBOb3RfZm91bmRcbiAgaW5cbiAgbG9vcCBzZXEubmV4dFxuXG5sZXQgZmluZF9ub2RlX3IgZiBzZXEgPVxuICBsZXQgcmVjIGxvb3AgY3VyciA9XG4gICAgaWYgY3VyciAhPSBzZXEgdGhlblxuICAgICAgbGV0IG5vZGUgPSBub2RlX29mX3NlcSBjdXJyIGluXG4gICAgICBpZiBub2RlLm5vZGVfYWN0aXZlIHRoZW5cbiAgICAgICAgaWYgZiBub2RlLm5vZGVfZGF0YSB0aGVuXG4gICAgICAgICAgbm9kZVxuICAgICAgICBlbHNlXG4gICAgICAgICAgbG9vcCBub2RlLm5vZGVfcHJldlxuICAgICAgZWxzZVxuICAgICAgICBsb29wIG5vZGUubm9kZV9wcmV2XG4gICAgZWxzZVxuICAgICAgcmFpc2UgTm90X2ZvdW5kXG4gIGluXG4gIGxvb3Agc2VxLnByZXZcblxubGV0IGZpbmRfbm9kZV9vcHRfbCBmIHNlcSA9XG4gIHRyeSBTb21lIChmaW5kX25vZGVfbCBmIHNlcSkgd2l0aCBOb3RfZm91bmQgLT4gTm9uZVxuXG5sZXQgZmluZF9ub2RlX29wdF9yIGYgc2VxID1cbiAgdHJ5IFNvbWUgKGZpbmRfbm9kZV9yIGYgc2VxKSB3aXRoIE5vdF9mb3VuZCAtPiBOb25lXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbigqIFJlYWRpbmcgZ3VpZGVcblxuICAgV2VsY29tZSB0byB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIEx3dCBjb3JlISBUaGlzIGlzIGEgYmlnIGZpbGUsIGJ1dCB3ZVxuICAgaG9wZSB0aGF0IHJlYWRpbmcgaXQgKHBhcnRzIGF0IGEgdGltZSEpIHdpbGwgbm90IGJlIHNjYXJ5IDopIEhlcmUgaXMgd2h5OlxuXG5cbiAgICogU2VjdGlvbmluZ1xuXG4gICBUaGUgY29kZSBpcyBicm9rZW4gdXAgaW50byBzZWN0aW9ucywgZWFjaCBvbmUgb2Ygd2hpY2ggaXMgYW4gaW50ZXJuYWwgbW9kdWxlLlxuICAgTW9zdCBvZiB0aGUgbW9kdWxlcyBoYXZlIGEgc2lnbmF0dXJlLCB3aGljaCBzZXJ2ZXMgYXMgYSBuZWF0IHRhYmxlIG9mXG4gICBjb250ZW50cy5cblxuICAgSXQgaXMgcmVjb21tZW5kZWQgdGhhdCB5b3UgcmVhZCB0aGlzIGZpbGUgd2l0aCBjb2RlIGZvbGRpbmcgZW5hYmxlZC4gSWYgeW91XG4gICBmb2xkIGFsbCB0aGUgbW9kdWxlcywgeW91IGNhbiB2aXN1YWxpemUgdGhlIGxvZ2ljYWwgc3RydWN0dXJlIG9mIEx3dCBxdWl0ZVxuICAgZWFzaWx5LiBZb3UgY2FuIHRoZW4gZXhwYW5kIG1vZHVsZXMgYXMgbmVlZGVkLCBkZXBlbmRpbmcgb24gd2hhdCBwYXJ0IG9mIHRoZVxuICAgaW1wbGVtZW50YXRpb24geW91IGFyZSBpbnRlcmVzdGVkIGluLiBXaXRob3V0IGNvZGUgZm9sZGluZywgeW91IGZhY2UgYW5cbiAgIGludGltaWRhdGluZyB3YWxsIG9mIGNvZGUgOiggWW91IGNhbiBzdGlsbCB2aXN1YWxseSBwYXJzZSB0aGUgZmlsZSwgaG93ZXZlcixcbiAgIGJlY2F1c2UgdGhlcmUgYXJlIHBsZW50eSBvZiBibGFuayBsaW5lcyB0byBoZWxwIHNlY3Rpb24gdGhpbmdzIG9mZi4gWW91IGNhblxuICAgYWxzbyB2aWV3IHRoaXMgZmlsZSBmb2xkZWQgb25saW5lOlxuXG4gICAgIGh0dHBzOi8vZ2lzdC5naXRodWIuY29tL2FhbnRyb24vOWZhYjBiZGVhZDk4YTYwZmNjZjA2ZTAxODkxODY4NjNcbiAgICAgaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vYWFudHJvbi85N2I1ODUyMGQ1YmI0ODU4Y2NhYzZmNTQ3MDBhMjRkN1xuXG4gICBUaGUgc2lnbmF0dXJlcyBhcmUgdW51c3VhbDogYmlnIGNvbW1lbnRzIGFyZSBhYnNlbnQuIFRoZXkgYXJlIG1vdmVkIGludG8gdGhlXG4gICBtb2R1bGVzLCBzbyB0aGF0IHRoZXkgYXJlIGhpZGRlbiBieSBjb2RlIGZvbGRpbmcgd2hlbiB5b3UgKHRoZSByZWFkZXIhKSBhcmVcbiAgIG5vdCBpbnRlcmVzdGVkIGluIHRob3NlIG1vZHVsZXMuXG5cblxuICAgKiBEb2N1bWVudGF0aW9uXG5cbiAgIFRoZSBkb2N1bWVudGF0aW9uIGJlZ2lucyB3aXRoIGFuIG92ZXJ2aWV3IG9mIG1ham9yIGNvbmNlcHRzIGFuZCBjb21wb25lbnRzLlxuICAgVGhpcyBvdmVydmlldyBwdXRzIGV2ZXJ5dGhpbmcgaW50byBjb250ZXh0LiBZb3UgZG9uJ3QgaGF2ZSB0byByZWFkIHRoZSB3aG9sZVxuICAgdGhpbmcuIFRoZSBvdmVydmlldyBiZWdpbnMgd2l0aCBiYXNpYyBjb25jZXB0cywgbW92ZXMgb24gdG8gYWR2YW5jZWQgb25lcyxcbiAgIGFuZCB0aGVuIGdldHMgaW50byB0aGUgdHJ1bHkgZXNvdGVyaWMuIFlvdSBjYW4gcmVhZCBhYm91dCBlYWNoIGNvbmNlcHQgb24gYW5cbiAgIGFzLW5lZWRlZCBiYXNpcy4gSG93ZXZlciwgb25jZSB5b3UgaGF2ZSByZWFkIHRoZSB3aG9sZSBvdmVydmlldywgeW91IHdpbGwgYmVcbiAgIGF3YXJlIG9mICpldmVyeXRoaW5nKiB0aGF0IGlzIG5lZWRlZCB0byB1bmRlcnN0YW5kLCBhbmQgd29yayB3aXRoLCB0aGUgY29yZVxuICAgb2YgTHd0LlxuXG4gICBMaXR0ZXJlZCBpbiB0aGUgY29kZSBhcmUgYWRkaXRpb25hbCBjb21tZW50cywgdGhhdCBnbyBpbi1kZXB0aCBvbiB2YXJpb3VzXG4gICBsb2NhbCBpbXBsZW1lbnRhdGlvbiBkZXRhaWxzLCBvcHBvcnR1bml0aWVzLCByZWdyZXRzLCBhbmQgdGhlIGxpa2UuXG5cbiAgIFRoZSBzZWN0aW9ucyAobW9kdWxlcykgb2YgdGhlIGNvZGUgY29ycmVzcG9uZCBjbG9zZWx5IHRvIHNlY3Rpb25zIG9mIHRoZVxuICAgb3ZlcnZpZXcuXG5cblxuICAgKiBXaGl0ZXNwYWNlXG5cbiAgIFRoZSB0b3RhbCBsaW5lIGNvdW50IG9mIHRoaXMgZmlsZSBtYXkgc2VlbSBmcmlnaHRlbmluZywgYnV0IG9uZSB0aGlyZCBvZiBpdFxuICAgaXMgd2hpdGVzcGFjZSBhbmQgY29tbWVudHMsIGJvdGggdGhlcmUgdG8gaGVscCB5b3UgcmVhZCB0aGUgcmVtYWluaW5nIHR3b1xuICAgdGhpcmRzIVxuXG4gICBBbHNvLCB3aXRoaW4gdGhvc2UgdHdvIHRoaXJkcywgdGhlcmUgYXJlIGxhcmdlIGdyb3VwcyBvZiBmdW5jdGlvbnMgdGhhdCBhcmVcbiAgIHJlcGV0aXRpdmUgYW5kIGZvcm11bGFpYywgc28gdGhlcmUgaXMgbXVjaCBsZXNzIGNvbmNlcHR1YWxseS11bmlxdWUgY29kZSBpblxuICAgTHd0IHRoYW4geW91IG1pZ2h0IHRoaW5rIGF0IGZpcnN0LlxuXG5cbiAgICogUGxlYXNlIGVkaXQgdGhlIGNvZGUgYW5kIHRoZSBkb2NzIVxuXG4gICBUaGlzIGNvZGUgaXMgbWVhbnQgdG8gYmUgcmVhZGFibGUsIGFuZCB0byBiZSBlZGl0ZWQuIElmIHlvdSBhcmUgcmVhZGluZ1xuICAgc29tZXRoaW5nLCBhbmQgdGhpbmsgdGhlcmUgaXMgYSBiZXR0ZXIgd2F5IHRvIGV4cHJlc3MgaXQsIHBsZWFzZSBnbyBhaGVhZCBhbmRcbiAgIG9wZW4gYSBwdWxsIHJlcXVlc3QgdG8gdGhlIEx3dCByZXBvc2l0b3J5IGF0XG5cbiAgICAgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0XG5cbiAgIEV2ZW4gaWYgeW91ciBwdWxsIHJlcXVlc3Qgc29tZWhvdyBkb2Vzbid0IGdldCBtZXJnZWQsIHlvdSB3aWxsIGhhdmUgZWR1Y2F0ZWRcbiAgIHRoZSBtYWludGFpbmVycywgbm90IHRvIG1lbnRpb24gb3RoZXIgY29udHJpYnV0b3JzLCBhbmQgdXNlcnMuIFRoaXMgaXMgdHJ1ZVxuICAgZXZlbiBpZiB0aGUgY2hhbmdlIGlzIHRyaXZpYWwgLS0gc29tZXRpbWVzLCBtYWludGFpbmVycyBqdXN0IG5lZWQgdG8gYmVcbiAgIGVkdWNhdGVkIG11bHRpcGxlIHRpbWVzIGJlZm9yZSB0aGV5IHNlZSB0aGUgd2lzZG9tIG9mIGl0IDovXG5cbiAgIExpa2V3aXNlLCBpZiB5b3Ugd291bGQgbGlrZSB0byBtYWtlIGEgY29kZSBjb250cmlidXRpb24gdG8gdGhlIEx3dCBjb3JlLCBpdFxuICAgaXMgcXVpdGUgd2VsY29tZSwgYW5kIHdlIGhvcGUgdGhhdCB0aGlzIGNvZGUgaXMgcmVhZGFibGUgZW5vdWdoIGZvciB5b3UgdG8gYmVcbiAgIGFibGUgdG8gbWFrZSBpdCFcblxuXG4gICBFbmpveSEgKilcblxuXG5cbigqIE92ZXJ2aWV3XG5cbiAgIEluIHRoaXMgZmlsZSwgdGhlcmUgaXMgYSBcIm1vZGVsXCIgZnVuY3Rpb24gLS0gW0x3dC5iaW5kXSAtLSB3aGljaCBwdWxsc1xuICAgdG9nZXRoZXIgbWFueSAodGhvdWdoIG5vdCBhbGwpIG9mIHRoZSBjb25jZXB0cyBhbmQgaGVscGVycyBkaXNjdXNzZWQgaW4gdGhpc1xuICAgb3ZlcnZpZXcuIFRvIGZpbmQgaXQsIHNlYXJjaCBmb3IgXCJsZXQgYmluZCxcIiBhbmQgeW91IGNhbiBleGFtaW5lIGl0IHdoaWxlXG4gICByZWFkaW5nIHRoZSBvdmVydmlldy4gVGhlIGF1dGhvcnMgb2YgdGhpcyBmaWxlIGludGVuZCB0byBwdXQgZXh0cmEgZWZmb3J0XG4gICBpbnRvIHdyaXRpbmcgbmljZSBjb21tZW50cyBpbnNpZGUgW0x3dC5iaW5kXSA6KVxuXG5cbiAgIDAuIE1haW4gbWVjaGFuaXNtIGFuZCB0d28gYXNwZWN0c1xuXG4gICBUaGUgTHd0IGludGVyZmFjZSAoW2x3dC5tbGldKSBwcm92aWRlcyBvbmUgbWFpbiBtZWNoYW5pc20sIHByb21pc2VzLCBhbmQgdHdvXG4gICBcImFzcGVjdHMsXCIgd2hpY2ggYXJlICpub3QqIG5lY2Vzc2FyeSB0byB1bmRlcnN0YW5kIHRoZSBtYWluIG1lY2hhbmlzbVxuICAgcHJvbWlzZXMsIGJ1dCB0aGV5IGFyZSBzdGlsbCB0aGVyZTpcblxuICAgLSBwcm9taXNlIGNhbmNlbGxhdGlvblxuICAgLSBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2VcblxuICAgSWYgeW91IGFyZSBub3QgaW50ZXJlc3RlZCBpbiBjYW5jZWxsYXRpb24gb3Igc3RvcmFnZSwgeW91IGNhbiBpZ25vcmUgdGhlc2VcbiAgIHR3byBjb21wbGljYXRpb25zLCBhbmQgc3RpbGwgZ2V0IGEgcHJldHR5IGdvb2QgdW5kZXJzdGFuZGluZyBvZiB0aGUgY29kZS4gVG9cbiAgIGhlbHAsIGFsbCBpZGVudGlmaWVycyByZWxhdGVkIHRvIGNhbmNlbGxhdGlvbiBjb250YWluIHRoZSBzdHJpbmcgXCJjYW5jZWwsXCJcbiAgIGFuZCBhbGwgaWRlbnRpZmllcnMgcmVsYXRlZCB0byBzdG9yYWdlIGNvbnRhaW4gXCJzdG9yYWdlLlwiXG5cblxuICAgMS4gUHJvbWlzZXNcblxuICAgQSBwcm9taXNlIGlzIGEgY2VsbCB0aGF0IGNhbiBiZSBpbiBvbmUgb2YgdHdvIHN0YXRlczogXCJyZXNvbHZlZFwiIG9yXG4gICBcInBlbmRpbmcuXCJcblxuICAgLSBSZXNvbHZlZCBwcm9taXNlc1xuXG4gICAgIEEgcmVzb2x2ZWQgcHJvbWlzZSBpcyBlaXRoZXIgXCJmdWxmaWxsZWRcIiB3aXRoIGEgdmFsdWUsIG9yIFwicmVqZWN0ZWRcIiB3aXRoXG4gICAgIGFuIGV4Y2VwdGlvbi4gVGhlIHN0YXRlIG9mIGEgcmVzb2x2ZWQgcHJvbWlzZSB3aWxsIG5ldmVyIGNoYW5nZSBhZ2FpbjogYVxuICAgICByZXNvbHZlZCBwcm9taXNlIGlzIGltbXV0YWJsZS4gQSByZXNvbHZlZCBwcm9taXNlIGlzIGJhc2ljYWxseSBlcXVpdmFsZW50XG4gICAgIHRvIGFuIFsoJ2EsIGV4bikgU3RkbGliLnJlc3VsdF0uIFJlc29sdmVkIHByb21pc2VzIGFyZSBwcm9kdWNlZCBpbiB0d29cbiAgICAgd2F5czpcblxuICAgICAtIFtMd3QucmV0dXJuXSwgW0x3dC5mYWlsXSwgYW5kIHJlbGF0ZWQgZnVuY3Rpb25zLCBwcm9kdWNlIFwidHJpdmlhbFwiXG4gICAgICAgcHJvbWlzZXMgdGhhdCBhcmUgcmVzb2x2ZWQgZnJvbSB0aGUgc3RhcnQuXG4gICAgIC0gVGhlIG90aGVyIHdheSBpcyB0byByZXNvbHZlIGEgcHJvbWlzZSB0aGF0IHN0YXJ0ZWQgb3V0IHBlbmRpbmcuXG5cbiAgICAgTm90ZSB0aGF0IHJlamVjdGVkIHByb21pc2VzIGhhdmUgbm90aGluZyB0byBkbyB3aXRoIHVuaGFuZGxlZCBleGNlcHRpb25zLlxuXG4gICAtIFBlbmRpbmcgcHJvbWlzZXNcblxuICAgICAuLi5hcmUgdGhvc2UgdGhhdCBtYXkgYmVjb21lIHJlc29sdmVkIGluIHRoZSBmdXR1cmUuIEVhY2ggcGVuZGluZyBwcm9taXNlXG4gICAgIGNhcnJpZXMgYSBsaXN0IG9mIGNhbGxiYWNrcy4gVGhlc2UgY2FsbGJhY2tzIGFyZSBhZGRlZCBieSBmdW5jdGlvbnMgbGlrZVxuICAgICBbTHd0LmJpbmRdLCBhbmQgY2FsbGVkIGJ5IEx3dCBpZi93aGVuIHRoZSBwcm9taXNlIGlzIHJlc29sdmVkLiBUaGVzZVxuICAgICBjYWxsYmFja3MgdHlwaWNhbGx5IGVuZCB1cCByZXNvbHZpbmcgYWRkaXRpb25hbCBwcm9taXNlczsgc2VlIHNlY3Rpb25cbiAgICAgXCJSZXNvbHV0aW9uIGxvb3BcIiBiZWxvdy5cblxuICAgICBQZW5kaW5nIHByb21pc2VzIGFyZSBwcm9kdWNlZCBpbiB0aHJlZSB3YXlzLCBhY2NvcmRpbmcgdG8gaG93IHRoZXkgY2FuIGJlXG4gICAgIHJlc29sdmVkOlxuXG4gICAgIC0gSW5pdGlhbCBwcm9taXNlc1xuXG4gICAgICAgLi4uYXJlIGNyZWF0ZWQgYnkgW0x3dC53YWl0XSBhbmQgW0x3dC50YXNrXS4gVGhlIHVzZXIgb2YgTHd0IHJlc29sdmVzXG4gICAgICAgdGhlc2UgcHJvbWlzZXMgbWFudWFsbHksIHRocm91Z2ggdGhlIHJlc29sdmVycyByZXR1cm5lZCBieSB0aG9zZVxuICAgICAgIGZ1bmN0aW9ucy5cblxuICAgICAtIFNlcXVlbnRpYWwgY29tcG9zaXRpb25cblxuICAgICAgIEZvciBleGFtcGxlLCBbTHd0LmJpbmRdLiBUaGVzZSBwcm9taXNlcyBvbmx5IGFyZSBvbmx5IHJlc29sdmVkIHdoZW4gdGhlXG4gICAgICAgcHJlY2VkaW5nIHNlcXVlbmNlIG9mIHByb21pc2VzIHJlc29sdmVzLiBUaGUgdXNlciBjYW5ub3QgcmVzb2x2ZSB0aGVzZVxuICAgICAgIHByb21pc2VzIGRpcmVjdGx5IChidXQgc2VlIHRoZSBzZWN0aW9uIG9uIGNhbmNlbGxhdGlvbiBiZWxvdykuXG5cbiAgICAgLSBDb25jdXJyZW50IGNvbXBvc2l0aW9uXG5cbiAgICAgICBGb3IgZXhhbXBsZSwgW0x3dC5qb2luXSBvciBbTHd0LmNob29zZV0uIFRoZXNlIHByb21pc2VzIGFyZSBvbmx5IHJlc29sdmVkXG4gICAgICAgd2hlbiBhbGwgb3Igb25lIG9mIGEgc2V0IG9mIFwicHJlY2VkaW5nXCIgcHJvbWlzZXMgcmVzb2x2ZS4gVGhlIHVzZXIgY2Fubm90XG4gICAgICAgcmVzb2x2ZSB0aGVzZSBwcm9taXNlcyBkaXJlY3RseSAoYnV0IHNlZSB0aGUgc2VjdGlvbiBvbiBjYW5jZWxsYXRpb25cbiAgICAgICBiZWxvdykuXG5cblxuICAgMi4gUmVzb2x2ZXJzXG5cbiAgIFJlc29sdmVycyBhcmUgZ2l2ZW4gdG8gdGhlIHVzZXIgYnkgW0x3dC53YWl0XSBhbmQgW0x3dC50YXNrXSwgYW5kIGNhbiBiZSB1c2VkXG4gICBieSB0aGUgdXNlciB0byByZXNvbHZlIHRoZSBjb3JyZXNwb25kaW5nIHByb21pc2VzLiBOb3RlIHRoYXQgdGhpcyBtZWFucyB0aGVcbiAgIHVzZXIgb25seSBldmVyIGdldHMgcmVzb2x2ZXJzIGZvciBpbml0aWFsIHByb21pc2VzLlxuXG4gICBJbnRlcm5hbGx5LCByZXNvbHZlcnMgYXJlIHRoZSBleGFjdCBzYW1lIG9iamVjdHMgYXMgdGhlIHByb21pc2VzIHRoZXlcbiAgIHJlc29sdmUsIGV2ZW4gdGhvdWdoIHRoZSByZXNvbHZlciBpcyBleHBvc2VkIGFzIGEgcmVmZXJlbmNlIG9mIGEgZGlmZmVyZW50XG4gICB0eXBlIGJ5IFtsd3QubWxpXS4gRm9yIGRldGFpbHMgb24gd2h5LCBzZWUgc2VjdGlvbiBcIlR5cGUgc3lzdGVtIGFidXNlXCIgYmVsb3cuXG5cblxuICAgMy4gQ2FsbGJhY2tzXG5cbiAgIC4uLmFyZSBhdHRhY2hlZCBieSBMd3QgdG8gcGVuZGluZyBwcm9taXNlcywgYW5kIGFyZSBydW4gYnkgTHd0IGlmL3doZW4gdGhvc2VcbiAgIHByb21pc2VzIGFyZSByZXNvbHZlZC4gVGhlc2UgY2FsbGJhY2tzIGFyZSBub3QgZGlyZWN0bHkgZXhwb3NlZCB0aHJvdWdoXG4gICBbbHd0Lm1saV0gLS0gdGhleSBhcmUgYSBsb3ctbGV2ZWwgbWVjaGFuaXNtLiBGb3IgZXhhbXBsZSwgdG8gaW1wbGVtZW50XG4gICBbTHd0LmJpbmQgcCBmXSwgTHd0IGF0dGFjaGVzIGEgY2FsbGJhY2sgdG8gW3BdIHRoYXQgZG9lcyBzb21lIGludGVybmFsIEx3dFxuICAgYm9vay1rZWVwaW5nLCBhbmQgdGhlbiBjYWxscyBbZl0gaWYgW3BdIGlzIGZ1bGZpbGxlZCwgYW5kIGRvZXMgc29tZXRoaW5nIGVsc2VcbiAgIGlmIFtwXSBpcyByZWplY3RlZC5cblxuICAgQ2FsbGJhY2tzIGNvbWUgaW4gdHdvIGZsYXZvcnM6IHJlZ3VsYXIgY2FsbGJhY2tzIGFuZCBjYW5jZWwgY2FsbGJhY2tzLiBUaGVcbiAgIG9ubHkgbWF0ZXJpYWwgZGlmZmVyZW5jZXMgYmV0d2VlbiB0aGVtIGFyZSB0aGF0OlxuXG4gICAtIHJlZ3VsYXIgY2FsbGJhY2tzIGFyZSBhbHdheXMgY2FsbGVkIHdoZW4gYSBwcm9taXNlIGlzIHJlc29sdmVkLCBidXQgY2FuY2VsXG4gICAgIGNhbGxiYWNrcyBhcmUgY2FsbGVkLCBpbiBhZGRpdGlvbiwgb25seSBpZiB0aGUgcHJvbWlzZSBpcyBjYW5jZWxlZCwgYW5kXG4gICAtIGFsbCBjYW5jZWwgY2FsbGJhY2tzIG9mIGEgcHJvbWlzZSBhcmUgY2FsbGVkIGJlZm9yZSBhbnkgcmVndWxhciBjYWxsYmFja1xuICAgICBpcyBjYWxsZWQuXG5cbiAgIENhbmNlbGxhdGlvbiBpcyBhIHNwZWNpYWwgY2FzZSBvZiByZXNvbHV0aW9uLCBpbiBwYXJ0aWN1bGFyLCBhIHNwZWNpYWwgY2FzZVxuICAgb2YgcmVqZWN0aW9uLCBidXQgc2VlIHRoZSBzZWN0aW9uIG9uIGNhbmNlbGxhdGlvbiBsYXRlciBiZWxvdy5cblxuXG4gICA0LiBSZXNvbHV0aW9uIGxvb3BcblxuICAgUmVzb2x2aW5nIGEgcGVuZGluZyBwcm9taXNlIHRyaWdnZXJzIGl0cyBjYWxsYmFja3MsIGFuZCB0aG9zZSBtaWdodCByZXNvbHZlXG4gICBtb3JlIHBlbmRpbmcgcHJvbWlzZXMsIHRyaWdnZXJpbmcgbW9yZSBjYWxsYmFja3MsIGV0Yy4gVGhpcyBiZWhhdmlvciBpcyB0aGVcbiAgICpyZXNvbHV0aW9uIGxvb3AqLiBMd3QgaGFzIHNvbWUgbWFjaGluZXJ5IHRvIGF2b2lkIHN0YWNrIG92ZXJmbG93IGFuZCBvdGhlclxuICAgdW5mb3J0dW5hdGUgc2l0dWF0aW9ucyBkdXJpbmcgdGhpcyBsb29wLlxuXG4gICBUaGlzIGNoYWluaW5nIG9mIHByb21pc2UgcmVzb2x1dGlvbnMgdGhyb3VnaCBjYWxsYmFja3MgY2FuIGJlIHNlZW4gYXMgYSBraW5kXG4gICBvZiBwcm9taXNlIGRlcGVuZGVuY3kgZ3JhcGgsIGluIHdoaWNoIHRoZSBub2RlcyBhcmUgcGVuZGluZyBwcm9taXNlcywgYW5kIHRoZVxuICAgZWRnZXMgYXJlIGNhbGxiYWNrcy4gRHVyaW5nIHRoZSByZXNvbHV0aW9uIGxvb3AsIEx3dCBzdGFydHMgYXQgc29tZSBpbml0aWFsXG4gICBwcm9taXNlIHRoYXQgaXMgZ2V0dGluZyByZXNvbHZlZCBieSB0aGUgdXNlciwgYW5kIHJlY3Vyc2l2ZWx5IHJlc29sdmVzIGFsbFxuICAgZGVwZW5kZW50IHByb21pc2VzLiBUaGUgZ3JhcGggaXMgbW9kaWZpZWQ6IHJlc29sdmVkIHByb21pc2VzIGFyZSBubyBsb25nZXJcbiAgIHBlbmRpbmcsIHNvIHRoZXkgYXJlIG5vIGxvbmdlciBwYXJ0IG9mIHRoZSBncmFwaC5cblxuICAgU29tZSBvZiB0aGVzZSBkZXBlbmRlbmNpZXMgYXJlIGV4cGxpY2l0IHRvIEx3dCwgZS5nLiB0aGUgY2FsbGJhY2tzIHJlZ2lzdGVyZWRcbiAgIGJ5IFtMd3QuYmluZF0uIE90aGVycyBhcmUgbm90IHZpc2libGUgdG8gTHd0LCBiZWNhdXNlIHRoZSB1c2VyIGNhbiBhbHdheXNcbiAgIHJlZ2lzdGVyIGEgY2FsbGJhY2sgdXNpbmcgYSBmdW5jdGlvbiBsaWtlIFtMd3Qub25fc3VjY2Vzc10sIGFuZCB1c2UgdGhhdFxuICAgY2FsbGJhY2sgdG8gcmVzb2x2ZSBhbm90aGVyIGluaXRpYWwgcHJvbWlzZS4gQWxsIHRoZSBleHBsaWNpdCBkZXBlbmRlbmNpZXNcbiAgIGFyZSBjcmVhdGVkIGJ5IEx3dCdzIG93biBzZXF1ZW50aWFsIGFuZCBjb25jdXJyZW50IGNvbXBvc2l0aW9uIGZ1bmN0aW9uc1xuICAgKHNvLCBbTHd0LmJpbmRdLCBbTHd0LmpvaW5dLCBldGMpLiBXaGV0aGVyIGRlcGVuZGVuY2llcyBhcmUgZXhwbGljaXQgb3Igbm90XG4gICBpcyByZWxldmFudCBvbmx5IHRvIGNhbmNlbGxhdGlvbi5cblxuXG4gICA1LiBDYW5jZWxsYXRpb25cblxuICAgQXMgZGVzY3JpYmVkIGFib3ZlLCBvcmRpbmFyeSBwcm9taXNlIHJlc29sdXRpb24gcHJvY2VlZHMgZnJvbSBhbiBpbml0aWFsXG4gICBwcm9taXNlLCBmb3J3YXJkIGFsb25nIGNhbGxiYWNrcyB0aHJvdWdoIHRoZSBkZXBlbmRlbmN5IGdyYXBoLiBTaW5jZSBpdFxuICAgc3RhcnRzIGZyb20gYW4gaW5pdGlhbCBwcm9taXNlLCBpdCBjYW4gb25seSBiZSB0cmlnZ2VyZWQgdXNpbmcgYSByZXNvbHZlci5cblxuICAgQ2FuY2VsbGF0aW9uIGlzIGEgc29ydCBvZiBkdWFsIHRvIG9yZGluYXJ5IHJlc29sdXRpb24uIEluc3RlYWQgb2Ygc3RhcnRpbmcgYXRcbiAgIGFuIGluaXRpYWwgcHJvbWlzZS9yZXNvbHZlciwgY2FuY2VsbGF0aW9uIHN0YXJ0cyBhdCAqYW55KiBwcm9taXNlLiBJdCB0aGVuXG4gICBnb2VzICpiYWNrd2FyZHMqIHRocm91Z2ggdGhlIGV4cGxpY2l0IGRlcGVuZGVuY3kgZ3JhcGgsIGxvb2tpbmcgZm9yXG4gICBjYW5jZWxhYmxlIGluaXRpYWwgcHJvbWlzZXMgdG8gY2FuY2VsIC0tIHRob3NlIHRoYXQgd2VyZSBjcmVhdGVkIGJ5XG4gICBbTHd0LnRhc2tdLiBBZnRlciBmaW5kaW5nIHRoZW0sIGNhbmNlbGxhdGlvbiByZXNvbHZlcyB0aGVtIG5vcm1hbGx5IHdpdGhcbiAgIFtSZWplY3RlZCBMd3QuQ2FuY2VsZWRdLCBjYXVzaW5nIGFuIG9yZGluYXJ5IHByb21pc2UgcmVzb2x1dGlvbiBwcm9jZXNzLlxuXG4gICBUbyBzdW1tYXJpemUsIGNhbmNlbGxhdGlvbiBpcyBhIHdheSB0byB0cmlnZ2VyIGFuICpvcmRpbmFyeSogcmVzb2x1dGlvbiBvZlxuICAgcHJvbWlzZXMgY3JlYXRlZCB3aXRoIFtMd3QudGFza10sIGJ5IGZpcnN0IHNlYXJjaGluZyBmb3IgdGhlbSBpbiB0aGUgcHJvbWlzZVxuICAgZGVwZW5kZW5jeSBncmFwaCAod2hpY2ggaXMgYXNzZW1ibGVkIGJ5IFtMd3QuYmluZF0sIFtMd3Quam9pbl0sIGV0YykuXG5cbiAgIFRoaXMgYmFja3dhcmRzIHNlYXJjaCBpcyB0cmlnZ2VyZWQgb25seSBieSBbTHd0LmNhbmNlbF0uIEl0IGlzIGFsc28gcG9zc2libGVcbiAgIGZvciB0aGUgdXNlciB0byBjYW5jZWwgYSBwcm9taXNlIGRpcmVjdGx5IGJ5IHJlamVjdGluZyBpdCB3aXRoXG4gICBbTHd0LkNhbmNlbGVkXSwgYnV0IGluIGFsbCBjYXNlcyB3aGVyZSB0aGUgdXNlciBjYW4gZG8gc28sIHRoZSBzZWFyY2ggd291bGRcbiAgIGJlIHJlZHVuZGFudCBhbnl3YXkgLS0gdGhlIHVzZXIgaGFzIG9ubHkgdHdvIHdheXMgb2YgZGlyZWN0bHkgcmVqZWN0aW5nIGFcbiAgIHByb21pc2Ugd2l0aCBbTHd0LkNhbmNlbGVkXSAob3IgYW55IGV4Y2VwdGlvbiwgZm9yIHRoYXQgbWF0dGVyKTpcblxuICAgLSBUaGUgdXNlciBjYW4gY3JlYXRlIGFuIGluaXRpYWwgcHJvbWlzZSwgdGhlbiByZWplY3QgaXQgdGhyb3VnaCBpdHNcbiAgICAgcmVzb2x2ZXIuIFRoZSBzZWFyY2ggaXMgcmVkdW5kYW50IGJlY2F1c2UgaXQgd291bGQgZmluZCBvbmx5IHRoZSBzYW1lXG4gICAgIGluaXRpYWwgcHJvbWlzZSB0byBjYW5jZWwuXG4gICAtIFRoZSB1c2VyIGNhbiBjcmVhdGUgYSB0cml2aWFsIHByb21pc2UgYnkgY2FsbGluZyBbTHd0LmZhaWwgTHd0LkNhbmNlbGVkXS5cbiAgICAgVGhlIHNlYXJjaCBpcyBhZ2FpbiByZWR1bmRhbnQ7IGluIHRoaXMgY2FzZSBpdCB3b3VsZCBmaW5kIG5vdGhpbmcgdG9cbiAgICAgY2FuY2VsLlxuXG4gICBOb3RlIHRoYXQgdGhlcmUgaXMgYSBxdWlyazogb25seSBwcm9taXNlcyBjcmVhdGVkIGJ5IFtMd3QudGFza10gYXJlXG4gICBzdXNjZXB0aWJsZSB0byBiZWluZyBjYW5jZWxlZCBieSBbTHd0LmNhbmNlbF0sIGJ1dCB0aGUgdXNlciBjYW4gbWFudWFsbHlcbiAgIGNhbmNlbCBpbml0aWFsIHByb21pc2VzIGNyZWF0ZWQgYnkgYm90aCBbTHd0LnRhc2tdIGFuZCBbTHd0LndhaXRdLlxuXG4gICBEdWUgdG8gW0x3dC5jYW5jZWxdLCBwcm9taXNlIGNhbmNlbGxhdGlvbiwgYW5kIHRoZXJlZm9yZSByZXNvbHV0aW9uLCBjYW4gYmVcbiAgIGluaXRpYXRlZCBieSB0aGUgdXNlciB3aXRob3V0IGFjY2VzcyB0byBhIHJlc29sdmVyLiBUaGlzIGlzIGltcG9ydGFudCBmb3JcbiAgIHJlYXNvbmluZyBhYm91dCBzdGF0ZSBjaGFuZ2VzIGluIHRoZSBpbXBsZW1lbnRhdGlvbiBvZiBMd3QsIGFuZCBpcyByZWZlcmVuY2VkXG4gICBpbiBzb21lIGltcGxlbWVudGF0aW9uIGRldGFpbCBjb21tZW50cy5cblxuXG4gICA2LiBObyBJL09cblxuICAgVGhlIEx3dCBjb3JlIGRlbGliZXJhdGVseSBkb2Vzbid0IGRvIEkvTy4gVGhlIHJlc29sdXRpb24gbG9vcCBzdG9wcyBydW5uaW5nXG4gICBvbmNlIG5vIHByb21pc2VzIGNhbiBiZSByZXNvbHZlZCBpbW1lZGlhdGVseS4gSXQgaGFzIHRvIGJlIHJlc3RhcnRlZCBsYXRlclxuICAgYnkgc29tZSBzdXJyb3VuZGluZyBJL08gbG9vcC4gVGhpcyBJL08gbG9vcCB0eXBpY2FsbHkga2VlcHMgdHJhY2sgb2YgcGVuZGluZ1xuICAgcHJvbWlzZXMgdGhhdCByZXByZXNlbnQgYmxvY2tlZCBvciBpbi1wcm9ncmVzcyBJL087IG90aGVyIHBlbmRpbmcgcHJvbWlzZXNcbiAgIHRoYXQgaW5kaXJlY3RseSBkZXBlbmQgb24gSS9PIGFyZSBub3QgZXhwbGljaXRseSB0cmFja2VkLiBUaGV5IGFyZSByZXRhaW5lZFxuICAgaW4gbWVtb3J5IGJ5IHJlZmVyZW5jZXMgY2FwdHVyZWQgaW5zaWRlIGNhbGxiYWNrcy5cblxuICAgT24gVW5peCBhbmQgV2luZG93cywgYSBzZXBhcmF0ZSB0b3AtbGV2ZWwgbG9vcCwgdHlwaWNhbGx5IFtMd3RfbWFpbi5ydW5dLCBpc1xuICAgbmVjZXNzYXJ5IHRvIHJlcGVhdGVkbHkgY2FsbCBbc2VsZWN0XSwgW2Vwb2xsXSwgb3IgW2tldmVudF0sIGFuZCByZXNvbHZlXG4gICBibG9ja2VkIEkvTyBwcm9taXNlcy5cblxuICAgSW4gSmF2YVNjcmlwdCwgcmVmZXJlbmNlcyB0byBwcm9taXNlcyBhcmUgcmV0YWluZWQgYnkgSmF2YVNjcmlwdCBjb2RlLCB3aGljaFxuICAgaXMsIGluIHR1cm4sIHRyaWdnZXJlZCBieSB0aGUgSlMgZW5naW5lLiBJbiBvdGhlciB3b3JkcywgdGhlIHRvcC1sZXZlbCBsb29wXG4gICBpcyBidXJpZWQgaW5zaWRlIHRoZSBKUyBlbmdpbmUuXG5cbiAgIFRoaXMgc2VwYXJhdGlvbiBvZiB0aGUgTHd0IGNvcmUgZnJvbSB0aGUgdG9wLWxldmVsIEkvTyBsb29wIGtlZXBzIHRoZSBjb3JlXG4gICBwb3J0YWJsZS5cblxuXG4gICA3LiBQcm9taXNlIFwicHJveHlpbmdcIlxuXG4gICBJbiBbTHd0LmJpbmQgOiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XSwgdGhlIG91dGVyIFsnYiB0XSBpcyBjcmVhdGVkIGJ5XG4gICBbYmluZF0gZmlyc3QsIGFuZCByZXR1cm5lZCB0byB0aGUgdXNlci4gVGhlIGlubmVyIFsnYiB0XSBpcyBjcmVhdGVkIGJ5IHRoZVxuICAgdXNlciBsYXRlciwgYW5kIHRoZW4gcmV0dXJuZWQgdG8gW2JpbmRdLiBBdCB0aGF0IHBvaW50LCBbYmluZF0gbmVlZHMgdG8gbWFrZVxuICAgdGhlIGlubmVyIGFuZCBvdXRlciBbJ2IgdF1zIGJlaGF2ZSBpZGVudGljYWxseS5cblxuICAgVGhpcyBpcyBhY2NvbXBsaXNoZWQgYnkgbWFraW5nIG9uZSBvZiB0aGUgcHJvbWlzZXMgcG9pbnQgdG8gdGhlIG90aGVyLiBUaGVcbiAgIGZpcnN0IG9mIHRoZSBwcm9taXNlcyB0aHVzIGJlY29tZXMgYSBcInByb3h5LFwiIGFuZCB0aGUgb3RoZXIgaXMgaXRzXG4gICBcInVuZGVybHlpbmdcIiBwcm9taXNlLlxuXG4gICBBZnRlciB0aGF0LCBhbGwgb3BlcmF0aW9ucyB0aGF0IHdvdWxkIGJlIHBlcmZvcm1lZCBieSBMd3Qgb24gdGhlIHByb3h5IGFyZVxuICAgaW5zdGVhZCBwZXJmb3JtZWQgb24gdGhlIHVuZGVybHlpbmcgcHJvbWlzZS4gVGhpcyBpcyBlbnN1cmVkIGJ5IHRoZSBudW1lcm91c1xuICAgY2FsbHMgdG8gdGhlIGludGVybmFsIGZ1bmN0aW9uIFt1bmRlcmx5aW5nXSBpbiB0aGlzIGZpbGUuXG5cbiAgIEJlY2F1c2Ugb2YgdGhlIHBlcnZhc2l2ZSB1c2Ugb2YgW3VuZGVybHlpbmddLCBwcm94aWVzIGNhbiBiZSBtb3JlIG9yIGxlc3NcbiAgIGlnbm9yZWQgb24gYSBmaXJzdCByZWFkaW5nIHRoZSBjb2RlLiBIb3dldmVyLCBiZWNvbWluZyBhIHByb3h5IGlzIGEga2luZCBvZlxuICAgc3RhdGUgY2hhbmdlLCBhbmQgYW55IHByb21pc2UgdGhhdCBpcyByZXR1cm5lZCBieSBhIGNhbGxiYWNrIHRvIFtiaW5kXSwgb3IgdG9cbiAgIGEgc2ltaWxhciBMd3QgZnVuY3Rpb24sIG1pZ2h0IGJlY29tZSBhIHByb3h5LiBUaGF0IG1lYW5zOiBqdXN0IGFib3V0IGFueVxuICAgcHJvbWlzZSB0aGF0IGlzIGhhbmRlZCB0byB0aGUgdXNlciwgbWlnaHQgYmVjb21lIGEgcHJveHkgcHJvbWlzZSBieSB0aGUgbmV4dFxuICAgdGltZSBMd3Qgc2VlcyBpdC4gVGhpcyBpcyBpbXBvcnRhbnQgZm9yIHJlYXNvbmluZyBhYm91dCBwb3NzaWJsZSBzdGF0ZVxuICAgY2hhbmdlcyBpbiBpbXBsZW1lbnRhdGlvbiBvZiBMd3QsIGFuZCBpcyByZWZlcmVuY2VkIGluIHNvbWUgaW1wbGVtZW50YXRpb25cbiAgIGRldGFpbCBjb21tZW50cy5cblxuXG4gICA4LiBTZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2VcblxuICAgTHd0IGhhcyBhIGdsb2JhbCBrZXktdmFsdWUgbWFwLiBUaGUgbWFwIGNhbiBiZSBwcmVzZXJ2ZWQgYWNyb3NzIHNlcXVlbnRpYWxcbiAgIGNvbXBvc2l0aW9uIGZ1bmN0aW9ucywgc28gdGhhdCBpdCBoYXMgdGhlIHNhbWUgc3RhdGUgaW4gdGhlIHVzZXIncyBjYWxsYmFja1xuICAgW2ZdIGFzIGl0IGRpZCBhdCB0aGUgdGltZSB0aGUgdXNlciBjYWxsZWQgW0x3dC5iaW5kIHAgZl0uXG5cbiAgIFRoZSBkZXRhaWxzIGFyZSBwcmV0dHkgc3RyYWlnaHRmb3J3YXJkLCBhbmQgZGlzY3Vzc2VkIGluIG1vZHVsZVxuICAgW1NlcXVlbmNlX2Fzc29jaWF0ZWRfc3RvcmFnZV0uIFRoZSBtYWluIHRoaW5nIHRvIGJlIGF3YXJlIG9mIGlzIHRoZSBtYW55XG4gICByZWZlcmVuY2VzIHRvIFtjdXJyZW50X3N0b3JhZ2VdIHRocm91Z2hvdXQgTHd0LCB3aGljaCBhcmUgbmVlZGVkIHRvIHByb3Blcmx5XG4gICBzYXZlIGFuZCByZXN0b3JlIHRoZSBtYXBwaW5nLlxuXG5cbiAgIDkuIFR5cGUgc3lzdGVtIGFidXNlXG5cbiAgIFRoZSBpbXBsZW1lbnRhdGlvbiB1c2VzIHRoZSB0eXBlIHN5c3RlbSBzb21ld2hhdCBleHRlbnNpdmVseS4gR2VudGxlXG4gICBpbnRyb2R1Y3Rpb25zIGNhbiBiZSBmb3VuZCBoZXJlOlxuXG4gICAgIGh0dHBzOi8vZGlzY3Vzcy5vY2FtbC5vcmcvdC8xNjEvN1xuICAgICBodHRwczovL2Rpc2N1c3Mub2NhbWwub3JnL3QvMTYxLzE2XG5cbiAgIEEgc2hvcnQgc3VtbWFyeSBmb2xsb3dzLlxuXG4gICBUaGUgcHJvbWlzZSBzdGF0ZSBpcywgaW50ZXJuYWxseSwgYSBHQURUIHdoaWNoIGVuY29kZXMgdGhlIHN0YXRlIGluIGl0cyB0eXBlXG4gICBwYXJhbWV0ZXJzLiBUaHVzLCBpZiB5b3UgZG8gW2xldCBwID0gdW5kZXJseWluZyBwXSwgdGhlIHNoYWRvd2luZyByZWZlcmVuY2VcbiAgIFtwXSBpcyBzdGF0aWNhbGx5IGtub3duICpub3QqIHRvIGJlIGEgcHJveHksIGFuZCB0aGUgY29tcGlsZXIga25vd3MgdGhhdCB0aGVcbiAgIGNvcnJlc3BvbmRpbmcgbWF0Y2ggY2FzZSBbUHJveHkgX10gaXMgaW1wb3NzaWJsZS5cblxuICAgVGhlIGV4dGVybmFsIHByb21pc2UgdHlwZSwgWydhIHRdLCBhbmQgdGhlIGV4dGVybmFsIHJlc29sdmVyIHR5cGUsIFsnYSB1XSxcbiAgIGFyZSBub3QgR0FEVHMuIEZ1cnRoZXJtb3JlLCB0aGV5IGFyZSwgcmVzcGVjdGl2ZWx5LCBjb3ZhcmlhbnQgYW5kXG4gICBjb250cmF2YXJpYW50IGluIFsnYV0sIHdoaWxlIHRoZSBpbnRlcm5hbCBwcm9taXNlIHR5cGUgaXMgaW52YXJpYW50IGluIFsnYV0uXG4gICBGb3IgdGhlc2UgcmVhc29ucywgdGhlcmUgYXJlIG5hc3R5IGNhc3RzIGJldHdlZW4gWydhIHRdLCBbJ2EgdV0sIGFuZCB0aGVcbiAgIGludGVybmFsIHByb21pc2UgdHlwZS4gVGhlIGltcGxlbWVudGF0aW9uIGlzLCBvZiBjb3Vyc2UsIHdyaXR0ZW4gaW4gdGVybXMgb2ZcbiAgIHRoZSBpbnRlcm5hbCB0eXBlLlxuXG4gICBDYXN0aW5nIGZyb20gYW4gWydhIHRdIHRvIGFuIGludGVybmFsIHByb21pc2UgcHJvZHVjZXMgYSByZWZlcmVuY2UgZm9yXG4gICB3aGljaCB0aGUgc3RhdGUgaXMgXCJ1bmtub3duXCI6IHRoaXMgaXMgc2ltdWxhdGVkIHdpdGggYSBoZWxwZXIgR0FEVCwgd2hpY2hcbiAgIGVuY29kZXMgZXhpc3RlbnRpYWwgdHlwZXMuIFRoZXJlIGFyZSBzZXZlcmFsIHNpbWlsYXIgY2FzdHMsIHdoaWNoIGFyZSB1c2VkXG4gICB0byBkb2N1bWVudCBwb3NzaWJsZSBzdGF0ZSBjaGFuZ2VzIGJldHdlZW4gdGhlIHRpbWUgYSBwcm9taXNlIGlzIGNyZWF0ZWQsXG4gICBhbmQgdGhlIGxhdGVyIHRpbWUgaXQgaXMgdXNlZCBpbiBhIGNhbGxiYWNrLiBZb3UgY2FuIHNlZSB0aGVzZSBjYXN0cyBpblxuICAgYWN0aW9uIGluIFtMd3QuYmluZF0uIFRoZSBjYXN0IHN5bnRheCBpcyBwcmV0dHkgbGlnaHQsIGFuZCwgYmVzaWRlcyBiZWluZ1xuICAgY29tbWVudGVkIGluIFtiaW5kXSwgYWxsIHN1Y2ggY2FzdHMgYXJlIGRvY3VtZW50ZWQgaW4gbW9kdWxlcyBbUHVibGljX3R5cGVzXVxuICAgYW5kIFtCYXNpY19oZWxwZXJzXS5cblxuXG4gICBJZiB5b3UndmUgbWFkZSBpdCB0aGlzIGZhciwgeW91IGFyZSBhbiBMd3QgZXhwZXJ0ISBSZWpvaWNlISAqKVxuXG5cblxuKCogW0x3dF9zZXF1ZW5jZV0gaXMgZGVwcmVjYXRlZCDigJMgd2UgZG9uJ3Qgd2FudCB1c2VycyBvdXRzaWRlIEx3dCB1c2luZyBpdC5cbiAgIEhvd2V2ZXIsIGl0IGlzIHN0aWxsIHVzZWQgaW50ZXJuYWxseSBieSBMd3QuIFNvLCBicmllZmx5IGRpc2FibGUgd2FybmluZyAzXG4gICAoXCJkZXByZWNhdGVkXCIpLCBhbmQgY3JlYXRlIGEgbG9jYWwsIG5vbi1kZXByZWNhdGVkIGFsaWFzIGZvclxuICAgW0x3dF9zZXF1ZW5jZV0gdGhhdCBjYW4gYmUgcmVmZXJyZWQgdG8gYnkgdGhlIHJlc3Qgb2YgdGhlIGNvZGUgaW4gdGhpc1xuICAgbW9kdWxlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbnkgbW9yZSB3YXJuaW5ncy4gKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbm1vZHVsZSBMd3Rfc2VxdWVuY2UgPSBMd3Rfc2VxdWVuY2VcbltAQEBvY2FtbC53YXJuaW5nIFwiKzNcIl1cblxuKCogU29tZSBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2UgdHlwZXNcblxuICAgU2VxdWVuY2UtYXNzb2NpYXRlZCBzdG9yYWdlIGlzIGRlZmluZWQgYW5kIGRvY3VtZW50ZWQgbGF0ZXIsIGluIG1vZHVsZVxuICAgW1NlcXVlbmNlX2Fzc29jaWF0ZWRfc3RvcmFnZV0uIEhvd2V2ZXIsIHRoZSBmb2xsb3dpbmcgdHlwZXMgYXJlIG1lbnRpb25lZCBpblxuICAgdGhlIGRlZmluaXRpb24gb2YgW3Byb21pc2VdLCBzbyB0aGV5IG11c3QgYmUgZGVmaW5lZCBoZXJlIGZpcnN0LiAqKVxubW9kdWxlIFN0b3JhZ2VfbWFwID1cbiAgTWFwLk1ha2VcbiAgICAoc3RydWN0XG4gICAgICB0eXBlIHQgPSBpbnRcbiAgICAgIGxldCBjb21wYXJlID0gY29tcGFyZVxuICAgIGVuZClcbnR5cGUgc3RvcmFnZSA9ICh1bml0IC0+IHVuaXQpIFN0b3JhZ2VfbWFwLnRcblxuXG5cbm1vZHVsZSBNYWluX2ludGVybmFsX3R5cGVzID1cbnN0cnVjdFxuICAoKiBQaGFudG9tIHR5cGVzIGZvciB1c2Ugd2l0aCB0eXBlcyBbcHJvbWlzZV0gYW5kIFtzdGF0ZV0uIFRoZXNlIGFyZSBuZXZlclxuICAgICBjb25zdHJ1Y3RlZDsgdGhlIHB1cnBvc2Ugb2YgdGhlIGNvbnN0cnVjdG9ycyBpcyB0byBwcm92ZSB0byB0aGUgdHlwZVxuICAgICBjaGVja2VyIHRoYXQgdGhlc2UgdHlwZXMgYXJlIGRpc3RpbmN0IGZyb20gZWFjaCBvdGhlci4gV2FybmluZyAzNywgXCJ1bnVzZWRcbiAgICAgY29uc3RydWN0b3IsXCIgdGhlcmVmb3JlIGhhcyB0byBiZSB0ZW1wb3JhcmlseSBzdXBwcmVzc2VkLiAqKVxuXG4gIFtAQEBvY2FtbC53YXJuaW5nIFwiLTM3XCJdXG5cbiAgdHlwZSB1bmRlcmx5aW5nID0gcHJpdmF0ZSBVbmRlcmx5aW5nX2FuZF90aGlzX2NvbnN0cnVjdG9yX2lzX25vdF91c2VkXG4gIHR5cGUgcHJveHkgPSBwcml2YXRlIFByb3h5X2FuZF90aGlzX2NvbnN0cnVjdG9yX2lzX25vdF91c2VkXG5cbiAgdHlwZSByZXNvbHZlZCA9IHByaXZhdGUgUmVzb2x2ZWRfYW5kX3RoaXNfY29uc3RydWN0b3JfaXNfbm90X3VzZWRcbiAgdHlwZSBwZW5kaW5nID0gcHJpdmF0ZSBQZW5kaW5nX2FuZF90aGlzX2NvbnN0cnVjdG9yX2lzX25vdF91c2VkXG5cbiAgW0BAQG9jYW1sLndhcm5pbmcgXCIrMzdcIl1cblxuXG5cbiAgKCogUHJvbWlzZXMgcHJvcGVyLiAqKVxuXG4gIHR5cGUgKCdhLCAndSwgJ2MpIHByb21pc2UgPSB7XG4gICAgbXV0YWJsZSBzdGF0ZSA6ICgnYSwgJ3UsICdjKSBzdGF0ZTtcbiAgfVxuXG4gIGFuZCAoXywgXywgXykgc3RhdGUgPVxuICAgIHwgRnVsZmlsbGVkIDogJ2EgICAgICAgICAgICAgICAgICAtPiAoJ2EsIHVuZGVybHlpbmcsIHJlc29sdmVkKSBzdGF0ZVxuICAgIHwgUmVqZWN0ZWQgIDogZXhuICAgICAgICAgICAgICAgICAtPiAoIF8sIHVuZGVybHlpbmcsIHJlc29sdmVkKSBzdGF0ZVxuICAgIHwgUGVuZGluZyAgIDogJ2EgY2FsbGJhY2tzICAgICAgICAtPiAoJ2EsIHVuZGVybHlpbmcsIHBlbmRpbmcpICBzdGF0ZVxuICAgIHwgUHJveHkgICAgIDogKCdhLCBfLCAnYykgcHJvbWlzZSAtPiAoJ2EsIHByb3h5LCAgICAgICdjKSAgICAgICBzdGF0ZVxuXG4gICgqIE5vdGU6XG5cbiAgICAgQSBwcm9taXNlIHdob3NlIHN0YXRlIGlzIFtQcm94eSBfXSBpcyBhIFwicHJveHlcIiBwcm9taXNlLiBBIHByb21pc2Ugd2hvc2VcbiAgICAgc3RhdGUgaXMgKm5vdCogW1Byb3h5IF9dIGlzIGFuIFwidW5kZXJseWluZ1wiIHByb21pc2UuXG5cbiAgICAgVGhlIFwidW5kZXJseWluZyBwcm9taXNlIG9mIFtwXVwiIGlzOlxuXG4gICAgIC0gW3BdLCBpZiBbcF0gaXMgaXRzZWxmIHVuZGVybHlpbmcuXG4gICAgIC0gT3RoZXJ3aXNlLCBbcF0gaXMgYSBwcm94eSBhbmQgaGFzIHN0YXRlIFtQcm94eSBwJ10uIFRoZSB1bmRlcmx5aW5nXG4gICAgICAgcHJvbWlzZSBvZiBbcF0gaXMgdGhlIHVuZGVybHlpbmcgcHJvbWlzZSBvZiBbcCddLlxuXG4gICAgIEluIG90aGVyIHdvcmRzLCB0byBmaW5kIHRoZSB1bmRlcmx5aW5nIHByb21pc2Ugb2YgYSBwcm94eSwgTHd0IGZvbGxvd3MgdGhlXG4gICAgIFtQcm94eSBfXSBsaW5rcyB0byB0aGUgZW5kLiAqKVxuXG4gICgqIE5vdGU6XG5cbiAgICAgV2hlbiBhIHByb21pc2UgaXMgcmVzb2x2ZWQsIG9yIGJlY29tZXMgYSBwcm94eSwgaXRzIHN0YXRlIGZpZWxkIGlzXG4gICAgIG11dGF0ZWQuIFRoaXMgaW52YWxpZGF0ZXMgdGhlIHR5cGUgaW52YXJpYW50cyBvbiB0aGUgcHJvbWlzZS4gU2VlIGludGVybmFsXG4gICAgIGZ1bmN0aW9uIFtzZXRfcHJvbWlzZV9zdGF0ZV0gZm9yIGRldGFpbHMgYWJvdXQgdGhhdC5cblxuICAgICBXaGVuIGFuIEx3dCBmdW5jdGlvbiBoYXMgYSByZWZlcmVuY2UgdG8gYSBwcm9taXNlLCBhbmQgYWxzbyByZWdpc3RlcnMgYVxuICAgICBjYWxsYmFjayB0aGF0IGhhcyBhIHJlZmVyZW5jZSB0byB0aGUgc2FtZSBwcm9taXNlLCB0aGUgaW52YXJpYW50cyBvbiB0aGVcbiAgICAgcmVmZXJlbmNlIG1heSBiZWNvbWUgaW52YWxpZCBieSB0aGUgdGltZSB0aGUgY2FsbGJhY2sgaXMgY2FsbGVkLiBBbGwgc3VjaFxuICAgICBjYWxsYmFja3MgaGF2ZSBjb21tZW50cyBleHBsYWluaW5nIHdoYXQgdGhlIHZhbGlkIGludmFyaWFudHMgYXJlIGF0IHRoYXRcbiAgICAgcG9pbnQsIGFuZC9vciBjYXN0cyB0byAoMSkgZ2V0IHRoZSBjb3JyZWN0IHR5cGluZyBhbmQgKDIpIGRvY3VtZW50IHRoZVxuICAgICBwb3RlbnRpYWwgc3RhdGUgY2hhbmdlIGZvciByZWFkZXJzIG9mIHRoZSBjb2RlLiAqKVxuXG5cblxuICAoKiBDYWxsYmFjayBpbmZvcm1hdGlvbiBmb3IgcGVuZGluZyBwcm9taXNlcy4gKilcblxuICBhbmQgJ2EgY2FsbGJhY2tzID0ge1xuICAgIG11dGFibGUgcmVndWxhcl9jYWxsYmFja3MgOiAnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3Q7XG4gICAgbXV0YWJsZSBjYW5jZWxfY2FsbGJhY2tzICA6ICdhIGNhbmNlbF9jYWxsYmFja19saXN0O1xuICAgIG11dGFibGUgaG93X3RvX2NhbmNlbCAgICAgOiBob3dfdG9fY2FuY2VsO1xuICAgIG11dGFibGUgY2xlYW51cHNfZGVmZXJyZWQgOiBpbnQ7XG4gIH1cblxuICBhbmQgJ2EgcmVndWxhcl9jYWxsYmFjayA9ICdhIHJlc29sdmVkX3N0YXRlIC0+IHVuaXRcblxuICBhbmQgY2FuY2VsX2NhbGxiYWNrID0gdW5pdCAtPiB1bml0XG5cbiAgYW5kICdhIHJlc29sdmVkX3N0YXRlID0gKCdhLCB1bmRlcmx5aW5nLCByZXNvbHZlZCkgc3RhdGVcblxuICBhbmQgaG93X3RvX2NhbmNlbCA9XG4gICAgfCBOb3RfY2FuY2VsYWJsZSAgICAgICAgICAgICAgOiAgICAgICAgICAgICAgICAgICAgICAgICAgIGhvd190b19jYW5jZWxcbiAgICB8IENhbmNlbF90aGlzX3Byb21pc2UgICAgICAgICA6ICAgICAgICAgICAgICAgICAgICAgICAgICAgaG93X3RvX2NhbmNlbFxuICAgIHwgUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgICAgIDogKF8sIF8sIF8pIHByb21pc2UgICAgICAtPiBob3dfdG9fY2FuY2VsXG4gICAgfCBQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgOiAoXywgXywgXykgcHJvbWlzZSBsaXN0IC0+IGhvd190b19jYW5jZWxcblxuICBhbmQgJ2EgcmVndWxhcl9jYWxsYmFja19saXN0ID1cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eVxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCBvZlxuICAgICAgJ2EgcmVndWxhcl9jYWxsYmFja19saXN0ICogJ2EgcmVndWxhcl9jYWxsYmFja19saXN0XG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIG9mXG4gICAgICAnYSByZWd1bGFyX2NhbGxiYWNrXG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2sgb2ZcbiAgICAgICdhIHJlZ3VsYXJfY2FsbGJhY2sgb3B0aW9uIHJlZlxuXG4gIGFuZCBfIGNhbmNlbF9jYWxsYmFja19saXN0ID1cbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2VtcHR5IDpcbiAgICAgIF8gY2FuY2VsX2NhbGxiYWNrX2xpc3RcbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCA6XG4gICAgICAnYSBjYW5jZWxfY2FsbGJhY2tfbGlzdCAqICdhIGNhbmNlbF9jYWxsYmFja19saXN0IC0+XG4gICAgICAgICdhIGNhbmNlbF9jYWxsYmFja19saXN0XG4gICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jYWxsYmFjayA6XG4gICAgICBzdG9yYWdlICogY2FuY2VsX2NhbGxiYWNrIC0+XG4gICAgICAgIF8gY2FuY2VsX2NhbGxiYWNrX2xpc3RcbiAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIDpcbiAgICAgICgnYSwgXywgXykgcHJvbWlzZSBMd3Rfc2VxdWVuY2Uubm9kZSAtPlxuICAgICAgICAnYSBjYW5jZWxfY2FsbGJhY2tfbGlzdFxuXG4gICgqIE5vdGVzOlxuXG4gICAgIFRoZXNlIHR5cGUgZGVmaW5pdGlvbnMgYXJlIGd1aWx0eSBvZiBwZXJmb3JtaW5nIHNldmVyYWwgb3B0aW1pemF0aW9ucyxcbiAgICAgd2l0aG91dCB3aGljaCB0aGV5IHdvdWxkIGJlIG11Y2ggZWFzaWVyIHRvIHVuZGVyc3RhbmQuXG5cbiAgICAgLSBUaGUgdHlwZSBwYXJhbWV0ZXJzIG9mIFsnYSByZXNvbHZlZF9zdGF0ZV0gZ3VhcmFudGVlIHRoYXQgaXQgaXMgZWl0aGVyXG4gICAgICAgW0Z1bGZpbGxlZCBfXSBvciBbUmVqZWN0ZWQgX10uIFNvLCBpdCBpcyBlcXVpdmFsZW50IHRvXG4gICAgICAgWygnYSwgZXhuKSBTdGRsaWIucmVzdWx0XSwgYW5kLCBpbmRlZWQsIHNob3VsZCBoYXZlIGFuIGlkZW50aWNhbFxuICAgICAgIG1lbW9yeSByZXByZXNlbnRhdGlvbi5cblxuICAgICAtIEFzIHBlciB0aGUgT3ZlcnZpZXcsIHRoZXJlIGFyZSByZWd1bGFyIGNhbGxiYWNrcyBhbmQgY2FuY2VsIGNhbGxiYWNrcy5cbiAgICAgICBDYW5jZWwgY2FsbGJhY2tzIGFyZSBjYWxsZWQgb25seSBvbiBjYW5jZWxsYXRpb24sIGFuZCwgdGhlbiwgYmVmb3JlIGFueVxuICAgICAgIHJlZ3VsYXIgY2FsbGJhY2tzIGFyZSBjYWxsZWQuXG5cbiAgICAgICBEZXNwaXRlIHRoZSBkaWZmZXJlbnQgdHlwZXMgZm9yIHRoZSB0d28ga2luZHMgb2YgY2FsbGJhY2tzLCB0aGV5IGFyZVxuICAgICAgIG90aGVyd2lzZSB0aGUgc2FtZS4gQ2FuY2VsIGNhbGxiYWNrcyBqdXN0IGRvbid0IG5lZWQgYSByZXN1bHQgc3RhdGVcbiAgICAgICBhcmd1bWVudCwgYmVjYXVzZSBpdCBpcyBrbm93biB0byBiZSBbUmVqZWN0ZWQgQ2FuY2VsZWRdLlxuXG4gICAgIC0gUmVndWxhciBjYWxsYmFja3MgYXJlIG5vdCBhbGxvd2VkIHRvIHJhaXNlIGV4Y2VwdGlvbnMuIEFsbCByZWd1bGFyXG4gICAgICAgY2FsbGJhY2tzIGFyZSBjcmVhdGVkIGluIHRoaXMgZmlsZSwgc28gdGhpcyBjYW4gYmUgY2hlY2tlZC5cblxuICAgICAgIENhbmNlbCBjYWxsYmFja3MgY2FuIHJhaXNlIGV4Y2VwdGlvbnMsIGJ1dCBpZiB0aGV5IGRvIHNvLCB0aGUgZXhjZXB0aW9uc1xuICAgICAgIGFyZSBwYXNzZWQgdG8gW2FzeW5jX2V4Y2VwdGlvbl9ob29rXS5cblxuICAgICAtIFtob3dfdG9fY2FuY2VsXSBpbXBsZW1lbnRzIHRoZSBkZXBlbmRlbmN5IGdyYXBoIG1lbnRpb25lZCBpbiB0aGVcbiAgICAgICBPdmVydmlldy4gSXQgaXMgdHJhdmVyc2VkIGJhY2t3YXJkcyBkdXJpbmcgW0x3dC5jYW5jZWxdLiBJdCBpcyBhIEdBRFRcbiAgICAgICBiZWNhdXNlIHdlIGRvbid0IGNhcmUgYWJvdXQgdGhlIGFjdHVhbCB0eXBlcyBvZiB0aGUgcHJvbWlzZSByZWZlcmVuY2VzXG4gICAgICAgc3RvcmVkLCBvciB0aGVpciBpbnZhcmlhbnRzLiBUaGUgY29uc3RydWN0b3JzIGNvcnJlc3BvbmQgdG8gcGVuZGluZ1xuICAgICAgIHByb21pc2Uga2luZHMgYXMgZm9sbG93czpcbiAgICAgICAgIC0gW05vdF9jYW5jZWxhYmxlXTogaW5pdGlhbCwgW0x3dC53YWl0XS5cbiAgICAgICAgIC0gW0NhbmNlbF90aGlzX3Byb21pc2VdOiBpbml0aWFsLCBbTHd0LnRhc2tdLlxuICAgICAgICAgLSBbUHJvcGFnYXRlX2NhbmNlbF90b19vbmVdOiBzZXF1ZW50aWFsIGNvbXBvc2l0aW9uLCBlLmcuIFtMd3QuYmluZF0uXG4gICAgICAgICAtIFtQcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWxdOiBjb25jdXJyZW50IGNvbXBvc2l0aW9uLCBlLmcuXG4gICAgICAgICAgIFtMd3Quam9pbl0uXG5cbiAgICAgLSBUaGUgdHdvIGNhbGxiYWNrIGxpc3QgdHlwZXMgYXJlIG9yZGluYXJ5IGFwcGVuZC1mcmllbmRseSBsaXN0cywgd2l0aCB0d29cbiAgICAgICBvcHRpbWl6YXRpb25zIGlubGluZWQ6XG5cbiAgICAgICAtIFsnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3RdIGFwcGFyZW50bHkgaGFzIHR3byBcImtpbmRzXCIgb2YgcmVndWxhclxuICAgICAgICAgY2FsbGJhY2tzLCBpbXBsaWNpdGx5IHJlbW92ZWQgYW5kIGV4cGxpY2l0bHkgcmVtb3ZhYmxlLiBBbGwgY2FsbGJhY2tzXG4gICAgICAgICBhcmUgcmVtb3ZhYmxlLiBJdCdzIGp1c3QgdGhhdCwgZm9yIHNvbWUgY2FsbGJhY2tzLCB0aGV5IHdpbGwgb25seSBiZVxuICAgICAgICAgcmVtb3ZlZCBhdCB0aGUgc2FtZSB0aW1lIHRoYXQgdGhlIHByb21pc2UgdGhleSBhcmUgYXR0YWNoZWQgdG8gYmVjb21lc1xuICAgICAgICAgcmVzb2x2ZWQuIFdoZW4gdGhhdCBoYXBwZW5zLCB0aGUgZW50aXJlIHN0YXRlIG9mIHRoYXQgcHJvbWlzZSBjaGFuZ2VzXG4gICAgICAgICB0byBbRnVsZmlsbGVkIF9dIG9yIFtSZWplY3RlZCBfXSwgYW5kIHRoZSByZWZlcmVuY2UgdG8gdGhlIHdob2xlXG4gICAgICAgICBjYWxsYmFjayBsaXN0IGlzIHNpbXBseSBsb3N0LiBUaGlzIFwicmVtb3Zlc1wiIHRoZSBjYWxsYmFjay4gRm9yIHRoZXNlXG4gICAgICAgICBjYWxsYmFja3MsIFsnYSByZWd1bGFyX2NhbGxiYWNrX2xpc3RdIGF0dGVtcHRzIHRvIHRyaW0gYW4gb3B0aW9uIGFuZCBhXG4gICAgICAgICByZWZlcmVuY2UgY2VsbCB3aXRoIHRoZVxuICAgICAgICAgW1JlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2tdIGNvbnN0cnVjdG9yLlxuXG4gICAgICAgLSBbJ2EgY2FuY2VsX2NhbGxiYWNrX2xpc3RdIGhhc1xuICAgICAgICAgW0NhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIG5vZGVdLCB3aGljaCBpcyB0aGUgc2FtZSBhc1xuICAgICAgICAgW0NhbmNlbF9jYWxsYmFja19saXN0X2NhbGxiYWNrIChfLCAoZnVuIF8gLT5cbiAgICAgICAgICAgTHd0X3NlcXVlbmNlLnJlbW92ZSBub2RlKSldLlxuICAgICAgICAgVGhpcyB3YXMgcHJvYmFibHkgZG9uZSB0byBhdm9pZCBhIGNsb3N1cmUgYWxsb2NhdGlvbi5cblxuICAgICAtIFRoZSBbY2xlYW51cHNfZGVmZXJyZWRdIGZpZWxkIGlzIGV4cGxhaW5lZCBpbiBtb2R1bGVcbiAgICAgICBbUGVuZGluZ19jYWxsYmFja3NdLiAqKVxuZW5kXG5vcGVuIE1haW5faW50ZXJuYWxfdHlwZXNcblxuXG5cbm1vZHVsZSBQdWJsaWNfdHlwZXMgPVxuc3RydWN0XG4gIHR5cGUgKydhIHRcbiAgdHlwZSAtJ2EgdVxuXG4gIGxldCB0b19wdWJsaWNfcHJvbWlzZSA6ICgnYSwgXywgXykgcHJvbWlzZSAtPiAnYSB0ID0gT2JqLm1hZ2ljXG4gIGxldCB0b19wdWJsaWNfcmVzb2x2ZXIgOiAoJ2EsIF8sIF8pIHByb21pc2UgLT4gJ2EgdSA9IE9iai5tYWdpY1xuXG4gIHR5cGUgXyBwYWNrZWRfcHJvbWlzZSA9XG4gICAgfCBJbnRlcm5hbCA6ICgnYSwgXywgXykgcHJvbWlzZSAtPiAnYSBwYWNrZWRfcHJvbWlzZVxuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG5cbiAgbGV0IHRvX2ludGVybmFsX3Byb21pc2UgKHAgOiAnYSB0KSA6ICdhIHBhY2tlZF9wcm9taXNlID1cbiAgICBJbnRlcm5hbCAoT2JqLm1hZ2ljIHApXG4gIGxldCB0b19pbnRlcm5hbF9yZXNvbHZlciAociA6ICdhIHUpIDogJ2EgcGFja2VkX3Byb21pc2UgPVxuICAgIEludGVybmFsIChPYmoubWFnaWMgcilcblxuICAoKiBNb3N0IGZ1bmN0aW9ucyB0aGF0IHRha2UgYSBwdWJsaWMgcHJvbWlzZSAoWydhIHRdKSBjb252ZXJ0IGl0IHRvIGFuXG4gICAgIGludGVybmFsIHByb21pc2UgYXMgZm9sbG93czpcblxuICAgICAgICgqIHAgOiAnYSB0ICopXG5cbiAgICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuXG4gICAgICAgKCogcCA6ICgnYSwgdSwgYykgcHJvbWlzZSwgd2hlcmUgdSBhbmQgYyBhcmUgZnJlc2ggdHlwZXMsIGkuZS4gdGhlXG4gICAgICAgICAgaW52YXJpYW50cyBvbiBwIGFyZSB1bmtub3duLiAqKVxuXG4gICAgIFRoaXMgY2FzdCBpcyBhIG5vLW9wIGNhc3QuIEl0IG9ubHkgcHJvZHVjZXMgYSByZWZlcmVuY2Ugd2l0aCBhIGRpZmZlcmVudFxuICAgICB0eXBlLiBUaGUgaW50cm9kdWN0aW9uIGFuZCBpbW1lZGlhdGUgZWxpbWluYXRpb24gb2YgW0ludGVybmFsIF9dIHNlZW1zIHRvXG4gICAgIGJlIG9wdGltaXplZCBhd2F5IGV2ZW4gb24gb2xkZXIgdmVyc2lvbnMgb2YgT0NhbWwgdGhhdCBkb24ndCBoYXZlIEZsYW1iZGFcbiAgICAgYW5kIGRvbid0IHN1cHBvcnQgW1tAQG9jYW1sLnVuYm94ZWRdXS4gKilcblxuICAoKiBUaGlzIGNvdWxkIHByb2JhYmx5IHNhdmUgYW4gYWxsb2NhdGlvbiBieSB1c2luZyBbT2JqLm1hZ2ljXS4gKilcbiAgbGV0IHN0YXRlX29mX3Jlc3VsdCA9IGZ1bmN0aW9uXG4gICAgfCBPayB4IC0+IEZ1bGZpbGxlZCB4XG4gICAgfCBFcnJvciBleG4gLT4gUmVqZWN0ZWQgZXhuXG5lbmRcbmluY2x1ZGUgUHVibGljX3R5cGVzXG5cblxuXG5tb2R1bGUgQmFzaWNfaGVscGVycyA6XG5zaWdcbiAgdmFsIGlkZW50aWNhbCA6ICgnYSwgXywgXykgcHJvbWlzZSAtPiAoJ2EsIF8sIF8pIHByb21pc2UgLT4gYm9vbFxuICB2YWwgdW5kZXJseWluZyA6ICgnYSwgJ3UsICdjKSBwcm9taXNlIC0+ICgnYSwgdW5kZXJseWluZywgJ2MpIHByb21pc2VcblxuICB0eXBlICgnYSwgJ3UsICdjKSBzdGF0ZV9jaGFuZ2VkID1cbiAgICB8IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgb2YgKCdhLCAndSwgJ2MpIHByb21pc2VcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuICB2YWwgc2V0X3Byb21pc2Vfc3RhdGUgOlxuICAgICgnYSwgXywgXykgcHJvbWlzZSAtPiAoJ2EsICd1LCAnYykgc3RhdGUgLT4gKCdhLCAndSwgJ2MpIHN0YXRlX2NoYW5nZWRcblxuICB0eXBlICdhIG1heV9ub3dfYmVfcHJveHkgPVxuICAgIHwgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IDpcbiAgICAgICgnYSwgXywgcGVuZGluZykgcHJvbWlzZSAtPiAnYSBtYXlfbm93X2JlX3Byb3h5XG4gICAgW0BAb2NhbWwudW5ib3hlZF1cbiAgdmFsIG1heV9ub3dfYmVfcHJveHkgOlxuICAgICgnYSwgdW5kZXJseWluZywgcGVuZGluZykgcHJvbWlzZSAtPiAnYSBtYXlfbm93X2JlX3Byb3h5XG5lbmQgPVxuc3RydWN0XG4gICgqIENoZWNrcyBwaHlzaWNhbCBlcXVhbGl0eSAoWz09XSkgb2YgdHdvIGludGVybmFsIHByb21pc2VzLiBVbmxpa2UgWz09XSwgZG9lc1xuICAgICBub3QgZm9yY2UgdW5pZmljYXRpb24gb2YgdGhlaXIgaW52YXJpYW50cy4gKilcbiAgbGV0IGlkZW50aWNhbCBwMSBwMiA9XG4gICAgKHRvX3B1YmxpY19wcm9taXNlIHAxKSA9PSAodG9fcHVibGljX3Byb21pc2UgcDIpXG5cbiAgKCogW3VuZGVybHlpbmcgcF0gZXZhbHVhdGVzIHRvIHRoZSB1bmRlcmx5aW5nIHByb21pc2Ugb2YgW3BdLlxuXG4gICAgIElmIG11bHRpcGxlIFtQcm94eSBfXSBsaW5rcyBhcmUgdHJhdmVyc2VkLCBbdW5kZXJseWluZ10gdXBkYXRlcyBhbGwgdGhlXG4gICAgIHByb3hpZXMgdG8gcG9pbnQgaW1tZWRpYXRlbHkgdG8gdGhlaXIgZmluYWwgdW5kZXJseWluZyBwcm9taXNlLiAqKVxuICBsZXQgcmVjIHVuZGVybHlpbmdcbiAgICAgIDogdHlwZSB1IGMuICgnYSwgdSwgYykgcHJvbWlzZSAtPiAoJ2EsIHVuZGVybHlpbmcsIGMpIHByb21pc2UgPVxuICAgIGZ1biBwIC0+XG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+IChwIDogKF8sIHVuZGVybHlpbmcsIF8pIHByb21pc2UpXG4gICAgfCBSZWplY3RlZCBfIC0+IHBcbiAgICB8IFBlbmRpbmcgXyAtPiBwXG4gICAgfCBQcm94eSBwJyAtPlxuICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcgaW5cbiAgICAgIGlmIG5vdCAoaWRlbnRpY2FsIHAnJyBwJykgdGhlblxuICAgICAgICBwLnN0YXRlIDwtIFByb3h5IHAnJztcbiAgICAgIHAnJ1xuXG5cblxuICB0eXBlICgnYSwgJ3UsICdjKSBzdGF0ZV9jaGFuZ2VkID1cbiAgICB8IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgb2YgKCdhLCAndSwgJ2MpIHByb21pc2VcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuXG4gIGxldCBzZXRfcHJvbWlzZV9zdGF0ZSBwIHN0YXRlID1cbiAgICBsZXQgcCA6IChfLCBfLCBfKSBwcm9taXNlID0gT2JqLm1hZ2ljIHAgaW5cbiAgICBwLnN0YXRlIDwtIHN0YXRlO1xuICAgIFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcFxuXG4gICgqIFtzZXRfcHJvbWlzZV9zdGF0ZSBwIHN0YXRlXSBtdXRhdGVzIHRoZSBzdGF0ZSBvZiBbcF0sIGFuZCBldmFsdWF0ZXMgdG8gYVxuICAgICAod3JhcHBlZCkgcmVmZXJlbmNlIHRvIFtwXSB3aXRoIHRoZSBzYW1lIGludmFyaWFudHMgYXMgb24gW3N0YXRlXS4gVGhlXG4gICAgIG9yaWdpbmFsIHJlZmVyZW5jZSBbcF0gc2hvdWxkIGJlIHNoYWRvd2VkIHdoZW4gY2FsbGluZyB0aGlzIGZ1bmN0aW9uOlxuXG4gICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9IHNldF9wcm9taXNlX3N0YXRlIHAgKEZ1bGZpbGxlZCA0MikgaW4gLi4uXG5cbiAgICAgVGhpcyBpcyBhIGtpbmQgb2YgY2hlYXAgaW1pdGF0aW9uIG9mIGxpbmVhciB0eXBpbmcsIHdoaWNoIGlzIGdvb2QgZW5vdWdoXG4gICAgIGZvciB0aGUgbmVlZHMgb2YgW2x3dC5tbF0uXG5cbiAgICAgSW50ZXJuYWwgZnVuY3Rpb25zIHRoYXQgdHJhbnNpdGl2ZWx5IGNhbGwgW3NldF9wcm9taXNlX3N0YXRlXSBsaWtld2lzZVxuICAgICByZXR1cm4gdGhlIG5ldyByZWZlcmVuY2UuIFRoaXMgZW5kcyBhdCBzb21lIHRvcC1sZXZlbCBmdW5jdGlvbiwgdHlwaWNhbGx5XG4gICAgIGVpdGhlciBhIGNhbGxiYWNrIG9yIGEgZnVuY3Rpb24gaW4gdGhlIHB1YmxpYyBBUEkuIFRoZXJlLCB0aGUgbmV3IHJlZmVyZW5jZVxuICAgICBpcyBzdGlsbCBib3VuZCwgYnV0IGlzIHRoZW4gZXhwbGljaXRseSBpZ25vcmVkLlxuXG4gICAgIFRoZSBzdGF0ZSBvZiBhIHByb21pc2UgaXMgbmV2ZXIgdXBkYXRlZCBkaXJlY3RseSBvdXRzaWRlIHRoaXMgbW9kdWxlXG4gICAgIFtCYXNpY19oZWxwZXJzXS4gQWxsIHVwZGF0ZXMgZWxzZXdoZXJlIGFyZSBkb25lIHRocm91Z2hcbiAgICAgW3NldF9wcm9taXNlX3N0YXRlXS5cblxuICAgICBUbyBhdm9pZCBwcm9ibGVtcyB3aXRoIHR5cGUtbGV2ZWwgaW52YXJpYW50cyBub3QgbWF0Y2hpbmcgcmVhbGl0eSwgZGF0YVxuICAgICBzdHJ1Y3R1cmVzIGRvIG5vdCBzdG9yZSBwcm9taXNlcyB3aXRoIGNvbmNyZXRlIGludmFyaWFudHMgLS0gZXhjZXB0XG4gICAgIHJlc29sdmVkIHByb21pc2VzLCB3aGljaCBhcmUgaW1tdXRhYmxlLiBJbmRlZWQsIGlmIG9uZSBsb29rcyBhdFxuICAgICBkZWZpbml0aW9ucyBvZiBkYXRhIHN0cnVjdHVyZXMgdGhhdCBjYW4gc3RvcmUgcGVuZGluZyBwcm9taXNlcywgZS5nLiB0aGVcbiAgICAgW2hvd190b19jYW5jZWxdIGdyYXBoLCB0aGUgaW52YXJpYW50cyBhcmUgZXhpc3RlbnRpYWxseSBxdWFudGlmaWVkLlxuXG4gICAgIE5vdGU6IGl0J3MgcG9zc2libGUgdG8gc3RhdGljYWxseSBkaXNhbGxvdyB0aGUgc2V0dGluZyBvZiB0aGUgW3N0YXRlXSBmaWVsZFxuICAgICBieSBtYWtpbmcgdHlwZSBbcHJvbWlzZV0gcHJpdmF0ZS4gSG93ZXZlciwgdGhhdCBzZWVtcyB0byByZXF1aXJlIHdyaXRpbmcgYVxuICAgICBzaWduYXR1cmUgdGhhdCBpcyBhIG5lYXItZHVwbGljYXRlIG9mIFtNYWluX2ludGVybmFsX3R5cGVzXSwgb3Igc29tZSBhYnVzZVxuICAgICBvZiBmdW5jdG9ycy4gKilcblxuXG5cbiAgdHlwZSAnYSBtYXlfbm93X2JlX3Byb3h5ID1cbiAgICB8IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSA6XG4gICAgICAoJ2EsIF8sIHBlbmRpbmcpIHByb21pc2UgLT4gJ2EgbWF5X25vd19iZV9wcm94eVxuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG5cbiAgbGV0IG1heV9ub3dfYmVfcHJveHkgcCA9IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwXG5cbiAgKCogTWFueSBmdW5jdGlvbnMsIGZvciBleGFtcGxlIFtMd3QuYmluZF0gYW5kIFtMd3Quam9pbl0sIGNyZWF0ZSBhIGZyZXNoXG4gICAgIHBlbmRpbmcgcHJvbWlzZSBbcF0gYW5kIHJldHVybiBpdCB0byB0aGUgdXNlci5cblxuICAgICBUaGV5IGRvIG5vdCByZXR1cm4gYSBjb3JyZXNwb25kaW5nIHJlc29sdmVyLiBUaGF0IG1lYW5zIHRoYXQgb25seSB0aGVcbiAgICAgZnVuY3Rpb24gaXRzZWxmICh0eXBpY2FsbHksIGEgY2FsbGJhY2sgcmVnaXN0ZXJlZCBieSBpdCkgY2FuIHJlc29sdmUgW3BdLlxuICAgICBUaGUgb25seSB0aGluZyB0aGUgdXNlciBjYW4gZG8gZGlyZWN0bHkgaXMgdHJ5IHRvIGNhbmNlbCBbcF0sIGJ1dCwgc2luY2VcbiAgICAgW3BdIGlzIG5vdCBhbiBpbml0aWFsIHByb21pc2UsIHRoZSBjYW5jZWxsYXRpb24gYXR0ZW1wdCBzaW1wbHkgcHJvcGFnYXRlc1xuICAgICBwYXN0IFtwXSB0byBbcF0ncyBwcmVkZWNlc3NvcnMuIElmIHRoYXQgZXZlbnR1YWxseSByZXN1bHRzIGluIGNhbmNlbGluZ1xuICAgICBbcF0sIGl0IHdpbGwgYmUgdGhyb3VnaCB0aGUgbm9ybWFsIG1lY2hhbmlzbXMgb2YgdGhlIGZ1bmN0aW9uIChlLmcuXG4gICAgIFtMd3QuYmluZF0ncyBjYWxsYmFjaykuXG5cbiAgICAgQXMgYSByZXN1bHQsIHRoZSBvbmx5IHBvc3NpYmxlIHN0YXRlIGNoYW5nZSwgYmVmb3JlIHRoZSBjYWxsYmFjaywgaXMgdGhhdFxuICAgICBbcF0gbWF5IGhhdmUgYmVjb21lIGEgcHJveHkuIE5vdyxcblxuICAgICAtIElmIFtwXSBkb2VzIG5vdCB1bmRlcmdvIHRoaXMgc3RhdGUgY2hhbmdlIGFuZCBiZWNvbWUgYSBwcm94eSwgaXQgcmVtYWluc1xuICAgICAgIGFuIHVuZGVybHlpbmcsIHBlbmRpbmcgcHJvbWlzZS5cbiAgICAgLSBJZiBbcF0gZG9lcyBiZWNvbWUgYSBwcm94eSwgaXQgd2lsbCBiZSBhIHByb3h5IGZvciBhbm90aGVyIHByb21pc2UgW3AnXVxuICAgICAgIGNyZWF0ZWQgZnJlc2ggYnkgW0x3dC5iaW5kXSwgdG8gd2hpY2ggdGhpcyBzYW1lIGFyZ3VtZW50IGFwcGxpZXMuIFNlZVxuICAgICAgIFttYWtlX2ludG9fcHJveHldLlxuXG4gICAgIFNvLCBieSBpbmR1Y3Rpb24gb24gdGhlIGxlbmd0aCBvZiB0aGUgcHJveHkgKFtQcm94eSBfXSkgY2hhaW4sIGF0IHRoZSB0aW1lXG4gICAgIHRoZSBjYWxsYmFjayBpcyBjYWxsZWQsIFtwXSBpcyBlaXRoZXIgYW4gdW5kZXJseWluZywgcGVuZGluZyBwcm9taXNlLCBvciBhXG4gICAgIHByb3h5IGZvciBhIHBlbmRpbmcgcHJvbWlzZS5cblxuICAgICBUaGUgY2FzdFxuXG4gICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluIC4uLlxuXG4gICAgIGVuY29kZXMgdGhlIHBvc3NpYmlsaXR5IG9mIHRoaXMgc3RhdGUgY2hhbmdlLiBJdCByZXBsYWNlcyBhIHJlZmVyZW5jZVxuXG4gICAgICAgcCA6ICgnYSwgdW5kZXJseWluZywgcGVuZGluZylcblxuICAgICB3aXRoXG5cbiAgICAgICBwIDogKCdhLCAkVW5rbm93biwgcGVuZGluZylcblxuICAgICBhbmQgaXMgdHlwaWNhbGx5IHNlZW4gYXQgdGhlIGJlZ2lubmluZyBvZiBjYWxsYmFja3MgcmVnaXN0ZXJlZCBieVxuICAgICBbTHd0LmJpbmRdIGFuZCBzaW1pbGFyIGZ1bmN0aW9ucy5cblxuICAgICBUaGUgY2FzdCBpcyBhIG5vLW9wIGNhc3QuIFRoZSBpbnRyb2R1Y3Rpb24gYW5kIGltbWVkaWF0ZSBlbGltaW5hdGlvbiBvZlxuICAgICBbU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBfXSBzZWVtcyB0byBiZSBvcHRpbWl6ZWQgYXdheSBldmVuIG9uIG9sZCB2ZXJzaW9uc1xuICAgICBvZiBPQ2FtbC4gKilcbmVuZFxub3BlbiBCYXNpY19oZWxwZXJzXG5cbigqIFNtYWxsIGhlbHBlcnMgdG8gYXZvaWQgY2F0Y2hpbmcgb2NhbWwtcnVudGltZSBleGNlcHRpb25zICopXG5tb2R1bGUgRXhjZXB0aW9uX2ZpbHRlciA9IHN0cnVjdFxuICB0eXBlIHQgPSBleG4gLT4gYm9vbFxuICBsZXQgaGFuZGxlX2FsbCA9IGZ1biBfIC0+IHRydWVcbiAgbGV0IGhhbmRsZV9hbGxfZXhjZXB0X3J1bnRpbWUgPSBmdW5jdGlvblxuICAgIHwgT3V0X29mX21lbW9yeSAtPiBmYWxzZVxuICAgIHwgU3RhY2tfb3ZlcmZsb3cgLT4gZmFsc2VcbiAgICB8IF8gLT4gdHJ1ZVxuICBsZXQgdiA9XG4gICAgKCogRGVmYXVsdCB2YWx1ZTogdGhlIGxlZ2FjeSBiZWhhdmlvdXIgdG8gYXZvaWQgYnJlYWtpbmcgcHJvZ3JhbXMgKilcbiAgICByZWYgaGFuZGxlX2FsbFxuICBsZXQgc2V0IGYgPSB2IDo9IGZcbiAgbGV0IHJ1biBlID0gIXYgZVxuZW5kXG5cbm1vZHVsZSBTZXF1ZW5jZV9hc3NvY2lhdGVkX3N0b3JhZ2UgOlxuc2lnXG4gICgqIFB1YmxpYyBpbnRlcmZhY2UgKilcbiAgdHlwZSAndiBrZXlcbiAgdmFsIG5ld19rZXkgOiB1bml0IC0+IF8ga2V5XG4gIHZhbCBnZXQgOiAndiBrZXkgLT4gJ3Ygb3B0aW9uXG4gIHZhbCB3aXRoX3ZhbHVlIDogJ3Yga2V5IC0+ICd2IG9wdGlvbiAtPiAodW5pdCAtPiAnYikgLT4gJ2JcblxuICAoKiBJbnRlcm5hbCBpbnRlcmZhY2UgKilcbiAgdmFsIGN1cnJlbnRfc3RvcmFnZSA6IHN0b3JhZ2UgcmVmXG5lbmQgPVxuc3RydWN0XG4gICgqIFRoZSBpZGVhIGJlaGluZCBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2UgaXMgdG8gcHJlc2VydmUgc29tZSB2YWx1ZXNcbiAgICAgZHVyaW5nIGEgY2FsbCB0byBbYmluZF0gb3Igb3RoZXIgc2VxdWVudGlhbCBjb21wb3NpdGlvbiBvcGVyYXRpb24sIGFuZFxuICAgICByZXN0b3JlIHRob3NlIHZhbHVlcyBpbiB0aGUgY2FsbGJhY2sgZnVuY3Rpb246XG5cbiAgICAgICBMd3Qud2l0aF92YWx1ZSBteV9rZXkgKFNvbWUgXCJmb29cIikgKGZ1biAoKSAtPlxuICAgICAgIHAgPnw9IGZ1biAoKSAtPlxuICAgICAgIGFzc2VydCAoTHd0LmdldCBteV9rZXkgPSBTb21lIFwiZm9vXCIpKVxuICAgICAgICAgKCogV2lsbCBzdWNjZWVkIGV2ZW4gaWYgdGhpcyBjYWxsYmFjayBpcyBjYWxsZWQgbGF0ZXIuICopXG5cbiAgICAgTm90ZSB0aGF0IGl0IGRvZXMgbm90IG1hdHRlciB0aGF0IHRoZSBjYWxsYmFjayBpcyBkZWZpbmVkIHdpdGhpbiBhblxuICAgICBhcmd1bWVudCBvZiBbd2l0aF92YWx1ZV0sIGkuZS4sIHRoaXMgZG9lcyB0aGUgc2FtZTpcblxuICAgICAgIGxldCBmID0gZnVuICgpIC0+IGFzc2VydCAoTHd0LmdldCBteV9rZXkgPSBTb21lIFwiZm9vXCIpIGluXG4gICAgICAgTHd0LndpdGhfdmFsdWUgbXlfa2V5IChTb21lIFwiZm9vXCIpIChmdW4gKCkgLT4gcCA+fD0gZilcblxuICAgICBBbGwgdGhhdCBtYXR0ZXJzIGlzIHRoYXQgdGhlIHRvcC1tb3N0IHNlcXVlbmNpbmcgb3BlcmF0aW9uIChpbiB0aGlzIGNhc2UsXG4gICAgIG1hcCkgaXMgZXhlY3V0ZWQgYnkgdGhhdCBhcmd1bWVudC5cblxuICAgICBUaGlzIGlzIGltcGxlbWVudGVkIHVzaW5nIGEgc2luZ2xlIGdsb2JhbCBoZXRlcm9nZW5lb3VzIGtleS12YWx1ZSBtYXAuXG4gICAgIFNlcXVlbnRpYWwgY29tcG9zaXRpb24gZnVuY3Rpb25zIHNuYXBzaG90IHRoaXMgbWFwIHdoZW4gdGhleSBhcmUgY2FsbGVkLFxuICAgICBhbmQgcmVzdG9yZSB0aGUgc25hcHNob3QgcmlnaHQgYmVmb3JlIGNhbGxpbmcgdGhlIHVzZXIncyBjYWxsYmFjay4gVGhlIHNhbWVcbiAgICAgaGFwcGVucyBmb3IgY2FuY2VsIHRyaWdnZXJzIGFkZGVkIGJ5IFtvbl9jYW5jZWxdLlxuXG4gICAgIE1haW50YWluZXIncyBub3RlOiBJIHRoaW5rIHVzaW5nIHRoaXMgbWVjaGFuaXNtIHNob3VsZCBiZSBkaXNjb3VyYWdlZCBpblxuICAgICBuZXcgY29kZS4gKilcblxuICB0eXBlICd2IGtleSA9IHtcbiAgICBpZCA6IGludDtcbiAgICBtdXRhYmxlIHZhbHVlIDogJ3Ygb3B0aW9uO1xuICB9XG5cbiAgbGV0IG5leHRfa2V5X2lkID0gcmVmIDBcblxuICBsZXQgbmV3X2tleSAoKSA9XG4gICAgbGV0IGlkID0gIW5leHRfa2V5X2lkIGluXG4gICAgbmV4dF9rZXlfaWQgOj0gaWQgKyAxO1xuICAgIHtpZCA9IGlkOyB2YWx1ZSA9IE5vbmV9XG5cbiAgbGV0IGN1cnJlbnRfc3RvcmFnZSA9IHJlZiBTdG9yYWdlX21hcC5lbXB0eVxuXG4gIGxldCBnZXQga2V5ID1cbiAgICBpZiBTdG9yYWdlX21hcC5tZW0ga2V5LmlkICFjdXJyZW50X3N0b3JhZ2UgdGhlbiBiZWdpblxuICAgICAgbGV0IHJlZnJlc2ggPSBTdG9yYWdlX21hcC5maW5kIGtleS5pZCAhY3VycmVudF9zdG9yYWdlIGluXG4gICAgICByZWZyZXNoICgpO1xuICAgICAgbGV0IHZhbHVlID0ga2V5LnZhbHVlIGluXG4gICAgICBrZXkudmFsdWUgPC0gTm9uZTtcbiAgICAgIHZhbHVlXG4gICAgZW5kXG4gICAgZWxzZVxuICAgICAgTm9uZVxuXG4gIGxldCB3aXRoX3ZhbHVlIGtleSB2YWx1ZSBmID1cbiAgICBsZXQgbmV3X3N0b3JhZ2UgPVxuICAgICAgbWF0Y2ggdmFsdWUgd2l0aFxuICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgbGV0IHJlZnJlc2ggPSBmdW4gKCkgLT4ga2V5LnZhbHVlIDwtIHZhbHVlIGluXG4gICAgICAgIFN0b3JhZ2VfbWFwLmFkZCBrZXkuaWQgcmVmcmVzaCAhY3VycmVudF9zdG9yYWdlXG4gICAgICB8IE5vbmUgLT5cbiAgICAgICAgU3RvcmFnZV9tYXAucmVtb3ZlIGtleS5pZCAhY3VycmVudF9zdG9yYWdlXG4gICAgaW5cblxuICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBuZXdfc3RvcmFnZTtcbiAgICB0cnlcbiAgICAgIGxldCByZXN1bHQgPSBmICgpIGluXG4gICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgIHJlc3VsdFxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+XG4gICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgIHJhaXNlIGV4blxuZW5kXG5pbmNsdWRlIFNlcXVlbmNlX2Fzc29jaWF0ZWRfc3RvcmFnZVxuXG5cblxubW9kdWxlIFBlbmRpbmdfY2FsbGJhY2tzIDpcbnNpZ1xuICAoKiBNdXRhdGluZyBjYWxsYmFjayBsaXN0cyBhdHRhY2hlZCB0byBwZW5kaW5nIHByb21pc2VzICopXG4gIHZhbCBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIDpcbiAgICAnYSBjYWxsYmFja3MgLT4gJ2EgcmVndWxhcl9jYWxsYmFjayAtPiB1bml0XG4gIHZhbCBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiA6XG4gICAgJ2EgdCBsaXN0IC0+ICdhIHJlZ3VsYXJfY2FsbGJhY2sgLT4gdW5pdFxuICB2YWwgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX3JlbW92ZV9mdW5jdGlvbiA6XG4gICAgJ2EgdCBsaXN0IC0+ICdhIHJlZ3VsYXJfY2FsbGJhY2sgLT4gY2FuY2VsX2NhbGxiYWNrXG4gIHZhbCBhZGRfY2FuY2VsX2NhbGxiYWNrIDogJ2EgY2FsbGJhY2tzIC0+IGNhbmNlbF9jYWxsYmFjayAtPiB1bml0XG4gIHZhbCBtZXJnZV9jYWxsYmFja3MgOiBmcm9tOidhIGNhbGxiYWNrcyAtPiBpbnRvOidhIGNhbGxiYWNrcyAtPiB1bml0XG5lbmQgPVxuc3RydWN0XG4gIGxldCBjb25jYXRfcmVndWxhcl9jYWxsYmFja3MgbDEgbDIgPVxuICAgIGJlZ2luIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHksIF8gLT4gbDJcbiAgICB8IF8sIFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPiBsMVxuICAgIHwgXywgXyAtPiBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IChsMSwgbDIpXG4gICAgZW5kIFtAb2NhbWwud2FybmluZyBcIi00XCJdXG5cbiAgbGV0IGNvbmNhdF9jYW5jZWxfY2FsbGJhY2tzIGwxIGwyID1cbiAgICBiZWdpbiBtYXRjaCBsMSwgbDIgd2l0aFxuICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHksIF8gLT4gbDJcbiAgICB8IF8sIENhbmNlbF9jYWxsYmFja19saXN0X2VtcHR5IC0+IGwxXG4gICAgfCBfLCBfIC0+IENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCAobDEsIGwyKVxuICAgIGVuZCBbQG9jYW1sLndhcm5pbmcgXCItNFwiXVxuXG4gICgqIEluIGEgY2FsbGJhY2sgbGlzdCwgZmlsdGVycyBvdXQgY2VsbHMgb2YgZXhwbGljaXRseSByZW1vdmFibGUgY2FsbGJhY2tzXG4gICAgIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQuICopXG4gIGxldCByZWMgY2xlYW5fdXBfY2FsbGJhY2tfY2VsbHMgPSBmdW5jdGlvblxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIHtjb250ZW50cyA9IE5vbmV9IC0+XG4gICAgICBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHlcblxuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIHtjb250ZW50cyA9IFNvbWUgX31cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgX1xuICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5IGFzIGNhbGxiYWNrcyAtPlxuICAgICAgY2FsbGJhY2tzXG5cbiAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9jb25jYXQgKGwxLCBsMikgLT5cbiAgICAgIGxldCBsMSA9IGNsZWFuX3VwX2NhbGxiYWNrX2NlbGxzIGwxIGluXG4gICAgICBsZXQgbDIgPSBjbGVhbl91cF9jYWxsYmFja19jZWxscyBsMiBpblxuICAgICAgY29uY2F0X3JlZ3VsYXJfY2FsbGJhY2tzIGwxIGwyXG5cbiAgKCogU2VlIFtjbGVhcl9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19jZWxsXSBhbmQgW21lcmdlX2NhbGxiYWNrc10uICopXG4gIGxldCBjbGVhbnVwX3Rocm90dGxlID0gNDJcblxuICAoKiBFeHBsaWNpdGx5IHJlbW92YWJsZSBjYWxsYmFja3MgYXJlIGFkZGVkIChtYWlubHkpIGJ5IFtMd3QuY2hvb3NlXSBhbmQgaXRzXG4gICAgIHNpbWlsYXIgZnVuY3Rpb25zLiBJbiBbTHd0LmNob29zZSBbcDsgcCddXSwgaWYgW3AnXSByZXNvbHZlcyBmaXJzdCwgdGhlXG4gICAgIGNhbGxiYWNrIGFkZGVkIGJ5IFtMd3QuY2hvb3NlXSB0byBbcF0gaXMgcmVtb3ZlZC5cblxuICAgICBUaGUgcmVtb3ZhbCBpdHNlbGYgaXMgYWNjb21wbGlzaGVkIHdoZW4gdGhpcyBmdW5jdGlvbiBjbGVhcnMgdGhlIHJlZmVyZW5jZVxuICAgICBjZWxsIFtjZWxsXSwgd2hpY2ggY29udGFpbnMgdGhlIHJlZmVyZW5jZSB0byB0aGF0IGNhbGxiYWNrLlxuXG4gICAgIElmIFtwXSBpcyBhIGxvbmctcGVuZGluZyBwcm9taXNlIHRoYXQgcmVwZWF0ZWRseSBwYXJ0aWNpcGF0ZXMgaW5cbiAgICAgW0x3dC5jaG9vc2VdLCBwZXJoYXBzIGluIGEgbG9vcCwgaXQgd2lsbCBhY2N1bXVsYXRlIGEgbGFyZ2UgbnVtYmVyIG9mXG4gICAgIGNsZWFyZWQgcmVmZXJlbmNlIGNlbGxzIGluIHRoaXMgZmFzaGlvbi4gVG8gYXZvaWQgYSBtZW1vcnkgbGVhaywgdGhleSBtdXN0XG4gICAgIGJlIGNsZWFuZWQgdXAuIEhvd2V2ZXIsIHRoZSBjZWxscyBhcmUgbm90IGNsZWFuZWQgdXAgb24gKmV2ZXJ5KiByZW1vdmFsLFxuICAgICBwcmVzdW1hYmx5IGJlY2F1c2Ugc2Nhbm5pbmcgdGhlIGNhbGxiYWNrIGxpc3QgdGhhdCBvZnRlbiwgYW5kIHJlYnVpbGRpbmdcbiAgICAgaXQsIGNhbiBnZXQgZXhwZW5zaXZlLlxuXG4gICAgIENsZWFudXAgaXMgdGhyb3R0bGVkIGJ5IG1haW50YWluaW5nIGEgY291bnRlciwgW2NsZWFudXBzX2RlZmVycmVkXSwgb24gZWFjaFxuICAgICBwZW5kaW5nIHByb21pc2UuIFRoZSBjb3VudGVyIGlzIGluY3JlbWVudGVkIGVhY2ggdGltZSB0aGlzIGZ1bmN0aW9uIHdhbnRzXG4gICAgIHRvIGNsZWFuIHRoZSBjYWxsYmFjayBsaXN0IChyaWdodCBhZnRlciBjbGVhcmluZyBhIGNlbGwpLiBXaGVuIHRoZSBjb3VudGVyXG4gICAgIHJlYWNoZXMgW2NsZWFudXBfdGhyb3R0bGVdLCB0aGUgY2FsbGJhY2sgbGlzdCBpcyBhY3R1YWxseSBzY2FubmVkIGFuZFxuICAgICBjbGVhcmVkIGNhbGxiYWNrIGNlbGxzIGFyZSByZW1vdmVkLiAqKVxuICBsZXQgY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfY2VsbCBjZWxsIH5vcmlnaW5hbGx5X2FkZGVkX3RvOnBzID1cbiAgICBjZWxsIDo9IE5vbmU7XG5cbiAgICAoKiBHbyB0aHJvdWdoIHRoZSBwcm9taXNlcyB0aGUgY2VsbCBoYWQgb3JpZ2luYWxseSBiZWVuIGFkZGVkIHRvLCBhbmQgZWl0aGVyXG4gICAgICAgZGVmZXIgYSBjbGVhbnVwLCBvciBhY3R1YWxseSBjbGVhbiB1cCB0aGVpciBjYWxsYmFjayBsaXN0cy4gKilcbiAgICBwcyB8PiBMaXN0Lml0ZXIgKGZ1biBwIC0+XG4gICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgKCogU29tZSBvZiB0aGUgcHJvbWlzZXMgbWF5IGFscmVhZHkgaGF2ZSBiZWVuIHJlc29sdmVkIGF0IHRoZSB0aW1lIHRoaXNcbiAgICAgICAgIGZ1bmN0aW9uIGlzIGNhbGxlZC4gKilcbiAgICAgIHwgRnVsZmlsbGVkIF8gLT4gKClcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPiAoKVxuXG4gICAgICB8IFBlbmRpbmcgY2FsbGJhY2tzIC0+XG4gICAgICAgIG1hdGNoIGNhbGxiYWNrcy5yZWd1bGFyX2NhbGxiYWNrcyB3aXRoXG4gICAgICAgICgqIElmIHRoZSBwcm9taXNlIGhhcyBvbmx5IG9uZSByZWd1bGFyIGNhbGxiYWNrLCBhbmQgaXQgaXMgcmVtb3ZhYmxlLCBpdFxuICAgICAgICAgICBtdXN0IGhhdmUgYmVlbiB0aGUgY2VsbCBjbGVhcmVkIGluIHRoaXMgZnVuY3Rpb24sIGFib3ZlLiBJbiB0aGF0XG4gICAgICAgICAgIGNhc2UsIGp1c3Qgc2V0IGl0cyBjYWxsYmFjayBsaXN0IHRvIGVtcHR5LiAqKVxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFjayBfIC0+XG4gICAgICAgICAgY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzIDwtIFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9lbXB0eVxuXG4gICAgICAgICgqIE1haW50YWluZXIncyBub3RlOiBJIHRoaW5rIHRoaXMgZnVuY3Rpb24gc2hvdWxkbid0IHRyeSB0byB0cmlnZ2VyIGFcbiAgICAgICAgICAgY2xlYW51cCBpbiB0aGUgZmlyc3QgdHdvIGNhc2VzLCBidXQgSSBhbSBwcmVzZXJ2aW5nIHRoZW0gZm9yIG5vdywgYXNcbiAgICAgICAgICAgdGhpcyBpcyBob3cgdGhlIGNvZGUgd2FzIHdyaXR0ZW4gaW4gdGhlIHBhc3QuICopXG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2VtcHR5XG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBfXG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCBfIC0+XG4gICAgICAgICAgbGV0IGNsZWFudXBzX2RlZmVycmVkID0gY2FsbGJhY2tzLmNsZWFudXBzX2RlZmVycmVkICsgMSBpblxuICAgICAgICAgIGlmIGNsZWFudXBzX2RlZmVycmVkID4gY2xlYW51cF90aHJvdHRsZSB0aGVuIGJlZ2luXG4gICAgICAgICAgICBjYWxsYmFja3MuY2xlYW51cHNfZGVmZXJyZWQgPC0gMDtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5yZWd1bGFyX2NhbGxiYWNrcyA8LVxuICAgICAgICAgICAgICBjbGVhbl91cF9jYWxsYmFja19jZWxscyBjYWxsYmFja3MucmVndWxhcl9jYWxsYmFja3NcbiAgICAgICAgICBlbmQgZWxzZVxuICAgICAgICAgICAgY2FsbGJhY2tzLmNsZWFudXBzX2RlZmVycmVkIDwtIGNsZWFudXBzX2RlZmVycmVkKVxuXG4gICgqIENvbmNhdGVuYXRlcyBib3RoIGtpbmRzIG9mIGNhbGxiYWNrcyBvbiBbfmZyb21dIHRvIHRoZSBjb3JyZXNwb25kaW5nIGxpc3RzXG4gICAgIG9mIFt+aW50b10uIFRoZSBjYWxsYmFjayBsaXN0cyBvbiBbfmZyb21dIGFyZSAqbm90KiB0aGVuIGNsZWFyZWQsIGJlY2F1c2VcbiAgICAgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQgb25seSBieSBbU2VxdWVudGlhbF9jb21wb3NpdGlvbi5tYWtlX2ludG9fcHJveHldLFxuICAgICB3aGljaCBpbW1lZGlhdGVseSBjaGFuZ2VzIHRoZSBzdGF0ZSBvZiBbfmZyb21dIGFuZCBsb3NlcyByZWZlcmVuY2VzIHRvIHRoZVxuICAgICBvcmlnaW5hbCBjYWxsYmFjayBsaXN0cy5cblxuICAgICBUaGUgW2NsZWFudXBzX2RlZmVycmVkXSBmaWVsZHMgb2YgYm90aCBwcm9taXNlcyBhcmUgc3VtbWVkLCBhbmQgaWYgdGhlIHN1bVxuICAgICBleGNlZWRzIFtjbGVhbnVwX3Rocm90dGxlXSwgYSBjbGVhbnVwIG9mIHJlZ3VsYXIgY2FsbGJhY2tzIGlzIHRyaWdnZXJlZC5cbiAgICAgVGhpcyBpcyB0byBwcmV2ZW50IG1lbW9yeSBsZWFrczsgc2VlXG4gICAgIFtjbGVhcl9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19jZWxsXS4gKilcbiAgbGV0IG1lcmdlX2NhbGxiYWNrcyB+ZnJvbSB+aW50byA9XG4gICAgbGV0IHJlZ3VsYXJfY2FsbGJhY2tzID1cbiAgICAgIGNvbmNhdF9yZWd1bGFyX2NhbGxiYWNrcyBpbnRvLnJlZ3VsYXJfY2FsbGJhY2tzIGZyb20ucmVndWxhcl9jYWxsYmFja3MgaW5cbiAgICBsZXQgY2xlYW51cHNfZGVmZXJyZWQgPSBpbnRvLmNsZWFudXBzX2RlZmVycmVkICsgZnJvbS5jbGVhbnVwc19kZWZlcnJlZCBpblxuXG4gICAgbGV0IHJlZ3VsYXJfY2FsbGJhY2tzLCBjbGVhbnVwc19kZWZlcnJlZCA9XG4gICAgICBpZiBjbGVhbnVwc19kZWZlcnJlZCA+IGNsZWFudXBfdGhyb3R0bGUgdGhlblxuICAgICAgICBjbGVhbl91cF9jYWxsYmFja19jZWxscyByZWd1bGFyX2NhbGxiYWNrcywgMFxuICAgICAgZWxzZVxuICAgICAgICByZWd1bGFyX2NhbGxiYWNrcywgY2xlYW51cHNfZGVmZXJyZWRcbiAgICBpblxuXG4gICAgbGV0IGNhbmNlbF9jYWxsYmFja3MgPVxuICAgICAgY29uY2F0X2NhbmNlbF9jYWxsYmFja3MgaW50by5jYW5jZWxfY2FsbGJhY2tzIGZyb20uY2FuY2VsX2NhbGxiYWNrcyBpblxuXG4gICAgaW50by5yZWd1bGFyX2NhbGxiYWNrcyA8LSByZWd1bGFyX2NhbGxiYWNrcztcbiAgICBpbnRvLmNhbmNlbF9jYWxsYmFja3MgPC0gY2FuY2VsX2NhbGxiYWNrcztcbiAgICBpbnRvLmNsZWFudXBzX2RlZmVycmVkIDwtIGNsZWFudXBzX2RlZmVycmVkXG5cblxuXG4gICgqIEdlbmVyYWwsIGludGVybmFsLCBmdW5jdGlvbiBmb3IgYWRkaW5nIGEgcmVndWxhciBjYWxsYmFjay4gKilcbiAgbGV0IGFkZF9yZWd1bGFyX2NhbGxiYWNrX2xpc3Rfbm9kZSBjYWxsYmFja3Mgbm9kZSA9XG4gICAgY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzIDwtXG4gICAgICBtYXRjaCBjYWxsYmFja3MucmVndWxhcl9jYWxsYmFja3Mgd2l0aFxuICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHkgLT5cbiAgICAgICAgbm9kZVxuICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIF9cbiAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIF9cbiAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2NvbmNhdCBfIGFzIGV4aXN0aW5nIC0+XG4gICAgICAgIFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9jb25jYXQgKG5vZGUsIGV4aXN0aW5nKVxuXG4gIGxldCBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIGNhbGxiYWNrcyBmID1cbiAgICBhZGRfcmVndWxhcl9jYWxsYmFja19saXN0X25vZGVcbiAgICAgIGNhbGxiYWNrcyAoUmVndWxhcl9jYWxsYmFja19saXN0X2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBmKVxuXG4gICgqIEFkZHMgW2NhbGxiYWNrXSBhcyByZW1vdmFibGUgdG8gZWFjaCBwcm9taXNlIGluIFtwc10uIFRoZSBmaXJzdCBwcm9taXNlIGluXG4gICAgIFtwc10gdG8gdHJpZ2dlciBbY2FsbGJhY2tdIHJlbW92ZXMgW2NhbGxiYWNrXSBmcm9tIHRoZSBvdGhlciBwcm9taXNlczsgdGhpc1xuICAgICBndWFyYW50ZWVzIHRoYXQgW2NhbGxiYWNrXSBpcyBjYWxsZWQgYXQgbW9zdCBvbmNlLiBBbGwgdGhlIHByb21pc2VzIGluIFtwc11cbiAgICAgbXVzdCBiZSBwZW5kaW5nLlxuXG4gICAgIFRoaXMgaXMgYW4gaW50ZXJuYWwgZnVuY3Rpb24sIGluZGlyZWN0bHkgdXNlZCBieSB0aGUgaW1wbGVtZW50YXRpb25zIG9mXG4gICAgIFtMd3QuY2hvb3NlXSBhbmQgcmVsYXRlZCBmdW5jdGlvbnMuICopXG4gIGxldCBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfYW5kX2dpdmVfY2VsbCBwcyBmID1cbiAgICBsZXQgcmVjIGNlbGwgPSByZWYgKFNvbWUgc2VsZl9yZW1vdmluZ19jYWxsYmFja193cmFwcGVyKVxuICAgIGFuZCBzZWxmX3JlbW92aW5nX2NhbGxiYWNrX3dyYXBwZXIgcmVzdWx0ID1cbiAgICAgIGNsZWFyX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2NlbGwgY2VsbCB+b3JpZ2luYWxseV9hZGRlZF90bzpwcztcbiAgICAgIGYgcmVzdWx0XG4gICAgaW5cblxuICAgIGxldCBub2RlID0gUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrIGNlbGwgaW5cbiAgICBwcyB8PiBMaXN0Lml0ZXIgKGZ1biBwIC0+XG4gICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgfCBQZW5kaW5nIGNhbGxiYWNrcyAtPiBhZGRfcmVndWxhcl9jYWxsYmFja19saXN0X25vZGUgY2FsbGJhY2tzIG5vZGVcbiAgICAgIHwgRnVsZmlsbGVkIF8gLT4gYXNzZXJ0IGZhbHNlXG4gICAgICB8IFJlamVjdGVkIF8gLT4gYXNzZXJ0IGZhbHNlKTtcblxuICAgIGNlbGxcblxuICBsZXQgYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX3RvX2VhY2hfb2YgcHMgZiA9XG4gICAgaWdub3JlIChhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfYW5kX2dpdmVfY2VsbCBwcyBmKVxuXG4gICgqIFRoaXMgaXMgYmFzaWNhbGx5IGp1c3QgdG8gc3VwcG9ydCBbTHd0LnByb3RlY3RlZF0sIHdoaWNoIG5lZWRzIHRvIHJlbW92ZVxuICAgICB0aGUgY2FsbGJhY2sgaW4gY2lyY3Vtc3RhbmNlcyBvdGhlciB0aGFuIHRoZSBjYWxsYmFjayBiZWluZyBjYWxsZWQuICopXG4gIGxldCBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfYW5kX2dpdmVfcmVtb3ZlX2Z1bmN0aW9uIHBzIGYgPVxuICAgIGxldCBjZWxsID0gYWRkX2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrX2FuZF9naXZlX2NlbGwgcHMgZiBpblxuICAgIGZ1biAoKSAtPlxuICAgICAgY2xlYXJfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfY2VsbCBjZWxsIH5vcmlnaW5hbGx5X2FkZGVkX3RvOnBzXG5cbiAgbGV0IGFkZF9jYW5jZWxfY2FsbGJhY2sgY2FsbGJhY2tzIGYgPVxuICAgIGxldCBub2RlID0gQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY2FsbGJhY2sgKCFjdXJyZW50X3N0b3JhZ2UsIGYpIGluXG5cbiAgICBjYWxsYmFja3MuY2FuY2VsX2NhbGxiYWNrcyA8LVxuICAgICAgbWF0Y2ggY2FsbGJhY2tzLmNhbmNlbF9jYWxsYmFja3Mgd2l0aFxuICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPlxuICAgICAgICBub2RlXG5cbiAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY2FsbGJhY2sgX1xuICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9yZW1vdmVfc2VxdWVuY2Vfbm9kZSBfXG4gICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCBfIC0+XG4gICAgICAgIENhbmNlbF9jYWxsYmFja19saXN0X2NvbmNhdCAobm9kZSwgY2FsbGJhY2tzLmNhbmNlbF9jYWxsYmFja3MpXG5lbmRcbm9wZW4gUGVuZGluZ19jYWxsYmFja3NcblxuXG5cbm1vZHVsZSBSZXNvbHV0aW9uX2xvb3AgOlxuc2lnXG4gICgqIEFsbCB1c2VyLXByb3ZpZGVkIGNhbGxiYWNrcyBhcmUgY2FsbGVkIGJ5IEx3dCBvbmx5IHRocm91Z2ggdGhpcyBtb2R1bGUuIEl0XG4gICAgIHRyYWNrcyB0aGUgY3VycmVudCBjYWxsYmFjayBzdGFjayBkZXB0aCwgYW5kIGRlY2lkZXMgd2hldGhlciBlYWNoIGNhbGxiYWNrXG4gICAgIGNhbGwgc2hvdWxkIGJlIGRlZmVycmVkIG9yIG5vdC4gKilcblxuICAoKiBJbnRlcm5hbCBpbnRlcmZhY2UgdXNlZCBvbmx5IGluIHRoaXMgbW9kdWxlIEx3dCAqKVxuICB2YWwgcmVzb2x2ZSA6XG4gICAgP2FsbG93X2RlZmVycmluZzpib29sIC0+XG4gICAgP21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aDppbnQgLT5cbiAgICAoJ2EsIHVuZGVybHlpbmcsIHBlbmRpbmcpIHByb21pc2UgLT5cbiAgICAnYSByZXNvbHZlZF9zdGF0ZSAtPlxuICAgICAgKCdhLCB1bmRlcmx5aW5nLCByZXNvbHZlZCkgc3RhdGVfY2hhbmdlZFxuXG4gIHZhbCBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW0gOlxuICAgID9hbGxvd19kZWZlcnJpbmc6Ym9vbCAtPlxuICAgID9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGg6aW50IC0+XG4gICAgKCdhIGNhbGxiYWNrcykgLT5cbiAgICAnYSByZXNvbHZlZF9zdGF0ZSAtPlxuICAgICAgdW5pdFxuXG4gIHZhbCBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXQgOlxuICAgID9ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6Ym9vbCAtPlxuICAgIGNhbGxiYWNrOih1bml0IC0+ICdhKSAtPlxuICAgIGlmX2RlZmVycmVkOih1bml0IC0+ICdhICogJ2IgcmVndWxhcl9jYWxsYmFjayAqICdiIHJlc29sdmVkX3N0YXRlKSAtPlxuICAgICAgJ2FcblxuICB2YWwgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgOiAoJ2EgLT4gdW5pdCkgLT4gJ2EgLT4gdW5pdFxuXG4gICgqIEludGVybmFsIGludGVyZmFjZSBleHBvc2VkIHRvIG90aGVyIG1vZHVsZXMgaW4gTHd0ICopXG4gIHZhbCBhYmFuZG9uX3dha2V1cHMgOiB1bml0IC0+IHVuaXRcblxuICAoKiBQdWJsaWMgaW50ZXJmYWNlICopXG4gIGV4Y2VwdGlvbiBDYW5jZWxlZFxuXG4gIHZhbCBhc3luY19leGNlcHRpb25faG9vayA6IChleG4gLT4gdW5pdCkgcmVmXG5lbmQgPVxuc3RydWN0XG4gICgqIFdoZW4gTHd0IG5lZWRzIHRvIGNhbGwgYSBjYWxsYmFjaywgaXQgZW50ZXJzIHRoZSByZXNvbHV0aW9uIGxvb3AuIFRoaXNcbiAgICAgdHlwaWNhbGx5IGhhcHBlbnMgd2hlbiBMd3Qgc2V0cyB0aGUgc3RhdGUgb2Ygb25lIHByb21pc2UgdG8gW0Z1bGZpbGxlZCBfXVxuICAgICBvciBbUmVqZWN0ZWQgX10uIFRoZSBjYWxsYmFja3MgdGhhdCB3ZXJlIGF0dGFjaGVkIHRvIHRoZSBwcm9taXNlIHdoZW4gaXRcbiAgICAgd2FzIHBlbmRpbmcgbXVzdCB0aGVuIGJlIGNhbGxlZC5cblxuICAgICBUaGlzIGFsc28gaGFwcGVucyBpbiBhIGZldyBvdGhlciBzaXR1YXRpb25zLiBGb3IgZXhhbXBsZSwgd2hlbiBbTHd0LmJpbmRdXG4gICAgIGlzIGNhbGxlZCBvbiBhIHByb21pc2UsIGJ1dCB0aGF0IHByb21pc2UgaXMgYWxyZWFkeSByZXNvbHZlZCwgdGhlIGNhbGxiYWNrXG4gICAgIHBhc3NlZCB0byBbYmluZF0gbXVzdCBiZSBjYWxsZWQuXG5cbiAgICAgVGhlIGNhbGxiYWNrcyB0cmlnZ2VyZWQgZHVyaW5nIHRoZSByZXNvbHV0aW9uIGxvb3AgbWlnaHQgcmVzb2x2ZSBtb3JlXG4gICAgIHByb21pc2VzLCB0cmlnZ2VyaW5nIG1vcmUgY2FsbGJhY2tzLCBhbmQgc28gb24uIFRoaXMgaXMgd2hhdCBtYWtlcyB0aGVcbiAgICAgcmVzb2x1dGlvbiBsb29wIGEge2UgbG9vcH0uXG5cbiAgICAgTHd0IGdlbmVyYWxseSB0cmllcyB0byBjYWxsIGVhY2ggY2FsbGJhY2sgaW1tZWRpYXRlbHkuIEhvd2V2ZXIsIHRoaXMgY2FuXG4gICAgIGxlYWQgdG8gYSBwcm9ncmVzc2l2ZSBkZWVwZW5pbmcgb2YgdGhlIGNhbGwgc3RhY2ssIHVudGlsIHRoZXJlIGlzIGEgc3RhY2tcbiAgICAgb3ZlcmZsb3cuIFRoaXMgY2FuJ3QgYmUgYXZvaWRlZCBieSBkb2luZyB0YWlsIGNhbGxzLCBiZWNhdXNlIEx3dCBhbHdheXNcbiAgICAgbmVlZHMgdG8gZG8gZXhjZXB0aW9uIGhhbmRsaW5nIGFyb3VuZCBjYWxsYmFja3MgY2FsbHM6IGVhY2ggY2FsbGJhY2sgY2FsbFxuICAgICBpcyBmb2xsb3dlZCBieSBhbiBleGNlcHRpb24gaGFuZGxlci4gSW5zdGVhZCwgd2hhdCBMd3QgZG9lcyBpcyB0cmFjayB0aGVcbiAgICAgY3VycmVudCBjYWxsYmFjayBjYWxsIGRlcHRoLiBPbmNlIHRoYXQgZGVwdGggcmVhY2hlcyBhIGNlcnRhaW4gbnVtYmVyLFxuICAgICBbZGVmYXVsdF9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGhdLCBkZWZpbmVkIGJlbG93LCBmdXJ0aGVyIGNhbGxiYWNrc1xuICAgICBhcmUgZGVmZXJyZWQgaW50byBhIHF1ZXVlIGluc3RlYWQuIFRoYXQgcXVldWUgaXMgZHJhaW5lZCB3aGVuIEx3dCBleGl0c1xuICAgICBmcm9tIHRoZSB0b3AtbW9zdCBjYWxsYmFjayBjYWxsIHRoYXQgdHJpZ2dlcmVkIHRoZSByZXNvbHV0aW9uIGxvb3AgaW4gdGhlXG4gICAgIGZpcnN0IHBsYWNlLlxuXG4gICAgIFRvIGVuc3VyZSB0aGF0IHRoaXMgZGVmZXJyYWwgbWVjaGFuaXNtIGlzIGFsd2F5cyBwcm9wZXJseSBpbnZva2VkLCBhbGxcbiAgICAgY2FsbGJhY2tzIGNhbGxlZCBieSBMd3QgYXJlIGNhbGxlZCB0aHJvdWdoIG9uZSBvZiB0aHJlZSBmdW5jdGlvbnMgcHJvdmlkZWRcbiAgICAgYnkgdGhpcyBtb2R1bGU6XG5cbiAgICAgLSBbcmVzb2x2ZV0sIHdoaWNoIGNhbGxzIGFsbCB0aGUgY2FsbGJhY2tzIGFzc29jaWF0ZWQgdG8gYSBwZW5kaW5nIHByb21pc2VcbiAgICAgICAoYW5kIHJlc29sdmVzIGl0LCBjaGFuZ2luZyBpdHMgc3RhdGUpLlxuICAgICAtIFtydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1dLCB3aGljaCBpcyBpbnRlcm5hbGx5IHVzZWQgYnkgW3Jlc29sdmVdIHRvXG4gICAgICAgY2FsbCBjYWxsYmFja3MgdGhhdCBhcmUgaW4gYSByZWNvcmQgb2YgdHlwZSBbJ2EgY2FsbGJhY2tzXSwgd2hpY2ggcmVjb3Jkc1xuICAgICAgIGFyZSBhc3NvY2lhdGVkIHdpdGggcGVuZGluZyBwcm9taXNlcy4gVGhpcyBmdW5jdGlvbiBpcyBleHBvc2VkIGJlY2F1c2VcbiAgICAgICB0aGUgY3VycmVudCBpbXBsZW1lbnRhdGlvbiBvZiBbTHd0LmNhbmNlbF0gbmVlZHMgdG8gY2FsbCBpdCBkaXJlY3RseS5cbiAgICAgICBQcm9taXNlIHJlc29sdXRpb24gYW5kIGNhbGxiYWNrIGNhbGxpbmcgYXJlIHNlcGFyYXRlZCBpbiBhIHVuaXF1ZSB3YXkgaW5cbiAgICAgICBbY2FuY2VsXS5cbiAgICAgLSBbcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XSwgd2hpY2ggaXMgdXNlZCBieSBbTHd0LmJpbmRdIGFuZCBzaW1pbGFyXG4gICAgICAgZnVuY3Rpb25zIHRvIGNhbGwgc2luZ2xlIGNhbGxiYWNrcyB3aGVuIHRoZSBwcm9taXNlcyBwYXNzZWQgdG9cbiAgICAgICBbTHd0LmJpbmRdLCBldGMuLCBhcmUgYWxyZWFkeSByZXNvbHZlZC5cblxuICAgICBDdXJyZW50IEx3dCBhY3R1YWxseSBoYXMgYSBtZXNzeSBtaXggb2YgY2FsbGJhY2stY2FsbGluZyBiZWhhdmlvcnMuIEZvclxuICAgICBleGFtcGxlLCBbTHd0LmJpbmRdIGlzIGV4cGVjdGVkIHRvIGFsd2F5cyBjYWxsIGl0cyBjYWxsYmFjayBpbW1lZGlhdGVseSxcbiAgICAgd2hpbGUgW0x3dC53YWtldXBfbGF0ZXJdIGlzIGV4cGVjdGVkIHRvIGRlZmVyIGFsbCBjYWxsYmFja3Mgb2YgdGhlIHByb21pc2VcbiAgICAgcmVzb2x2ZWQsIHtlIHVubGVzc30gTHd0IGlzIG5vdCBhbHJlYWR5IGluc2lkZSB0aGUgcmVzb2x1dGlvbiBsb29wLlxuXG4gICAgIFdlIHBsYW5uZWQgdG8gbWFrZSB0aGVzZSBiZWhhdmlvcnMgdW5pZm9ybSBpbiBMd3QgNC4wLjAsIGJ1dCBkZWNpZGVkXG4gICAgIGFnYWluc3QgaXQgZHVlIHRvIHRoZSByaXNrIG9mIGJyZWFraW5nIHVzZXJzLiBTZWVcblxuICAgICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9wdWxsLzUwMFxuICAgICAtIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9wdWxsLzUxOVxuXG4gICAgIEFzIHBhcnQgb2YgdGhlIHByZXBhcmF0aW9uIGZvciB0aGUgY2hhbmdlLCB0aGUgYWJvdmUgY2FsbGJhY2staW52b2tpbmdcbiAgICAgZnVuY3Rpb25zIHN1cHBvcnQgc2V2ZXJhbCBvcHRpb25hbCBhcmd1bWVudHMgdG8gZW11bGF0ZSB0aGUgdmFyaW91c1xuICAgICBiZWhhdmlvcnMuIFdlIGRlY2lkZWQgbm90IHRvIHJlbW92ZSB0aGlzIG1hY2hpbmVyeSwgYmVjYXVzZSB3ZSBtaWdodCB3YW50XG4gICAgIHRvIGV4cG9zZSBkaWZmZXJlbnQgQVBJcyB0byBMd3QgaW4gdGhlIGZ1dHVyZS5cblxuICAgICAtIFt+YWxsb3dfZGVmZXJyaW5nOmZhbHNlXSBhbGxvd3MgaWdub3JpbmcgdGhlIGNhbGxiYWNrIHN0YWNrIGRlcHRoLCBhbmRcbiAgICAgICBjYWxsaW5nIHRoZSBjYWxsYmFja3MgaW1tZWRpYXRlbHkuIFRoaXMgZW11bGF0ZXMgdGhlIG9sZCByZXNvbHV0aW9uXG4gICAgICAgYmVoYXZpb3IuXG4gICAgIC0gW35tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGg6MV0gYWxsb3dzIGxpbWl0aW5nIHRoZSBkZXB0aCB3aGljaFxuICAgICAgIHRyaWdnZXJzIGRlZmVycmFsIG9uIGEgcGVyLWNhbGwtc2l0ZSBiYXNpcy4gVGhpcyBpcyB1c2VkIGJ5XG4gICAgICAgW0x3dC53YWtldXBfbGF0ZXJdLlxuICAgICAtIFt+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVdIGlzIGxpa2VcbiAgICAgICBbfmFsbG93X2RlZmVycmluZzpmYWxzZV0sIHdoaWNoIGlnbm9yZXMgdGhlIGNhbGxiYWNrIHN0YWNrIGRlcHRoLlxuICAgICAgIEhvd2V2ZXIsIHRvIGVuc3VyZSB0aGF0IHRoZSBjYWxsYmFjayBpcyB0YWlsLWNhbGxlZCwgTHd0IGRvZXNuJ3QgZXZlblxuICAgICAgIHVwZGF0ZSB0aGUgY2FsbGJhY2sgc3RhY2sgZGVwdGggZm9yIHRoZSBiZW5lZml0IG9mICpvdGhlciogY2FsbGJhY2tcbiAgICAgICBjYWxscy4gSXQganVzdCBibGluZGx5IGNhbGxzIHRoZSBjYWxsYmFjay5cblxuICAgICBTZWUgZGlzY3Vzc2lvbiBvZiBjYWxsYmFjay1jYWxsaW5nIHNlbWFudGljcyBpbjpcblxuICAgICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9pc3N1ZXMvMzI5XG5cbiAgICAgKiBDb250ZXh0XG5cbiAgICAgVGhlIHJlc29sdXRpb24gbG9vcCBlZmZlY3RpdmVseSBoYW5kbGVzIGFsbCBwcm9taXNlcyB0aGF0IGNhbiBiZSByZXNvbHZlZFxuICAgICBpbW1lZGlhdGVseSwgd2l0aG91dCBibG9ja2luZyBvbiBJL08uIEEgY29tcGxldGUgcHJvZ3JhbSB0aGF0IGRvZXMgSS9PXG4gICAgIGNhbGxzIFtMd3RfbWFpbi5ydW5dLiBTZWUgXCJObyBJL09cIiBpbiB0aGUgT3ZlcnZpZXcuICopXG5cblxuXG4gIGxldCBhc3luY19leGNlcHRpb25faG9vayA9XG4gICAgcmVmIChmdW4gZXhuIC0+XG4gICAgICBwcmVycl9zdHJpbmcgXCJGYXRhbCBlcnJvcjogZXhjZXB0aW9uIFwiO1xuICAgICAgcHJlcnJfc3RyaW5nIChQcmludGV4Yy50b19zdHJpbmcgZXhuKTtcbiAgICAgIHByZXJyX2NoYXIgJ1xcbic7XG4gICAgICBQcmludGV4Yy5wcmludF9iYWNrdHJhY2Ugc3RkZXJyO1xuICAgICAgZmx1c2ggc3RkZXJyO1xuICAgICAgZXhpdCAyKVxuXG4gIGxldCBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIHYgPVxuICAgICgqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IGNhcmUgaWYgW2ZdIGV2YWx1YXRlcyB0byBhIHByb21pc2UuIEluXG4gICAgICAgcGFydGljdWxhciwgaWYgW2Ygdl0gZXZhbHVhdGVzIHRvIFtwXSBhbmQgW3BdIGlzIGFscmVhZHkgcmVqZWN0ZWQgb3Igd2lsbFxuICAgICAgIGJlIHJlamVjdCBsYXRlciwgaXQgaXMgbm90IHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGlzIGZ1bmN0aW9uIHRvIHBhc3NcbiAgICAgICB0aGUgZXhjZXB0aW9uIHRvIFshYXN5bmNfZXhjZXB0aW9uX2hvb2tdLiAqKVxuICAgIHRyeSBmIHZcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgICAgIWFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4blxuXG5cblxuICBleGNlcHRpb24gQ2FuY2VsZWRcblxuXG5cbiAgKCogUnVucyB0aGUgY2FsbGJhY2tzIChmb3JtZXJseSkgYXNzb2NpYXRlZCB0byBhIHByb21pc2UuIENhbmNlbCBjYWxsYmFja3MgYXJlXG4gICAgIHJ1biBmaXJzdCwgaWYgdGhlIHByb21pc2Ugd2FzIGNhbmNlbGVkLiBUaGVzZSBhcmUgZm9sbG93ZWQgYnkgcmVndWxhclxuICAgICBjYWxsYmFja3MuXG5cbiAgICAgVGhlIHJlYXNvbiBmb3IgdGhlIFwiZm9ybWVybHlcIiBpcyB0aGF0IHRoZSBwcm9taXNlJ3Mgc3RhdGUgaGFzIGFscmVhZHkgYmVlblxuICAgICBzZXQgdG8gW0Z1bGZpbGxlZCBfXSBvciBbUmVqZWN0ZWQgX10sIHNvIHRoZSBjYWxsYmFja3MgYXJlIG5vIGxvbmdlclxuICAgICByZWFjaGFibGUgdGhyb3VnaCB0aGUgcHJvbWlzZSByZWZlcmVuY2UuIFRoaXMgaXMgd2h5IHRoZSBkaXJlY3QgW2NhbGxiYWNrc11cbiAgICAgcmVjb3JkIG11c3QgYmUgZ2l2ZW4gdG8gdGhpcyBmdW5jdGlvbi4gKilcbiAgbGV0IHJ1bl9jYWxsYmFja3NcbiAgICAgIChjYWxsYmFja3MgOiAnYSBjYWxsYmFja3MpXG4gICAgICAocmVzdWx0IDogJ2EgcmVzb2x2ZWRfc3RhdGUpIDogdW5pdCA9XG5cbiAgICBsZXQgcnVuX2NhbmNlbF9jYWxsYmFja3MgZnMgPVxuICAgICAgbGV0IHJlYyBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgcmVzdCA9XG4gICAgICAgIG1hdGNoIGZzIHdpdGhcbiAgICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eSAtPlxuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfY2FsbGJhY2sgKHN0b3JhZ2UsIGYpIC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHN0b3JhZ2U7XG4gICAgICAgICAgaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiAoKTtcbiAgICAgICAgICBpdGVyX2xpc3QgcmVzdFxuICAgICAgICB8IENhbmNlbF9jYWxsYmFja19saXN0X3JlbW92ZV9zZXF1ZW5jZV9ub2RlIG5vZGUgLT5cbiAgICAgICAgICBMd3Rfc2VxdWVuY2UucmVtb3ZlIG5vZGU7XG4gICAgICAgICAgaXRlcl9saXN0IHJlc3RcbiAgICAgICAgfCBDYW5jZWxfY2FsbGJhY2tfbGlzdF9jb25jYXQgKGZzLCBmcycpIC0+XG4gICAgICAgICAgaXRlcl9jYWxsYmFja19saXN0IGZzIChmcyc6OnJlc3QpXG5cbiAgICAgIGFuZCBpdGVyX2xpc3QgcmVzdCA9XG4gICAgICAgIG1hdGNoIHJlc3Qgd2l0aFxuICAgICAgICB8IFtdIC0+ICgpXG4gICAgICAgIHwgZnM6OnJlc3QgLT4gaXRlcl9jYWxsYmFja19saXN0IGZzIHJlc3RcblxuICAgICAgaW5cblxuICAgICAgaXRlcl9jYWxsYmFja19saXN0IGZzIFtdXG4gICAgaW5cblxuICAgIGxldCBydW5fcmVndWxhcl9jYWxsYmFja3MgZnMgPVxuICAgICAgbGV0IHJlYyBpdGVyX2NhbGxiYWNrX2xpc3QgZnMgcmVzdCA9XG4gICAgICAgIG1hdGNoIGZzIHdpdGhcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHkgLT5cbiAgICAgICAgICBpdGVyX2xpc3QgcmVzdFxuICAgICAgICB8IFJlZ3VsYXJfY2FsbGJhY2tfbGlzdF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgZiAtPlxuICAgICAgICAgIGYgcmVzdWx0O1xuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrXG4gICAgICAgICAgICB7Y29udGVudHMgPSBOb25lfSAtPlxuICAgICAgICAgIGl0ZXJfbGlzdCByZXN0XG4gICAgICAgIHwgUmVndWxhcl9jYWxsYmFja19saXN0X2V4cGxpY2l0bHlfcmVtb3ZhYmxlX2NhbGxiYWNrXG4gICAgICAgICAgICB7Y29udGVudHMgPSBTb21lIGZ9IC0+XG4gICAgICAgICAgZiByZXN1bHQ7XG4gICAgICAgICAgaXRlcl9saXN0IHJlc3RcbiAgICAgICAgfCBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfY29uY2F0IChmcywgZnMnKSAtPlxuICAgICAgICAgIGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyAoZnMnOjpyZXN0KVxuXG4gICAgICBhbmQgaXRlcl9saXN0IHJlc3QgPVxuICAgICAgICBtYXRjaCByZXN0IHdpdGhcbiAgICAgICAgfCBbXSAtPiAoKVxuICAgICAgICB8IGZzOjpyZXN0IC0+IGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyByZXN0XG5cbiAgICAgIGluXG5cbiAgICAgIGl0ZXJfY2FsbGJhY2tfbGlzdCBmcyBbXVxuICAgIGluXG5cbiAgICAoKiBQYXR0ZXJuIG1hdGNoaW5nIGlzIG11Y2ggZmFzdGVyIHRoYW4gcG9seW1vcnBoaWMgY29tcGFyaXNvbi4gKilcbiAgICBsZXQgaXNfY2FuY2VsZWQgPVxuICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgIHwgUmVqZWN0ZWQgQ2FuY2VsZWQgLT4gdHJ1ZVxuICAgICAgfCBSZWplY3RlZCBfIC0+IGZhbHNlXG4gICAgICB8IEZ1bGZpbGxlZCBfIC0+IGZhbHNlXG4gICAgaW5cbiAgICBpZiBpc19jYW5jZWxlZCB0aGVuXG4gICAgICBydW5fY2FuY2VsX2NhbGxiYWNrcyBjYWxsYmFja3MuY2FuY2VsX2NhbGxiYWNrcztcbiAgICBydW5fcmVndWxhcl9jYWxsYmFja3MgY2FsbGJhY2tzLnJlZ3VsYXJfY2FsbGJhY2tzXG5cblxuXG4gIGxldCBkZWZhdWx0X21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA9IDQyXG5cbiAgbGV0IGN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA9IHJlZiAwXG5cbiAgdHlwZSBkZWZlcnJlZF9jYWxsYmFja3MgPVxuICAgIERlZmVycmVkIDogKCdhIGNhbGxiYWNrcyAqICdhIHJlc29sdmVkX3N0YXRlKSAtPiBkZWZlcnJlZF9jYWxsYmFja3NcbiAgICBbQEBvY2FtbC51bmJveGVkXVxuXG4gIGxldCBkZWZlcnJlZF9jYWxsYmFja3MgOiBkZWZlcnJlZF9jYWxsYmFja3MgUXVldWUudCA9IFF1ZXVlLmNyZWF0ZSAoKVxuXG4gICgqIEJlZm9yZSBlbnRlcmluZyBhIHJlc29sdXRpb24gbG9vcCwgaXQgaXMgbmVjZXNzYXJ5IHRvIHRha2UgYSBzbmFwc2hvdCBvZlxuICAgICB0aGUgY3VycmVudCBzdGF0ZSBvZiBzZXF1ZW5jZS1hc3NvY2lhdGVkIHN0b3JhZ2UuIFRoaXMgaXMgYmVjYXVzZSBtYW55IG9mXG4gICAgIHRoZSBjYWxsYmFja3MgdGhhdCB3aWxsIGJlIHJ1biB3aWxsIG1vZGlmeSB0aGUgc3RvcmFnZS4gVGhlIHN0b3JhZ2UgaXNcbiAgICAgcmVzdG9yZWQgdG8gdGhlIHNuYXBzaG90IHdoZW4gdGhlIHJlc29sdXRpb24gbG9vcCBpcyBleGl0ZWQuICopXG4gIGxldCBlbnRlcl9yZXNvbHV0aW9uX2xvb3AgKCkgPVxuICAgIGN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA6PSAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoICsgMTtcbiAgICBsZXQgc3RvcmFnZV9zbmFwc2hvdCA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cbiAgICBzdG9yYWdlX3NuYXBzaG90XG5cbiAgbGV0IGxlYXZlX3Jlc29sdXRpb25fbG9vcCAoc3RvcmFnZV9zbmFwc2hvdCA6IHN0b3JhZ2UpIDogdW5pdCA9XG4gICAgaWYgIWN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aCA9IDEgdGhlbiBiZWdpblxuICAgICAgd2hpbGUgbm90IChRdWV1ZS5pc19lbXB0eSBkZWZlcnJlZF9jYWxsYmFja3MpIGRvXG4gICAgICAgIGxldCBEZWZlcnJlZCAoY2FsbGJhY2tzLCByZXN1bHQpID0gUXVldWUucG9wIGRlZmVycmVkX2NhbGxiYWNrcyBpblxuICAgICAgICBydW5fY2FsbGJhY2tzIGNhbGxiYWNrcyByZXN1bHRcbiAgICAgIGRvbmVcbiAgICBlbmQ7XG4gICAgY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIDo9ICFjdXJyZW50X2NhbGxiYWNrX25lc3RpbmdfZGVwdGggLSAxO1xuICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzdG9yYWdlX3NuYXBzaG90XG5cbiAgbGV0IHJ1bl9pbl9yZXNvbHV0aW9uX2xvb3AgZiA9XG4gICAgbGV0IHN0b3JhZ2Vfc25hcHNob3QgPSBlbnRlcl9yZXNvbHV0aW9uX2xvb3AgKCkgaW5cbiAgICBsZXQgcmVzdWx0ID0gZiAoKSBpblxuICAgIGxlYXZlX3Jlc29sdXRpb25fbG9vcCBzdG9yYWdlX3NuYXBzaG90O1xuICAgIHJlc3VsdFxuXG4gICgqIFRoaXMgaXMgYmFzaWNhbGx5IGEgaGFjayB0byBmaXggaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2lzc3Vlcy80OC5cbiAgICAgSWYgY3VycmVudGx5IHJlc29sdmluZyBwcm9taXNlcywgaXQgaW1tZWRpYXRlbHkgZXhpdHMgYWxsIHJlY3Vyc2l2ZVxuICAgICBlbnRyaWVzIG9mIHRoZSByZXNvbHV0aW9uIGxvb3AsIGdvZXMgdG8gdGhlIHRvcCBsZXZlbCwgcnVucyBhbnkgZGVmZXJyZWRcbiAgICAgY2FsbGJhY2tzLCBhbmQgZXhpdHMgdGhlIHRvcC1sZXZlbCByZXNvbHV0aW9uIGxvb3AuXG5cbiAgICAgVGhlIG5hbWUgc2hvdWxkIHByb2JhYmx5IGJlIFthYmFvbmRvbl9yZXNvbHV0aW9uX2xvb3BdLiAqKVxuICBsZXQgYWJhbmRvbl93YWtldXBzICgpID1cbiAgICBpZiAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoIDw+IDAgdGhlblxuICAgICAgbGVhdmVfcmVzb2x1dGlvbl9sb29wIFN0b3JhZ2VfbWFwLmVtcHR5XG5cblxuXG4gIGxldCBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1cbiAgICAgID8oYWxsb3dfZGVmZXJyaW5nID0gdHJ1ZSlcbiAgICAgID8obWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoID0gZGVmYXVsdF9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGgpXG4gICAgICBjYWxsYmFja3MgcmVzdWx0ID1cblxuICAgIGxldCBzaG91bGRfZGVmZXIgPVxuICAgICAgYWxsb3dfZGVmZXJyaW5nXG4gICAgICAmJiAhY3VycmVudF9jYWxsYmFja19uZXN0aW5nX2RlcHRoID49IG1heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aFxuICAgIGluXG5cbiAgICBpZiBzaG91bGRfZGVmZXIgdGhlblxuICAgICAgUXVldWUucHVzaCAoRGVmZXJyZWQgKGNhbGxiYWNrcywgcmVzdWx0KSkgZGVmZXJyZWRfY2FsbGJhY2tzXG4gICAgZWxzZVxuICAgICAgcnVuX2luX3Jlc29sdXRpb25fbG9vcCAoZnVuICgpIC0+XG4gICAgICAgIHJ1bl9jYWxsYmFja3MgY2FsbGJhY2tzIHJlc3VsdClcblxuICBsZXQgcmVzb2x2ZSA/YWxsb3dfZGVmZXJyaW5nID9tYXhpbXVtX2NhbGxiYWNrX25lc3RpbmdfZGVwdGggcCByZXN1bHQgPVxuICAgIGxldCBQZW5kaW5nIGNhbGxiYWNrcyA9IHAuc3RhdGUgaW5cbiAgICBsZXQgcCA9IHNldF9wcm9taXNlX3N0YXRlIHAgcmVzdWx0IGluXG5cbiAgICBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1cbiAgICAgID9hbGxvd19kZWZlcnJpbmcgP21heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aCBjYWxsYmFja3MgcmVzdWx0O1xuXG4gICAgcFxuXG4gIGxldCBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgID8ocnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsID0gZmFsc2UpXG4gICAgICB+Y2FsbGJhY2s6ZlxuICAgICAgfmlmX2RlZmVycmVkID1cblxuICAgIGlmIHJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbCB0aGVuXG4gICAgICBmICgpXG5cbiAgICBlbHNlXG4gICAgICBsZXQgc2hvdWxkX2RlZmVyID1cbiAgICAgICAgIWN1cnJlbnRfY2FsbGJhY2tfbmVzdGluZ19kZXB0aFxuICAgICAgICAgID49IGRlZmF1bHRfbWF4aW11bV9jYWxsYmFja19uZXN0aW5nX2RlcHRoXG4gICAgICBpblxuXG4gICAgICBpZiBzaG91bGRfZGVmZXIgdGhlbiBiZWdpblxuICAgICAgICBsZXQgaW1tZWRpYXRlX3Jlc3VsdCwgZGVmZXJyZWRfY2FsbGJhY2ssIGRlZmVycmVkX3Jlc3VsdCA9XG4gICAgICAgICAgaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgbGV0IGRlZmVycmVkX3JlY29yZCA9XG4gICAgICAgICAge1xuICAgICAgICAgICAgcmVndWxhcl9jYWxsYmFja3MgPVxuICAgICAgICAgICAgICBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrXG4gICAgICAgICAgICAgICAgZGVmZXJyZWRfY2FsbGJhY2s7XG4gICAgICAgICAgICBjYW5jZWxfY2FsbGJhY2tzID0gQ2FuY2VsX2NhbGxiYWNrX2xpc3RfZW1wdHk7XG4gICAgICAgICAgICBob3dfdG9fY2FuY2VsID0gTm90X2NhbmNlbGFibGU7XG4gICAgICAgICAgICBjbGVhbnVwc19kZWZlcnJlZCA9IDBcbiAgICAgICAgICB9XG4gICAgICAgIGluXG4gICAgICAgIFF1ZXVlLnB1c2hcbiAgICAgICAgICAoRGVmZXJyZWQgKGRlZmVycmVkX3JlY29yZCwgZGVmZXJyZWRfcmVzdWx0KSkgZGVmZXJyZWRfY2FsbGJhY2tzO1xuICAgICAgICBpbW1lZGlhdGVfcmVzdWx0XG4gICAgICBlbmRcbiAgICAgIGVsc2VcbiAgICAgICAgcnVuX2luX3Jlc29sdXRpb25fbG9vcCAoZnVuICgpIC0+XG4gICAgICAgICAgZiAoKSlcbmVuZFxuaW5jbHVkZSBSZXNvbHV0aW9uX2xvb3BcblxuXG5cbm1vZHVsZSBSZXNvbHZpbmcgOlxuc2lnXG4gIHZhbCB3YWtldXBfbGF0ZXJfcmVzdWx0IDogJ2EgdSAtPiAoJ2EsIGV4bikgcmVzdWx0IC0+IHVuaXRcbiAgdmFsIHdha2V1cF9sYXRlciA6ICdhIHUgLT4gJ2EgLT4gdW5pdFxuICB2YWwgd2FrZXVwX2xhdGVyX2V4biA6IF8gdSAtPiBleG4gLT4gdW5pdFxuXG4gIHZhbCB3YWtldXBfcmVzdWx0IDogJ2EgdSAtPiAoJ2EsIGV4bikgcmVzdWx0IC0+IHVuaXRcbiAgdmFsIHdha2V1cCA6ICdhIHUgLT4gJ2EgLT4gdW5pdFxuICB2YWwgd2FrZXVwX2V4biA6IF8gdSAtPiBleG4gLT4gdW5pdFxuXG4gIHZhbCBjYW5jZWwgOiAnYSB0IC0+IHVuaXRcbmVuZCA9XG5zdHJ1Y3RcbiAgKCogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZGV2aWF0ZXMgZnJvbSB0aGUgXCJpZGVhbFwiIGNhbGxiYWNrIGRlZmVycmFsXG4gICAgIGJlaGF2aW9yOiBpdCBydW5zIGNhbGxiYWNrcyBkaXJlY3RseSBvbiB0aGUgY3VycmVudCBzdGFjay4gSXQgc2hvdWxkXG4gICAgIHRoZXJlZm9yZSBiZSBwb3NzaWJsZSB0byBjYXVzZSBhIHN0YWNrIG92ZXJmbG93IHVzaW5nIHRoaXMgZnVuY3Rpb24uICopXG4gIGxldCB3YWtldXBfZ2VuZXJhbCBhcGlfZnVuY3Rpb25fbmFtZSByIHJlc3VsdCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9yZXNvbHZlciByIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgUmVqZWN0ZWQgQ2FuY2VsZWQgLT5cbiAgICAgICgpXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgUHJpbnRmLmtzcHJpbnRmIGludmFsaWRfYXJnIFwiTHd0LiVzXCIgYXBpX2Z1bmN0aW9uX25hbWVcbiAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgIFByaW50Zi5rc3ByaW50ZiBpbnZhbGlkX2FyZyBcIkx3dC4lc1wiIGFwaV9mdW5jdGlvbl9uYW1lXG5cbiAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgbGV0IHJlc3VsdCA9IHN0YXRlX29mX3Jlc3VsdCByZXN1bHQgaW5cbiAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPSByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgIGlnbm9yZSBwXG5cbiAgbGV0IHdha2V1cF9yZXN1bHQgciByZXN1bHQgPSB3YWtldXBfZ2VuZXJhbCBcIndha2V1cF9yZXN1bHRcIiByIHJlc3VsdFxuICBsZXQgd2FrZXVwIHIgdiA9IHdha2V1cF9nZW5lcmFsIFwid2FrZXVwXCIgciAoT2sgdilcbiAgbGV0IHdha2V1cF9leG4gciBleG4gPSB3YWtldXBfZ2VuZXJhbCBcIndha2V1cF9leG5cIiByIChFcnJvciBleG4pXG5cbiAgbGV0IHdha2V1cF9sYXRlcl9nZW5lcmFsIGFwaV9mdW5jdGlvbl9uYW1lIHIgcmVzdWx0ID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Jlc29sdmVyIHIgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBSZWplY3RlZCBDYW5jZWxlZCAtPlxuICAgICAgKClcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICBQcmludGYua3NwcmludGYgaW52YWxpZF9hcmcgXCJMd3QuJXNcIiBhcGlfZnVuY3Rpb25fbmFtZVxuICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgUHJpbnRmLmtzcHJpbnRmIGludmFsaWRfYXJnIFwiTHd0LiVzXCIgYXBpX2Z1bmN0aW9uX25hbWVcblxuICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICBsZXQgcmVzdWx0ID0gc3RhdGVfb2ZfcmVzdWx0IHJlc3VsdCBpblxuICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgIHJlc29sdmUgfm1heGltdW1fY2FsbGJhY2tfbmVzdGluZ19kZXB0aDoxIHAgcmVzdWx0IGluXG4gICAgICBpZ25vcmUgcFxuXG4gIGxldCB3YWtldXBfbGF0ZXJfcmVzdWx0IHIgcmVzdWx0ID1cbiAgICB3YWtldXBfbGF0ZXJfZ2VuZXJhbCBcIndha2V1cF9sYXRlcl9yZXN1bHRcIiByIHJlc3VsdFxuICBsZXQgd2FrZXVwX2xhdGVyIHIgdiA9XG4gICAgd2FrZXVwX2xhdGVyX2dlbmVyYWwgXCJ3YWtldXBfbGF0ZXJcIiByIChPayB2KVxuICBsZXQgd2FrZXVwX2xhdGVyX2V4biByIGV4biA9XG4gICAgd2FrZXVwX2xhdGVyX2dlbmVyYWwgXCJ3YWtldXBfbGF0ZXJfZXhuXCIgciAoRXJyb3IgZXhuKVxuXG5cblxuICB0eXBlIHBhY2tlZF9jYWxsYmFja3MgPVxuICAgIHwgUGFja2VkIDogXyBjYWxsYmFja3MgLT4gcGFja2VkX2NhbGxiYWNrc1xuICAgIFtAQG9jYW1sLnVuYm94ZWRdXG5cbiAgKCogTm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gZGV2aWF0ZXMgZnJvbSB0aGUgXCJpZGVhbFwiIGNhbGxiYWNrIGRlZmVycmFsXG4gICAgIGJlaGF2aW9yOiBpdCBydW5zIGNhbGxiYWNrcyBkaXJlY3RseSBvbiB0aGUgY3VycmVudCBzdGFjay4gSXQgc2hvdWxkXG4gICAgIHRoZXJlZm9yZSBiZSBwb3NzaWJsZSB0byBjYXVzZSBhIHN0YWNrIG92ZXJmbG93IHVzaW5nIHRoaXMgZnVuY3Rpb24uICopXG4gIGxldCBjYW5jZWwgcCA9XG4gICAgbGV0IGNhbmNlbGVkX3Jlc3VsdCA9IFJlamVjdGVkIENhbmNlbGVkIGluXG5cbiAgICAoKiBXYWxrcyB0aGUgcHJvbWlzZSBkZXBlbmRlbmN5IGdyYXBoIGJhY2t3YXJkcywgbG9va2luZyBmb3IgY2FuY2VsYWJsZVxuICAgICAgIGluaXRpYWwgcHJvbWlzZXMsIGFuZCBjYW5jZWxzIChvbmx5KSB0aGVtLlxuXG4gICAgICAgRm91bmQgaW5pdGlhbCBwcm9taXNlcyBhcmUgY2FuY2VsZWQgaW1tZWRpYXRlbHksIGFzIHRoZXkgYXJlIGZvdW5kLCBieVxuICAgICAgIHNldHRpbmcgdGhlaXIgc3RhdGUgdG8gW1JlamVjdGVkIENhbmNlbGVkXS4gVGhpcyBpcyB0byBwcmV2ZW50IHRoZW0gZnJvbVxuICAgICAgIGJlaW5nIFwiZm91bmQgdHdpY2VcIiBpZiB0aGV5IGFyZSByZWFjaGFibGUgYnkgdHdvIG9yIG1vcmUgZGlzdGluY3QgcGF0aHNcbiAgICAgICB0aHJvdWdoIHRoZSBwcm9taXNlIGRlcGVuZGVuY3kgZ3JhcGguXG5cbiAgICAgICBUaGUgY2FsbGJhY2tzIG9mIHRoZXNlIGluaXRpYWwgcHJvbWlzZXMgYXJlIHRoZW4gcnVuLCBpbiBhIHNlcGFyYXRlXG4gICAgICAgcGhhc2UuIFRoZXNlIGNhbGxiYWNrcyBwcm9wYWdhdGUgY2FuY2VsbGF0aW9uIGZvcndhcmRzIHRvIGFueSBkZXBlbmRlbnRcbiAgICAgICBwcm9taXNlcy4gU2VlIFwiQ2FuY2VsbGF0aW9uXCIgaW4gdGhlIE92ZXJ2aWV3LiAqKVxuICAgIGxldCBwcm9wYWdhdGVfY2FuY2VsIDogKF8sIF8sIF8pIHByb21pc2UgLT4gcGFja2VkX2NhbGxiYWNrcyBsaXN0ID1cbiAgICAgICAgZnVuIHAgLT5cbiAgICAgIGxldCByZWMgY2FuY2VsX2FuZF9jb2xsZWN0X2NhbGxiYWNrcyA6XG4gICAgICAgICAgJ2EgJ3UgJ2MuIHBhY2tlZF9jYWxsYmFja3MgbGlzdCAtPiAoJ2EsICd1LCAnYykgcHJvbWlzZSAtPlxuICAgICAgICAgICAgcGFja2VkX2NhbGxiYWNrcyBsaXN0ID1cbiAgICAgICAgICBmdW4gKHR5cGUgYykgY2FsbGJhY2tzX2FjY3VtdWxhdG9yIChwIDogKF8sIF8sIGMpIHByb21pc2UpIC0+XG5cbiAgICAgICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cbiAgICAgICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgICAgICgqIElmIHRoZSBwcm9taXNlIGlzIG5vdCBzdGlsbCBwZW5kaW5nLCBpdCBjYW4ndCBiZSBjYW5jZWxlZC4gKilcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgIGNhbGxiYWNrc19hY2N1bXVsYXRvclxuICAgICAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICAgICBjYWxsYmFja3NfYWNjdW11bGF0b3JcblxuICAgICAgICB8IFBlbmRpbmcgY2FsbGJhY2tzIC0+XG4gICAgICAgICAgbWF0Y2ggY2FsbGJhY2tzLmhvd190b19jYW5jZWwgd2l0aFxuICAgICAgICAgIHwgTm90X2NhbmNlbGFibGUgLT5cbiAgICAgICAgICAgIGNhbGxiYWNrc19hY2N1bXVsYXRvclxuICAgICAgICAgIHwgQ2FuY2VsX3RoaXNfcHJvbWlzZSAtPlxuICAgICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgICAgICAgIHNldF9wcm9taXNlX3N0YXRlIHAgY2FuY2VsZWRfcmVzdWx0IGluXG4gICAgICAgICAgICBpZ25vcmUgcDtcbiAgICAgICAgICAgIChQYWNrZWQgY2FsbGJhY2tzKTo6Y2FsbGJhY2tzX2FjY3VtdWxhdG9yXG4gICAgICAgICAgfCBQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwJyAtPlxuICAgICAgICAgICAgY2FuY2VsX2FuZF9jb2xsZWN0X2NhbGxiYWNrcyBjYWxsYmFja3NfYWNjdW11bGF0b3IgcCdcbiAgICAgICAgICB8IFByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcyAtPlxuICAgICAgICAgICAgTGlzdC5mb2xkX2xlZnQgY2FuY2VsX2FuZF9jb2xsZWN0X2NhbGxiYWNrcyBjYWxsYmFja3NfYWNjdW11bGF0b3IgcHNcbiAgICAgIGluXG4gICAgICBjYW5jZWxfYW5kX2NvbGxlY3RfY2FsbGJhY2tzIFtdIHBcbiAgICBpblxuXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgY2FsbGJhY2tzID0gcHJvcGFnYXRlX2NhbmNlbCBwIGluXG5cbiAgICBjYWxsYmFja3MgfD4gTGlzdC5pdGVyIChmdW4gKFBhY2tlZCBjYWxsYmFja3MpIC0+XG4gICAgICBydW5fY2FsbGJhY2tzX29yX2RlZmVyX3RoZW1cbiAgICAgICAgfmFsbG93X2RlZmVycmluZzpmYWxzZSBjYWxsYmFja3MgY2FuY2VsZWRfcmVzdWx0KVxuZW5kXG5pbmNsdWRlIFJlc29sdmluZ1xuXG5cblxubW9kdWxlIFRyaXZpYWxfcHJvbWlzZXMgOlxuc2lnXG4gIHZhbCByZXR1cm4gOiAnYSAtPiAnYSB0XG4gIHZhbCBmYWlsIDogZXhuIC0+IF8gdFxuICB2YWwgb2ZfcmVzdWx0IDogKCdhLCBleG4pIHJlc3VsdCAtPiAnYSB0XG5cbiAgdmFsIHJldHVybl91bml0IDogdW5pdCB0XG4gIHZhbCByZXR1cm5fdHJ1ZSA6IGJvb2wgdFxuICB2YWwgcmV0dXJuX2ZhbHNlIDogYm9vbCB0XG4gIHZhbCByZXR1cm5fbm9uZSA6IF8gb3B0aW9uIHRcbiAgdmFsIHJldHVybl9zb21lIDogJ2EgLT4gJ2Egb3B0aW9uIHRcbiAgdmFsIHJldHVybl9vayA6ICdhIC0+ICgnYSwgXykgcmVzdWx0IHRcbiAgdmFsIHJldHVybl9lcnJvciA6ICdlIC0+IChfLCAnZSkgcmVzdWx0IHRcbiAgdmFsIHJldHVybl9uaWwgOiBfIGxpc3QgdFxuXG4gIHZhbCBmYWlsX3dpdGggOiBzdHJpbmcgLT4gXyB0XG4gIHZhbCBmYWlsX2ludmFsaWRfYXJnIDogc3RyaW5nIC0+IF8gdFxuZW5kID1cbnN0cnVjdFxuICBsZXQgcmV0dXJuIHYgPVxuICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IEZ1bGZpbGxlZCB2fVxuXG4gIGxldCBvZl9yZXN1bHQgcmVzdWx0ID1cbiAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSBzdGF0ZV9vZl9yZXN1bHQgcmVzdWx0fVxuXG4gIGxldCBmYWlsIGV4biA9XG4gICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gUmVqZWN0ZWQgZXhufVxuXG4gIGxldCByZXR1cm5fdW5pdCA9IHJldHVybiAoKVxuICBsZXQgcmV0dXJuX25vbmUgPSByZXR1cm4gTm9uZVxuICBsZXQgcmV0dXJuX3NvbWUgeCA9IHJldHVybiAoU29tZSB4KVxuICBsZXQgcmV0dXJuX25pbCA9IHJldHVybiBbXVxuICBsZXQgcmV0dXJuX3RydWUgPSByZXR1cm4gdHJ1ZVxuICBsZXQgcmV0dXJuX2ZhbHNlID0gcmV0dXJuIGZhbHNlXG4gIGxldCByZXR1cm5fb2sgeCA9IHJldHVybiAoT2sgeClcbiAgbGV0IHJldHVybl9lcnJvciB4ID0gcmV0dXJuIChFcnJvciB4KVxuXG4gIGxldCBmYWlsX3dpdGggbXNnID1cbiAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSBSZWplY3RlZCAoRmFpbHVyZSBtc2cpfVxuXG4gIGxldCBmYWlsX2ludmFsaWRfYXJnIG1zZyA9XG4gICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gUmVqZWN0ZWQgKEludmFsaWRfYXJndW1lbnQgbXNnKX1cbmVuZFxuaW5jbHVkZSBUcml2aWFsX3Byb21pc2VzXG5cblxuXG5tb2R1bGUgUGVuZGluZ19wcm9taXNlcyA6XG5zaWdcbiAgKCogSW50ZXJuYWwgKilcbiAgdmFsIG5ld19wZW5kaW5nIDpcbiAgICBob3dfdG9fY2FuY2VsOmhvd190b19jYW5jZWwgLT4gKCdhLCB1bmRlcmx5aW5nLCBwZW5kaW5nKSBwcm9taXNlXG4gIHZhbCBwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgOiBfIHQgbGlzdCAtPiBob3dfdG9fY2FuY2VsXG5cbiAgKCogSW5pdGlhbCBwZW5kaW5nIHByb21pc2VzIChwdWJsaWMpICopXG4gIHZhbCB3YWl0IDogdW5pdCAtPiAnYSB0ICogJ2EgdVxuICB2YWwgdGFzayA6IHVuaXQgLT4gJ2EgdCAqICdhIHVcblxuICB2YWwgYWRkX3Rhc2tfciA6ICdhIHUgTHd0X3NlcXVlbmNlLnQgLT4gJ2EgdFxuICB2YWwgYWRkX3Rhc2tfbCA6ICdhIHUgTHd0X3NlcXVlbmNlLnQgLT4gJ2EgdFxuXG4gIHZhbCBwcm90ZWN0ZWQgOiAnYSB0IC0+ICdhIHRcbiAgdmFsIG5vX2NhbmNlbCA6ICdhIHQgLT4gJ2EgdFxuZW5kID1cbnN0cnVjdFxuICBsZXQgbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWwgPVxuICAgIGxldCBzdGF0ZSA9XG4gICAgICBQZW5kaW5nIHtcbiAgICAgICAgcmVndWxhcl9jYWxsYmFja3MgPSBSZWd1bGFyX2NhbGxiYWNrX2xpc3RfZW1wdHk7XG4gICAgICAgIGNhbmNlbF9jYWxsYmFja3MgPSBDYW5jZWxfY2FsbGJhY2tfbGlzdF9lbXB0eTtcbiAgICAgICAgaG93X3RvX2NhbmNlbDtcbiAgICAgICAgY2xlYW51cHNfZGVmZXJyZWQgPSAwO1xuICAgICAgfVxuICAgIGluXG4gICAge3N0YXRlfVxuXG4gIGxldCBwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMgPVxuICAgICgqIFVzaW5nIGEgZGlydHkgY2FzdCBoZXJlIHRvIGF2b2lkIHJlYnVpbGRpbmcgdGhlIGxpc3QgOiggTm90IGJvdGhlcmluZ1xuICAgICAgIHdpdGggdGhlIGludmFyaWFudHMsIGJlY2F1c2UgW1Byb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbF0gcGFja3MgdGhlbSxcbiAgICAgICBhbmQgY29kZSB0aGF0IG1hdGNoZXMgb24gW1Byb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbF0gZG9lc24ndCBjYXJlIGFib3V0XG4gICAgICAgdGhlbSBhbnl3YXkuICopXG4gICAgbGV0IGNhc3RfcHJvbWlzZV9saXN0IDogJ2EgdCBsaXN0IC0+ICgnYSwgXywgXykgcHJvbWlzZSBsaXN0ID0gT2JqLm1hZ2ljIGluXG4gICAgUHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIChjYXN0X3Byb21pc2VfbGlzdCBwcylcblxuXG5cbiAgbGV0IHdhaXQgKCkgPVxuICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Tm90X2NhbmNlbGFibGUgaW5cbiAgICB0b19wdWJsaWNfcHJvbWlzZSBwLCB0b19wdWJsaWNfcmVzb2x2ZXIgcFxuXG4gIGxldCB0YXNrICgpID1cbiAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOkNhbmNlbF90aGlzX3Byb21pc2UgaW5cbiAgICB0b19wdWJsaWNfcHJvbWlzZSBwLCB0b19wdWJsaWNfcmVzb2x2ZXIgcFxuXG5cblxuXG4gIGxldCBjYXN0X3NlcXVlbmNlX25vZGVcbiAgICAgIChub2RlIDogJ2EgdSBMd3Rfc2VxdWVuY2Uubm9kZSlcbiAgICAgIChfYWN0dWFsX2NvbnRlbnQ6KCdhLCAndSwgJ2MpIHByb21pc2UpXG4gICAgICAgIDogKCdhLCAndSwgJ2MpIHByb21pc2UgTHd0X3NlcXVlbmNlLm5vZGUgPVxuICAgIE9iai5tYWdpYyBub2RlXG5cbiAgbGV0IGFkZF90YXNrX3Igc2VxdWVuY2UgPVxuICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Q2FuY2VsX3RoaXNfcHJvbWlzZSBpblxuICAgIGxldCBub2RlID0gTHd0X3NlcXVlbmNlLmFkZF9yICh0b19wdWJsaWNfcmVzb2x2ZXIgcCkgc2VxdWVuY2UgaW5cbiAgICBsZXQgbm9kZSA9IGNhc3Rfc2VxdWVuY2Vfbm9kZSBub2RlIHAgaW5cblxuICAgIGxldCBQZW5kaW5nIGNhbGxiYWNrcyA9IHAuc3RhdGUgaW5cbiAgICBjYWxsYmFja3MuY2FuY2VsX2NhbGxiYWNrcyA8LVxuICAgICAgQ2FuY2VsX2NhbGxiYWNrX2xpc3RfcmVtb3ZlX3NlcXVlbmNlX25vZGUgbm9kZTtcblxuICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICBsZXQgYWRkX3Rhc2tfbCBzZXF1ZW5jZSA9XG4gICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDpDYW5jZWxfdGhpc19wcm9taXNlIGluXG4gICAgbGV0IG5vZGUgPSBMd3Rfc2VxdWVuY2UuYWRkX2wgKHRvX3B1YmxpY19yZXNvbHZlciBwKSBzZXF1ZW5jZSBpblxuICAgIGxldCBub2RlID0gY2FzdF9zZXF1ZW5jZV9ub2RlIG5vZGUgcCBpblxuXG4gICAgbGV0IFBlbmRpbmcgY2FsbGJhY2tzID0gcC5zdGF0ZSBpblxuICAgIGNhbGxiYWNrcy5jYW5jZWxfY2FsbGJhY2tzIDwtXG4gICAgICBDYW5jZWxfY2FsbGJhY2tfbGlzdF9yZW1vdmVfc2VxdWVuY2Vfbm9kZSBub2RlO1xuXG4gICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG5cblxuICBsZXQgcHJvdGVjdGVkIHAgPVxuICAgIGxldCBJbnRlcm5hbCBwX2ludGVybmFsID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcF9pbnRlcm5hbCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT4gcFxuICAgIHwgUmVqZWN0ZWQgXyAtPiBwXG5cbiAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgbGV0IHAnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Q2FuY2VsX3RoaXNfcHJvbWlzZSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcF9yZXN1bHQgPVxuICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnID0gbWF5X25vd19iZV9wcm94eSBwJyBpblxuICAgICAgICBsZXQgcCcgPSB1bmRlcmx5aW5nIHAnIGluXG4gICAgICAgICgqIEluIHRoaXMgY2FsbGJhY2ssIFtwJ10gd2lsbCBlaXRoZXIgc3RpbGwgaXRzZWxmIGJlIHBlbmRpbmcsIG9yIGl0XG4gICAgICAgICAgIHdpbGwgaGF2ZSBiZWNvbWUgYSBwcm94eSBmb3IgYSBwZW5kaW5nIHByb21pc2UuIFRoZSByZWFzb25pbmcgZm9yXG4gICAgICAgICAgIHRoaXMgaXMgYWxtb3N0IHRoZSBzYW1lIGFzIGluIHRoZSBjb21tZW50IGF0IFttYXlfbm93X2JlX3Byb3h5XS4gVGhlXG4gICAgICAgICAgIGRpZmZlcmVuY2VzIGFyZTpcblxuICAgICAgICAgICAtIFtwJ10gKmlzKiBhbiBpbml0aWFsIHByb21pc2UsIHNvIGl0ICpjYW4qIGdldCBjYW5jZWxlZC4gSG93ZXZlciwgaWZcbiAgICAgICAgICAgICBpdCBkb2VzLCB0aGUgW29uX2NhbmNlbF0gaGFuZGxlciBpbnN0YWxsZWQgYmVsb3cgd2lsbCByZW1vdmUgdGhpc1xuICAgICAgICAgICAgIGNhbGxiYWNrLlxuICAgICAgICAgICAtIFtwJ10gbmV2ZXIgZ2V0cyBwYXNzZWQgdG8gW21ha2VfaW50b19wcm94eV0sIHRoZSBvbmx5IGVmZmVjdCBvZlxuICAgICAgICAgICAgIHdoaWNoIGlzIHRoYXQgaXQgY2Fubm90IGJlIHRoZSB1bmRlcmx5aW5nIHByb21pc2Ugb2YgYW5vdGhlclxuICAgICAgICAgICAgIChwcm94eSkgcHJvbWlzZS4gU28sIFtwJ10gY2FuIG9ubHkgYXBwZWFyIGF0IHRoZSBoZWFkIG9mIGEgY2hhaW4gb2ZcbiAgICAgICAgICAgICBbUHJveHkgX10gbGlua3MsIGFuZCBpdCdzIG5vdCBuZWNlc3NhcnkgdG8gd29ycnkgYWJvdXQgd2hldGhlciB0aGVcbiAgICAgICAgICAgICBpbmR1Y3RpdmUgcmVhc29uaW5nIGF0IFttYXlfbm93X2JlX3Byb3h5XSBhcHBsaWVzLiAqKVxuXG4gICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnID1cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcgcF9yZXN1bHQgaW5cbiAgICAgICAgaWdub3JlIHAnXG4gICAgICBpblxuXG4gICAgICBsZXQgcmVtb3ZlX3RoZV9jYWxsYmFjayA9XG4gICAgICAgIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja19hbmRfZ2l2ZV9yZW1vdmVfZnVuY3Rpb25cbiAgICAgICAgICBbcF0gY2FsbGJhY2tcbiAgICAgIGluXG5cbiAgICAgIGxldCBQZW5kaW5nIHAnX2NhbGxiYWNrcyA9IHAnLnN0YXRlIGluXG4gICAgICBhZGRfY2FuY2VsX2NhbGxiYWNrIHAnX2NhbGxiYWNrcyByZW1vdmVfdGhlX2NhbGxiYWNrO1xuXG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSBwJ1xuXG4gIGxldCBub19jYW5jZWwgcCA9XG4gICAgbGV0IEludGVybmFsIHBfaW50ZXJuYWwgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwX2ludGVybmFsKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPiBwXG4gICAgfCBSZWplY3RlZCBfIC0+IHBcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IHAnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6Tm90X2NhbmNlbGFibGUgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJyA9IG1heV9ub3dfYmVfcHJveHkgcCcgaW5cbiAgICAgICAgbGV0IHAnID0gdW5kZXJseWluZyBwJyBpblxuICAgICAgICAoKiBJbiB0aGlzIGNhbGxiYWNrLCBbcCddIHdpbGwgZWl0aGVyIHN0aWxsIGl0c2VsZiBiZSBwZW5kaW5nLCBvciBpdFxuICAgICAgICAgICB3aWxsIGhhdmUgYmVjb21lIGEgcHJveHkgZm9yIGEgcGVuZGluZyBwcm9taXNlLiBUaGUgcmVhc29uaW5nIGZvclxuICAgICAgICAgICB0aGlzIGlzIGFzIGluIFtwcm90ZWN0ZWRdIGFuZCBbbWF5X25vd19iZV9wcm94eV0sIGJ1dCBldmVuIHNpbXBsZXIsXG4gICAgICAgICAgIGJlY2F1c2UgW3AnXSBpcyBub3QgY2FuY2VsYWJsZS4gKilcblxuICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJyA9XG4gICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnIHBfcmVzdWx0IGluXG4gICAgICAgIGlnbm9yZSBwJ1xuICAgICAgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHAnXG5lbmRcbmluY2x1ZGUgUGVuZGluZ19wcm9taXNlc1xuXG5cblxubW9kdWxlIFNlcXVlbnRpYWxfY29tcG9zaXRpb24gOlxuc2lnXG4gICgqIE1haW4gaW50ZXJmYWNlIChwdWJsaWMpICopXG4gIHZhbCBiaW5kIDogJ2EgdCAtPiAoJ2EgLT4gJ2IgdCkgLT4gJ2IgdFxuICB2YWwgbWFwIDogKCdhIC0+ICdiKSAtPiAnYSB0IC0+ICdiIHRcbiAgZXh0ZXJuYWwgcmVyYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJlcmFpc2VcIlxuICB2YWwgY2F0Y2ggOiAodW5pdCAtPiAnYSB0KSAtPiAoZXhuIC0+ICdhIHQpIC0+ICdhIHRcbiAgdmFsIGZpbmFsaXplIDogKHVuaXQgLT4gJ2EgdCkgLT4gKHVuaXQgLT4gdW5pdCB0KSAtPiAnYSB0XG4gIHZhbCB0cnlfYmluZCA6ICh1bml0IC0+ICdhIHQpIC0+ICgnYSAtPiAnYiB0KSAtPiAoZXhuIC0+ICdiIHQpIC0+ICdiIHRcblxuICAoKiBDYW5jZWwgY2FsbGJhY2tzIChwdWJsaWMpLiAqKVxuICB2YWwgb25fY2FuY2VsIDogJ2EgdCAtPiAodW5pdCAtPiB1bml0KSAtPiB1bml0XG5cbiAgKCogTm9uLXByb21pc2UgY2FsbGJhY2tzIChwdWJsaWMpICopXG4gIHZhbCBvbl9zdWNjZXNzIDogJ2EgdCAtPiAoJ2EgLT4gdW5pdCkgLT4gdW5pdFxuICB2YWwgb25fZmFpbHVyZSA6IF8gdCAtPiAoZXhuIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIG9uX3Rlcm1pbmF0aW9uIDogXyB0IC0+ICh1bml0IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIG9uX2FueSA6ICdhIHQgLT4gKCdhIC0+IHVuaXQpIC0+IChleG4gLT4gdW5pdCkgLT4gdW5pdFxuXG4gICgqIEJhY2t0cmFjZSBzdXBwb3J0IChpbnRlcm5hbDsgZm9yIHVzZSBieSB0aGUgUFBYKSAqKVxuICB2YWwgYmFja3RyYWNlX2JpbmQgOlxuICAgIChleG4gLT4gZXhuKSAtPiAnYSB0IC0+ICgnYSAtPiAnYiB0KSAtPiAnYiB0XG4gIHZhbCBiYWNrdHJhY2VfY2F0Y2ggOlxuICAgIChleG4gLT4gZXhuKSAtPiAodW5pdCAtPiAnYSB0KSAtPiAoZXhuIC0+ICdhIHQpIC0+ICdhIHRcbiAgdmFsIGJhY2t0cmFjZV9maW5hbGl6ZSA6XG4gICAgKGV4biAtPiBleG4pIC0+ICh1bml0IC0+ICdhIHQpIC0+ICh1bml0IC0+IHVuaXQgdCkgLT4gJ2EgdFxuICB2YWwgYmFja3RyYWNlX3RyeV9iaW5kIDpcbiAgICAoZXhuIC0+IGV4bikgLT4gKHVuaXQgLT4gJ2EgdCkgLT4gKCdhIC0+ICdiIHQpIC0+IChleG4gLT4gJ2IgdCkgLT4gJ2IgdFxuZW5kID1cbnN0cnVjdFxuICAoKiBUaGVyZSBhcmUgZml2ZSBwcmltYXJ5IHNlcXVlbnRpYWwgY29tcG9zaXRpb24gZnVuY3Rpb25zOiBbYmluZF0sIFttYXBdLFxuICAgICBbY2F0Y2hdLCBbZmluYWxpemVdLCBhbmQgW3RyeV9iaW5kXS4gT2YgdGhlc2UsIFt0cnlfYmluZF0gaXMgdGhlIG1vc3RcbiAgICAgZ2VuZXJhbCAtLSBhbGwgdGhlIG90aGVycyBjYW4gYmUgaW1wbGVtZW50ZWQgaW4gdGVybXMgb2YgaXQuXG5cbiAgICAgTHd0IGNvbmZsYXRlcyBjb25jdXJyZW5jeSB3aXRoIGVycm9yIHByb3BhZ2F0aW9uLiBJZiBMd3QgZGlkIG5vdCBkbyB0aGlzLFxuICAgICB0aGVyZSB3b3VsZCBiZSBvbmx5IHR3byBwcmltYXJ5IGZ1bmN0aW9uczogW2JpbmRdIGFuZCBbbWFwXSwgYW5kLCBvZiB0aGVzZVxuICAgICB0d28sIFtiaW5kXSBpcyB0aGUgbW9zdCBnZW5lcmFsLiBTaW5jZSBbYmluZF0gaXMgdGhlIG1vc3QgcmVsZXZhbnRcbiAgICAgc3BlY2lmaWNhbGx5IHRvIGNvbmN1cnJlbmN5LCBhbmQgaXMgYWxzbyB0aGUgbW9zdCBmYW1pbGlhciBmdW5jdGlvbiBpbiBMd3QsXG4gICAgIGl0cyBpbXBsZW1lbnRhdGlvbiBzZXJ2ZXMgYXMgYSBraW5kIG9mIFwibW9kZWxcIiBmb3IgdGhlIHJlc3QuIEl0IGlzIHRoZSBtb3N0XG4gICAgIGNvbW1lbnRlZCwgYW5kIGFsbCB0aGUgb3RoZXIgZnVuY3Rpb25zIGZvbGxvdyBhIHNpbWlsYXIgcGF0dGVybiB0byBbYmluZF0uXG5cbiAgICAgRm91ciBvZiB0aGUgcHJpbWFyeSBmdW5jdGlvbnMgaGF2ZSBbYmFja3RyYWNlXypdIHZlcnNpb25zLCB3aGljaCBhcmUgbm90XG4gICAgIHRydWx5IHB1YmxpYywgYW5kIGV4aXN0IHRvIHN1cHBvcnQgdGhlIFBQWC4gW2JhY2t0cmFjZV9tYXBdIGRvZXMgbm90IGV4aXN0XG4gICAgIGJlY2F1c2UgdGhlIFBQWCBkb2VzIG5vdCBuZWVkIGl0LlxuXG4gICAgIFRoZSByZW1haW5pbmcgZm91ciBmdW5jdGlvbnMgaW4gdGhpcyBzZWN0aW9uIGF0dGFjaCBcImxvd2VyLWxldmVsLWlzaFwiXG4gICAgIG5vbi1wcm9taXNlLXByb2R1Y2luZyBjYWxsYmFja3MgdG8gcHJvbWlzZXM6IHRoZXNlIGFyZSB0aGUgW29uXypdXG4gICAgIGZ1bmN0aW9ucy4gT2YgdGhlc2UsIFtvbl9hbnldIGlzIHRoZSBtb3N0IGdlbmVyYWwuIElmIEx3dCBkaWQgbm90IGNvbmZsYXRlXG4gICAgIGNvbmN1cnJlbmN5IHdpdGggZXJyb3IgaGFuZGxpbmcsIHRoZXJlIHdvdWxkIG9ubHkgYmUgb25lOiBbb25fc3VjY2Vzc10uICopXG5cblxuXG4gICgqIE1ha2VzIFt+dXNlcl9wcm92aWRlZF9wcm9taXNlXSBpbnRvIGEgcHJveHkgb2YgW35vdXRlcl9wcm9taXNlXS4gQWZ0ZXJcbiAgICAgW21ha2VfaW50b19wcm94eV0sIHRoZXNlIHR3byBwcm9taXNlIHJlZmVyZW5jZXMgXCJiZWhhdmUgaWRlbnRpY2FsbHkuXCJcblxuICAgICBOb3RlIHRoYXQgdGhpcyBpcyBub3Qgc3ltbWV0cmljOiBbdXNlcl9wcm92aWRlZF9wcm9taXNlXSBhbHdheXMgYmVjb21lcyB0aGVcbiAgICAgcHJveHkuIFttYWtlX2ludG9fcHJveHldIGlzIGNhbGxlZCBvbmx5IGJ5IFtiaW5kXSBhbmQgc2ltaWxhciBmdW5jdGlvbnMgaW5cbiAgICAgdGhpcyBtb2R1bGUuIFRoaXMgbWVhbnMgdGhhdDpcblxuICAgICAtIHRoZSBvbmx5IHdheSBmb3IgYSBwcm9taXNlIHRvIGJlY29tZSBhIHByb3h5IGlzIGJ5IGJlaW5nIHJldHVybmVkIGZyb21cbiAgICAgICB0aGUgY2FsbGJhY2sgZ2l2ZW4gYnkgdGhlIHVzZXIgdG8gW2JpbmRdLCBvciBhIHNpbWlsYXIgZnVuY3Rpb24sIGFuZFxuICAgICAtIHRoZSBvbmx5IHdheSBmb3IgYSBwcm9taXNlIHRvIGJlY29tZSB1bmRlcmx5aW5nIGZvciBhIHByb21pc2Ugb3RoZXIgdGhhblxuICAgICAgIGl0c2VsZiBpcyB0byBiZSB0aGUgb3V0ZXIgcHJvbWlzZSBvcmlnaW5hbGx5IHJldHVybmVkIHRvIHRoZSB1c2VyIGZyb21cbiAgICAgICBbYmluZF0sIG9yIGEgc2ltaWxhciBmdW5jdGlvbi5cblxuICAgICBUaGVzZSB0d28gZmFjdHMgYXJlIGltcG9ydGFudCBmb3IgcmVhc29uaW5nIGFib3V0IGhvdyBhbmQgd2hpY2ggcHJvbWlzZXNcbiAgICAgY2FuIGJlY29tZSBwcm94aWVzLCB1bmRlcmx5aW5nLCBldGMuOyBpbiBwYXJ0aWN1bGFyLCBpdCBpcyB1c2VkIGluIHRoZVxuICAgICBhcmd1bWVudCBpbiBbbWF5X25vd19iZV9wcm94eV0gZm9yIGNvcnJlY3QgcHJlZGljdGlvbnMgYWJvdXQgc3RhdGUgY2hhbmdlcy5cblxuICAgICBbfm91dGVyX3Byb21pc2VdIGlzIGFsd2F5cyBhIHBlbmRpbmcgcHJvbWlzZSB3aGVuIFttYWtlX2ludG9fcHJveHldIGlzXG4gICAgIGNhbGxlZDsgZm9yIHRoZSBleHBsYW5hdGlvbiwgc2VlIFttYXlfbm93X2JlX3Byb3h5XSAodGhvdWdoIHRoZSBjYWxsZXIgb2ZcbiAgICAgW21ha2VfaW50b19wcm94eV0gYWx3YXlzIGNhbGxzIFt1bmRlcmx5aW5nXSBmaXJzdCB0byBwYXNzIHRoZSB1bmRlcmx5aW5nXG4gICAgIHBlbmRpbmcgcHJvbWlzZSB0byBbbWFrZV9pbnRvX3Byb3h5XSkuXG5cbiAgICAgVGhlIHJlYXNvbnMgcHJveHlpbmcgaXMgdXNlZCwgaW5zdGVhZCBvZiBhZGRpbmcgYSBjYWxsYmFjayB0b1xuICAgICBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gdG8gcmVzb2x2ZSBbfm91dGVyX3Byb21pc2VdIHdoZW4gdGhlIGZvcm1lclxuICAgICBiZWNvbWVzIHJlc29sdmVkIHByb2JhYmx5IGFyZTpcblxuICAgICAtIFByb21pc2VzIGhhdmUgbW9yZSBiZWhhdmlvcnMgdGhhbiByZXNvbHV0aW9uLiBPbmUgd291bGQgaGF2ZSB0byBhZGQgYVxuICAgICAgIGNhbmNlbGxhdGlvbiBoYW5kbGVyIHRvIFt+b3V0ZXJfcHJvbWlzZV0gdG8gcHJvcGFnYXRlIHRoZSBjYW5jZWxsYXRpb25cbiAgICAgICBiYWNrIHRvIFt+dXNlcl9wcm92aWRlZF9wcm9taXNlXSwgZm9yIGV4YW1wbGUuIEl0IG1heSBiZSBlYXNpZXIgdG8ganVzdFxuICAgICAgIHRoaW5rIG9mIHRoZW0gYXMgdGhlIHNhbWUgcHJvbWlzZS5cbiAgICAgLSBJZiB1c2luZyBjYWxsYmFja3MsIHJlc29sdmluZyBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gd291bGQgbm90XG4gICAgICAgaW1tZWRpYXRlbHkgcmVzb2x2ZSBbfm91dGVyX3Byb21pc2VdLiBBbm90aGVyIGNhbGxiYWNrIGFkZGVkIHRvXG4gICAgICAgW351c2VyX3Byb3ZpZGVkX3Byb21pc2VdIG1pZ2h0IHNlZSBbfnVzZXJfcHJvdmlkZWRfcHJvbWlzZV0gcmVzb2x2ZWQsXG4gICAgICAgYnV0IFt+b3V0ZXJfcHJvbWlzZV0gc3RpbGwgcGVuZGluZywgZGVwZW5kaW5nIG9uIHRoZSBvcmRlciBpbiB3aGljaFxuICAgICAgIGNhbGxiYWNrcyBhcmUgcnVuLiAqKVxuICBsZXQgbWFrZV9pbnRvX3Byb3h5XG4gICAgICAodHlwZSBjKVxuICAgICAgfihvdXRlcl9wcm9taXNlIDogKCdhLCB1bmRlcmx5aW5nLCBwZW5kaW5nKSBwcm9taXNlKVxuICAgICAgfih1c2VyX3Byb3ZpZGVkX3Byb21pc2UgOiAoJ2EsIF8sIGMpIHByb21pc2UpXG4gICAgICAgIDogKCdhLCB1bmRlcmx5aW5nLCBjKSBzdGF0ZV9jaGFuZ2VkID1cblxuICAgICgqIFVzaW5nIFtwJ10gYXMgaXQncyB0aGUgbmFtZSB1c2VkIGluc2lkZSBbYmluZF0sIGV0Yy4sIGZvciBwcm9taXNlcyB3aXRoXG4gICAgICAgdGhpcyByb2xlIC0tIFtwJ10gaXMgdGhlIHByb21pc2UgcmV0dXJuZWQgYnkgdGhlIHVzZXIncyBmdW5jdGlvbi4gKilcbiAgICBsZXQgcCcgPSB1bmRlcmx5aW5nIHVzZXJfcHJvdmlkZWRfcHJvbWlzZSBpblxuXG4gICAgaWYgaWRlbnRpY2FsIHAnIG91dGVyX3Byb21pc2UgdGhlblxuICAgICAgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJ1xuICAgICAgKCogV2UgcmVhbGx5IHdhbnQgdG8gcmV0dXJuIFtTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIG91dGVyX3Byb21pc2VdLCBidXRcbiAgICAgICAgIHRoZSByZWZlcmVuY2UgdGhyb3VnaCBbcCddIGhhcyB0aGUgcmlnaHQgdHlwZS4gKilcblxuICAgIGVsc2VcbiAgICAgIG1hdGNoIHAnLnN0YXRlIHdpdGhcbiAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIG91dGVyX3Byb21pc2UgcCcuc3RhdGVcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2Ugb3V0ZXJfcHJvbWlzZSBwJy5zdGF0ZVxuXG4gICAgICB8IFBlbmRpbmcgcCdfY2FsbGJhY2tzIC0+XG4gICAgICAgIGxldCBQZW5kaW5nIG91dGVyX2NhbGxiYWNrcyA9IG91dGVyX3Byb21pc2Uuc3RhdGUgaW5cblxuICAgICAgICBtZXJnZV9jYWxsYmFja3MgfmZyb206cCdfY2FsbGJhY2tzIH5pbnRvOm91dGVyX2NhbGxiYWNrcztcbiAgICAgICAgb3V0ZXJfY2FsbGJhY2tzLmhvd190b19jYW5jZWwgPC0gcCdfY2FsbGJhY2tzLmhvd190b19jYW5jZWw7XG5cbiAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcgPVxuICAgICAgICAgIHNldF9wcm9taXNlX3N0YXRlIHAnIChQcm94eSBvdXRlcl9wcm9taXNlKSBpblxuICAgICAgICBpZ25vcmUgcCc7XG5cbiAgICAgICAgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBvdXRlcl9wcm9taXNlXG4gICAgICAgICgqIFRoZSBzdGF0ZSBoYXNuJ3QgYWN0dWFsbHkgY2hhbmdlZCwgYnV0IHdlIHN0aWxsIGhhdmUgdG8gd3JhcFxuICAgICAgICAgICBbb3V0ZXJfcHJvbWlzZV0gZm9yIHR5cGUgY2hlY2tpbmcuICopXG5cbiAgICAgICAgKCogVGhlIHN0YXRlIG9mIFtwJ10gbWF5IGluc3RlYWQgaGF2ZSBjaGFuZ2VkIC0tIGl0IG1heSBoYXZlIGJlY29tZSBhXG4gICAgICAgICAgIHByb3h5LiBIb3dldmVyLCBjYWxsZXJzIG9mIFttYWtlX2ludG9fcHJveHldIGRvbid0IGtub3cgaWZcbiAgICAgICAgICAgW3VzZXJfcHJvdmlkZWRfcHJvbWlzZV0gd2FzIGEgcHJveHkgb3Igbm90ICh0aGF0J3Mgd2h5IHdlIGNhbGxcbiAgICAgICAgICAgdW5kZXJseWluZyBvbiBpdCBhdCB0aGUgdG9wIG9mIHRoaXMgZnVuY3Rpb24sIHRvIGdldCBbcCddKS4gV2UgY2FuXG4gICAgICAgICAgIHRoZXJlZm9yZSB0YWtlIGEgZGFuZ2Vyb3VzIHNob3J0Y3V0IGFuZCBub3QgYm90aGVyIHJldHVybmluZyBhIG5ld1xuICAgICAgICAgICByZWZlcmVuY2UgdG8gW3VzZXJfcHJvdmlkZWRfcHJvbWlzZV0gZm9yIHNoYWRvd2luZy4gKilcblxuXG5cbiAgKCogTWFpbnRhaW5lcidzIG5vdGU6IGEgbG90IG9mIHRoZSBjb2RlIGJlbG93IGNhbiBwcm9iYWJseSBiZSBkZWR1cGxpY2F0ZWQgaW5cbiAgICAgc29tZSB3YXksIGVzcGVjaWFsbHkgaWYgYXNzdW1pbmcgRmxhbWJkYS4gKilcblxuICBsZXQgYmluZCBwIGYgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgICgqIEluIGNhc2UgW0x3dC5iaW5kXSBuZWVkcyB0byBkZWZlciB0aGUgY2FsbCB0byBbZl0sIHRoaXMgZnVuY3Rpb24gd2lsbCBiZVxuICAgICAgIGNhbGxlZCB0byBjcmVhdGU6XG5cbiAgICAgICAxLiBUaGUgcHJvbWlzZSwgW3AnJ10sIHRoYXQgbXVzdCBiZSByZXR1cm5lZCB0byB0aGUgY2FsbGVyIGltbWVkaWF0ZWx5LlxuICAgICAgIDIuIFRoZSBjYWxsYmFjayB0aGF0IHJlc29sdmVzIFtwJyddLlxuXG4gICAgICAgW0x3dC5iaW5kXSBkZWZlcnMgdGhlIGNhbGwgdG8gW2ZdIGluIHR3byBjaXJjdW1zdGFuY2VzOlxuXG4gICAgICAgMS4gVGhlIHByb21pc2UgW3BdIGlzIHBlbmRpbmcuXG4gICAgICAgMi4gVGhlIHByb21pc2UgW3BdIGlzIGZ1bGZpbGxlZCwgYnV0IHRoZSBjdXJyZW50IGNhbGxiYWNrIGNhbGwgbmVzdGluZ1xuICAgICAgICAgIGRlcHRoIGlzIHN1Y2ggdGhhdCB0aGUgY2FsbCB0byBbZl0gbXVzdCBnbyBpbnRvIHRoZSBjYWxsYmFjayBxdWV1ZSwgaW5cbiAgICAgICAgICBvcmRlciB0byBhdm9pZCBzdGFjayBvdmVyZmxvdy5cblxuICAgICAgTWVjaGFuaXNtICgyKSBpcyBjdXJyZW50bHkgZGlzYWJsZWQuIEl0IG1heSBiZSB1c2VkIGluIGFuIGFsdGVybmF0aXZlIEx3dFxuICAgICAgQVBJLlxuXG4gICAgICBGdW5jdGlvbnMgb3RoZXIgdGhhbiBbTHd0LmJpbmRdIGhhdmUgYW5hbG9nb3VzIGRlZmVycmFsIGJlaGF2aW9yLiAqKVxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cbiAgICAgICgqIFRoZSByZXN1bHQgcHJvbWlzZSBpcyBhIGZyZXNoIHBlbmRpbmcgcHJvbWlzZS5cblxuICAgICAgICAgSW5pdGlhbGx5LCB0cnlpbmcgdG8gY2FuY2VsIHRoaXMgZnJlc2ggcGVuZGluZyBwcm9taXNlIFtwJyddIHdpbGxcbiAgICAgICAgIHByb3BhZ2F0ZSB0aGUgY2FuY2VsbGF0aW9uIGF0dGVtcHQgdG8gW3BdIChiYWNrd2FyZHMgdGhyb3VnaCB0aGVcbiAgICAgICAgIHByb21pc2UgZGVwZW5kZW5jeSBncmFwaCkuIElmL3doZW4gW3BdIGlzIGZ1bGZpbGxlZCwgTHd0IHdpbGwgY2FsbCB0aGVcbiAgICAgICAgIHVzZXIncyBjYWxsYmFjayBbZl0gYmVsb3csIHdoaWNoIHdpbGwgcHJvdmlkZSBhIG5ldyBwcm9taXNlIFtwJ10sIGFuZFxuICAgICAgICAgW3AnXSB3aWxsIGJlY29tZSBhIHByb3h5IG9mIFtwJyddLiBBdCB0aGF0IHBvaW50LCB0cnlpbmcgdG8gY2FuY2VsXG4gICAgICAgICBbcCcnXSB3aWxsIGJlIGVxdWl2YWxlbnQgdG8gdHJ5aW5nIHRvIGNhbmNlbCBbcCddLCBzbyB0aGUgYmVoYXZpb3Igd2lsbFxuICAgICAgICAgZGVwZW5kIG9uIGhvdyB0aGUgdXNlciBvYnRhaW5lZCBbcCddLiAqKVxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGYgdiB3aXRoIGV4blxuICAgICAgICAgICAgd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cbiAgICAgICAgICAoKiBSdW4gdGhlIHVzZXIncyBmdW5jdGlvbiBbZl0uICopXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG4gICAgICAgICAgKCogW3AnJ10gd2FzIGFuIHVuZGVybHlpbmcgcHJvbWlzZSB3aGVuIGl0IHdhcyBjcmVhdGVkIGFib3ZlLCBidXQgaXRcbiAgICAgICAgICAgICBtYXkgaGF2ZSBiZWNvbWUgYSBwcm94eSBieSB0aGUgdGltZSB0aGlzIGNvZGUgaXMgYmVpbmcgZXhlY3V0ZWQuXG4gICAgICAgICAgICAgSG93ZXZlciwgaXQgaXMgc3RpbGwgZWl0aGVyIGFuIHVuZGVybHlpbmcgcGVuZGluZyBwcm9taXNlLCBvciBhXG4gICAgICAgICAgICAgcHJveHkgZm9yIGEgcGVuZGluZyBwcm9taXNlLiBUaGVyZWZvcmUsIFttYXlfbm93X2JlX3Byb3h5XSBwcm9kdWNlc1xuICAgICAgICAgICAgIGEgcmVmZXJlbmNlIHdpdGggdGhlIHJpZ2h0IHR5cGUgdmFyaWFibGVzLiBXZSBpbW1lZGlhdGVseSBnZXRcbiAgICAgICAgICAgICBbcCcnXSdzIGN1cnJlbnQgdW5kZXJseWluZyBwcm9taXNlLiAqKVxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgICAgICAoKiBNYWtlIHRoZSBvdXRlciBwcm9taXNlIFtwJyddIGJlaGF2aW9yYWxseSBpZGVudGljYWwgdG8gdGhlIHByb21pc2VcbiAgICAgICAgICAgICBbcCddIHJldHVybmVkIGJ5IFtmXSBieSBtYWtpbmcgW3AnXSBpbnRvIGEgcHJveHkgb2YgW3AnJ10uICopXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHBfcmVzdWx0IC0+XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJycgcF9yZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBmIHYpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgKHAnJywgY2FsbGJhY2spID0gY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcbiAgICAgIHAnJ1xuXG4gIGxldCBiYWNrdHJhY2VfYmluZCBhZGRfbG9jIHAgZiA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGYgdlxuICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT5cbiAgICAgICAgICAgICAgZmFpbCAoYWRkX2xvYyBleG4pIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcnIChSZWplY3RlZCAoYWRkX2xvYyBleG4pKSBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGYgdilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gUmVqZWN0ZWQgKGFkZF9sb2MgZXhuKX1cblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgbWFwIGYgcCA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcnX3Jlc3VsdCA9XG4gICAgICAgICAgICB0cnkgRnVsZmlsbGVkIChmIHYpIHdpdGggZXhuXG4gICAgICAgICAgICB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBSZWplY3RlZCBleG5cbiAgICAgICAgICBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJycgcCcnX3Jlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcF9yZXN1bHQgLT5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgcmVzb2x2ZSB+YWxsb3dfZGVmZXJyaW5nOmZhbHNlIHAnJyBwX3Jlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2VcbiAgICAgICAgICAgIHtzdGF0ZSA9XG4gICAgICAgICAgICAgIHRyeSBGdWxmaWxsZWQgKGYgdilcbiAgICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gUmVqZWN0ZWQgZXhufSlcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgKHAnJywgY2FsbGJhY2spID1cbiAgICAgICAgICAgIGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAocCcnLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPSBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrO1xuICAgICAgcCcnXG5cbiAgZXh0ZXJuYWwgcmVyYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJlcmFpc2VcIlxuXG4gIGxldCBjYXRjaCBmIGggPVxuICAgIGxldCBwID1cbiAgICAgIHRyeSBmICgpXG4gICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgIGluXG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHAnJyA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihQcm9wYWdhdGVfY2FuY2VsX3RvX29uZSBwKSBpblxuXG4gICAgICBsZXQgc2F2ZWRfc3RvcmFnZSA9ICFjdXJyZW50X3N0b3JhZ2UgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHBfcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcF9yZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCBfIGFzIHBfcmVzdWx0IC0+XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwJycgcF9yZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9XG4gICAgICAgICAgICB0cnkgaCBleG5cbiAgICAgICAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG4gICAgICAgICAgaW5cbiAgICAgICAgICBsZXQgSW50ZXJuYWwgcCcgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X25vd19iZV9wZW5kaW5nX3Byb3h5IHAnJyA9IG1heV9ub3dfYmVfcHJveHkgcCcnIGluXG4gICAgICAgICAgbGV0IHAnJyA9IHVuZGVybHlpbmcgcCcnIGluXG5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwJycgPVxuICAgICAgICAgICAgbWFrZV9pbnRvX3Byb3h5IH5vdXRlcl9wcm9taXNlOnAnJyB+dXNlcl9wcm92aWRlZF9wcm9taXNlOnAnIGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuICAgICAgaW5cblxuICAgICAgKHRvX3B1YmxpY19wcm9taXNlIHAnJywgY2FsbGJhY2spXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGggZXhuKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgYmFja3RyYWNlX2NhdGNoIGFkZF9sb2MgZiBoID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cblxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIG1hdGNoIHBfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyBhcyBwX3Jlc3VsdCAtPlxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCcnIHBfcmVzdWx0IGluXG4gICAgICAgICAgaWdub3JlIHAnJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgY3VycmVudF9zdG9yYWdlIDo9IHNhdmVkX3N0b3JhZ2U7XG5cbiAgICAgICAgICBsZXQgcCcgPVxuICAgICAgICAgICAgdHJ5IGggZXhuXG4gICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgICAgICAgICAgICBmYWlsIChhZGRfbG9jIGV4bilcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaCAoYWRkX2xvYyBleG4pKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgdHJ5X2JpbmQgZiBmJyBoID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cblxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIG1hdGNoIHBfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBmJyB2XG4gICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBoIGV4blxuICAgICAgICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG4gICAgICBpblxuXG4gICAgICAodG9fcHVibGljX3Byb21pc2UgcCcnLCBjYWxsYmFjaylcbiAgICBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBmJyB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGggZXhuKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgYmFja3RyYWNlX3RyeV9iaW5kIGFkZF9sb2MgZiBmJyBoID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cblxuICAgIGxldCBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBwJycgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDooUHJvcGFnYXRlX2NhbmNlbF90b19vbmUgcCkgaW5cblxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGxldCBjYWxsYmFjayBwX3Jlc3VsdCA9XG4gICAgICAgIG1hdGNoIHBfcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuXG4gICAgICAgICAgbGV0IHAnID1cbiAgICAgICAgICAgIHRyeSBmJyB2XG4gICAgICAgICAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPlxuICAgICAgICAgICAgICBmYWlsIChhZGRfbG9jIGV4bilcbiAgICAgICAgICBpblxuICAgICAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCcgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcnID0gbWF5X25vd19iZV9wcm94eSBwJycgaW5cbiAgICAgICAgICBsZXQgcCcnID0gdW5kZXJseWluZyBwJycgaW5cblxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnJyA9XG4gICAgICAgICAgICBtYWtlX2ludG9fcHJveHkgfm91dGVyX3Byb21pc2U6cCcnIH51c2VyX3Byb3ZpZGVkX3Byb21pc2U6cCcgaW5cbiAgICAgICAgICBpZ25vcmUgcCcnXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcblxuICAgICAgICAgIGxldCBwJyA9XG4gICAgICAgICAgICB0cnkgaCBleG5cbiAgICAgICAgICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+XG4gICAgICAgICAgICAgIGZhaWwgKGFkZF9sb2MgZXhuKVxuICAgICAgICAgIGluXG4gICAgICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwJycgPSBtYXlfbm93X2JlX3Byb3h5IHAnJyBpblxuICAgICAgICAgIGxldCBwJycgPSB1bmRlcmx5aW5nIHAnJyBpblxuXG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCcnID1cbiAgICAgICAgICAgIG1ha2VfaW50b19wcm94eSB+b3V0ZXJfcHJvbWlzZTpwJycgfnVzZXJfcHJvdmlkZWRfcHJvbWlzZTpwJyBpblxuICAgICAgICAgIGlnbm9yZSBwJydcbiAgICAgIGluXG5cbiAgICAgICh0b19wdWJsaWNfcHJvbWlzZSBwJycsIGNhbGxiYWNrKVxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgICAgfnJ1bl9pbW1lZGlhdGVseV9hbmRfZW5zdXJlX3RhaWxfY2FsbDp0cnVlXG4gICAgICAgIH5jYWxsYmFjazooZnVuICgpIC0+IGYnIHYpXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9XG4gICAgICAgICAgICBjcmVhdGVfcmVzdWx0X3Byb21pc2VfYW5kX2NhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKHAnJywgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaCAoYWRkX2xvYyBleG4pKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCAocCcnLCBjYWxsYmFjaykgPVxuICAgICAgICAgICAgY3JlYXRlX3Jlc3VsdF9wcm9taXNlX2FuZF9jYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgIChwJycsIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IChwJycsIGNhbGxiYWNrKSA9IGNyZWF0ZV9yZXN1bHRfcHJvbWlzZV9hbmRfY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2s7XG4gICAgICBwJydcblxuICBsZXQgZmluYWxpemUgZiBmJyA9XG4gICAgdHJ5X2JpbmQgZlxuICAgICAgKGZ1biB4IC0+IGJpbmQgKGYnICgpKSAoZnVuICgpIC0+IHJldHVybiB4KSlcbiAgICAgIChmdW4gZSAtPiBiaW5kIChmJyAoKSkgKGZ1biAoKSAtPiBmYWlsIGUpKVxuXG4gIGxldCBiYWNrdHJhY2VfZmluYWxpemUgYWRkX2xvYyBmIGYnID1cbiAgICBiYWNrdHJhY2VfdHJ5X2JpbmQgYWRkX2xvYyBmXG4gICAgICAoZnVuIHggLT4gYmluZCAoZicgKCkpIChmdW4gKCkgLT4gcmV0dXJuIHgpKVxuICAgICAgKGZ1biBlIC0+IGJpbmQgKGYnICgpKSAoZnVuICgpIC0+IGZhaWwgKGFkZF9sb2MgZSkpKVxuXG5cblxuICBsZXQgb25fY2FuY2VsIHAgZiA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbWF0Y2ggcC5zdGF0ZSB3aXRoXG4gICAgfCBSZWplY3RlZCBDYW5jZWxlZCAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgICgoKSwgKGZ1biBfIC0+IGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgKCkpLCBGdWxmaWxsZWQgKCkpKVxuXG4gICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICAoKVxuXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgKClcblxuICAgIHwgUGVuZGluZyBjYWxsYmFja3MgLT5cbiAgICAgIGFkZF9jYW5jZWxfY2FsbGJhY2sgY2FsbGJhY2tzIGZcblxuXG5cbiAgbGV0IG9uX3N1Y2Nlc3MgcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGZ1biByZXN1bHQgLT5cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICAgIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGYgdlxuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICAgICgpXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIF8gLT5cbiAgICAgICgpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cbiAgbGV0IG9uX2ZhaWx1cmUgcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGZ1biByZXN1bHQgLT5cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgICgpXG5cbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIGV4blxuICAgIGluXG5cbiAgICBtYXRjaCBwLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAoKVxuXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiBleG4pXG4gICAgICAgIH5pZl9kZWZlcnJlZDooZnVuICgpIC0+XG4gICAgICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgICAgICAoKCksIGNhbGxiYWNrLCBwLnN0YXRlKSlcblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IGNhbGxiYWNrID0gY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2tcblxuICBsZXQgb25fdGVybWluYXRpb24gcCBmID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG5cbiAgICBsZXQgY2FsbGJhY2tfaWZfZGVmZXJyZWQgKCkgPVxuICAgICAgbGV0IHNhdmVkX3N0b3JhZ2UgPSAhY3VycmVudF9zdG9yYWdlIGluXG5cbiAgICAgIGZ1biBfcmVzdWx0IC0+XG4gICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiAoKSlcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgICgoKSwgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBSZWplY3RlZCBfIC0+XG4gICAgICBydW5fY2FsbGJhY2tfb3JfZGVmZXJfaXRcbiAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmICgpKVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICBhZGRfaW1wbGljaXRseV9yZW1vdmVkX2NhbGxiYWNrIHBfY2FsbGJhY2tzIGNhbGxiYWNrXG5cbiAgbGV0IG9uX2FueSBwIGYgZyA9XG4gICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuXG4gICAgbGV0IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpID1cbiAgICAgIGxldCBzYXZlZF9zdG9yYWdlID0gIWN1cnJlbnRfc3RvcmFnZSBpblxuXG4gICAgICBmdW4gcmVzdWx0IC0+XG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjdXJyZW50X3N0b3JhZ2UgOj0gc2F2ZWRfc3RvcmFnZTtcbiAgICAgICAgICBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBmIHZcblxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGN1cnJlbnRfc3RvcmFnZSA6PSBzYXZlZF9zdG9yYWdlO1xuICAgICAgICAgIGhhbmRsZV93aXRoX2FzeW5jX2V4Y2VwdGlvbl9ob29rIGcgZXhuXG4gICAgaW5cblxuICAgIG1hdGNoIHAuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgIHJ1bl9jYWxsYmFja19vcl9kZWZlcl9pdFxuICAgICAgICB+cnVuX2ltbWVkaWF0ZWx5X2FuZF9lbnN1cmVfdGFpbF9jYWxsOnRydWVcbiAgICAgICAgfmNhbGxiYWNrOihmdW4gKCkgLT4gaGFuZGxlX3dpdGhfYXN5bmNfZXhjZXB0aW9uX2hvb2sgZiB2KVxuICAgICAgICB+aWZfZGVmZXJyZWQ6KGZ1biAoKSAtPlxuICAgICAgICAgIGxldCBjYWxsYmFjayA9IGNhbGxiYWNrX2lmX2RlZmVycmVkICgpIGluXG4gICAgICAgICAgKCgpLCBjYWxsYmFjaywgcC5zdGF0ZSkpXG5cbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgcnVuX2NhbGxiYWNrX29yX2RlZmVyX2l0XG4gICAgICAgIH5ydW5faW1tZWRpYXRlbHlfYW5kX2Vuc3VyZV90YWlsX2NhbGw6dHJ1ZVxuICAgICAgICB+Y2FsbGJhY2s6KGZ1biAoKSAtPiBoYW5kbGVfd2l0aF9hc3luY19leGNlcHRpb25faG9vayBnIGV4bilcbiAgICAgICAgfmlmX2RlZmVycmVkOihmdW4gKCkgLT5cbiAgICAgICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgICAgICgoKSwgY2FsbGJhY2ssIHAuc3RhdGUpKVxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgPSBjYWxsYmFja19pZl9kZWZlcnJlZCAoKSBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuZW5kXG5pbmNsdWRlIFNlcXVlbnRpYWxfY29tcG9zaXRpb25cblxuXG4oKiBUaGlzIGJlbG9uZ3Mgd2l0aCB0aGUgW3Byb3RlY3RlZF0gYW5kIHN1Y2gsIGJ1dCBpdCBkZXBlbmRzIG9uIHByaW1pdGl2ZXMgZnJvbVxuICAgW1NlcXVlbnRpYWxfY29tcG9zaXRpb25dLiAqKVxubGV0IHdyYXBfaW5fY2FuY2VsYWJsZSBwID1cbiBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuIGxldCBwX3VuZGVybHlpbmcgPSB1bmRlcmx5aW5nIHBfaW50ZXJuYWwgaW5cbiBtYXRjaCBwX3VuZGVybHlpbmcuc3RhdGUgd2l0aFxuIHwgRnVsZmlsbGVkIF8gLT4gcFxuIHwgUmVqZWN0ZWQgXyAtPiBwXG4gfCBQZW5kaW5nIF8gLT5cbiAgIGxldCBwJywgciA9IHRhc2sgKCkgaW5cbiAgIG9uX2NhbmNlbCBwJyAoZnVuICgpIC0+IGNhbmNlbCBwKTtcbiAgIG9uX2FueSBwICh3YWtldXAgcikgKHdha2V1cF9leG4gcik7XG4gICBwJ1xuXG5cbm1vZHVsZSBDb25jdXJyZW50X2NvbXBvc2l0aW9uIDpcbnNpZ1xuICB2YWwgZG9udF93YWl0IDogKHVuaXQgLT4gXyB0KSAtPiAoZXhuIC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGFzeW5jIDogKHVuaXQgLT4gXyB0KSAtPiB1bml0XG4gIHZhbCBpZ25vcmVfcmVzdWx0IDogXyB0IC0+IHVuaXRcblxuICB2YWwgYm90aCA6ICdhIHQgLT4gJ2IgdCAtPiAoJ2EgKiAnYikgdFxuICB2YWwgam9pbiA6IHVuaXQgdCBsaXN0IC0+IHVuaXQgdFxuICB2YWwgYWxsIDogKCdhIHQpIGxpc3QgLT4gKCdhIGxpc3QpIHRcblxuICB2YWwgY2hvb3NlIDogJ2EgdCBsaXN0IC0+ICdhIHRcbiAgdmFsIHBpY2sgOiAnYSB0IGxpc3QgLT4gJ2EgdFxuXG4gIHZhbCBuY2hvb3NlIDogJ2EgdCBsaXN0IC0+ICdhIGxpc3QgdFxuICB2YWwgbnBpY2sgOiAnYSB0IGxpc3QgLT4gJ2EgbGlzdCB0XG5cbiAgdmFsIG5jaG9vc2Vfc3BsaXQgOiAnYSB0IGxpc3QgLT4gKCdhIGxpc3QgKiAnYSB0IGxpc3QpIHRcbmVuZCA9XG5zdHJ1Y3RcbiAgZXh0ZXJuYWwgcmVyYWlzZSA6IGV4biAtPiAnYSA9IFwiJXJlcmFpc2VcIlxuXG4gIGxldCBkb250X3dhaXQgZiBoID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgKClcbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgaCBleG5cblxuICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgbGV0IGNhbGxiYWNrIHJlc3VsdCA9XG4gICAgICAgIG1hdGNoIHJlc3VsdCB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICAgICAoKVxuICAgICAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgICAgIGggZXhuXG4gICAgICBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuXG4gIGxldCBhc3luYyBmID1cbiAgICBsZXQgcCA9XG4gICAgICB0cnkgZiAoKVxuICAgICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cbiAgICBpblxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG5cbiAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgKClcbiAgICB8IFJlamVjdGVkIGV4biAtPlxuICAgICAgIWFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4blxuXG4gICAgfCBQZW5kaW5nIHBfY2FsbGJhY2tzIC0+XG4gICAgICBsZXQgY2FsbGJhY2sgcmVzdWx0ID1cbiAgICAgICAgbWF0Y2ggcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICAgICgpXG4gICAgICAgIHwgUmVqZWN0ZWQgZXhuIC0+XG4gICAgICAgICAgIWFzeW5jX2V4Y2VwdGlvbl9ob29rIGV4blxuICAgICAgaW5cbiAgICAgIGFkZF9pbXBsaWNpdGx5X3JlbW92ZWRfY2FsbGJhY2sgcF9jYWxsYmFja3MgY2FsbGJhY2tcblxuICBsZXQgaWdub3JlX3Jlc3VsdCBwID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIF8gLT5cbiAgICAgICgpXG4gICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgIHJlcmFpc2UgZXhuXG5cbiAgICB8IFBlbmRpbmcgcF9jYWxsYmFja3MgLT5cbiAgICAgIGxldCBjYWxsYmFjayByZXN1bHQgPVxuICAgICAgICBtYXRjaCByZXN1bHQgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCBfIC0+XG4gICAgICAgICAgKClcbiAgICAgICAgfCBSZWplY3RlZCBleG4gLT5cbiAgICAgICAgICAhYXN5bmNfZXhjZXB0aW9uX2hvb2sgZXhuXG4gICAgICBpblxuICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFja1xuXG5cblxuICBsZXQgam9pbiBwcyA9XG4gICAgbGV0IHAnID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgIGxldCBudW1iZXJfcGVuZGluZ19pbl9wcyA9IHJlZiAwIGluXG4gICAgbGV0IGpvaW5fcmVzdWx0ID0gcmVmIChGdWxmaWxsZWQgKCkpIGluXG5cbiAgICAoKiBDYWxsYmFjayBhdHRhY2hlZCB0byBlYWNoIHByb21pc2UgaW4gW3BzXSB0aGF0IGlzIHN0aWxsIHBlbmRpbmcgYXQgdGhlXG4gICAgICAgdGltZSBbam9pbl0gaXMgY2FsbGVkLiAqKVxuICAgIGxldCBjYWxsYmFjayBuZXdfcmVzdWx0ID1cbiAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCcgPSBtYXlfbm93X2JlX3Byb3h5IHAnIGluXG5cbiAgICAgIGJlZ2luIG1hdGNoIG5ld19yZXN1bHQgd2l0aFxuICAgICAgfCBGdWxmaWxsZWQgKCkgLT4gKClcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgKCogRm9yIHRoZSBmaXJzdCBwcm9taXNlIGluIFtwc10gdG8gYmUgcmVqZWN0ZWQsIHNldCB0aGUgcmVzdWx0IG9mIHRoZVxuICAgICAgICAgW2pvaW5dIHRvIHJlamVjdGVkIHdpdGggdGhlIHNhbWUgZXhjZXB0aW9uLi4gKilcbiAgICAgICAgbWF0Y2ggIWpvaW5fcmVzdWx0IHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgKCkgLT4gam9pbl9yZXN1bHQgOj0gbmV3X3Jlc3VsdFxuICAgICAgICB8IFJlamVjdGVkIF8gLT4gKClcbiAgICAgIGVuZDtcblxuICAgICAgKCogSW4gYWxsIGNhc2VzLCBkZWNyZW1lbnQgdGhlIG51bWJlciBvZiBwcm9taXNlcyBzdGlsbCBwZW5kaW5nLCBhbmRcbiAgICAgICAgIHJlc29sdmUgdGhlIFtqb2luXSBvbmNlIGFsbCBwcm9taXNlcyByZXNvbHZlLiAqKVxuICAgICAgbnVtYmVyX3BlbmRpbmdfaW5fcHMgOj0gIW51bWJlcl9wZW5kaW5nX2luX3BzIC0gMTtcbiAgICAgIGlmICFudW1iZXJfcGVuZGluZ19pbl9wcyA9IDAgdGhlbiBiZWdpblxuICAgICAgICBsZXQgcCcgPSB1bmRlcmx5aW5nIHAnIGluXG4gICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAnID1cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgKHVuZGVybHlpbmcgcCcpICFqb2luX3Jlc3VsdCBpblxuICAgICAgICBpZ25vcmUgcCdcbiAgICAgIGVuZFxuICAgIGluXG5cbiAgICAoKiBBdHRhY2ggdGhlIGFib3ZlIGNhbGxiYWNrLiBTaW11bHRhbmVvdXNseSBjb3VudCBob3cgbWFueSBwZW5kaW5nIHByb21pc2VzXG4gICAgICAgdGhlcmUgYXJlIGluIFtwc10gKGluaXRpYWxseSkuIElmIHRoYXQgbnVtYmVyIGlzIHplcm8sIHRoZSBbam9pbl0gbXVzdFxuICAgICAgIHJlc29sdmUgaW1tZWRpYXRlbHkuICopXG4gICAgbGV0IHJlYyBhdHRhY2hfY2FsbGJhY2tfb3JfcmVzb2x2ZV9pbW1lZGlhdGVseSBwcyA9XG4gICAgICBtYXRjaCBwcyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIGlmICFudW1iZXJfcGVuZGluZ19pbl9wcyA9IDAgdGhlblxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9ICFqb2luX3Jlc3VsdH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHAnXG5cbiAgICAgIHwgcDo6cHMgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgUGVuZGluZyBwX2NhbGxiYWNrcyAtPlxuICAgICAgICAgIG51bWJlcl9wZW5kaW5nX2luX3BzIDo9ICFudW1iZXJfcGVuZGluZ19pbl9wcyArIDE7XG4gICAgICAgICAgYWRkX2ltcGxpY2l0bHlfcmVtb3ZlZF9jYWxsYmFjayBwX2NhbGxiYWNrcyBjYWxsYmFjaztcbiAgICAgICAgICBhdHRhY2hfY2FsbGJhY2tfb3JfcmVzb2x2ZV9pbW1lZGlhdGVseSBwc1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyBwX3Jlc3VsdCAtPlxuICAgICAgICAgICgqIEFzIGluIHRoZSBjYWxsYmFjayBhYm92ZSwgYnV0IGZvciBhbHJlYWR5LXJlc29sdmVkIHByb21pc2VzIGluXG4gICAgICAgICAgICAgW3BzXTogcmVqZWN0IHRoZSBbam9pbl0gd2l0aCB0aGUgc2FtZSBleGNlcHRpb24gYXMgaW4gdGhlIGZpcnN0XG4gICAgICAgICAgICAgcmVqZWN0ZWQgcHJvbWlzZSBmb3VuZC4gW2pvaW5dIHN0aWxsIHdhaXRzIGZvciBhbnkgcGVuZGluZyBwcm9taXNlc1xuICAgICAgICAgICAgIGJlZm9yZSBhY3R1YWxseSByZXNvbHZpbmcsIHRob3VnaC4gKilcbiAgICAgICAgICBiZWdpbiBtYXRjaCAham9pbl9yZXN1bHQgd2l0aFxuICAgICAgICAgIHwgRnVsZmlsbGVkICgpIC0+IGpvaW5fcmVzdWx0IDo9IHBfcmVzdWx0O1xuICAgICAgICAgIHwgUmVqZWN0ZWQgXyAtPiAoKVxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBhdHRhY2hfY2FsbGJhY2tfb3JfcmVzb2x2ZV9pbW1lZGlhdGVseSBwc1xuXG4gICAgICAgIHwgRnVsZmlsbGVkICgpIC0+XG4gICAgICAgICAgYXR0YWNoX2NhbGxiYWNrX29yX3Jlc29sdmVfaW1tZWRpYXRlbHkgcHNcbiAgICBpblxuXG4gICAgYXR0YWNoX2NhbGxiYWNrX29yX3Jlc29sdmVfaW1tZWRpYXRlbHkgcHNcblxuICAoKiB0aGlzIGlzIDMgd29yZHMsIHNtYWxsZXIgdGhhbiB0aGUgMiB0aW1lcyAyIHdvcmRzIGEgcGFpciBvZiByZWZlcmVuY2VzXG4gICAgIHdvdWxkIHRha2UuICopXG4gIHR5cGUgKCdhLCdiKSBwYWlyID0ge1xuICAgIG11dGFibGUgeDE6ICdhIG9wdGlvbjtcbiAgICBtdXRhYmxlIHgyOiAnYiBvcHRpb247XG4gIH1cblxuICBsZXQgYm90aCBwMSBwMiA9XG4gICAgbGV0IHBhaXIgPSB7eDEgPSBOb25lOyB4MiA9IE5vbmV9IGluXG4gICAgbGV0IHAxJyA9IGJpbmQgcDEgKGZ1biB2IC0+IHBhaXIueDEgPC0gU29tZSB2OyByZXR1cm5fdW5pdCkgaW5cbiAgICBsZXQgcDInID0gYmluZCBwMiAoZnVuIHYgLT4gcGFpci54MiA8LSBTb21lIHY7IHJldHVybl91bml0KSBpblxuICAgIGpvaW4gW3AxJzsgcDInXSB8PiBtYXAgKGZ1biAoKSAtPlxuICAgICAgbWF0Y2ggcGFpci54MSwgcGFpci54MiB3aXRoXG4gICAgICB8IFNvbWUgdjEsIFNvbWUgdjIgLT4gdjEsIHYyXG4gICAgICB8IF8gLT4gYXNzZXJ0IGZhbHNlKVxuXG4gIGxldCBhbGwgcHMgPVxuICAgIG1hdGNoIHBzIHdpdGhcbiAgICB8IFtdIC0+IHJldHVybl9uaWxcbiAgICB8IFt4XSAtPiBtYXAgKGZ1biB5IC0+IFt5XSkgeFxuICAgIHwgW3g7IHldIC0+IG1hcCAoZnVuICh4LCB5KSAtPiBbeDsgeV0pIChib3RoIHggeSlcbiAgICB8IF8gLT5cbiAgICAgIGxldCB2cyA9IEFycmF5Lm1ha2UgKExpc3QubGVuZ3RoIHBzKSBOb25lIGluXG4gICAgICBwc1xuICAgICAgfD4gTGlzdC5tYXBpIChmdW4gaW5kZXggcCAtPlxuICAgICAgICBiaW5kIHAgKGZ1biB2IC0+IHZzLihpbmRleCkgPC0gU29tZSB2OyByZXR1cm5fdW5pdCkpXG4gICAgICB8PiBqb2luXG4gICAgICB8PiBtYXAgKGZ1biAoKSAtPlxuICAgICAgICAgIGxldCByZWMgdG9fbGlzdF91bm9wdCBpIGFjYyA9XG4gICAgICAgICAgICBpZiBpIDwgMCB0aGVuXG4gICAgICAgICAgICAgIGFjY1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBtYXRjaCBBcnJheS51bnNhZmVfZ2V0IHZzIGkgd2l0aFxuICAgICAgICAgICAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gICAgICAgICAgICAgIHwgU29tZSB4IC0+IHRvX2xpc3RfdW5vcHQgKGkgLSAxKSAoeDo6YWNjKVxuICAgICAgICAgIGluXG4gICAgICAgICAgdG9fbGlzdF91bm9wdCAoQXJyYXkubGVuZ3RoIHZzIC0gMSkgW10pXG5cbiAgKCogTWFpbnRhaW5lcidzIG5vdGU6IHRoZSBuZXh0IGZldyBmdW5jdGlvbnMgYXJlIGhlbHBlcnMgZm9yIFtjaG9vc2VdIGFuZFxuICAgICBbcGlja10uIFBlcmhhcHMgdGhleSBzaG91bGQgYmUgZmFjdG9yZWQgaW50byBzb21lIGtpbmQgb2YgZ2VuZXJpY1xuICAgICBbY2hvb3NlXS9bcGlja10gaW1wbGVtZW50YXRpb24sIHdoaWNoIG1heSBhY3R1YWxseSBiZSBvcHRpbWFsIGFueXdheSB3aXRoXG4gICAgIEZsYW1iZGEuICopXG5cbiAgbGV0IGNvdW50X3Jlc29sdmVkX3Byb21pc2VzX2luIChwcyA6ICdhIHQgbGlzdCkgPVxuICAgIGxldCByZWMgY291bnRfYW5kX2dhdGhlcl9yZWplY3RlZCB0b3RhbCByZWplY3RlZCBwcyA9XG4gICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgIHwgW10gLT4gRXJyb3IgKHRvdGFsLCByZWplY3RlZClcbiAgICAgICB8IHAgOjogcHMgLT5cbiAgICAgICAgICAgIGxldCBJbnRlcm5hbCBxID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgICAgICBtYXRjaCAodW5kZXJseWluZyBxKS5zdGF0ZSB3aXRoXG4gICAgICAgICAgICB8IEZ1bGZpbGxlZCBfIC0+IGNvdW50X2FuZF9nYXRoZXJfcmVqZWN0ZWQgdG90YWwgcmVqZWN0ZWQgcHNcbiAgICAgICAgICAgIHwgUmVqZWN0ZWQgXyAtPiBjb3VudF9hbmRfZ2F0aGVyX3JlamVjdGVkICh0b3RhbCArIDEpIChwIDo6IHJlamVjdGVkKSBwc1xuICAgICAgICAgICAgfCBQZW5kaW5nIF8gLT4gY291bnRfYW5kX2dhdGhlcl9yZWplY3RlZCB0b3RhbCByZWplY3RlZCBwc1xuICAgIGluXG4gICAgbGV0IHJlYyBjb3VudF9mdWxmaWxsZWQgdG90YWwgcHMgPVxuICAgICAgIG1hdGNoIHBzIHdpdGhcbiAgICAgICB8IFtdIC0+IE9rIHRvdGFsXG4gICAgICAgfCBwIDo6IHBzIC0+XG4gICAgICAgICAgICBsZXQgSW50ZXJuYWwgcSA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcSkuc3RhdGUgd2l0aFxuICAgICAgICAgICAgfCBGdWxmaWxsZWQgXyAtPiBjb3VudF9mdWxmaWxsZWQgKHRvdGFsICsgMSkgcHNcbiAgICAgICAgICAgIHwgUmVqZWN0ZWQgXyAtPiBjb3VudF9hbmRfZ2F0aGVyX3JlamVjdGVkIDEgW3BdIHBzXG4gICAgICAgICAgICB8IFBlbmRpbmcgXyAtPiBjb3VudF9mdWxmaWxsZWQgdG90YWwgcHNcbiAgICBpblxuICAgIGNvdW50X2Z1bGZpbGxlZCAwIHBzXG5cbiAgKCogRXZhbHVhdGVzIHRvIHRoZSBbbl10aCBwcm9taXNlIGluIFtwc10sIGFtb25nIG9ubHkgdGhvc2UgcHJvbWlzZXMgaW4gW3BzXVxuICAgICB0aGF0IGFyZSByZXNvbHZlZC4gVGhlIGNhbGxlciBpcyBleHBlY3RlZCB0byBlbnN1cmUgdGhhdCB0aGVyZSBhcmUgYXRcbiAgICAgbGVhc3QgW25dIHJlc29sdmVkIHByb21pc2VzIGluIFtwc10uICopXG4gIGxldCByZWMgbnRoX3Jlc29sdmVkIChwcyA6ICdhIHQgbGlzdCkgKG4gOiBpbnQpIDogJ2EgdCA9XG4gICAgbWF0Y2ggcHMgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgIGFzc2VydCBmYWxzZVxuXG4gICAgfCBwOjpwcyAtPlxuICAgICAgbGV0IEludGVybmFsIHAnID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICBtYXRjaCAodW5kZXJseWluZyBwJykuc3RhdGUgd2l0aFxuICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgbnRoX3Jlc29sdmVkIHBzIG5cblxuICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiBwXG4gICAgICAgIGVsc2UgbnRoX3Jlc29sdmVkIHBzIChuIC0gMSlcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiBwXG4gICAgICAgIGVsc2UgbnRoX3Jlc29sdmVkIHBzIChuIC0gMSlcblxuICAoKiBMaWtlIFtudGhfcmVzb2x2ZWRdLCBidXQgY2FuY2VscyBhbGwgcGVuZGluZyBwcm9taXNlcyBmb3VuZCB3aGlsZVxuICAgICB0cmF2ZXJzaW5nIFtwc10uICopXG4gIGxldCByZWMgbnRoX3Jlc29sdmVkX2FuZF9jYW5jZWxfcGVuZGluZyAocHMgOiAnYSB0IGxpc3QpIChuIDogaW50KSA6ICdhIHQgPVxuICAgIG1hdGNoIHBzIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBhc3NlcnQgZmFsc2VcblxuICAgIHwgcDo6cHMgLT5cbiAgICAgIGxldCBJbnRlcm5hbCBwJyA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCcpLnN0YXRlIHdpdGhcbiAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgIGNhbmNlbCBwO1xuICAgICAgICBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIG5cblxuICAgICAgfCBGdWxmaWxsZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiAoTGlzdC5pdGVyIGNhbmNlbCBwczsgcClcbiAgICAgICAgZWxzZSBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIChuIC0gMSlcbiAgICAgIHwgUmVqZWN0ZWQgXyAtPlxuICAgICAgICBpZiBuIDw9IDAgdGhlbiAoTGlzdC5pdGVyIGNhbmNlbCBwczsgcClcbiAgICAgICAgZWxzZSBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzIChuIC0gMSlcblxuICAoKiBUaGUgUFJORyBzdGF0ZSBpcyBpbml0aWFsaXplZCB3aXRoIGEgY29uc3RhbnQgdG8gbWFrZSBub24tSU8tYmFzZWQgcHJvZ3JhbXNcbiAgICAgZGV0ZXJtaW5pc3RpYy4gKilcbiAgKCogTWFpbnRhaW5lcidzIG5vdGU6IGlzIHRoaXMgbmVjZXNzYXJ5PyAqKVxuICBsZXQgcHJuZyA9IGxhenkgKFJhbmRvbS5TdGF0ZS5tYWtlIFt8fF0pXG5cbiAgbGV0IGNob29zZSBwcyA9XG4gICAgaWYgcHMgPSBbXSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZ1xuICAgICAgICBcIkx3dC5jaG9vc2UgW10gd291bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclwiO1xuICAgIG1hdGNoIGNvdW50X3Jlc29sdmVkX3Byb21pc2VzX2luIHBzIHdpdGhcbiAgICB8IE9rIDAgLT5cbiAgICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgICAgbGV0IGNhbGxiYWNrIHJlc3VsdCA9XG4gICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCA9IG1heV9ub3dfYmVfcHJveHkgcCBpblxuICAgICAgICBsZXQgcCA9IHVuZGVybHlpbmcgcCBpblxuICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID1cbiAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgICAgaWdub3JlIHBcbiAgICAgIGluXG4gICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBjYWxsYmFjaztcblxuICAgICAgdG9fcHVibGljX3Byb21pc2UgcFxuXG4gICAgfCBPayAxIC0+XG4gICAgICBudGhfcmVzb2x2ZWQgcHMgMFxuXG4gICAgfCBPayBuIC0+XG4gICAgICBudGhfcmVzb2x2ZWQgcHMgKFJhbmRvbS5TdGF0ZS5pbnQgKExhenkuZm9yY2UgcHJuZykgbilcblxuICAgIHwgRXJyb3IgKG4sIHBzKSAtPlxuICAgICAgbnRoX3Jlc29sdmVkIHBzIChSYW5kb20uU3RhdGUuaW50IChMYXp5LmZvcmNlIHBybmcpIG4pXG5cbiAgbGV0IHBpY2sgcHMgPVxuICAgIGlmIHBzID0gW10gdGhlblxuICAgICAgaW52YWxpZF9hcmcgXCJMd3QucGljayBbXSB3b3VsZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXCI7XG4gICAgbWF0Y2ggY291bnRfcmVzb2x2ZWRfcHJvbWlzZXNfaW4gcHMgd2l0aFxuICAgIHwgT2sgMCAtPlxuICAgICAgbGV0IHAgPSBuZXdfcGVuZGluZyB+aG93X3RvX2NhbmNlbDoocHJvcGFnYXRlX2NhbmNlbF90b19zZXZlcmFsIHBzKSBpblxuXG4gICAgICBsZXQgY2FsbGJhY2sgcmVzdWx0ID1cbiAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluXG4gICAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG4gICAgICAgIGxldCBTdGF0ZV9tYXlfaGF2ZV9jaGFuZ2VkIHAgPVxuICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwIHJlc3VsdCBpblxuICAgICAgICBpZ25vcmUgcFxuICAgICAgaW5cbiAgICAgIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja190b19lYWNoX29mIHBzIGNhbGxiYWNrO1xuXG4gICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICB8IE9rIDEgLT5cbiAgICAgIG50aF9yZXNvbHZlZF9hbmRfY2FuY2VsX3BlbmRpbmcgcHMgMFxuXG4gICAgfCBPayBuIC0+XG4gICAgICBudGhfcmVzb2x2ZWRfYW5kX2NhbmNlbF9wZW5kaW5nIHBzXG4gICAgICAgIChSYW5kb20uU3RhdGUuaW50IChMYXp5LmZvcmNlIHBybmcpIG4pXG5cbiAgICB8IEVycm9yIChuLCBxcykgLT5cbiAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICBudGhfcmVzb2x2ZWQgcXMgKFJhbmRvbS5TdGF0ZS5pbnQgKExhenkuZm9yY2UgcHJuZykgbilcblxuXG5cbiAgKCogSWYgW25jaG9vc2UgcHNdIG9yIFtucGljayBwc10gZm91bmQgYWxsIHByb21pc2VzIGluIFtwc10gcGVuZGluZywgdGhlXG4gICAgIGNhbGxiYWNrIGFkZGVkIHRvIGVhY2ggcHJvbWlzZSBpbiBbcHNdIGV2ZW50dWFsbHkgY2FsbHMgdGhpcyBmdW5jdGlvbi4gVGhlXG4gICAgIGZ1bmN0aW9uIGNvbGxlY3RzIHByb21pc2VzIGluIFtwc10gdGhhdCBoYXZlIGJlY29tZSBmdWxmaWxsZWQsIG9yIGZpbmRzIG9uZVxuICAgICBwcm9taXNlIGluIFtwc10gdGhhdCBoYXMgYmVlbiByZWplY3RlZC4gSXQgdGhlbiByZXR1cm5zIHRoZSBkZXNpcmVkIHN0YXRlXG4gICAgIG9mIHRoZSBmaW5hbCBwcm9taXNlOiBlaXRoZXIgdGhlIGxpc3Qgb2YgcmVzdWx0cyBjb2xsZWN0ZWQsIG9yIHRoZVxuICAgICBleGNlcHRpb24gZm91bmQuICopXG4gIGxldCByZWMgY29sbGVjdF9mdWxmaWxsZWRfcHJvbWlzZXNfYWZ0ZXJfcGVuZGluZ1xuICAgICAgKHJlc3VsdHMgOiAnYSBsaXN0KVxuICAgICAgKHBzIDogJ2EgdCBsaXN0KSA6XG4gICAgICAgICgnYSBsaXN0IHJlc29sdmVkX3N0YXRlKSA9XG5cbiAgICBtYXRjaCBwcyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgRnVsZmlsbGVkIChMaXN0LnJldiByZXN1bHRzKVxuXG4gICAgfCBwOjpwcyAtPlxuICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cblxuICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICBjb2xsZWN0X2Z1bGZpbGxlZF9wcm9taXNlc19hZnRlcl9wZW5kaW5nICh2OjpyZXN1bHRzKSBwc1xuXG4gICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgIHJlc3VsdFxuXG4gICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICBjb2xsZWN0X2Z1bGZpbGxlZF9wcm9taXNlc19hZnRlcl9wZW5kaW5nIHJlc3VsdHMgcHNcblxuICBsZXQgbmNob29zZSBwcyA9XG4gICAgKCogSWYgYXQgbGVhc3Qgb25lIHByb21pc2UgaW4gW3BzXSBpcyBmb3VuZCBmdWxmaWxsZWQsIHRoaXMgZnVuY3Rpb24gaXNcbiAgICAgICBjYWxsZWQgdG8gZmluZCBhbGwgc3VjaCBwcm9taXNlcy4gKilcbiAgICBpZiBwcyA9IFtdIHRoZW5cbiAgICAgIGludmFsaWRfYXJnXG4gICAgICAgIFwiTHd0Lm5jaG9vc2UgW10gd291bGQgcmV0dXJuIGEgcHJvbWlzZSB0aGF0IGlzIHBlbmRpbmcgZm9yZXZlclwiO1xuICAgIGxldCByZWMgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkIGFjYyBwcyA9XG4gICAgICBtYXRjaCBwcyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIHJldHVybiAoTGlzdC5yZXYgYWNjKVxuXG4gICAgICB8IHA6OnBzIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCAodjo6YWNjKSBwc1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSB7c3RhdGUgPSByZXN1bHR9XG5cbiAgICAgICAgfCBQZW5kaW5nIF8gLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgYWNjIHBzXG4gICAgaW5cblxuICAgICgqIExvb2tzIGZvciBhbHJlYWR5LXJlc29sdmVkIHByb21pc2VzIGluIFtwc10uIElmIG5vbmUgYXJlIGZ1bGZpbGxlZCBvclxuICAgICAgIHJlamVjdGVkLCBhZGRzIGEgY2FsbGJhY2sgdG8gYWxsIHByb21pc2VzIGluIFtwc10gKGFsbCBvZiB3aGljaCBhcmVcbiAgICAgICBwZW5kaW5nKS4gKilcbiAgICBsZXQgcmVjIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzJyA9XG4gICAgICBtYXRjaCBwcycgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICBsZXQgcCA9IG5ld19wZW5kaW5nIH5ob3dfdG9fY2FuY2VsOihwcm9wYWdhdGVfY2FuY2VsX3RvX3NldmVyYWwgcHMpIGluXG5cbiAgICAgICAgbGV0IGNhbGxiYWNrIF9yZXN1bHQgPVxuICAgICAgICAgIGxldCBTdGF0ZV9tYXlfbm93X2JlX3BlbmRpbmdfcHJveHkgcCA9IG1heV9ub3dfYmVfcHJveHkgcCBpblxuICAgICAgICAgIGxldCBwID0gdW5kZXJseWluZyBwIGluXG4gICAgICAgICAgbGV0IHJlc3VsdCA9IGNvbGxlY3RfZnVsZmlsbGVkX3Byb21pc2VzX2FmdGVyX3BlbmRpbmcgW10gcHMgaW5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID1cbiAgICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSBwIHJlc3VsdCBpblxuICAgICAgICAgIGlnbm9yZSBwXG4gICAgICAgIGluXG4gICAgICAgIGFkZF9leHBsaWNpdGx5X3JlbW92YWJsZV9jYWxsYmFja190b19lYWNoX29mIHBzIGNhbGxiYWNrO1xuXG4gICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHBcblxuICAgICAgfCBwOjpwcyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgW3ZdIHBzXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHBzXG4gICAgaW5cblxuICAgIGxldCBwID0gY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHMgaW5cbiAgICBwXG5cbiAgKCogU2VlIFtuY2hvb3NlXS4gVGhpcyBmdW5jdGlvbiBkaWZmZXJzIG9ubHkgaW4gaGF2aW5nIGFkZGl0aW9uYWwgY2FsbHMgdG9cbiAgICAgW2NhbmNlbF0uICopXG4gIGxldCBucGljayBwcyA9XG4gICAgaWYgcHMgPSBbXSB0aGVuXG4gICAgICBpbnZhbGlkX2FyZyBcIkx3dC5ucGljayBbXSB3b3VsZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXCI7XG4gICAgbGV0IHJlYyBjb2xsZWN0X2FscmVhZHlfZnVsZmlsbGVkX3Byb21pc2VzX29yX2ZpbmRfcmVqZWN0ZWQgYWNjIHBzJyA9XG4gICAgICBtYXRjaCBwcycgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgICByZXR1cm4gKExpc3QucmV2IGFjYylcblxuICAgICAgfCBwOjpwcycgLT5cbiAgICAgICAgbGV0IEludGVybmFsIHAgPSB0b19pbnRlcm5hbF9wcm9taXNlIHAgaW5cbiAgICAgICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgICAgICB8IEZ1bGZpbGxlZCB2IC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X2Z1bGZpbGxlZF9wcm9taXNlc19vcl9maW5kX3JlamVjdGVkICh2OjphY2MpIHBzJ1xuXG4gICAgICAgIHwgUmVqZWN0ZWQgXyBhcyByZXN1bHQgLT5cbiAgICAgICAgICBMaXN0Lml0ZXIgY2FuY2VsIHBzO1xuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCBhY2MgcHMnXG4gICAgaW5cblxuICAgIGxldCByZWMgY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHMnID1cbiAgICAgIG1hdGNoIHBzJyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgICAgICBsZXQgY2FsbGJhY2sgX3Jlc3VsdCA9XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluXG4gICAgICAgICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cbiAgICAgICAgICBsZXQgcmVzdWx0ID0gY29sbGVjdF9mdWxmaWxsZWRfcHJvbWlzZXNfYWZ0ZXJfcGVuZGluZyBbXSBwcyBpblxuICAgICAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9oYXZlX2NoYW5nZWQgcCA9XG4gICAgICAgICAgICByZXNvbHZlIH5hbGxvd19kZWZlcnJpbmc6ZmFsc2UgcCByZXN1bHQgaW5cbiAgICAgICAgICBpZ25vcmUgcFxuICAgICAgICBpblxuICAgICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBjYWxsYmFjaztcblxuICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICAgIHwgcDo6cHMnIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9mdWxmaWxsZWRfcHJvbWlzZXNfb3JfZmluZF9yZWplY3RlZCBbdl0gcHMnXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIExpc3QuaXRlciBjYW5jZWwgcHM7XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHMnXG4gICAgaW5cblxuICAgIGxldCBwID0gY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcHMgaW5cbiAgICBwXG5cblxuXG4gICgqIFNhbWUgZ2VuZXJhbCBwYXR0ZXJuIGFzIFtucGlja10gYW5kIFtuY2hvb3NlXS4gKilcbiAgbGV0IG5jaG9vc2Vfc3BsaXQgcHMgPVxuICAgIGlmIHBzID0gW10gdGhlblxuICAgICAgaW52YWxpZF9hcmdcbiAgICAgICAgXCJMd3QubmNob29zZV9zcGxpdCBbXSB3b3VsZCByZXR1cm4gYSBwcm9taXNlIHRoYXQgaXMgcGVuZGluZyBmb3JldmVyXCI7XG4gICAgbGV0IHJlYyBmaW5pc2hcbiAgICAgICAgKHRvX3Jlc29sdmUgOiAoJ2EgbGlzdCAqICdhIHQgbGlzdCwgdW5kZXJseWluZywgcGVuZGluZykgcHJvbWlzZSlcbiAgICAgICAgKGZ1bGZpbGxlZCA6ICdhIGxpc3QpXG4gICAgICAgIChwZW5kaW5nIDogJ2EgdCBsaXN0KVxuICAgICAgICAocHMgOiAnYSB0IGxpc3QpXG4gICAgICAgICAgOiAoJ2EgbGlzdCAqICdhIHQgbGlzdCwgdW5kZXJseWluZywgcmVzb2x2ZWQpIHN0YXRlX2NoYW5nZWQgPVxuXG4gICAgICBtYXRjaCBwcyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSB0b19yZXNvbHZlXG4gICAgICAgICAgKEZ1bGZpbGxlZCAoTGlzdC5yZXYgZnVsZmlsbGVkLCBMaXN0LnJldiBwZW5kaW5nKSlcblxuICAgICAgfCBwOjpwcyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwX2ludGVybmFsKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBmaW5pc2ggdG9fcmVzb2x2ZSAodjo6ZnVsZmlsbGVkKSBwZW5kaW5nIHBzXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHJlc29sdmUgfmFsbG93X2RlZmVycmluZzpmYWxzZSB0b19yZXNvbHZlIHJlc3VsdFxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgZmluaXNoIHRvX3Jlc29sdmUgZnVsZmlsbGVkIChwOjpwZW5kaW5nKSBwc1xuICAgIGluXG5cbiAgICBsZXQgcmVjIGNvbGxlY3RfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyByZXN1bHRzIHBlbmRpbmcgcHMgPVxuICAgICAgbWF0Y2ggcHMgd2l0aFxuICAgICAgfCBbXSAtPlxuICAgICAgICAoKiBNYWludGFpbmVyJ3Mgbm90ZTogc2hvdWxkIHRoZSBwZW5kaW5nIHByb21pc2UgbGlzdCBhbHNvIGJlXG4gICAgICAgICAgIHJldmVyc2VkPyBJdCBpcyByZXZlcnNlZCBpbiBmaW5pc2guICopXG4gICAgICAgIHJldHVybiAoTGlzdC5yZXYgcmVzdWx0cywgcGVuZGluZylcblxuICAgICAgfCBwOjpwcyAtPlxuICAgICAgICBsZXQgSW50ZXJuYWwgcF9pbnRlcm5hbCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgICAgICBtYXRjaCAodW5kZXJseWluZyBwX2ludGVybmFsKS5zdGF0ZSB3aXRoXG4gICAgICAgIHwgRnVsZmlsbGVkIHYgLT5cbiAgICAgICAgICBjb2xsZWN0X2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgKHY6OnJlc3VsdHMpIHBlbmRpbmcgcHNcblxuICAgICAgICB8IFJlamVjdGVkIF8gYXMgcmVzdWx0IC0+XG4gICAgICAgICAgdG9fcHVibGljX3Byb21pc2Uge3N0YXRlID0gcmVzdWx0fVxuXG4gICAgICAgIHwgUGVuZGluZyBfIC0+XG4gICAgICAgICAgY29sbGVjdF9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIHJlc3VsdHMgKHA6OnBlbmRpbmcpIHBzXG4gICAgaW5cblxuICAgIGxldCByZWMgY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgcGVuZGluZ19hY2MgcHMnID1cbiAgICAgIG1hdGNoIHBzJyB3aXRoXG4gICAgICB8IFtdIC0+XG4gICAgICAgIGxldCBwID0gbmV3X3BlbmRpbmcgfmhvd190b19jYW5jZWw6KHByb3BhZ2F0ZV9jYW5jZWxfdG9fc2V2ZXJhbCBwcykgaW5cblxuICAgICAgICBsZXQgY2FsbGJhY2sgX3Jlc3VsdCA9XG4gICAgICAgICAgbGV0IFN0YXRlX21heV9ub3dfYmVfcGVuZGluZ19wcm94eSBwID0gbWF5X25vd19iZV9wcm94eSBwIGluXG4gICAgICAgICAgbGV0IHAgPSB1bmRlcmx5aW5nIHAgaW5cbiAgICAgICAgICBsZXQgU3RhdGVfbWF5X2hhdmVfY2hhbmdlZCBwID0gZmluaXNoIHAgW10gW10gcHMgaW5cbiAgICAgICAgICBpZ25vcmUgcFxuICAgICAgICBpblxuICAgICAgICBhZGRfZXhwbGljaXRseV9yZW1vdmFibGVfY2FsbGJhY2tfdG9fZWFjaF9vZiBwcyBjYWxsYmFjaztcblxuICAgICAgICB0b19wdWJsaWNfcHJvbWlzZSBwXG5cbiAgICAgIHwgcDo6cHMnIC0+XG4gICAgICAgIGxldCBJbnRlcm5hbCBwX2ludGVybmFsID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgICAgIG1hdGNoICh1bmRlcmx5aW5nIHBfaW50ZXJuYWwpLnN0YXRlIHdpdGhcbiAgICAgICAgfCBGdWxmaWxsZWQgdiAtPlxuICAgICAgICAgIGNvbGxlY3RfYWxyZWFkeV9yZXNvbHZlZF9wcm9taXNlcyBbdl0gcGVuZGluZ19hY2MgcHMnXG5cbiAgICAgICAgfCBSZWplY3RlZCBfIGFzIHJlc3VsdCAtPlxuICAgICAgICAgIHRvX3B1YmxpY19wcm9taXNlIHtzdGF0ZSA9IHJlc3VsdH1cblxuICAgICAgICB8IFBlbmRpbmcgXyAtPlxuICAgICAgICAgIGNoZWNrX2Zvcl9hbHJlYWR5X3Jlc29sdmVkX3Byb21pc2VzIChwOjpwZW5kaW5nX2FjYykgcHMnXG4gICAgaW5cblxuICAgIGxldCBwID0gY2hlY2tfZm9yX2FscmVhZHlfcmVzb2x2ZWRfcHJvbWlzZXMgW10gcHMgaW5cbiAgICBwXG5lbmRcbmluY2x1ZGUgQ29uY3VycmVudF9jb21wb3NpdGlvblxuXG5cblxubW9kdWxlIE1pc2NlbGxhbmVvdXMgOlxuc2lnXG4gICgqIFByb21pc2Ugc3RhdGUgcXVlcnkgKilcbiAgdHlwZSAnYSBzdGF0ZSA9XG4gICAgfCBSZXR1cm4gb2YgJ2FcbiAgICB8IEZhaWwgb2YgZXhuXG4gICAgfCBTbGVlcFxuXG4gIHZhbCBzdGF0ZSA6ICdhIHQgLT4gJ2Egc3RhdGVcbiAgdmFsIGlzX3NsZWVwaW5nIDogJ2EgdCAtPiBib29sXG4gIHZhbCBkZWJ1Z19zdGF0ZV9pcyA6ICdhIHN0YXRlIC0+ICdhIHQgLT4gYm9vbCB0XG5cbiAgKCogRnVuY3Rpb24gbGlmdGVycyAqKVxuICB2YWwgYXBwbHkgOiAoJ2EgLT4gJ2IgdCkgLT4gJ2EgLT4gJ2IgdFxuXG4gIHZhbCB3cmFwIDpcbiAgICAodW5pdCAtPiAnYikgLT5cbiAgICAnYiB0XG4gIHZhbCB3cmFwMSA6XG4gICAgKCdhMSAtPiAnYikgLT5cbiAgICAoJ2ExIC0+ICdiIHQpXG4gIHZhbCB3cmFwMiA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2IgdClcbiAgdmFsIHdyYXAzIDpcbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdiIHQpXG4gIHZhbCB3cmFwNCA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYikgLT5cbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdiIHQpXG4gIHZhbCB3cmFwNSA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2IgdClcbiAgdmFsIHdyYXA2IDpcbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2IpIC0+XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2E2IC0+ICdiIHQpXG4gIHZhbCB3cmFwNyA6XG4gICAgKCdhMSAtPiAnYTIgLT4gJ2EzIC0+ICdhNCAtPiAnYTUgLT4gJ2E2IC0+ICdhNyAtPiAnYikgLT5cbiAgICAoJ2ExIC0+ICdhMiAtPiAnYTMgLT4gJ2E0IC0+ICdhNSAtPiAnYTYgLT4gJ2E3IC0+ICdiIHQpXG5cbiAgKCogUGF1c2VkIHByb21pc2VzICopXG4gIHZhbCBwYXVzZSA6IHVuaXQgLT4gdW5pdCB0XG4gIHZhbCB3YWtldXBfcGF1c2VkIDogdW5pdCAtPiB1bml0XG4gIHZhbCBwYXVzZWRfY291bnQgOiB1bml0IC0+IGludFxuICB2YWwgcmVnaXN0ZXJfcGF1c2Vfbm90aWZpZXIgOiAoaW50IC0+IHVuaXQpIC0+IHVuaXRcbiAgdmFsIGFiYW5kb25fcGF1c2VkIDogdW5pdCAtPiB1bml0XG5cbiAgKCogSW50ZXJuYWwgaW50ZXJmYWNlIGZvciBvdGhlciBtb2R1bGVzIGluIEx3dCAqKVxuICB2YWwgcG9sbCA6ICdhIHQgLT4gJ2Egb3B0aW9uXG5lbmQgPVxuc3RydWN0XG4gIHR5cGUgJ2Egc3RhdGUgPVxuICAgIHwgUmV0dXJuIG9mICdhXG4gICAgfCBGYWlsIG9mIGV4blxuICAgIHwgU2xlZXBcblxuICBleHRlcm5hbCByZXJhaXNlIDogZXhuIC0+ICdhID0gXCIlcmVyYWlzZVwiXG5cbiAgbGV0IHN0YXRlIHAgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgIHwgRnVsZmlsbGVkIHYgLT4gUmV0dXJuIHZcbiAgICB8IFJlamVjdGVkIGV4biAtPiBGYWlsIGV4blxuICAgIHwgUGVuZGluZyBfIC0+IFNsZWVwXG5cbiAgbGV0IGRlYnVnX3N0YXRlX2lzIGV4cGVjdGVkX3N0YXRlIHAgPVxuICAgIHJldHVybiAoc3RhdGUgcCA9IGV4cGVjdGVkX3N0YXRlKVxuXG4gIGxldCBpc19zbGVlcGluZyBwID1cbiAgICBsZXQgSW50ZXJuYWwgcCA9IHRvX2ludGVybmFsX3Byb21pc2UgcCBpblxuICAgIG1hdGNoICh1bmRlcmx5aW5nIHApLnN0YXRlIHdpdGhcbiAgICB8IEZ1bGZpbGxlZCBfIC0+IGZhbHNlXG4gICAgfCBSZWplY3RlZCBfIC0+IGZhbHNlXG4gICAgfCBQZW5kaW5nIF8gLT4gdHJ1ZVxuXG4gIGxldCBwb2xsIHAgPVxuICAgIGxldCBJbnRlcm5hbCBwID0gdG9faW50ZXJuYWxfcHJvbWlzZSBwIGluXG4gICAgbWF0Y2ggKHVuZGVybHlpbmcgcCkuc3RhdGUgd2l0aFxuICAgIHwgUmVqZWN0ZWQgZSAtPiByZXJhaXNlIGVcbiAgICB8IEZ1bGZpbGxlZCB2IC0+IFNvbWUgdlxuICAgIHwgUGVuZGluZyBfIC0+IE5vbmVcblxuXG5cbiAgbGV0IGFwcGx5IGYgeCA9XG4gICAgdHJ5IGYgeCB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwIGYgPVxuICAgIHRyeSByZXR1cm4gKGYgKCkpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDEgZiB4MSA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSlcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwMiBmIHgxIHgyID1cbiAgICB0cnkgcmV0dXJuIChmIHgxIHgyKVxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXAzIGYgeDEgeDIgeDMgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEgeDIgeDMpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDQgZiB4MSB4MiB4MyB4NCA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSB4MiB4MyB4NClcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG4gIGxldCB3cmFwNSBmIHgxIHgyIHgzIHg0IHg1ID1cbiAgICB0cnkgcmV0dXJuIChmIHgxIHgyIHgzIHg0IHg1KVxuICAgIHdpdGggZXhuIHdoZW4gRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IGZhaWwgZXhuXG5cbiAgbGV0IHdyYXA2IGYgeDEgeDIgeDMgeDQgeDUgeDYgPVxuICAgIHRyeSByZXR1cm4gKGYgeDEgeDIgeDMgeDQgeDUgeDYpXG4gICAgd2l0aCBleG4gd2hlbiBFeGNlcHRpb25fZmlsdGVyLnJ1biBleG4gLT4gZmFpbCBleG5cblxuICBsZXQgd3JhcDcgZiB4MSB4MiB4MyB4NCB4NSB4NiB4NyA9XG4gICAgdHJ5IHJldHVybiAoZiB4MSB4MiB4MyB4NCB4NSB4NiB4NylcbiAgICB3aXRoIGV4biB3aGVuIEV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4biAtPiBmYWlsIGV4blxuXG5cblxuICBsZXQgcGF1c2VfaG9vayA9IHJlZiBpZ25vcmVcblxuICBsZXQgcGF1c2VkID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKVxuICBsZXQgcGF1c2VkX2NvdW50ID0gcmVmIDBcblxuICBsZXQgcGF1c2UgKCkgPVxuICAgIGxldCBwID0gYWRkX3Rhc2tfciBwYXVzZWQgaW5cbiAgICBpbmNyIHBhdXNlZF9jb3VudDtcbiAgICAhcGF1c2VfaG9vayAhcGF1c2VkX2NvdW50O1xuICAgIHBcblxuICBsZXQgd2FrZXVwX3BhdXNlZCAoKSA9XG4gICAgaWYgTHd0X3NlcXVlbmNlLmlzX2VtcHR5IHBhdXNlZCB0aGVuXG4gICAgICBwYXVzZWRfY291bnQgOj0gMFxuICAgIGVsc2UgYmVnaW5cbiAgICAgIGxldCB0bXAgPSBMd3Rfc2VxdWVuY2UuY3JlYXRlICgpIGluXG4gICAgICBMd3Rfc2VxdWVuY2UudHJhbnNmZXJfciBwYXVzZWQgdG1wO1xuICAgICAgcGF1c2VkX2NvdW50IDo9IDA7XG4gICAgICBMd3Rfc2VxdWVuY2UuaXRlcl9sIChmdW4gciAtPiB3YWtldXAgciAoKSkgdG1wXG4gICAgZW5kXG5cbiAgbGV0IHJlZ2lzdGVyX3BhdXNlX25vdGlmaWVyIGYgPSBwYXVzZV9ob29rIDo9IGZcblxuICBsZXQgYWJhbmRvbl9wYXVzZWQgKCkgPVxuICAgIEx3dF9zZXF1ZW5jZS5jbGVhciBwYXVzZWQ7XG4gICAgcGF1c2VkX2NvdW50IDo9IDBcblxuICBsZXQgcGF1c2VkX2NvdW50ICgpID0gIXBhdXNlZF9jb3VudFxuZW5kXG5pbmNsdWRlIE1pc2NlbGxhbmVvdXNcblxubW9kdWxlIExldF9zeW50YXggPVxuc3RydWN0XG4gIG1vZHVsZSBMZXRfc3ludGF4ID1cbiAgc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBtYXAgdCB+ZiA9IG1hcCBmIHRcbiAgICBsZXQgYmluZCB0IH5mID0gYmluZCB0IGZcbiAgICBsZXQgYm90aCA9IGJvdGhcblxuICAgIG1vZHVsZSBPcGVuX29uX3JocyA9XG4gICAgc3RydWN0XG4gICAgZW5kXG4gIGVuZFxuZW5kXG5cbm1vZHVsZSBJbmZpeCA9XG5zdHJ1Y3RcbiAgbGV0ICg+Pj0pID0gYmluZFxuICBsZXQgKD08PCkgZiBwID0gYmluZCBwIGZcbiAgbGV0ICg+fD0pIHAgZiA9IG1hcCBmIHBcbiAgbGV0ICg9fDwpID0gbWFwXG4gIGxldCAoPCY+KSBwIHAnID0gam9pbiBbcDsgcCddXG4gIGxldCAoPD8+KSBwIHAnID0gY2hvb3NlIFtwOyBwJ11cblxuICBpbmNsdWRlIExldF9zeW50YXhcbmVuZFxuaW5jbHVkZSAoIEluZml4IDogbW9kdWxlIHR5cGUgb2YgSW5maXggd2l0aCBtb2R1bGUgTGV0X3N5bnRheCA6PSBMZXRfc3ludGF4LkxldF9zeW50YXggKVxuXG5tb2R1bGUgU3ludGF4ID1cbnN0cnVjdFxuICBsZXQgKGxldCopID0gYmluZFxuICBsZXQgKGFuZCopID0gYm90aFxuXG4gIGxldCAobGV0KykgeCBmID0gbWFwIGYgeFxuICBsZXQgKGFuZCspID0gYm90aFxuZW5kXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbmV4Y2VwdGlvbiBPZmZcblxudHlwZSBvbl9zd2l0Y2ggPSB7XG4gIG11dGFibGUgaG9va3MgOiAodW5pdCAtPiB1bml0IEx3dC50KSBsaXN0O1xufVxuXG50eXBlIHN0YXRlID1cbiAgfCBTdF9vbiBvZiBvbl9zd2l0Y2hcbiAgfCBTdF9vZmZcblxudHlwZSB0ID0geyBtdXRhYmxlIHN0YXRlIDogc3RhdGUgfVxuXG5sZXQgY3JlYXRlICgpID0geyBzdGF0ZSA9IFN0X29uIHsgaG9va3MgPSBbXSB9IH1cblxubGV0IGlzX29uIHN3aXRjaCA9XG4gIG1hdGNoIHN3aXRjaC5zdGF0ZSB3aXRoXG4gIHwgU3Rfb24gXyAtPiB0cnVlXG4gIHwgU3Rfb2ZmIC0+IGZhbHNlXG5cbmxldCBjaGVjayA9IGZ1bmN0aW9uXG4gIHwgU29tZXsgc3RhdGUgPSBTdF9vZmYgfSAtPiByYWlzZSBPZmZcbiAgfCBTb21lIHtzdGF0ZSA9IFN0X29uIF99IHwgTm9uZSAtPiAoKVxuXG5sZXQgYWRkX2hvb2sgc3dpdGNoIGhvb2sgPVxuICBtYXRjaCBzd2l0Y2ggd2l0aFxuICB8IFNvbWUgeyBzdGF0ZSA9IFN0X29uIG9zIH0gLT5cbiAgICBvcy5ob29rcyA8LSBob29rIDo6IG9zLmhvb2tzXG4gIHwgU29tZSB7IHN0YXRlID0gU3Rfb2ZmIH0gLT5cbiAgICByYWlzZSBPZmZcbiAgfCBOb25lIC0+XG4gICAgKClcblxubGV0IGFkZF9ob29rX29yX2V4ZWMgc3dpdGNoIGhvb2sgPVxuICBtYXRjaCBzd2l0Y2ggd2l0aFxuICB8IFNvbWUgeyBzdGF0ZSA9IFN0X29uIG9zIH0gLT5cbiAgICBvcy5ob29rcyA8LSBob29rIDo6IG9zLmhvb2tzO1xuICAgIEx3dC5yZXR1cm5fdW5pdFxuICB8IFNvbWUgeyBzdGF0ZSA9IFN0X29mZiB9IC0+XG4gICAgaG9vayAoKVxuICB8IE5vbmUgLT5cbiAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IHR1cm5fb2ZmIHN3aXRjaCA9XG4gIG1hdGNoIHN3aXRjaC5zdGF0ZSB3aXRoXG4gIHwgU3Rfb24geyBob29rcyA9IGhvb2tzIH0gLT5cbiAgICBzd2l0Y2guc3RhdGUgPC0gU3Rfb2ZmO1xuICAgIEx3dC5qb2luIChMaXN0Lm1hcCAoZnVuIGhvb2sgLT4gTHd0LmFwcGx5IGhvb2sgKCkpIGhvb2tzKVxuICB8IFN0X29mZiAtPlxuICAgIEx3dC5yZXR1cm5fdW5pdFxuXG5sZXQgd2l0aF9zd2l0Y2ggZm4gPVxuICBsZXQgc3dpdGNoID0gY3JlYXRlICgpIGluXG4gIEx3dC5maW5hbGl6ZVxuICAgIChmdW4gKCkgLT4gZm4gc3dpdGNoKVxuICAgIChmdW4gKCkgLT4gdHVybl9vZmYgc3dpdGNoKVxuIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG5vcGVuIEx3dC5TeW50YXhcbm9wZW4gTHd0LkluZml4XG5cbnR5cGUgKydhIG5vZGUgPSBOaWwgfCBDb25zIG9mICdhICogJ2EgdFxuXG5hbmQgJ2EgdCA9IHVuaXQgLT4gJ2Egbm9kZSBMd3QudFxuXG5sZXQgcmV0dXJuX25pbCA9IEx3dC5yZXR1cm4gTmlsXG5cbmxldCBlbXB0eSA6ICdhIHQgPSBmdW4gKCkgLT4gcmV0dXJuX25pbFxuXG5sZXQgcmV0dXJuICh4IDogJ2EpIDogJ2EgdCA9IGZ1biAoKSAtPiBMd3QucmV0dXJuIChDb25zICh4LCBlbXB0eSkpXG5cbmxldCByZXR1cm5fbHd0ICh4IDogJ2EgTHd0LnQpIDogJ2EgdCA9IGZ1biAoKSAtPlxuICAgbGV0KyB4ID0geCBpblxuICAgQ29ucyAoeCwgZW1wdHkpXG5cbmxldCBjb25zIHggdCAoKSA9IEx3dC5yZXR1cm4gKENvbnMgKHgsIHQpKVxuXG5sZXQgY29uc19sd3QgeCB0ICgpID1cbiAgIGxldCsgeCA9IHggaW5cbiAgIENvbnMgKHgsIHQpXG5cbigqIEEgbm90ZSBvbiByZWN1cnNpbmcgdGhyb3VnaCB0aGUgc2VxczpcbiAgIFdoZW4gdHJhdmVyc2luZyBhIHNlcSwgdGhlIGZpcnN0IHRpbWUgd2UgZXZhbHVhdGUgYSBzdXNwZW5kZWQgbm9kZSB3ZSBhcmVcbiAgIG9uIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBiaW5kICg+Pj0pLiBJbiB0aGF0IGNhc2UsIHdlIHVzZSBhcHBseSB0byBjYXB0dXJlXG4gICBleGNlcHRpb25zIGludG8gcHJvbWlzZSByZWplY3Rpb24uXG5cbiAgIFRoaXMgaXMgb25seSBuZWVkZWQgb24gdGhlIGZpcnN0IGl0ZXJhdGlvbiBiZWNhdXNlIHdlIGFyZSB3aXRoaW4gYSBjYWxsYmFja1xuICAgcGFzc2VkIHRvIEx3dCBvbiB0aGUgcmlnaHQtaGFuZCBzaWRlIG9mIGEgYmluZCBhZnRlciB0aGF0LlxuXG4gICBUaHJvdWdob3V0IHRoaXMgZmlsZSB3ZSB1c2UgdGhlIHNhbWUgY29kZSBwYXR0ZXJuIHRvIGFjaGlldmUgdGhpczogd2VcbiAgIHNoYWRvdyB0aGUgcmVjdXJzaXZlIHRyYXZlcnNhbCBmdW5jdGlvbiB3aXRoIGFuIGlkZW50aWNhbC1idXQtZm9yLXRoZS1hcHBseVxuICAgbm9uLXJlY3Vyc2l2ZSBjb3B5LiAqKVxuXG5sZXQgcmVjIGFwcGVuZCBzZXExIHNlcTIgKCkgPVxuICBzZXExICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiBzZXEyICgpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMikpXG5sZXQgYXBwZW5kIHNlcTEgc2VxMiAoKSA9XG4gIEx3dC5hcHBseSBzZXExICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiBzZXEyICgpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgYXBwZW5kIG5leHQgc2VxMikpXG5cbmxldCByZWMgbWFwIGYgc2VxICgpID1cbiAgc2VxICgpID58PSBmdW5jdGlvblxuICB8IE5pbCAtPiBOaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbGV0IHggPSBmIHggaW5cbiAgICAgIENvbnMgKHgsIG1hcCBmIG5leHQpXG5sZXQgbWFwIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+fD0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gTmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCB4ID0gZiB4IGluXG4gICAgICBDb25zICh4LCBtYXAgZiBuZXh0KVxuXG5sZXQgcmVjIG1hcF9zIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCsgeCA9IGYgeCBpblxuICAgICAgQ29ucyAoeCwgbWFwX3MgZiBuZXh0KVxubGV0IG1hcF9zIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBsZXQrIHggPSBmIHggaW5cbiAgICAgIENvbnMgKHgsIG1hcF9zIGYgbmV4dClcblxubGV0IHJlYyBmaWx0ZXJfbWFwIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gKFxuICAgICAgbGV0IHggPSBmIHggaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXAgZiBuZXh0ICgpXG4gICAgICB8IFNvbWUgeSAtPiBMd3QucmV0dXJuIChDb25zICh5LCBmaWx0ZXJfbWFwIGYgbmV4dCkgKSlcbmxldCBmaWx0ZXJfbWFwIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+IChcbiAgICAgIGxldCB4ID0gZiB4IGluXG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwIGYgbmV4dCAoKVxuICAgICAgfCBTb21lIHkgLT4gTHd0LnJldHVybiAoQ29ucyAoeSwgZmlsdGVyX21hcCBmIG5leHQpICkpXG5cbmxldCByZWMgZmlsdGVyX21hcF9zIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gKFxuICAgICAgbGV0KiB4ID0gZiB4IGluXG4gICAgICBtYXRjaCB4IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBmaWx0ZXJfbWFwX3MgZiBuZXh0ICgpXG4gICAgICB8IFNvbWUgeSAtPiBMd3QucmV0dXJuIChDb25zICh5LCBmaWx0ZXJfbWFwX3MgZiBuZXh0KSApKVxubGV0IGZpbHRlcl9tYXBfcyBmIHNlcSAoKSA9XG4gIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPiAoXG4gICAgICBsZXQqIHggPSBmIHggaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBOb25lIC0+IGZpbHRlcl9tYXBfcyBmIG5leHQgKClcbiAgICAgIHwgU29tZSB5IC0+IEx3dC5yZXR1cm4gKENvbnMgKHksIGZpbHRlcl9tYXBfcyBmIG5leHQpICkpXG5cbmxldCByZWMgZmlsdGVyIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCBvayA9IGYgeCBpblxuICAgICAgaWYgb2sgdGhlbiBMd3QucmV0dXJuIChDb25zICh4LCBmaWx0ZXIgZiBuZXh0KSkgZWxzZSBmaWx0ZXIgZiBuZXh0ICgpXG5sZXQgZmlsdGVyIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBsZXQgb2sgPSBmIHggaW5cbiAgICAgIGlmIG9rIHRoZW4gTHd0LnJldHVybiAoQ29ucyAoeCwgZmlsdGVyIGYgbmV4dCkpIGVsc2UgZmlsdGVyIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGZpbHRlcl9zIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGxldCogb2sgPSBmIHggaW5cbiAgICAgIGlmIG9rIHRoZW4gTHd0LnJldHVybiAoQ29ucyAoeCwgZmlsdGVyX3MgZiBuZXh0KSkgZWxzZSBmaWx0ZXJfcyBmIG5leHQgKClcbmxldCBmaWx0ZXJfcyBmIHNlcSAoKSA9XG4gIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gIHwgTmlsIC0+IHJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgbGV0KiBvayA9IGYgeCBpblxuICAgICAgaWYgb2sgdGhlbiBMd3QucmV0dXJuIChDb25zICh4LCBmaWx0ZXJfcyBmIG5leHQpKSBlbHNlIGZpbHRlcl9zIGYgbmV4dCAoKVxuXG5sZXQgcmVjIGZsYXRfbWFwIGYgc2VxICgpID1cbiAgc2VxICgpID4+PSBmdW5jdGlvblxuICB8IE5pbCAtPiByZXR1cm5fbmlsXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgIGZsYXRfbWFwX2FwcCBmIChmIHgpIG5leHQgKClcblxuKCogdGhpcyBpcyBbYXBwZW5kIHNlcSAoZmxhdF9tYXAgZiB0YWlsKV0gKilcbmFuZCBmbGF0X21hcF9hcHAgZiBzZXEgdGFpbCAoKSA9XG4gIHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gZmxhdF9tYXAgZiB0YWlsICgpXG4gIHwgQ29ucyAoeCwgbmV4dCkgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgZmxhdF9tYXBfYXBwIGYgbmV4dCB0YWlsKSlcblxubGV0IGZsYXRfbWFwIGYgc2VxICgpID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gcmV0dXJuX25pbFxuICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICBmbGF0X21hcF9hcHAgZiAoZiB4KSBuZXh0ICgpXG5cbmxldCBmb2xkX2xlZnQgZiBhY2Mgc2VxID1cbiAgbGV0IHJlYyBhdXggZiBhY2Mgc2VxID1cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LnJldHVybiBhY2NcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGxldCBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGF1eCBmIGFjYyBuZXh0XG4gIGluXG4gIGxldCBhdXggZiBhY2Mgc2VxID1cbiAgICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgYWNjID0gZiBhY2MgeCBpblxuICAgICAgICBhdXggZiBhY2MgbmV4dFxuICBpblxuICBhdXggZiBhY2Mgc2VxXG5cbmxldCBmb2xkX2xlZnRfcyBmIGFjYyBzZXEgPVxuICBsZXQgcmVjIGF1eCBmIGFjYyBzZXEgPVxuICAgIHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiBMd3QucmV0dXJuIGFjY1xuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0KiBhY2MgPSBmIGFjYyB4IGluXG4gICAgICAgIGF1eCBmIGFjYyBuZXh0XG4gIGluXG4gIGxldCBhdXggZiBhY2Mgc2VxID1cbiAgICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQqIGFjYyA9IGYgYWNjIHggaW5cbiAgICAgICAgYXV4IGYgYWNjIG5leHRcbiAgaW5cbiAgYXV4IGYgYWNjIHNlcVxuXG5sZXQgaXRlciBmIHNlcSA9XG4gIGxldCByZWMgYXV4IHNlcSA9XG4gICAgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm5fdW5pdFxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgZiB4O1xuICAgICAgICBhdXggbmV4dFxuICBpblxuICBsZXQgYXV4IHNlcSA9XG4gICAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgICB8IE5pbCAtPiBMd3QucmV0dXJuX3VuaXRcbiAgICB8IENvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgIGYgeDtcbiAgICAgICAgYXV4IG5leHRcbiAgaW5cbiAgYXV4IHNlcVxuXG5sZXQgaXRlcl9zIGYgc2VxID1cbiAgbGV0IHJlYyBhdXggc2VxID1cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LnJldHVybl91bml0XG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQqICgpID0gZiB4IGluXG4gICAgICAgIGF1eCBuZXh0XG4gIGluXG4gIGxldCBhdXggc2VxID1cbiAgICBMd3QuYXBwbHkgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+IEx3dC5yZXR1cm5fdW5pdFxuICAgIHwgQ29ucyAoeCwgbmV4dCkgLT5cbiAgICAgICAgbGV0KiAoKSA9IGYgeCBpblxuICAgICAgICBhdXggbmV4dFxuICBpblxuICBhdXggc2VxXG5cbmxldCBpdGVyX3AgZiBzZXEgPVxuICBsZXQgcmVjIGF1eCBhY2Mgc2VxID1cbiAgICBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LmpvaW4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgcCA9IGYgeCBpblxuICAgICAgICBhdXggKHA6OmFjYykgbmV4dFxuICBpblxuICBsZXQgYXV4IGFjYyBzZXEgPVxuICAgIEx3dC5hcHBseSBzZXEgKCkgPj49IGZ1bmN0aW9uXG4gICAgfCBOaWwgLT4gTHd0LmpvaW4gYWNjXG4gICAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgICAgICBsZXQgcCA9IGYgeCBpblxuICAgICAgICBhdXggKHA6OmFjYykgbmV4dFxuICBpblxuICBhdXggW10gc2VxXG5cbmxldCBpdGVyX24gPyhtYXhfY29uY3VycmVuY3kgPSAxKSBmIHNlcSA9XG4gIGJlZ2luXG4gICAgaWYgbWF4X2NvbmN1cnJlbmN5IDw9IDAgdGhlblxuICAgICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgICBQcmludGYuc3ByaW50ZlxuICAgICAgICAgIFwiTHd0X3NlcS5pdGVyX246IG1heF9jb25jdXJyZW5jeSBtdXN0IGJlID4gMCwgJWQgZ2l2ZW5cIlxuICAgICAgICAgIG1heF9jb25jdXJyZW5jeVxuICAgICAgaW5cbiAgICAgIGludmFsaWRfYXJnIG1lc3NhZ2VcbiAgZW5kO1xuICBsZXQgcmVjIGxvb3AgcnVubmluZyBhdmFpbGFibGUgc2VxID1cbiAgICBiZWdpblxuICAgICAgaWYgYXZhaWxhYmxlID4gMCB0aGVuIChcbiAgICAgICAgTHd0LnJldHVybiAocnVubmluZywgYXZhaWxhYmxlKVxuICAgICAgKVxuICAgICAgZWxzZSAoXG4gICAgICAgIEx3dC5uY2hvb3NlX3NwbGl0IHJ1bm5pbmcgPj49IGZ1biAoY29tcGxldGUsIHJ1bm5pbmcpIC0+XG4gICAgICAgIEx3dC5yZXR1cm4gKHJ1bm5pbmcsIGF2YWlsYWJsZSArIExpc3QubGVuZ3RoIGNvbXBsZXRlKVxuICAgICAgKVxuICAgIGVuZCA+Pj0gZnVuIChydW5uaW5nLCBhdmFpbGFibGUpIC0+XG4gICAgc2VxICgpID4+PSBmdW5jdGlvblxuICAgIHwgTmlsIC0+XG4gICAgICBMd3Quam9pbiBydW5uaW5nXG4gICAgfCBDb25zIChlbHQsIHNlcSkgLT5cbiAgICAgIGxvb3AgKGYgZWx0IDo6IHJ1bm5pbmcpIChwcmVkIGF2YWlsYWJsZSkgc2VxXG4gIGluXG4gICgqIGJlY2F1c2UgdGhlIHJlY3Vyc2lvbiBpcyBtb3JlIGNvbXBsaWNhdGVkIGhlcmUsIHdlIGFwcGx5IHRoZSBzZXEgZGlyZWN0bHkgYXRcbiAgICAgdGhlIGNhbGwtc2l0ZSBpbnN0ZWFkICopXG4gIGxvb3AgW10gbWF4X2NvbmN1cnJlbmN5IChmdW4gKCkgLT4gTHd0LmFwcGx5IHNlcSAoKSlcblxubGV0IHJlYyB1bmZvbGQgZiB1ICgpID1cbiAgbWF0Y2ggZiB1IHdpdGhcbiAgfCBOb25lIC0+IHJldHVybl9uaWxcbiAgfCBTb21lICh4LCB1JykgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgdW5mb2xkIGYgdScpKVxuICB8IGV4Y2VwdGlvbiBleGMgd2hlbiBMd3QuRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhjIC0+IEx3dC5mYWlsIGV4Y1xuXG5sZXQgcmVjIHVuZm9sZF9sd3QgZiB1ICgpID1cbiAgbGV0KiB4ID0gZiB1IGluXG4gIG1hdGNoIHggd2l0aFxuICB8IE5vbmUgLT4gcmV0dXJuX25pbFxuICB8IFNvbWUgKHgsIHUnKSAtPiBMd3QucmV0dXJuIChDb25zICh4LCB1bmZvbGRfbHd0IGYgdScpKVxubGV0IHVuZm9sZF9sd3QgZiB1ICgpID1cbiAgbGV0KiB4ID0gTHd0LmFwcGx5IGYgdSBpblxuICBtYXRjaCB4IHdpdGhcbiAgfCBOb25lIC0+IHJldHVybl9uaWxcbiAgfCBTb21lICh4LCB1JykgLT4gTHd0LnJldHVybiAoQ29ucyAoeCwgdW5mb2xkX2x3dCBmIHUnKSlcblxubGV0IHJlYyBvZl9saXN0ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiBlbXB0eVxuICB8IGggOjogdCAtPiBjb25zIGggKG9mX2xpc3QgdClcblxubGV0IHJlYyB0b19saXN0IHNlcSA9XG4gIHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gTHd0LnJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgIGxldCsgbCA9IHRvX2xpc3QgbmV4dCBpblxuICAgIHggOjogbFxubGV0IHRvX2xpc3Qgc2VxID1cbiAgTHd0LmFwcGx5IHNlcSAoKSA+Pj0gZnVuY3Rpb25cbiAgfCBOaWwgLT4gTHd0LnJldHVybl9uaWxcbiAgfCBDb25zICh4LCBuZXh0KSAtPlxuICAgIGxldCsgbCA9IHRvX2xpc3QgbmV4dCBpblxuICAgIHggOjogbFxuXG5sZXQgcmVjIG9mX3NlcSBzZXEgKCkgPVxuICBtYXRjaCBzZXEgKCkgd2l0aFxuICB8IFNlcS5OaWwgLT4gcmV0dXJuX25pbFxuICB8IFNlcS5Db25zICh4LCBuZXh0KSAtPlxuICAgIEx3dC5yZXR1cm4gKENvbnMgKHgsIChvZl9zZXEgbmV4dCkpKVxuICB8IGV4Y2VwdGlvbiBleG4gd2hlbiBMd3QuRXhjZXB0aW9uX2ZpbHRlci5ydW4gZXhuIC0+IEx3dC5mYWlsIGV4blxuXG5sZXQgcmVjIG9mX3NlcV9sd3QgKHNlcTogJ2EgTHd0LnQgU2VxLnQpOiAnYSB0ID0gZnVuICgpIC0+XG4gICAgbWF0Y2ggc2VxICgpIHdpdGhcbiAgICB8IFNlcS5OaWwgLT4gcmV0dXJuX25pbFxuICAgIHwgU2VxLkNvbnMgKHgsIG5leHQpIC0+XG4gICAgICAgbGV0KyB4ID0geCBpblxuICAgICAgIGxldCBuZXh0ID0gb2Zfc2VxX2x3dCBuZXh0IGluXG4gICAgICAgQ29ucyAoeCwgbmV4dClcbmxldCBvZl9zZXFfbHd0IChzZXE6ICdhIEx3dC50IFNlcS50KTogJ2EgdCA9IGZ1biAoKSAtPlxuICAgIG1hdGNoIHNlcSAoKSB3aXRoXG4gICAgfCBTZXEuTmlsIC0+IHJldHVybl9uaWxcbiAgICB8IFNlcS5Db25zICh4LCBuZXh0KSAtPlxuICAgICAgIGxldCsgeCA9IHggaW5cbiAgICAgICBsZXQgbmV4dCA9IG9mX3NlcV9sd3QgbmV4dCBpblxuICAgICAgIENvbnMgKHgsIG5leHQpXG4gICAgfCBleGNlcHRpb24gZXhjIHdoZW4gTHd0LkV4Y2VwdGlvbl9maWx0ZXIucnVuIGV4YyAtPiBMd3QuZmFpbCBleGNcbiIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5vcGVuIEx3dC5JbmZpeFxuXG5leGNlcHRpb24gQ2xvc2VkXG5leGNlcHRpb24gRnVsbFxuZXhjZXB0aW9uIEVtcHR5XG5cbigqIEEgbm9kZSBpbiBhIHF1ZXVlIG9mIHBlbmRpbmcgZGF0YS4gKilcbnR5cGUgJ2Egbm9kZSA9IHtcbiAgbXV0YWJsZSBuZXh0IDogJ2Egbm9kZTtcbiAgKCogTmV4dCBub2RlIGluIHRoZSBxdWV1ZS4gRm9yIHRoZSBsYXN0IG5vZGUgaXQgcG9pbnRzIHRvIGl0c2VsZi4gKilcbiAgbXV0YWJsZSBkYXRhIDogJ2Egb3B0aW9uO1xuICAoKiBEYXRhIG9mIHRoaXMgbm9kZS4gRm9yIHRoZSBsYXN0IG5vZGUgaXQgaXMgYWx3YXlzIFtOb25lXS4gKilcbn1cblxuKCogTm90ZTogYSBxdWV1ZSBmb3IgYW4gZXhoYXVzdGVkIHN0cmVhbSBpcyByZXByZXNlbnRlZCBieSBhIG5vZGVcbiAgIGNvbnRhaW5pbmcgW05vbmVdIGZvbGxvd2VkIGJ5IGEgbm9kZSB3aXRoIGl0c2VsZiBhcyBuZXh0IGFuZCBbTm9uZV1cbiAgIGFzIGRhdGEuICopXG5cbmxldCBuZXdfbm9kZSAoKSA9XG4gIGxldCByZWMgbm9kZSA9IHsgbmV4dCA9IG5vZGU7IGRhdGEgPSBOb25lIH0gaW5cbiAgbm9kZVxuXG4oKiBUeXBlIG9mIGEgc3RyZWFtIHNvdXJjZSB1c2luZyBhIGZ1bmN0aW9uIHRvIGNyZWF0ZSBuZXcgZWxlbWVudHMuICopXG50eXBlICdhIGZyb20gPSB7XG4gIGZyb21fY3JlYXRlIDogdW5pdCAtPiAnYSBvcHRpb24gTHd0LnQ7XG4gICgqIEZ1bmN0aW9uIHVzZWQgdG8gY3JlYXRlIG5ldyBlbGVtZW50cy4gKilcbiAgbXV0YWJsZSBmcm9tX3RocmVhZCA6IHVuaXQgTHd0LnQ7XG4gICgqIFRocmVhZCB3aGljaDpcblxuICAgICAtIHdhaXQgZm9yIHRoZSB0aHJlYWQgcmV0dXJuZWQgYnkgdGhlIGxhc3QgY2FsbCB0byBbZnJvbV9uZXh0XSxcbiAgICAgLSBhZGQgdGhlIG5leHQgZWxlbWVudCB0byB0aGUgZW5kIG9mIHRoZSBxdWV1ZS5cblxuICAgICBJZiBpdCBpcyBhIHNsZWVwaW5nIHRocmVhZCwgdGhlbiBpdCBtdXN0IGJlIHVzZWQgaW5zdGVhZCBvZiBjcmVhdGluZyBhXG4gICAgIG5ldyBvbmUgd2l0aCBbZnJvbV9jcmVhdGVdLiAqKVxufVxuXG4oKiBUeXBlIG9mIGEgc3RyZWFtIHNvdXJjZSBmb3IgcHVzaCBzdHJlYW1zLiAqKVxudHlwZSBwdXNoID0ge1xuICBtdXRhYmxlIHB1c2hfc2lnbmFsIDogdW5pdCBMd3QudDtcbiAgKCogVGhyZWFkIHNpZ25hbGVkIHdoZW4gYSBuZXcgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgc3RyZWFtLiAqKVxuICBtdXRhYmxlIHB1c2hfd2FpdGluZyA6IGJvb2w7XG4gICgqIElzIGEgdGhyZWFkIHdhaXRpbmcgb24gW3B1c2hfc2lnbmFsXSA/ICopXG4gIG11dGFibGUgcHVzaF9leHRlcm5hbCA6IE9iai50IFtAb2NhbWwud2FybmluZyBcIi02OVwiXTtcbiAgKCogUmVmZXJlbmNlIHRvIGFuIGV4dGVybmFsIHNvdXJjZS4gKilcbn1cblxuKCogVHlwZSBvZiBhIHN0cmVhbSBzb3VyY2UgZm9yIGJvdW5kZWQtcHVzaCBzdHJlYW1zLiAqKVxudHlwZSAnYSBwdXNoX2JvdW5kZWQgPSB7XG4gIG11dGFibGUgcHVzaGJfc2lnbmFsIDogdW5pdCBMd3QudDtcbiAgKCogVGhyZWFkIHNpZ25hbGVkIHdoZW4gYSBuZXcgZWxlbWVudCBpcyBhZGRlZCB0byB0aGUgc3RyZWFtLiAqKVxuICBtdXRhYmxlIHB1c2hiX3dhaXRpbmcgOiBib29sO1xuICAoKiBJcyBhIHRocmVhZCB3YWl0aW5nIG9uIFtwdXNoYl9zaWduYWxdID8gKilcbiAgbXV0YWJsZSBwdXNoYl9zaXplIDogaW50O1xuICAoKiBTaXplIG9mIHRoZSBxdWV1ZS4gKilcbiAgbXV0YWJsZSBwdXNoYl9jb3VudCA6IGludDtcbiAgKCogQ3VycmVudCBsZW5ndGggb2YgdGhlIHF1ZXVlLiAqKVxuICBtdXRhYmxlIHB1c2hiX3BlbmRpbmcgOiAnYSBvcHRpb247XG4gICgqIFRoZSBuZXh0IGVsZW1lbnQgdG8gcHVzaCBpZiBhIHRocmVhZCBibG9ja2VkIG9uIHB1c2guIFdlIHN0b3JlIGl0XG4gICAgIGhlcmUgdG8gYmUgc3VyZSBpdCB3aWxsIGJlIHRoZSBmaXJzdCBlbGVtZW50IHRvIGJlIGFkZGVkIHdoZW5cbiAgICAgc3BhY2UgYmVjb21lcyBhdmFpbGFibGUuICopXG4gIG11dGFibGUgcHVzaGJfcHVzaF93YWl0ZXIgOiB1bml0IEx3dC50O1xuICBtdXRhYmxlIHB1c2hiX3B1c2hfd2FrZW5lciA6IHVuaXQgTHd0LnU7XG4gICgqIFRocmVhZCBibG9ja2VkIG9uIHB1c2guICopXG4gIG11dGFibGUgcHVzaGJfZXh0ZXJuYWwgOiBPYmoudCBbQG9jYW1sLndhcm5pbmcgXCItNjlcIl07XG4gICgqIFJlZmVyZW5jZSB0byBhbiBleHRlcm5hbCBzb3VyY2UuICopXG59XG5cbigqIFNvdXJjZSBvZiBhIHN0cmVhbS4gKilcbnR5cGUgJ2Egc291cmNlID1cbiAgfCBGcm9tIG9mICdhIGZyb21cbiAgfCBGcm9tX2RpcmVjdCBvZiAodW5pdCAtPiAnYSBvcHRpb24pXG4gIHwgUHVzaCBvZiBwdXNoXG4gIHwgUHVzaF9ib3VuZGVkIG9mICdhIHB1c2hfYm91bmRlZFxuXG50eXBlICdhIHQgPSB7XG4gIHNvdXJjZSA6ICdhIHNvdXJjZTtcbiAgKCogVGhlIHNvdXJjZSBvZiB0aGUgc3RyZWFtLiAqKVxuICBjbG9zZSA6IHVuaXQgTHd0LnU7XG4gICgqIEEgd2FrZW5lciBmb3IgYSB0aHJlYWQgdGhhdCBzbGVlcHMgdW50aWwgdGhlIHN0cmVhbSBpcyBjbG9zZWQuICopXG4gIGNsb3NlZCA6IHVuaXQgTHd0LnQ7XG4gICgqIEEgd2FpdGVyIGZvciBhIHRocmVhZCB0aGF0IHNsZWVwcyB1bnRpbCB0aGUgc3RyZWFtIGlzIGNsb3NlZC4gKilcbiAgbXV0YWJsZSBub2RlIDogJ2Egbm9kZTtcbiAgKCogUG9pbnRlciB0byBmaXJzdCBwZW5kaW5nIGVsZW1lbnQsIG9yIHRvIFtsYXN0XSBpZiB0aGVyZSBpcyBub1xuICAgICBwZW5kaW5nIGVsZW1lbnQuICopXG4gIGxhc3QgOiAnYSBub2RlIHJlZjtcbiAgKCogTm9kZSBtYXJraW5nIHRoZSBlbmQgb2YgdGhlIHF1ZXVlIG9mIHBlbmRpbmcgZWxlbWVudHMuICopXG59XG5cbmNsYXNzIHR5cGUgWydhXSBib3VuZGVkX3B1c2ggPSBvYmplY3RcbiAgbWV0aG9kIHNpemUgOiBpbnRcbiAgbWV0aG9kIHJlc2l6ZSA6IGludCAtPiB1bml0XG4gIG1ldGhvZCBwdXNoIDogJ2EgLT4gdW5pdCBMd3QudFxuICBtZXRob2QgY2xvc2UgOiB1bml0XG4gIG1ldGhvZCBjb3VudCA6IGludFxuICBtZXRob2QgYmxvY2tlZCA6IGJvb2xcbiAgbWV0aG9kIGNsb3NlZCA6IGJvb2xcbiAgbWV0aG9kIHNldF9yZWZlcmVuY2UgOiAnYS4gJ2EgLT4gdW5pdFxuZW5kXG5cbigqIFRoZSBvbmx5IGRpZmZlcmVuY2UgYmV0d2VlbiB0d28gY2xvbmVzIGlzIHRoZSBwb2ludGVyIHRvIHRoZSBmaXJzdFxuICAgcGVuZGluZyBlbGVtZW50LiAqKVxubGV0IGNsb25lIHMgPVxuICAobWF0Y2ggcy5zb3VyY2Ugd2l0aFxuICAgfCBQdXNoX2JvdW5kZWQgXyAtPiBpbnZhbGlkX2FyZyBcIkx3dF9zdHJlYW0uY2xvbmVcIlxuICAgfCBGcm9tIF8gfCBGcm9tX2RpcmVjdCBfIHwgUHVzaCBfIC0+ICgpKTtcbiAge1xuICAgIHNvdXJjZSA9IHMuc291cmNlO1xuICAgIGNsb3NlID0gcy5jbG9zZTtcbiAgICBjbG9zZWQgPSBzLmNsb3NlZDtcbiAgICBub2RlID0gcy5ub2RlO1xuICAgIGxhc3QgPSBzLmxhc3Q7XG4gIH1cblxubGV0IGZyb21fc291cmNlIHNvdXJjZSA9XG4gIGxldCBub2RlID0gbmV3X25vZGUgKCkgaW5cbiAgbGV0IGNsb3NlZCwgY2xvc2UgPSBMd3Qud2FpdCAoKSBpblxuICB7IHNvdXJjZSA7IGNsb3NlIDsgY2xvc2VkIDsgbm9kZSA7IGxhc3QgPSByZWYgbm9kZSB9XG5cbmxldCBmcm9tIGYgPVxuICBmcm9tX3NvdXJjZSAoRnJvbSB7IGZyb21fY3JlYXRlID0gZjsgZnJvbV90aHJlYWQgPSBMd3QucmV0dXJuX3VuaXQgfSlcblxubGV0IGZyb21fZGlyZWN0IGYgPVxuICBmcm9tX3NvdXJjZSAoRnJvbV9kaXJlY3QgZilcblxubGV0IGNsb3NlZCBzID0gcy5jbG9zZWRcblxubGV0IGlzX2Nsb3NlZCBzID1cbiAgbm90IChMd3QuaXNfc2xlZXBpbmcgKGNsb3NlZCBzKSlcblxubGV0IGVucXVldWUnIGUgbGFzdCA9XG4gIGxldCBub2RlID0gIWxhc3RcbiAgYW5kIG5ld19sYXN0ID0gbmV3X25vZGUgKCkgaW5cbiAgbm9kZS5kYXRhIDwtIGU7XG4gIG5vZGUubmV4dCA8LSBuZXdfbGFzdDtcbiAgbGFzdCA6PSBuZXdfbGFzdFxuXG5sZXQgZW5xdWV1ZSBlIHMgPVxuICBlbnF1ZXVlJyBlIHMubGFzdFxuXG5sZXQgY3JlYXRlX3dpdGhfcmVmZXJlbmNlICgpID1cbiAgKCogQ3JlYXRlIHRoZSBzb3VyY2UgZm9yIG5vdGlmaWNhdGlvbnMgb2YgbmV3IGVsZW1lbnRzLiAqKVxuICBsZXQgc291cmNlLCBwdXNoX3NpZ25hbF9yZXNvbHZlciA9XG4gICAgbGV0IHB1c2hfc2lnbmFsLCBwdXNoX3NpZ25hbF9yZXNvbHZlciA9IEx3dC53YWl0ICgpIGluXG4gICAgKHsgcHVzaF9zaWduYWw7XG4gICAgICAgcHVzaF93YWl0aW5nID0gZmFsc2U7XG4gICAgICAgcHVzaF9leHRlcm5hbCA9IE9iai5yZXByICgpIH0sXG4gICAgIHJlZiBwdXNoX3NpZ25hbF9yZXNvbHZlcilcbiAgaW5cbiAgbGV0IHQgPSBmcm9tX3NvdXJjZSAoUHVzaCBzb3VyY2UpIGluXG4gICgqIFtwdXNoXSBzaG91bGQgbm90IGNsb3NlIG92ZXIgW3RdIHNvIHRoYXQgaXQgY2FuIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGV2ZW5cbiAgICogdGhlcmUgYXJlIHN0aWxsIHJlZmVyZW5jZXMgdG8gW3B1c2hdLiBVbnBhY2sgYWxsIHRoZSBjb21wb25lbnRzIG9mIFt0XVxuICAgKiB0aGF0IFtwdXNoXSBuZWVkcyBhbmQgcmVmZXJlbmNlIHRob3NlIGlkZW50aWZpZXJzIGluc3RlYWQuICopXG4gIGxldCBjbG9zZSA9IHQuY2xvc2UgYW5kIGNsb3NlZCA9IHQuY2xvc2VkIGFuZCBsYXN0ID0gdC5sYXN0IGluXG4gICgqIFRoZSBwdXNoIGZ1bmN0aW9uLiBJdCBkb2VzIG5vdCBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdHJlYW0uICopXG4gIGxldCBwdXNoIHggPVxuICAgIGlmIG5vdCAoTHd0LmlzX3NsZWVwaW5nIGNsb3NlZCkgdGhlbiByYWlzZSBDbG9zZWQ7XG4gICAgKCogUHVzaCB0aGUgZWxlbWVudCBhdCB0aGUgZW5kIG9mIHRoZSBxdWV1ZS4gKilcbiAgICBlbnF1ZXVlJyB4IGxhc3Q7XG4gICAgKCogU2VuZCBhIHNpZ25hbCBpZiBhdCBsZWFzdCBvbmUgdGhyZWFkIGlzIHdhaXRpbmcgZm9yIGEgbmV3XG4gICAgICAgZWxlbWVudC4gKilcbiAgICBpZiBzb3VyY2UucHVzaF93YWl0aW5nIHRoZW4gYmVnaW5cbiAgICAgIHNvdXJjZS5wdXNoX3dhaXRpbmcgPC0gZmFsc2U7XG4gICAgICAoKiBVcGRhdGUgdGhyZWFkcy4gKilcbiAgICAgIGxldCBvbGRfcHVzaF9zaWduYWxfcmVzb2x2ZXIgPSAhcHVzaF9zaWduYWxfcmVzb2x2ZXIgaW5cbiAgICAgIGxldCBuZXdfd2FpdGVyLCBuZXdfcHVzaF9zaWduYWxfcmVzb2x2ZXIgPSBMd3Qud2FpdCAoKSBpblxuICAgICAgc291cmNlLnB1c2hfc2lnbmFsIDwtIG5ld193YWl0ZXI7XG4gICAgICBwdXNoX3NpZ25hbF9yZXNvbHZlciA6PSBuZXdfcHVzaF9zaWduYWxfcmVzb2x2ZXI7XG4gICAgICAoKiBTaWduYWwgdGhhdCBhIG5ldyB2YWx1ZSBoYXMgYmVlbiByZWNlaXZlZC4gKilcbiAgICAgIEx3dC53YWtldXBfbGF0ZXIgb2xkX3B1c2hfc2lnbmFsX3Jlc29sdmVyICgpXG4gICAgZW5kO1xuICAgICgqIERvIHRoaXMgYXQgdGhlIGVuZCBpbiBjYXNlIG9uZSBvZiB0aGUgZnVuY3Rpb24gcmFpc2UgYW5cbiAgICAgICBleGNlcHRpb24uICopXG4gICAgaWYgeCA9IE5vbmUgdGhlbiBMd3Qud2FrZXVwIGNsb3NlICgpXG4gIGluXG4gICh0LCBwdXNoLCBmdW4geCAtPiBzb3VyY2UucHVzaF9leHRlcm5hbCA8LSBPYmoucmVwciB4KVxuXG5sZXQgcmV0dXJuIGEgPVxuICBsZXQgc3RyZWFtLCBwdXNoLCBfID0gY3JlYXRlX3dpdGhfcmVmZXJlbmNlICgpIGluXG4gIHB1c2ggKFNvbWUgYSk7XG4gIHB1c2ggTm9uZTtcbiAgc3RyZWFtXG5cbmxldCByZXR1cm5fbHd0IGEgPVxuICBsZXQgc291cmNlLCBwdXNoLCBfID0gY3JlYXRlX3dpdGhfcmVmZXJlbmNlICgpIGluXG4gIEx3dC5kb250X3dhaXRcbiAgICAoZnVuICgpIC0+XG4gICAgICBMd3QuYmluZCBhIChmdW4geCAtPlxuICAgICAgICBwdXNoIChTb21lIHgpO1xuICAgICAgICBwdXNoIE5vbmU7XG4gICAgICAgIEx3dC5yZXR1cm5fdW5pdCkpXG4gICAgKGZ1biBfZXhjIC0+IHB1c2ggTm9uZSk7XG4gIHNvdXJjZVxuXG5sZXQgb2Zfc2VxIHMgPVxuICBsZXQgcyA9IHJlZiBzIGluXG4gIGxldCBnZXQgKCkgPVxuICAgIG1hdGNoICFzICgpIHdpdGhcbiAgICB8IFNlcS5OaWwgLT4gTm9uZVxuICAgIHwgU2VxLkNvbnMgKGVsdCwgcycpIC0+IHMgOj0gcyc7IFNvbWUgZWx0XG4gIGluXG4gIGZyb21fZGlyZWN0IGdldFxuXG5sZXQgb2ZfbHd0X3NlcSBzID1cbiAgbGV0IHMgPSByZWYgcyBpblxuICBsZXQgZ2V0ICgpID1cbiAgICAhcyAoKSA+fD0gZnVuY3Rpb25cbiAgICB8IEx3dF9zZXEuTmlsIC0+IE5vbmVcbiAgICB8IEx3dF9zZXEuQ29ucyAoZWx0LCBzJykgLT4gcyA6PSBzJzsgU29tZSBlbHRcbiAgaW5cbiAgZnJvbSBnZXRcblxuXG5sZXQgY3JlYXRlICgpID1cbiAgbGV0IHNvdXJjZSwgcHVzaCwgXyA9IGNyZWF0ZV93aXRoX3JlZmVyZW5jZSAoKSBpblxuICAoc291cmNlLCBwdXNoKVxuXG5sZXQgb2ZfaXRlciBpdGVyIGkgPVxuICBsZXQgc3RyZWFtLCBwdXNoID0gY3JlYXRlICgpIGluXG4gIGl0ZXIgKGZ1biB4IC0+IHB1c2ggKFNvbWUgeCkpIGk7XG4gIHB1c2ggTm9uZTtcbiAgc3RyZWFtXG5cbmxldCBvZl9saXN0IGwgPVxuICBvZl9pdGVyIExpc3QuaXRlciBsXG5cbmxldCBvZl9hcnJheSBhID1cbiAgb2ZfaXRlciBBcnJheS5pdGVyIGFcblxubGV0IG9mX3N0cmluZyBzID1cbiAgb2ZfaXRlciBTdHJpbmcuaXRlciBzXG5cbigqIEFkZCB0aGUgcGVuZGluZyBlbGVtZW50IHRvIHRoZSBxdWV1ZSBhbmQgbm90aWZ5IHRoZSBibG9ja2VkIHB1c2hlZC5cblxuICAgUHJlY29uZGl0aW9uOiBpbmZvLnB1c2hiX3BlbmRpbmcgPSBTb21lIF9cblxuICAgVGhpcyBkb2VzIG5vdCBtb2RpZnkgaW5mby5wdXNoYl9jb3VudC4gKilcbmxldCBub3RpZnlfcHVzaGVyIGluZm8gbGFzdCA9XG4gICgqIFB1c2ggdGhlIGVsZW1lbnQgYXQgdGhlIGVuZCBvZiB0aGUgcXVldWUuICopXG4gIGVucXVldWUnIGluZm8ucHVzaGJfcGVuZGluZyBsYXN0O1xuICAoKiBDbGVhciBwZW5kaW5nIGVsZW1lbnQuICopXG4gIGluZm8ucHVzaGJfcGVuZGluZyA8LSBOb25lO1xuICAoKiBXYWtldXAgdGhlIHB1c2hlci4gKilcbiAgbGV0IG9sZF93YWtlbmVyID0gaW5mby5wdXNoYl9wdXNoX3dha2VuZXIgaW5cbiAgbGV0IHdhaXRlciwgd2FrZW5lciA9IEx3dC50YXNrICgpIGluXG4gIGluZm8ucHVzaGJfcHVzaF93YWl0ZXIgPC0gd2FpdGVyO1xuICBpbmZvLnB1c2hiX3B1c2hfd2FrZW5lciA8LSB3YWtlbmVyO1xuICBMd3Qud2FrZXVwX2xhdGVyIG9sZF93YWtlbmVyICgpXG5cbmNsYXNzIFsnYV0gYm91bmRlZF9wdXNoX2ltcGwgKGluZm8gOiAnYSBwdXNoX2JvdW5kZWQpIHdha2VuZXJfY2VsbCBsYXN0IGNsb3NlID0gb2JqZWN0XG4gIHZhbCBtdXRhYmxlIGNsb3NlZCA9IGZhbHNlXG5cbiAgbWV0aG9kIHNpemUgPVxuICAgIGluZm8ucHVzaGJfc2l6ZVxuXG4gIG1ldGhvZCByZXNpemUgc2l6ZSA9XG4gICAgaWYgc2l6ZSA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkx3dF9zdHJlYW0uYm91bmRlZF9wdXNoI3Jlc2l6ZVwiO1xuICAgIGluZm8ucHVzaGJfc2l6ZSA8LSBzaXplO1xuICAgIGlmIGluZm8ucHVzaGJfY291bnQgPCBpbmZvLnB1c2hiX3NpemUgJiYgaW5mby5wdXNoYl9wZW5kaW5nIDw+IE5vbmUgdGhlbiBiZWdpblxuICAgICAgaW5mby5wdXNoYl9jb3VudCA8LSBpbmZvLnB1c2hiX2NvdW50ICsgMTtcbiAgICAgIG5vdGlmeV9wdXNoZXIgaW5mbyBsYXN0XG4gICAgZW5kXG5cbiAgbWV0aG9kIHB1c2ggeCA9XG4gICAgaWYgY2xvc2VkIHRoZW5cbiAgICAgIEx3dC5mYWlsIENsb3NlZFxuICAgIGVsc2UgaWYgaW5mby5wdXNoYl9wZW5kaW5nIDw+IE5vbmUgdGhlblxuICAgICAgTHd0LmZhaWwgRnVsbFxuICAgIGVsc2UgaWYgaW5mby5wdXNoYl9jb3VudCA+PSBpbmZvLnB1c2hiX3NpemUgdGhlbiBiZWdpblxuICAgICAgaW5mby5wdXNoYl9wZW5kaW5nIDwtIFNvbWUgeDtcbiAgICAgIEx3dC5jYXRjaFxuICAgICAgICAoZnVuICgpIC0+IGluZm8ucHVzaGJfcHVzaF93YWl0ZXIpXG4gICAgICAgIChmdW4gZXhuIC0+XG4gICAgICAgICAgIG1hdGNoIGV4biB3aXRoXG4gICAgICAgICAgIHwgTHd0LkNhbmNlbGVkIC0+XG4gICAgICAgICAgICAgaW5mby5wdXNoYl9wZW5kaW5nIDwtIE5vbmU7XG4gICAgICAgICAgICAgbGV0IHdhaXRlciwgd2FrZW5lciA9IEx3dC50YXNrICgpIGluXG4gICAgICAgICAgICAgaW5mby5wdXNoYl9wdXNoX3dhaXRlciA8LSB3YWl0ZXI7XG4gICAgICAgICAgICAgaW5mby5wdXNoYl9wdXNoX3dha2VuZXIgPC0gd2FrZW5lcjtcbiAgICAgICAgICAgICBMd3QuZmFpbCBleG5cbiAgICAgICAgICAgfCBfIC0+XG4gICAgICAgICAgICAgTHd0LmZhaWwgZXhuKVxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAoKiBQdXNoIHRoZSBlbGVtZW50IGF0IHRoZSBlbmQgb2YgdGhlIHF1ZXVlLiAqKVxuICAgICAgZW5xdWV1ZScgKFNvbWUgeCkgbGFzdDtcbiAgICAgIGluZm8ucHVzaGJfY291bnQgPC0gaW5mby5wdXNoYl9jb3VudCArIDE7XG4gICAgICAoKiBTZW5kIGEgc2lnbmFsIGlmIGF0IGxlYXN0IG9uZSB0aHJlYWQgaXMgd2FpdGluZyBmb3IgYSBuZXdcbiAgICAgICAgIGVsZW1lbnQuICopXG4gICAgICBpZiBpbmZvLnB1c2hiX3dhaXRpbmcgdGhlbiBiZWdpblxuICAgICAgICBpbmZvLnB1c2hiX3dhaXRpbmcgPC0gZmFsc2U7XG4gICAgICAgICgqIFVwZGF0ZSB0aHJlYWRzLiAqKVxuICAgICAgICBsZXQgb2xkX3dha2VuZXIgPSAhd2FrZW5lcl9jZWxsIGluXG4gICAgICAgIGxldCBuZXdfd2FpdGVyLCBuZXdfd2FrZW5lciA9IEx3dC53YWl0ICgpIGluXG4gICAgICAgIGluZm8ucHVzaGJfc2lnbmFsIDwtIG5ld193YWl0ZXI7XG4gICAgICAgIHdha2VuZXJfY2VsbCA6PSBuZXdfd2FrZW5lcjtcbiAgICAgICAgKCogU2lnbmFsIHRoYXQgYSBuZXcgdmFsdWUgaGFzIGJlZW4gcmVjZWl2ZWQuICopXG4gICAgICAgIEx3dC53YWtldXBfbGF0ZXIgb2xkX3dha2VuZXIgKClcbiAgICAgIGVuZDtcbiAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgIGVuZFxuXG4gIG1ldGhvZCBjbG9zZSA9XG4gICAgaWYgbm90IGNsb3NlZCB0aGVuIGJlZ2luXG4gICAgICBjbG9zZWQgPC0gdHJ1ZTtcbiAgICAgIGxldCBub2RlID0gIWxhc3QgYW5kIG5ld19sYXN0ID0gbmV3X25vZGUgKCkgaW5cbiAgICAgIG5vZGUuZGF0YSA8LSBOb25lO1xuICAgICAgbm9kZS5uZXh0IDwtIG5ld19sYXN0O1xuICAgICAgbGFzdCA6PSBuZXdfbGFzdDtcbiAgICAgIGlmIGluZm8ucHVzaGJfcGVuZGluZyA8PiBOb25lIHRoZW4gYmVnaW5cbiAgICAgICAgaW5mby5wdXNoYl9wZW5kaW5nIDwtIE5vbmU7XG4gICAgICAgIEx3dC53YWtldXBfbGF0ZXJfZXhuIGluZm8ucHVzaGJfcHVzaF93YWtlbmVyIENsb3NlZFxuICAgICAgZW5kO1xuICAgICAgKCogU2VuZCBhIHNpZ25hbCBpZiBhdCBsZWFzdCBvbmUgdGhyZWFkIGlzIHdhaXRpbmcgZm9yIGEgbmV3XG4gICAgICAgICBlbGVtZW50LiAqKVxuICAgICAgaWYgaW5mby5wdXNoYl93YWl0aW5nIHRoZW4gYmVnaW5cbiAgICAgICAgaW5mby5wdXNoYl93YWl0aW5nIDwtIGZhbHNlO1xuICAgICAgICBsZXQgb2xkX3dha2VuZXIgPSAhd2FrZW5lcl9jZWxsIGluXG4gICAgICAgICgqIFNpZ25hbCB0aGF0IGEgbmV3IHZhbHVlIGhhcyBiZWVuIHJlY2VpdmVkLiAqKVxuICAgICAgICBMd3Qud2FrZXVwX2xhdGVyIG9sZF93YWtlbmVyICgpXG4gICAgICBlbmQ7XG4gICAgICBMd3Qud2FrZXVwIGNsb3NlICgpO1xuICAgIGVuZFxuXG4gIG1ldGhvZCBjb3VudCA9XG4gICAgaW5mby5wdXNoYl9jb3VudFxuXG4gIG1ldGhvZCBibG9ja2VkID1cbiAgICBpbmZvLnB1c2hiX3BlbmRpbmcgPD4gTm9uZVxuXG4gIG1ldGhvZCBjbG9zZWQgPVxuICAgIGNsb3NlZFxuXG4gIG1ldGhvZCBzZXRfcmVmZXJlbmNlIDogJ2EuICdhIC0+IHVuaXQgPVxuICAgIGZ1biB4IC0+IGluZm8ucHVzaGJfZXh0ZXJuYWwgPC0gT2JqLnJlcHIgeFxuZW5kXG5cbmxldCBjcmVhdGVfYm91bmRlZCBzaXplID1cbiAgaWYgc2l6ZSA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIkx3dF9zdHJlYW0uY3JlYXRlX2JvdW5kZWRcIjtcbiAgKCogQ3JlYXRlIHRoZSBzb3VyY2UgZm9yIG5vdGlmaWNhdGlvbnMgb2YgbmV3IGVsZW1lbnRzLiAqKVxuICBsZXQgaW5mbywgd2FrZW5lcl9jZWxsID1cbiAgICBsZXQgd2FpdGVyLCB3YWtlbmVyID0gTHd0LndhaXQgKCkgaW5cbiAgICBsZXQgcHVzaF93YWl0ZXIsIHB1c2hfd2FrZW5lciA9IEx3dC50YXNrICgpIGluXG4gICAgKHsgcHVzaGJfc2lnbmFsID0gd2FpdGVyO1xuICAgICAgIHB1c2hiX3dhaXRpbmcgPSBmYWxzZTtcbiAgICAgICBwdXNoYl9zaXplID0gc2l6ZTtcbiAgICAgICBwdXNoYl9jb3VudCA9IDA7XG4gICAgICAgcHVzaGJfcGVuZGluZyA9IE5vbmU7XG4gICAgICAgcHVzaGJfcHVzaF93YWl0ZXIgPSBwdXNoX3dhaXRlcjtcbiAgICAgICBwdXNoYl9wdXNoX3dha2VuZXIgPSBwdXNoX3dha2VuZXI7XG4gICAgICAgcHVzaGJfZXh0ZXJuYWwgPSBPYmoucmVwciAoKSB9LFxuICAgICByZWYgd2FrZW5lcilcbiAgaW5cbiAgbGV0IHQgPSBmcm9tX3NvdXJjZSAoUHVzaF9ib3VuZGVkIGluZm8pIGluXG4gICh0LCBuZXcgYm91bmRlZF9wdXNoX2ltcGwgaW5mbyB3YWtlbmVyX2NlbGwgdC5sYXN0IHQuY2xvc2UpXG5cbigqIFdhaXQgZm9yIGEgbmV3IGVsZW1lbnQgdG8gYmUgYWRkZWQgdG8gdGhlIHF1ZXVlIG9mIHBlbmRpbmcgZWxlbWVudFxuICAgb2YgdGhlIHN0cmVhbS4gKilcbmxldCBmZWVkIHMgPVxuICBtYXRjaCBzLnNvdXJjZSB3aXRoXG4gIHwgRnJvbSBmcm9tIC0+XG4gICAgKCogVGhlcmUgaXMgYWxyZWFkeSBhIHRocmVhZCBzdGFydGVkIHRvIGNyZWF0ZSBhIG5ldyBlbGVtZW50LFxuICAgICAgIHdhaXQgZm9yIHRoaXMgb25lIHRvIHRlcm1pbmF0ZS4gKilcbiAgICBpZiBMd3QuaXNfc2xlZXBpbmcgZnJvbS5mcm9tX3RocmVhZCB0aGVuXG4gICAgICBMd3QucHJvdGVjdGVkIGZyb20uZnJvbV90aHJlYWRcbiAgICBlbHNlIGJlZ2luXG4gICAgICAoKiBPdGhlcndpc2UgcmVxdWVzdCBhIG5ldyBlbGVtZW50LiAqKVxuICAgICAgbGV0IHRocmVhZCA9XG4gICAgICAgIGZyb20uZnJvbV9jcmVhdGUgKCkgPj49IGZ1biB4IC0+XG4gICAgICAgICgqIFB1c2ggdGhlIGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWUuICopXG4gICAgICAgIGVucXVldWUgeCBzO1xuICAgICAgICBpZiB4ID0gTm9uZSB0aGVuIEx3dC53YWtldXAgcy5jbG9zZSAoKTtcbiAgICAgICAgTHd0LnJldHVybl91bml0XG4gICAgICBpblxuICAgICAgKCogQWxsb3cgb3RoZXIgdGhyZWFkcyB0byBhY2Nlc3MgdGhpcyB0aHJlYWQuICopXG4gICAgICBmcm9tLmZyb21fdGhyZWFkIDwtIHRocmVhZDtcbiAgICAgIEx3dC5wcm90ZWN0ZWQgdGhyZWFkXG4gICAgZW5kXG4gIHwgRnJvbV9kaXJlY3QgZiAtPlxuICAgIGxldCB4ID0gZiAoKSBpblxuICAgICgqIFB1c2ggdGhlIGVsZW1lbnQgdG8gdGhlIGVuZCBvZiB0aGUgcXVldWUuICopXG4gICAgZW5xdWV1ZSB4IHM7XG4gICAgaWYgeCA9IE5vbmUgdGhlbiBMd3Qud2FrZXVwIHMuY2xvc2UgKCk7XG4gICAgTHd0LnJldHVybl91bml0XG4gIHwgUHVzaCBwdXNoIC0+XG4gICAgcHVzaC5wdXNoX3dhaXRpbmcgPC0gdHJ1ZTtcbiAgICBMd3QucHJvdGVjdGVkIHB1c2gucHVzaF9zaWduYWxcbiAgfCBQdXNoX2JvdW5kZWQgcHVzaCAtPlxuICAgIHB1c2gucHVzaGJfd2FpdGluZyA8LSB0cnVlO1xuICAgIEx3dC5wcm90ZWN0ZWQgcHVzaC5wdXNoYl9zaWduYWxcblxuKCogUmVtb3ZlIFtub2RlXSBmcm9tIHRoZSB0b3Agb2YgdGhlIHF1ZXVlLCBvciBkbyBub3RoaW5nIGlmIGl0IHdhc1xuICAgYWxyZWFkeSBjb25zdW1lZC5cblxuICAgUHJlY29uZGl0aW9uOiBub2RlLmRhdGEgPD4gTm9uZVxuKilcbmxldCBjb25zdW1lIHMgbm9kZSA9XG4gIGlmIG5vZGUgPT0gcy5ub2RlIHRoZW4gYmVnaW5cbiAgICBzLm5vZGUgPC0gbm9kZS5uZXh0O1xuICAgIG1hdGNoIHMuc291cmNlIHdpdGhcbiAgICB8IFB1c2hfYm91bmRlZCBpbmZvIC0+XG4gICAgICBpZiBpbmZvLnB1c2hiX3BlbmRpbmcgPSBOb25lIHRoZW5cbiAgICAgICAgaW5mby5wdXNoYl9jb3VudCA8LSBpbmZvLnB1c2hiX2NvdW50IC0gMVxuICAgICAgZWxzZVxuICAgICAgICBub3RpZnlfcHVzaGVyIGluZm8gcy5sYXN0XG4gICAgfCBGcm9tIF8gfCBGcm9tX2RpcmVjdCBfIHwgUHVzaCBfIC0+XG4gICAgICAoKVxuICBlbmRcblxubGV0IHJlYyBwZWVrX3JlYyBzIG5vZGUgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gcGVla19yZWMgcyBub2RlXG4gIGVsc2VcbiAgICBMd3QucmV0dXJuIG5vZGUuZGF0YVxuXG5sZXQgcGVlayBzID0gcGVla19yZWMgcyBzLm5vZGVcblxubGV0IHJlYyBucGVla19yZWMgbm9kZSBhY2MgbiBzID1cbiAgaWYgbiA8PSAwIHRoZW5cbiAgICBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MpXG4gIGVsc2UgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IG5wZWVrX3JlYyBub2RlIGFjYyBuIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIG5wZWVrX3JlYyBub2RlLm5leHQgKHggOjogYWNjKSAobiAtIDEpIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcblxubGV0IG5wZWVrIG4gcyA9IG5wZWVrX3JlYyBzLm5vZGUgW10gbiBzXG5cbmxldCByZWMgZ2V0X3JlYyBzIG5vZGUgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZ2V0X3JlYyBzIG5vZGVcbiAgZWxzZSBiZWdpblxuICAgIGlmIG5vZGUuZGF0YSA8PiBOb25lIHRoZW4gY29uc3VtZSBzIG5vZGU7XG4gICAgTHd0LnJldHVybiBub2RlLmRhdGFcbiAgZW5kXG5cbmxldCBnZXQgcyA9IGdldF9yZWMgcyBzLm5vZGVcblxubGV0IHJlYyBnZXRfZXhuX3JlYyBzIG5vZGUgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgTHd0LnRyeV9iaW5kXG4gICAgICAoZnVuICgpIC0+IGZlZWQgcylcbiAgICAgIChmdW4gKCkgLT4gZ2V0X2V4bl9yZWMgcyBub2RlKVxuICAgICAgKGZ1biBleG4gLT4gTHd0LnJldHVybiAoU29tZSAoUmVzdWx0LkVycm9yIGV4bikpKVxuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgdmFsdWUgLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgTHd0LnJldHVybiAoU29tZSAoUmVzdWx0Lk9rIHZhbHVlKSlcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuXG5sZXQgd3JhcF9leG4gcyA9IGZyb20gKGZ1biAoKSAtPiBnZXRfZXhuX3JlYyBzIHMubm9kZSlcblxubGV0IHJlYyBuZ2V0X3JlYyBub2RlIGFjYyBuIHMgPVxuICBpZiBuIDw9IDAgdGhlblxuICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcbiAgZWxzZSBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gbmdldF9yZWMgbm9kZSBhY2MgbiBzXG4gIGVsc2VcbiAgICBtYXRjaCBzLm5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbmdldF9yZWMgbm9kZS5uZXh0ICh4IDo6IGFjYykgKG4gLSAxKSBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MpXG5cbmxldCBuZ2V0IG4gcyA9IG5nZXRfcmVjIHMubm9kZSBbXSBuIHNcblxubGV0IHJlYyBnZXRfd2hpbGVfcmVjIG5vZGUgYWNjIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBnZXRfd2hpbGVfcmVjIG5vZGUgYWNjIGYgc1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgbGV0IHRlc3QgPSBmIHggaW5cbiAgICAgIGlmIHRlc3QgdGhlbiBiZWdpblxuICAgICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgICAgZ2V0X3doaWxlX3JlYyBub2RlLm5leHQgKHggOjogYWNjKSBmIHNcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcblxubGV0IGdldF93aGlsZSBmIHMgPSBnZXRfd2hpbGVfcmVjIHMubm9kZSBbXSBmIHNcblxubGV0IHJlYyBnZXRfd2hpbGVfc19yZWMgbm9kZSBhY2MgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGdldF93aGlsZV9zX3JlYyBub2RlIGFjYyBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT4gYmVnaW5cbiAgICAgICAgZiB4ID4+PSBmdW5jdGlvblxuICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgICAgICBnZXRfd2hpbGVfc19yZWMgbm9kZS5uZXh0ICh4IDo6IGFjYykgZiBzXG4gICAgICAgIHwgZmFsc2UgLT5cbiAgICAgICAgICBMd3QucmV0dXJuIChMaXN0LnJldiBhY2MpXG4gICAgICBlbmRcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm4gKExpc3QucmV2IGFjYylcblxubGV0IGdldF93aGlsZV9zIGYgcyA9IGdldF93aGlsZV9zX3JlYyBzLm5vZGUgW10gZiBzXG5cbmxldCByZWMgbmV4dF9yZWMgcyBub2RlID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IG5leHRfcmVjIHMgbm9kZVxuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBMd3QucmV0dXJuIHhcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5mYWlsIEVtcHR5XG5cbmxldCBuZXh0IHMgPSBuZXh0X3JlYyBzIHMubm9kZVxuXG5sZXQgcmVjIGxhc3RfbmV3X3JlYyBub2RlIHggcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBsZXQgdGhyZWFkID0gZmVlZCBzIGluXG4gICAgbWF0Y2ggTHd0LnN0YXRlIHRocmVhZCB3aXRoXG4gICAgfCBMd3QuUmV0dXJuIF8gLT5cbiAgICAgIGxhc3RfbmV3X3JlYyBub2RlIHggc1xuICAgIHwgTHd0LkZhaWwgZXhuIC0+XG4gICAgICBMd3QuZmFpbCBleG5cbiAgICB8IEx3dC5TbGVlcCAtPlxuICAgICAgTHd0LnJldHVybiB4XG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxhc3RfbmV3X3JlYyBub2RlLm5leHQgeCBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIHhcblxubGV0IGxhc3RfbmV3IHMgPVxuICBsZXQgbm9kZSA9IHMubm9kZSBpblxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgbGV0IHRocmVhZCA9IG5leHQgcyBpblxuICAgIG1hdGNoIEx3dC5zdGF0ZSB0aHJlYWQgd2l0aFxuICAgIHwgTHd0LlJldHVybiB4IC0+XG4gICAgICBsYXN0X25ld19yZWMgbm9kZSB4IHNcbiAgICB8IEx3dC5GYWlsIF8gfCBMd3QuU2xlZXAgLT5cbiAgICAgIHRocmVhZFxuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBsYXN0X25ld19yZWMgbm9kZS5uZXh0IHggc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LmZhaWwgRW1wdHlcblxubGV0IHJlYyB0b19saXN0X3JlYyBub2RlIGFjYyBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IHRvX2xpc3RfcmVjIG5vZGUgYWNjIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgdG9fbGlzdF9yZWMgbm9kZS5uZXh0ICh4IDo6IGFjYykgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjKVxuXG5sZXQgdG9fbGlzdCBzID0gdG9fbGlzdF9yZWMgcy5ub2RlIFtdIHNcblxubGV0IHJlYyB0b19zdHJpbmdfcmVjIG5vZGUgYnVmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gdG9fc3RyaW5nX3JlYyBub2RlIGJ1ZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgeDtcbiAgICAgIHRvX3N0cmluZ19yZWMgbm9kZS5uZXh0IGJ1ZiBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuIChCdWZmZXIuY29udGVudHMgYnVmKVxuXG5sZXQgdG9fc3RyaW5nIHMgPSB0b19zdHJpbmdfcmVjIHMubm9kZSAoQnVmZmVyLmNyZWF0ZSAxMjgpIHNcblxubGV0IGp1bmsgcyA9XG4gIGxldCBub2RlID0gcy5ub2RlIGluXG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW4gYmVnaW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPlxuICAgIGlmIG5vZGUuZGF0YSA8PiBOb25lIHRoZW4gY29uc3VtZSBzIG5vZGU7XG4gICAgTHd0LnJldHVybl91bml0XG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgaWYgbm9kZS5kYXRhIDw+IE5vbmUgdGhlbiBjb25zdW1lIHMgbm9kZTtcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgZW5kXG5cbmxldCByZWMgbmp1bmtfcmVjIG5vZGUgbiBzID1cbiAgaWYgbiA8PSAwIHRoZW5cbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgZWxzZSBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gbmp1bmtfcmVjIG5vZGUgbiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSBfIC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIG5qdW5rX3JlYyBub2RlLm5leHQgKG4gLSAxKSBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IG5qdW5rIG4gcyA9IG5qdW5rX3JlYyBzLm5vZGUgbiBzXG5cbmxldCByZWMganVua193aGlsZV9yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4ganVua193aGlsZV9yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGxldCB0ZXN0ID0gZiB4IGluXG4gICAgICBpZiB0ZXN0IHRoZW4gYmVnaW5cbiAgICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICAgIGp1bmtfd2hpbGVfcmVjIG5vZGUubmV4dCBmIHNcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl91bml0XG5cbmxldCBqdW5rX3doaWxlIGYgcyA9IGp1bmtfd2hpbGVfcmVjIHMubm9kZSBmIHNcblxubGV0IHJlYyBqdW5rX3doaWxlX3NfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGp1bmtfd2hpbGVfc19yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT4gYmVnaW5cbiAgICAgICAgZiB4ID4+PSBmdW5jdGlvblxuICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgICAgICBqdW5rX3doaWxlX3NfcmVjIG5vZGUubmV4dCBmIHNcbiAgICAgICAgfCBmYWxzZSAtPlxuICAgICAgICAgIEx3dC5yZXR1cm5fdW5pdFxuICAgICAgZW5kXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IGp1bmtfd2hpbGVfcyBmIHMgPSBqdW5rX3doaWxlX3NfcmVjIHMubm9kZSBmIHNcblxubGV0IHJlYyBqdW5rX29sZF9yZWMgbm9kZSBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGxldCB0aHJlYWQgPSBmZWVkIHMgaW5cbiAgICBtYXRjaCBMd3Quc3RhdGUgdGhyZWFkIHdpdGhcbiAgICB8IEx3dC5SZXR1cm4gXyAtPlxuICAgICAganVua19vbGRfcmVjIG5vZGUgc1xuICAgIHwgTHd0LkZhaWwgZXhuIC0+XG4gICAgICBMd3QuZmFpbCBleG5cbiAgICB8IEx3dC5TbGVlcCAtPlxuICAgICAgTHd0LnJldHVybl91bml0XG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSBfIC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGp1bmtfb2xkX3JlYyBub2RlLm5leHQgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl91bml0XG5cbmxldCBqdW5rX29sZCBzID0ganVua19vbGRfcmVjIHMubm9kZSBzXG5cbmxldCByZWMgZ2V0X2F2YWlsYWJsZV9yZWMgbm9kZSBhY2MgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBsZXQgdGhyZWFkID0gZmVlZCBzIGluXG4gICAgbWF0Y2ggTHd0LnN0YXRlIHRocmVhZCB3aXRoXG4gICAgfCBMd3QuUmV0dXJuIF8gLT5cbiAgICAgIGdldF9hdmFpbGFibGVfcmVjIG5vZGUgYWNjIHNcbiAgICB8IEx3dC5GYWlsIGV4biAtPlxuICAgICAgcmFpc2UgZXhuXG4gICAgfCBMd3QuU2xlZXAgLT5cbiAgICAgIExpc3QucmV2IGFjY1xuICBlbHNlXG4gICAgbWF0Y2ggbm9kZS5kYXRhIHdpdGhcbiAgICB8IFNvbWUgeCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBnZXRfYXZhaWxhYmxlX3JlYyBub2RlLm5leHQgKHggOjogYWNjKSBzXG4gICAgfCBOb25lIC0+XG4gICAgICBMaXN0LnJldiBhY2NcblxubGV0IGdldF9hdmFpbGFibGUgcyA9IGdldF9hdmFpbGFibGVfcmVjIHMubm9kZSBbXSBzXG5cbmxldCByZWMgZ2V0X2F2YWlsYWJsZV91cF90b19yZWMgbm9kZSBhY2MgbiBzID1cbiAgaWYgbiA8PSAwIHRoZW5cbiAgICBMaXN0LnJldiBhY2NcbiAgZWxzZSBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgbGV0IHRocmVhZCA9IGZlZWQgcyBpblxuICAgIG1hdGNoIEx3dC5zdGF0ZSB0aHJlYWQgd2l0aFxuICAgIHwgTHd0LlJldHVybiBfIC0+XG4gICAgICBnZXRfYXZhaWxhYmxlX3VwX3RvX3JlYyBub2RlIGFjYyBuIHNcbiAgICB8IEx3dC5GYWlsIGV4biAtPlxuICAgICAgcmFpc2UgZXhuXG4gICAgfCBMd3QuU2xlZXAgLT5cbiAgICAgIExpc3QucmV2IGFjY1xuICBlbHNlXG4gICAgbWF0Y2ggcy5ub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGdldF9hdmFpbGFibGVfdXBfdG9fcmVjIG5vZGUubmV4dCAoeCA6OiBhY2MpIChuIC0gMSkgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTGlzdC5yZXYgYWNjXG5cbmxldCBnZXRfYXZhaWxhYmxlX3VwX3RvIG4gcyA9IGdldF9hdmFpbGFibGVfdXBfdG9fcmVjIHMubm9kZSBbXSBuIHNcblxubGV0IHJlYyBpc19lbXB0eSBzID1cbiAgaWYgcy5ub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gaXNfZW1wdHkgc1xuICBlbHNlXG4gICAgTHd0LnJldHVybiAocy5ub2RlLmRhdGEgPSBOb25lKVxuXG5sZXQgbWFwIGYgcyA9XG4gIGZyb20gKGZ1biAoKSAtPiBnZXQgcyA+fD0gZnVuY3Rpb25cbiAgfCBTb21lIHggLT5cbiAgICBsZXQgeCA9IGYgeCBpblxuICAgIFNvbWUgeFxuICB8IE5vbmUgLT5cbiAgICBOb25lKVxuXG5sZXQgbWFwX3MgZiBzID1cbiAgZnJvbSAoZnVuICgpIC0+IGdldCBzID4+PSBmdW5jdGlvblxuICB8IFNvbWUgeCAtPlxuICAgIGYgeCA+fD0gKGZ1biB4IC0+IFNvbWUgeClcbiAgfCBOb25lIC0+XG4gICAgTHd0LnJldHVybl9ub25lKVxuXG5sZXQgZmlsdGVyIGYgcyA9XG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgbGV0IHQgPSBnZXQgcyBpblxuICAgIHQgPj49IGZ1bmN0aW9uXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGxldCB0ZXN0ID0gZiB4IGluXG4gICAgICBpZiB0ZXN0IHRoZW5cbiAgICAgICAgdFxuICAgICAgZWxzZVxuICAgICAgICBuZXh0ICgpXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBmaWx0ZXJfcyBmIHMgPVxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIGxldCB0ID0gZ2V0IHMgaW5cbiAgICB0ID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSB4IC0+IGJlZ2luXG4gICAgICAgIGYgeCA+Pj0gZnVuY3Rpb25cbiAgICAgICAgfCB0cnVlIC0+XG4gICAgICAgICAgdFxuICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgbmV4dCAoKVxuICAgICAgZW5kXG4gICAgfCBOb25lIC0+XG4gICAgICB0XG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgZmlsdGVyX21hcCBmIHMgPVxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIGdldCBzID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSB4IC0+XG4gICAgICBsZXQgeCA9IGYgeCBpblxuICAgICAgKG1hdGNoIHggd2l0aFxuICAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgICBMd3QucmV0dXJuIHhcbiAgICAgICB8IE5vbmUgLT5cbiAgICAgICAgIG5leHQgKCkpXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBmaWx0ZXJfbWFwX3MgZiBzID1cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBnZXQgcyA+Pj0gZnVuY3Rpb25cbiAgICB8IFNvbWUgeCAtPlxuICAgICAgbGV0IHQgPSBmIHggaW5cbiAgICAgICh0ID4+PSBmdW5jdGlvblxuICAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgICB0XG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBuZXh0ICgpKVxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgbWFwX2xpc3QgZiBzID1cbiAgbGV0IHBlbmRpbmdzID0gcmVmIFtdIGluXG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgbWF0Y2ggIXBlbmRpbmdzIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICAoZ2V0IHMgPj49IGZ1bmN0aW9uXG4gICAgICAgfCBTb21lIHggLT5cbiAgICAgICAgIGxldCBsID0gZiB4IGluXG4gICAgICAgICBwZW5kaW5ncyA6PSBsO1xuICAgICAgICAgbmV4dCAoKVxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgTHd0LnJldHVybl9ub25lKVxuICAgIHwgeCA6OiBsIC0+XG4gICAgICBwZW5kaW5ncyA6PSBsO1xuICAgICAgTHd0LnJldHVybiAoU29tZSB4KVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IG1hcF9saXN0X3MgZiBzID1cbiAgbGV0IHBlbmRpbmdzID0gcmVmIFtdIGluXG4gIGxldCByZWMgbmV4dCAoKSA9XG4gICAgbWF0Y2ggIXBlbmRpbmdzIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICAoZ2V0IHMgPj49IGZ1bmN0aW9uXG4gICAgICAgfCBTb21lIHggLT5cbiAgICAgICAgIGYgeCA+Pj0gZnVuIGwgLT5cbiAgICAgICAgIHBlbmRpbmdzIDo9IGw7XG4gICAgICAgICBuZXh0ICgpXG4gICAgICAgfCBOb25lIC0+XG4gICAgICAgICBMd3QucmV0dXJuX25vbmUpXG4gICAgfCB4IDo6IGwgLT5cbiAgICAgIHBlbmRpbmdzIDo9IGw7XG4gICAgICBMd3QucmV0dXJuIChTb21lIHgpXG4gIGluXG4gIGZyb20gbmV4dFxuXG5sZXQgZmxhdHRlbiBzID1cbiAgbWFwX2xpc3QgKGZ1biBsIC0+IGwpIHNcblxubGV0IHJlYyBmb2xkX3JlYyBub2RlIGYgcyBhY2MgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZm9sZF9yZWMgbm9kZSBmIHMgYWNjXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxldCBhY2MgPSBmIHggYWNjIGluXG4gICAgICBmb2xkX3JlYyBub2RlLm5leHQgZiBzIGFjY1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiBhY2NcblxubGV0IGZvbGQgZiBzIGFjYyA9IGZvbGRfcmVjIHMubm9kZSBmIHMgYWNjXG5cbmxldCByZWMgZm9sZF9zX3JlYyBub2RlIGYgcyBhY2MgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZm9sZF9zX3JlYyBub2RlIGYgcyBhY2NcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgZiB4IGFjYyA+Pj0gZnVuIGFjYyAtPlxuICAgICAgZm9sZF9zX3JlYyBub2RlLm5leHQgZiBzIGFjY1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybiBhY2NcblxubGV0IGZvbGRfcyBmIHMgYWNjID0gZm9sZF9zX3JlYyBzLm5vZGUgZiBzIGFjY1xuXG5sZXQgcmVjIGl0ZXJfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGl0ZXJfcmVjIG5vZGUgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxldCAoKSA9IGYgeCBpblxuICAgICAgaXRlcl9yZWMgbm9kZS5uZXh0IGYgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl91bml0XG5cbmxldCBpdGVyIGYgcyA9IGl0ZXJfcmVjIHMubm9kZSBmIHNcblxubGV0IHJlYyBpdGVyX3NfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGl0ZXJfc19yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgZiB4ID4+PSBmdW4gKCkgLT5cbiAgICAgIGl0ZXJfc19yZWMgbm9kZS5uZXh0IGYgc1xuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl91bml0XG5cbmxldCBpdGVyX3MgZiBzID0gaXRlcl9zX3JlYyBzLm5vZGUgZiBzXG5cbmxldCByZWMgaXRlcl9wX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBpdGVyX3BfcmVjIG5vZGUgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IC0+XG4gICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgIGxldCByZXMgPSBmIHggaW5cbiAgICAgIGxldCByZXN0ID0gaXRlcl9wX3JlYyBub2RlLm5leHQgZiBzIGluXG4gICAgICByZXMgPj49IGZ1biAoKSAtPiByZXN0XG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX3VuaXRcblxubGV0IGl0ZXJfcCBmIHMgPSBpdGVyX3BfcmVjIHMubm9kZSBmIHNcblxubGV0IGl0ZXJfbiA/KG1heF9jb25jdXJyZW5jeSA9IDEpIGYgc3RyZWFtID1cbiAgYmVnaW5cbiAgICBpZiBtYXhfY29uY3VycmVuY3kgPD0gMCB0aGVuXG4gICAgICBsZXQgbWVzc2FnZSA9XG4gICAgICAgIFByaW50Zi5zcHJpbnRmXG4gICAgICAgICAgXCJMd3Rfc3RyZWFtLml0ZXJfbjogbWF4X2NvbmN1cnJlbmN5IG11c3QgYmUgPiAwLCAlZCBnaXZlblwiXG4gICAgICAgICAgbWF4X2NvbmN1cnJlbmN5XG4gICAgICBpblxuICAgICAgaW52YWxpZF9hcmcgbWVzc2FnZVxuICBlbmQ7XG4gIGxldCByZWMgbG9vcCBydW5uaW5nIGF2YWlsYWJsZSA9XG4gICAgYmVnaW5cbiAgICAgIGlmIGF2YWlsYWJsZSA+IDAgdGhlbiAoXG4gICAgICAgIEx3dC5yZXR1cm4gKHJ1bm5pbmcsIGF2YWlsYWJsZSlcbiAgICAgIClcbiAgICAgIGVsc2UgKFxuICAgICAgICBMd3QubmNob29zZV9zcGxpdCBydW5uaW5nID4+PSBmdW4gKGNvbXBsZXRlLCBydW5uaW5nKSAtPlxuICAgICAgICBMd3QucmV0dXJuIChydW5uaW5nLCBhdmFpbGFibGUgKyBMaXN0Lmxlbmd0aCBjb21wbGV0ZSlcbiAgICAgIClcbiAgICBlbmQgPj49IGZ1biAocnVubmluZywgYXZhaWxhYmxlKSAtPlxuICAgIGdldCBzdHJlYW0gPj49IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+XG4gICAgICBMd3Quam9pbiBydW5uaW5nXG4gICAgfCBTb21lIGVsdCAtPlxuICAgICAgbG9vcCAoZiBlbHQgOjogcnVubmluZykgKHByZWQgYXZhaWxhYmxlKVxuICBpblxuICBsb29wIFtdIG1heF9jb25jdXJyZW5jeVxuXG5sZXQgcmVjIGZpbmRfcmVjIG5vZGUgZiBzID1cbiAgaWYgbm9kZSA9PSAhKHMubGFzdCkgdGhlblxuICAgIGZlZWQgcyA+Pj0gZnVuICgpIC0+IGZpbmRfcmVjIG5vZGUgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IGFzIG9wdCAtPlxuICAgICAgY29uc3VtZSBzIG5vZGU7XG4gICAgICBsZXQgdGVzdCA9IGYgeCBpblxuICAgICAgaWYgdGVzdCB0aGVuXG4gICAgICAgIEx3dC5yZXR1cm4gb3B0XG4gICAgICBlbHNlXG4gICAgICAgIGZpbmRfcmVjIG5vZGUubmV4dCBmIHNcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuXG5sZXQgZmluZCBmIHMgPSBmaW5kX3JlYyBzLm5vZGUgZiBzXG5cbmxldCByZWMgZmluZF9zX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBmaW5kX3NfcmVjIG5vZGUgZiBzXG4gIGVsc2VcbiAgICBtYXRjaCBub2RlLmRhdGEgd2l0aFxuICAgIHwgU29tZSB4IGFzIG9wdCAtPiBiZWdpblxuICAgICAgICBjb25zdW1lIHMgbm9kZTtcbiAgICAgICAgZiB4ID4+PSBmdW5jdGlvblxuICAgICAgICB8IHRydWUgLT5cbiAgICAgICAgICBMd3QucmV0dXJuIG9wdFxuICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgZmluZF9zX3JlYyBub2RlLm5leHQgZiBzXG4gICAgICBlbmRcbiAgICB8IE5vbmUgLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuXG5sZXQgZmluZF9zIGYgcyA9IGZpbmRfc19yZWMgcy5ub2RlIGYgc1xuXG5sZXQgcmVjIGZpbmRfbWFwX3JlYyBub2RlIGYgcyA9XG4gIGlmIG5vZGUgPT0gIShzLmxhc3QpIHRoZW5cbiAgICBmZWVkIHMgPj49IGZ1biAoKSAtPiBmaW5kX21hcF9yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGV0IHggPSBmIHggaW5cbiAgICAgIGlmIHggPSBOb25lIHRoZW5cbiAgICAgICAgZmluZF9tYXBfcmVjIG5vZGUubmV4dCBmIHNcbiAgICAgIGVsc2VcbiAgICAgICAgTHd0LnJldHVybiB4XG4gICAgfCBOb25lIC0+XG4gICAgICBMd3QucmV0dXJuX25vbmVcblxubGV0IGZpbmRfbWFwIGYgcyA9IGZpbmRfbWFwX3JlYyBzLm5vZGUgZiBzXG5cbmxldCByZWMgZmluZF9tYXBfc19yZWMgbm9kZSBmIHMgPVxuICBpZiBub2RlID09ICEocy5sYXN0KSB0aGVuXG4gICAgZmVlZCBzID4+PSBmdW4gKCkgLT4gZmluZF9tYXBfc19yZWMgbm9kZSBmIHNcbiAgZWxzZVxuICAgIG1hdGNoIG5vZGUuZGF0YSB3aXRoXG4gICAgfCBTb21lIHggLT5cbiAgICAgIGNvbnN1bWUgcyBub2RlO1xuICAgICAgbGV0IHQgPSBmIHggaW5cbiAgICAgICh0ID4+PSBmdW5jdGlvblxuICAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgZmluZF9tYXBfc19yZWMgbm9kZS5uZXh0IGYgc1xuICAgICAgIHwgU29tZSBfIC0+XG4gICAgICAgICB0KVxuICAgIHwgTm9uZSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG5cbmxldCBmaW5kX21hcF9zIGYgcyA9IGZpbmRfbWFwX3NfcmVjIHMubm9kZSBmIHNcblxubGV0IGNvbWJpbmUgczEgczIgPVxuICBsZXQgbmV4dCAoKSA9XG4gICAgbGV0IHQxID0gZ2V0IHMxIGFuZCB0MiA9IGdldCBzMiBpblxuICAgIHQxID4+PSBmdW4gbjEgLT5cbiAgICB0MiA+Pj0gZnVuIG4yIC0+XG4gICAgbWF0Y2ggbjEsIG4yIHdpdGhcbiAgICB8IFNvbWUgeDEsIFNvbWUgeDIgLT5cbiAgICAgIEx3dC5yZXR1cm4gKFNvbWUoeDEsIHgyKSlcbiAgICB8IF8gLT5cbiAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IGFwcGVuZCBzMSBzMiA9XG4gIGxldCBjdXJyZW50X3MgPSByZWYgczEgaW5cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBsZXQgdCA9IGdldCAhY3VycmVudF9zIGluXG4gICAgdCA+Pj0gZnVuY3Rpb25cbiAgICB8IFNvbWUgXyAtPlxuICAgICAgdFxuICAgIHwgTm9uZSAtPlxuICAgICAgaWYgIWN1cnJlbnRfcyA9PSBzMiB0aGVuXG4gICAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICAgICAgZWxzZSBiZWdpblxuICAgICAgICBjdXJyZW50X3MgOj0gczI7XG4gICAgICAgIG5leHQgKClcbiAgICAgIGVuZFxuICBpblxuICBmcm9tIG5leHRcblxubGV0IGNvbmNhdCBzX3RvcCA9XG4gIGxldCBjdXJyZW50X3MgPSByZWYgKGZyb20gKGZ1biAoKSAtPiBMd3QucmV0dXJuX25vbmUpKSBpblxuICBsZXQgcmVjIG5leHQgKCkgPVxuICAgIGxldCB0ID0gZ2V0ICFjdXJyZW50X3MgaW5cbiAgICB0ID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSBfIC0+XG4gICAgICB0XG4gICAgfCBOb25lIC0+XG4gICAgICBnZXQgc190b3AgPj49IGZ1bmN0aW9uXG4gICAgICB8IFNvbWUgcyAtPlxuICAgICAgICBjdXJyZW50X3MgOj0gcztcbiAgICAgICAgbmV4dCAoKVxuICAgICAgfCBOb25lIC0+XG4gICAgICAgIEx3dC5yZXR1cm5fbm9uZVxuICBpblxuICBmcm9tIG5leHRcblxubGV0IGNob29zZSBzdHJlYW1zID1cbiAgbGV0IHNvdXJjZSBzID0gKHMsIGdldCBzID58PSBmdW4geCAtPiAocywgeCkpIGluXG4gIGxldCBzdHJlYW1zID0gcmVmIChMaXN0Lm1hcCBzb3VyY2Ugc3RyZWFtcykgaW5cbiAgbGV0IHJlYyBuZXh0ICgpID1cbiAgICBtYXRjaCAhc3RyZWFtcyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG4gICAgfCBsIC0+XG4gICAgICBMd3QuY2hvb3NlIChMaXN0Lm1hcCBzbmQgbCkgPj49IGZ1biAocywgeCkgLT5cbiAgICAgIGxldCBsID0gTGlzdC5yZW1vdmVfYXNzcSBzIGwgaW5cbiAgICAgIG1hdGNoIHggd2l0aFxuICAgICAgfCBTb21lIF8gLT5cbiAgICAgICAgc3RyZWFtcyA6PSBzb3VyY2UgcyA6OiBsO1xuICAgICAgICBMd3QucmV0dXJuIHhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBzdHJlYW1zIDo9IGw7XG4gICAgICAgIG5leHQgKClcbiAgaW5cbiAgZnJvbSBuZXh0XG5cbmxldCBwYXJzZSBzIGYgPVxuICAobWF0Y2ggcy5zb3VyY2Ugd2l0aFxuICAgfCBQdXNoX2JvdW5kZWQgXyAtPiBpbnZhbGlkX2FyZyBcIkx3dF9zdHJlYW0ucGFyc2VcIlxuICAgfCBGcm9tIF8gfCBGcm9tX2RpcmVjdCBfIHwgUHVzaCBfIC0+ICgpKTtcbiAgbGV0IG5vZGUgPSBzLm5vZGUgaW5cbiAgTHd0LmNhdGNoXG4gICAgKGZ1biAoKSAtPiBmIHMpXG4gICAgKGZ1biBleG4gLT5cbiAgICAgICBzLm5vZGUgPC0gbm9kZTtcbiAgICAgICBMd3QuZmFpbCBleG4pXG5cbmxldCBoZXhkdW1wIHN0cmVhbSA9XG4gIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIDgwIGFuZCBudW0gPSByZWYgMCBpblxuICBmcm9tIGJlZ2luIGZ1biBfIC0+XG4gICAgbmdldCAxNiBzdHJlYW0gPj49IGZ1bmN0aW9uXG4gICAgfCBbXSAtPlxuICAgICAgTHd0LnJldHVybl9ub25lXG4gICAgfCBsIC0+XG4gICAgICBCdWZmZXIuY2xlYXIgYnVmO1xuICAgICAgUHJpbnRmLmJwcmludGYgYnVmIFwiJTA4eHwgIFwiICFudW07XG4gICAgICBudW0gOj0gIW51bSArIDE2O1xuICAgICAgbGV0IHJlYyBieXRlcyBwb3MgPSBmdW5jdGlvblxuICAgICAgICB8IFtdIC0+XG4gICAgICAgICAgYmxhbmtzIHBvc1xuICAgICAgICB8IHggOjogbCAtPlxuICAgICAgICAgIGlmIHBvcyA9IDggdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmICcgJztcbiAgICAgICAgICBQcmludGYuYnByaW50ZiBidWYgXCIlMDJ4IFwiIChDaGFyLmNvZGUgeCk7XG4gICAgICAgICAgYnl0ZXMgKHBvcyArIDEpIGxcbiAgICAgIGFuZCBibGFua3MgcG9zID1cbiAgICAgICAgaWYgcG9zIDwgMTYgdGhlbiBiZWdpblxuICAgICAgICAgIGlmIHBvcyA9IDggdGhlblxuICAgICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiICAgIFwiXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIFwiICAgXCI7XG4gICAgICAgICAgYmxhbmtzIChwb3MgKyAxKVxuICAgICAgICBlbmRcbiAgICAgIGluXG4gICAgICBieXRlcyAwIGw7XG4gICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCIgfFwiO1xuICAgICAgTGlzdC5pdGVyIChmdW4gY2ggLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAoaWYgY2ggPj0gJ1xceDIwJyAmJiBjaCA8PSAnXFx4N2UnIHRoZW4gY2ggZWxzZSAnLicpKSBsO1xuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnfCc7XG4gICAgICBMd3QucmV0dXJuIChTb21lKEJ1ZmZlci5jb250ZW50cyBidWYpKVxuICBlbmRcbiIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG4oKiogTW9kdWxlIFtMd3RfcmVzdWx0XTogZXhwbGljaXQgZXJyb3IgaGFuZGxpbmcgKilcblxub3BlbiBSZXN1bHRcblxudHlwZSAoKydhLCArJ2IpIHQgPSAoJ2EsICdiKSBSZXN1bHQudCBMd3QudFxuXG5sZXQgcmV0dXJuIHggPSBMd3QucmV0dXJuIChPayB4KVxubGV0IGZhaWwgZSA9IEx3dC5yZXR1cm4gKEVycm9yIGUpXG5cbmxldCBsaWZ0ID0gTHd0LnJldHVyblxubGV0IG9rIHggPSBMd3QubWFwIChmdW4geSAtPiBPayB5KSB4XG5sZXQgZXJyb3IgeCA9IEx3dC5tYXAgKGZ1biB5IC0+IEVycm9yIHkpIHhcblxubGV0IG1hcCBmIGUgPVxuICBMd3QubWFwXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gRXJyb3IgZVxuICAgICAgfCBPayB4IC0+IE9rIChmIHgpKVxuICAgIGVcblxubGV0IG1hcF9lcnJvciBmIGUgPVxuICBMd3QubWFwXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gRXJyb3IgKGYgZSlcbiAgICAgIHwgT2sgeCAtPiBPayB4KVxuICAgIGVcbmxldCBtYXBfZXJyIGYgZSA9IG1hcF9lcnJvciBmIGVcblxubGV0IGNhdGNoIGUgPVxuICBMd3QuY2F0Y2hcbiAgICAoZnVuICgpIC0+IG9rIChlICgpKSlcbiAgICBmYWlsXG5cbmxldCBnZXRfZXhuIGUgPVxuICBMd3QuYmluZCBlXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IE9rIHggLT4gTHd0LnJldHVybiB4XG4gICAgICB8IEVycm9yIGUgLT4gTHd0LmZhaWwgZSlcblxubGV0IGJpbmQgZSBmID1cbiAgTHd0LmJpbmQgZVxuICAgIChmdW5jdGlvblxuICAgICAgfCBFcnJvciBlIC0+IEx3dC5yZXR1cm4gKEVycm9yIGUpXG4gICAgICB8IE9rIHggLT4gZiB4KVxuICAgICAgXG5sZXQgYmluZF9lcnJvciBlIGYgPVxuICBMd3QuYmluZCBlXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gZiBlXG4gICAgICB8IE9rIHggLT4gTHd0LnJldHVybiAoT2sgeCkpXG4gICAgICBcbmxldCBiaW5kX2x3dCBlIGYgPVxuICBMd3QuYmluZCBlXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IE9rIHggLT4gb2sgKGYgeClcbiAgICAgIHwgRXJyb3IgZSAtPiBmYWlsIGUpXG5cbmxldCBiaW5kX3Jlc3VsdCBlIGYgPVxuICBMd3QubWFwXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gRXJyb3IgZVxuICAgICAgfCBPayB4IC0+IGYgeClcbiAgICBlXG5cbmxldCBiaW5kX2x3dF9lcnJvciBlIGYgPVxuICBMd3QuYmluZCBlXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gTHd0LmJpbmQgKGYgZSkgZmFpbFxuICAgICAgfCBPayB4IC0+IHJldHVybiB4KVxubGV0IGJpbmRfbHd0X2VyciBlIGYgPSBiaW5kX2x3dF9lcnJvciBlIGZcblxubGV0IGJvdGggYSBiID1cbiAgbGV0IHMgPSByZWYgTm9uZSBpblxuICBsZXQgc2V0X29uY2UgZSA9XG4gICAgbWF0Y2ggIXMgd2l0aFxuICAgIHwgTm9uZSAtPiBzOj0gU29tZSBlXG4gICAgfCBTb21lIF8gLT4gKClcbiAgaW5cbiAgbGV0IChhLGIpID0gbWFwX2Vycm9yIHNldF9vbmNlIGEsbWFwX2Vycm9yIHNldF9vbmNlIGIgaW5cbiAgbGV0IHNvbWVfYXNzZXJ0ID0gZnVuY3Rpb25cbiAgICB8IE5vbmUgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBTb21lIGUgLT4gRXJyb3IgZVxuICBpblxuICBMd3QubWFwXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IE9rIHgsIE9rIHkgLT4gT2sgKHgseSlcbiAgICAgIHwgRXJyb3IgXywgT2sgX1xuICAgICAgfCBPayBfLEVycm9yIF9cbiAgICAgIHwgRXJyb3IgXywgRXJyb3IgXyAtPiBzb21lX2Fzc2VydCAhcylcbiAgICAoTHd0LmJvdGggYSBiKVxuXG5sZXQgaXRlciBmIHIgPVxuICBMd3QuYmluZCByXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IE9rIHggLT4gZiB4XG4gICAgICB8IEVycm9yIF8gLT4gTHd0LnJldHVybl91bml0KVxuXG5sZXQgaXRlcl9lcnJvciBmIHIgPVxuICBMd3QuYmluZCByXG4gICAgKGZ1bmN0aW9uXG4gICAgICB8IEVycm9yIGUgLT4gZiBlXG4gICAgICB8IE9rIF8gLT4gTHd0LnJldHVybl91bml0KVxuXG5tb2R1bGUgSW5maXggPSBzdHJ1Y3RcbiAgbGV0ICg+Pj0pID0gYmluZFxuICBsZXQgKD58PSkgZSBmID0gbWFwIGYgZVxuZW5kXG5cbm1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gIG1vZHVsZSBMZXRfc3ludGF4ID0gc3RydWN0XG4gICAgbGV0IHJldHVybiA9IHJldHVyblxuICAgIGxldCBtYXAgdCB+ZiA9IG1hcCBmIHRcbiAgICBsZXQgYmluZCB0IH5mID0gYmluZCB0IGZcbiAgICBsZXQgYm90aCA9IGJvdGhcbiAgICBtb2R1bGUgT3Blbl9vbl9yaHMgPSBzdHJ1Y3RcbiAgICBlbmRcbiAgZW5kXG5lbmRcblxubW9kdWxlIFN5bnRheCA9IHN0cnVjdFxuICBsZXQgKGxldCopID0gYmluZFxuICBsZXQgKGFuZCopID0gYm90aFxuXG4gIGxldCAobGV0KykgeCBmID0gbWFwIGYgeFxuICBsZXQgKGFuZCspID0gYm90aFxuZW5kXG5cbmluY2x1ZGUgSW5maXhcbiIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5cblxubW9kdWxlIHR5cGUgT3JkZXJlZFR5cGUgPVxuc2lnXG4gIHR5cGUgdFxuICB2YWwgY29tcGFyZTogdCAtPiB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSB0eXBlIFMgPVxuc2lnXG4gIHR5cGUgZWx0XG4gIHR5cGUgdFxuICB2YWwgZW1wdHk6IHRcbiAgdmFsIGlzX2VtcHR5OiB0IC0+IGJvb2xcbiAgdmFsIGFkZDogZWx0IC0+IHQgLT4gdFxuICB2YWwgdW5pb246IHQgLT4gdCAtPiB0XG4gIHZhbCBmaW5kX21pbjogdCAtPiBlbHRcbiAgdmFsIGxvb2t1cF9taW46IHQgLT4gZWx0IG9wdGlvblxuICB2YWwgcmVtb3ZlX21pbjogdCAtPiB0XG4gIHZhbCBzaXplOiB0IC0+IGludFxuZW5kXG5cbm1vZHVsZSBNYWtlKE9yZDogT3JkZXJlZFR5cGUpIDogKFMgd2l0aCB0eXBlIGVsdCA9IE9yZC50KSA9XG5zdHJ1Y3RcbiAgdHlwZSBlbHQgPSBPcmQudFxuXG4gIHR5cGUgdCA9IHRyZWUgbGlzdFxuICBhbmQgdHJlZSA9IE5vZGUgb2YgZWx0ICogaW50ICogdHJlZSBsaXN0XG5cbiAgbGV0IHJvb3QgKE5vZGUgKHgsIF8sIF8pKSA9IHhcbiAgbGV0IHJhbmsgKE5vZGUgKF8sIHIsIF8pKSA9IHJcbiAgbGV0IGxpbmsgKE5vZGUgKHgxLCByMSwgYzEpIGFzIHQxKSAoTm9kZSAoeDIsIHIyLCBjMikgYXMgdDIpID1cbiAgICBsZXQgYyA9IE9yZC5jb21wYXJlIHgxIHgyIGluXG4gICAgaWYgYyA8PSAwIHRoZW4gTm9kZSAoeDEsIHIxICsgMSwgdDI6OmMxKSBlbHNlIE5vZGUoeDIsIHIyICsgMSwgdDE6OmMyKVxuICBsZXQgcmVjIGlucyB0ID1cbiAgICBmdW5jdGlvblxuICAgICAgW10gICAgIC0+XG4gICAgICBbdF1cbiAgICB8ICh0Jzo6XykgYXMgdHMgd2hlbiByYW5rIHQgPCByYW5rIHQnIC0+XG4gICAgICB0Ojp0c1xuICAgIHwgdCc6OnRzIC0+XG4gICAgICBpbnMgKGxpbmsgdCB0JykgdHNcblxuICBsZXQgZW1wdHkgPSBbXVxuICBsZXQgaXNfZW1wdHkgdHMgPSB0cyA9IFtdXG4gIGxldCBhZGQgeCB0cyA9IGlucyAoTm9kZSAoeCwgMCwgW10pKSB0c1xuICBsZXQgcmVjIHVuaW9uIHRzIHRzJyA9XG4gICAgbWF0Y2ggdHMsIHRzJyB3aXRoXG4gICAgICAoW10sIF8pIC0+IHRzJ1xuICAgIHwgKF8sIFtdKSAtPiB0c1xuICAgIHwgKHQxOjp0czEsIHQyOjp0czIpICAtPlxuICAgICAgaWYgcmFuayB0MSA8IHJhbmsgdDIgdGhlbiB0MSA6OiB1bmlvbiB0czEgKHQyOjp0czIpXG4gICAgICBlbHNlIGlmIHJhbmsgdDIgPCByYW5rIHQxIHRoZW4gdDIgOjogdW5pb24gKHQxOjp0czEpIHRzMlxuICAgICAgZWxzZSBpbnMgKGxpbmsgdDEgdDIpICh1bmlvbiB0czEgdHMyKVxuXG4gIGxldCByZWMgZmluZF9taW4gPVxuICAgIGZ1bmN0aW9uXG4gICAgICBbXSAgICAtPiByYWlzZSBOb3RfZm91bmRcbiAgICB8IFt0XSAgIC0+IHJvb3QgdFxuICAgIHwgdDo6dHMgLT5cbiAgICAgIGxldCB4ID0gZmluZF9taW4gdHMgaW5cbiAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgKHJvb3QgdCkgeCBpblxuICAgICAgaWYgYyA8IDAgdGhlbiByb290IHQgZWxzZSB4XG5cbiAgbGV0IHJlYyBsb29rdXBfbWluID1cbiAgICBmdW5jdGlvblxuICAgIHwgW10gICAgLT4gTm9uZVxuICAgIHwgW3RdICAgLT4gU29tZSAocm9vdCB0KVxuICAgIHwgdDo6dHMgLT5cbiAgICAgIG1hdGNoIGxvb2t1cF9taW4gdHMgd2l0aFxuICAgICAgfCBOb25lIC0+IE5vbmVcbiAgICAgIHwgU29tZSB4IGFzIHJlc3VsdCAtPlxuICAgICAgICBsZXQgYyA9IE9yZC5jb21wYXJlIChyb290IHQpIHggaW5cbiAgICAgICAgaWYgYyA8IDAgdGhlbiBTb21lIChyb290IHQpIGVsc2UgcmVzdWx0XG5cbiAgbGV0IHJlYyBnZXRfbWluID1cbiAgICBmdW5jdGlvblxuICAgICAgW10gICAgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBbdF0gICAtPiAodCwgW10pXG4gICAgfCB0Ojp0cyAtPlxuICAgICAgbGV0ICh0JywgdHMnKSA9IGdldF9taW4gdHMgaW5cbiAgICAgIGxldCBjID0gT3JkLmNvbXBhcmUgKHJvb3QgdCkgKHJvb3QgdCcpIGluXG4gICAgICBpZiBjIDwgMCB0aGVuICh0LCB0cykgZWxzZSAodCcsIHQ6OnRzJylcblxuICBsZXQgcmVtb3ZlX21pbiA9XG4gICAgZnVuY3Rpb25cbiAgICAgIFtdIC0+IHJhaXNlIE5vdF9mb3VuZFxuICAgIHwgdHMgLT5cbiAgICAgIGxldCAoTm9kZSAoXywgXywgYyksIHRzKSA9IGdldF9taW4gdHMgaW5cbiAgICAgIHVuaW9uIChMaXN0LnJldiBjKSB0c1xuXG4gIGxldCByZWMgc2l6ZSBsID1cbiAgICBsZXQgc2l6ZXRyZWUgKE5vZGUgKF8sXyx0bCkpID0gMSArIHNpemUgdGwgaW5cbiAgICBMaXN0LmZvbGRfbGVmdCAoZnVuIHMgdCAtPiBzICsgc2l6ZXRyZWUgdCkgMCBsXG5lbmRcbiIsIigqIFRoaXMgZmlsZSBpcyBwYXJ0IG9mIEx3dCwgcmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRS5tZCBmb3JcbiAgIGRldGFpbHMsIG9yIHZpc2l0IGh0dHBzOi8vZ2l0aHViLmNvbS9vY3NpZ2VuL2x3dC9ibG9iL21hc3Rlci9MSUNFTlNFLm1kLiAqKVxuXG5cblxuKCogQSBzdXJ2ZXkgYW5kIG1lYXN1cmVtZW50cyBvZiBtb3JlIG9wdGltaXplZCBpbXBsZW1lbnRhdGlvbnMgY2FuIGJlIGZvdW5kIGF0OlxuXG4gICAgaHR0cHM6Ly9qc3Rob21hcy5naXRodWIuaW8vbWFwLWNvbXBhcmlzb24uaHRtbFxuXG4gICBTZWUgZGlzY3Vzc2lvbiBpbiBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvcHVsbC8zNDcuICopXG5sZXQgdGFpbF9yZWN1cnNpdmVfbWFwIGYgbCA9XG4gIExpc3QucmV2IChMaXN0LnJldl9tYXAgZiBsKVxuXG5sZXQgdGFpbF9yZWN1cnNpdmVfbWFwaV9yZXYgZiBsID1cbiAgbGV0IHJlYyBpbm5lciBhY2MgaSA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBhY2NcbiAgICB8IGhkOjp0bCAtPiAoaW5uZXIgW0BvY2FtbC50YWlsY2FsbF0pICgoZiBpIGhkKTo6YWNjKSAoaSArIDEpIHRsXG4gIGluXG4gIGlubmVyIFtdIDAgbFxuXG5vcGVuIEx3dC5JbmZpeFxuXG5sZXQgcmVjIGl0ZXJfcyBmIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIEx3dC5yZXR1cm5fdW5pdFxuICB8IHggOjogbCAtPlxuICAgIEx3dC5hcHBseSBmIHggPj49IGZ1biAoKSAtPlxuICAgIGl0ZXJfcyBmIGxcblxubGV0IGl0ZXJfcCBmIGwgPVxuICBsZXQgdHMgPSBMaXN0LnJldl9tYXAgKEx3dC5hcHBseSBmKSBsIGluXG4gIEx3dC5qb2luIHRzXG5cbmxldCByZWMgaXRlcmlfcyBpIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybl91bml0XG4gIHwgeCA6OiBsIC0+XG4gICAgTHd0LmFwcGx5IChmIGkpIHggPj49IGZ1biAoKSAtPlxuICAgIGl0ZXJpX3MgKGkgKyAxKSBmIGxcblxubGV0IGl0ZXJpX3MgZiBsID0gaXRlcmlfcyAwIGYgbFxuXG5sZXQgaXRlcmlfcCBmIGwgPVxuICBsZXQgZicgaSA9IEx3dC5hcHBseSAoZiBpKSBpblxuICBsZXQgdHMgPSB0YWlsX3JlY3Vyc2l2ZV9tYXBpX3JldiBmJyBsIGluXG4gIEx3dC5qb2luIHRzXG5cbmxldCBtYXBfcyBmIGwgPVxuICBsZXQgcmVjIGlubmVyIGFjYyA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBMaXN0LnJldiBhY2MgfD4gTHd0LnJldHVyblxuICAgIHwgaGQ6OnRsIC0+XG4gICAgICBMd3QuYXBwbHkgZiBoZCA+Pj0gZnVuIHIgLT5cbiAgICAgIChpbm5lciBbQG9jYW1sLnRhaWxjYWxsXSkgKHI6OmFjYykgdGxcbiAgaW5cbiAgaW5uZXIgW10gbFxuXG5sZXQgcmVjIF9jb2xsZWN0X3JldiBhY2MgPSBmdW5jdGlvblxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybiBhY2NcbiAgfCB0Ojp0cyAtPlxuICAgIHQgPj49IGZ1biBpIC0+XG4gICAgKF9jb2xsZWN0X3JldiBbQG9jYW1sLnRhaWxjYWxsXSkgKGk6OmFjYykgdHNcblxubGV0IG1hcF9wIGYgbCA9XG4gIGxldCB0cyA9IExpc3QucmV2X21hcCAoTHd0LmFwcGx5IGYpIGwgaW5cbiAgX2NvbGxlY3RfcmV2IFtdIHRzXG5cbmxldCBmaWx0ZXJfbWFwX3MgZiBsID1cbiAgbGV0IHJlYyBpbm5lciBhY2MgPSBmdW5jdGlvblxuICAgIHwgW10gICAgIC0+IExpc3QucmV2IGFjYyB8PiBMd3QucmV0dXJuXG4gICAgfCBoZDo6dGwgLT5cbiAgICAgIEx3dC5hcHBseSBmIGhkID4+PSBmdW5jdGlvblxuICAgICAgfCBTb21lIHYgLT4gKGlubmVyIFtAb2NhbWwudGFpbGNhbGxdKSAodjo6YWNjKSB0bFxuICAgICAgfCBOb25lIC0+IChpbm5lciBbQG9jYW1sLnRhaWxjYWxsXSkgYWNjIHRsXG4gIGluXG4gIGlubmVyIFtdIGxcblxubGV0IGZpbHRlcl9tYXBfcCBmIGwgPVxuICBsZXQgcmVjIF9jb2xsZWN0X29wdGlvbmFsX3JldiBhY2MgPSBmdW5jdGlvblxuICB8IFtdICAgIC0+IEx3dC5yZXR1cm4gYWNjXG4gIHwgdDo6dHMgLT5cbiAgICB0ID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSB2IC0+IChfY29sbGVjdF9vcHRpb25hbF9yZXYgW0BvY2FtbC50YWlsY2FsbF0pICh2OjphY2MpIHRzXG4gICAgfCBOb25lIC0+IChfY29sbGVjdF9vcHRpb25hbF9yZXYgW0BvY2FtbC50YWlsY2FsbF0pIGFjYyB0c1xuICBpblxuICBsZXQgdHMgPSBMaXN0LnJldl9tYXAgKEx3dC5hcHBseSBmKSBsIGluXG4gIF9jb2xsZWN0X29wdGlvbmFsX3JldiBbXSB0c1xuXG5sZXQgbWFwaV9zIGYgbCA9XG4gIGxldCByZWMgaW5uZXIgYWNjIGkgPSBmdW5jdGlvblxuICAgIHwgW10gICAgIC0+IExpc3QucmV2IGFjYyB8PiBMd3QucmV0dXJuXG4gICAgfCBoZDo6dGwgLT5cbiAgICAgIEx3dC5hcHBseSAoZiBpKSBoZCA+Pj0gZnVuIHYgLT5cbiAgICAgIChpbm5lciBbQG9jYW1sLnRhaWxjYWxsXSkgKHY6OmFjYykgKGkrMSkgdGxcbiAgaW5cbiAgaW5uZXIgW10gMCBsXG5cbmxldCBtYXBpX3AgZiBsID1cbiAgbGV0IGYnIGkgPSBMd3QuYXBwbHkgKGYgaSkgaW5cbiAgbGV0IHRzID0gdGFpbF9yZWN1cnNpdmVfbWFwaV9yZXYgZicgbCBpblxuICBfY29sbGVjdF9yZXYgW10gdHNcblxubGV0IHJlYyByZXZfbWFwX2FwcGVuZF9zIGFjYyBmIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIEx3dC5yZXR1cm4gYWNjXG4gIHwgeCA6OiBsIC0+XG4gICAgTHd0LmFwcGx5IGYgeCA+Pj0gZnVuIHggLT5cbiAgICByZXZfbWFwX2FwcGVuZF9zICh4IDo6IGFjYykgZiBsXG5cbmxldCByZXZfbWFwX3MgZiBsID1cbiAgcmV2X21hcF9hcHBlbmRfcyBbXSBmIGxcblxubGV0IHJlYyByZXZfbWFwX2FwcGVuZF9wIGFjYyBmIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIGFjY1xuICB8IHggOjogbCAtPlxuICAgIHJldl9tYXBfYXBwZW5kX3BcbiAgICAgIChMd3QuYXBwbHkgZiB4ID4+PSBmdW4geCAtPlxuICAgICAgIGFjYyA+fD0gZnVuIGwgLT5cbiAgICAgICB4IDo6IGwpIGYgbFxuXG5sZXQgcmV2X21hcF9wIGYgbCA9XG4gIHJldl9tYXBfYXBwZW5kX3AgTHd0LnJldHVybl9uaWwgZiBsXG5cbmxldCByZWMgZm9sZF9sZWZ0X3MgZiBhY2MgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybiBhY2NcbiAgfCB4IDo6IGwgLT5cbiAgICBMd3QuYXBwbHkgKGYgYWNjKSB4ID4+PSBmdW4gYWNjIC0+XG4gICAgKGZvbGRfbGVmdF9zIFtAb2NhbWwudGFpbGNhbGxdKSBmIGFjYyBsXG5cbmxldCBmb2xkX3JpZ2h0X3MgZiBsIGFjYyA9XG4gIGxldCByZWMgaW5uZXIgZiBhID0gZnVuY3Rpb25cbiAgICB8IFtdICAgICAtPiBMd3QucmV0dXJuIGFcbiAgICB8IGhkOjp0bCAtPiAoTHd0LmFwcGx5IChmIGhkKSBhKSA+Pj0gZnVuIGEnIC0+XG4gICAgICAoaW5uZXIgW0BvY2FtbC50YWlsY2FsbF0pIGYgYScgdGxcbiAgaW5cbiAgaW5uZXIgZiBhY2MgKExpc3QucmV2IGwpXG5cbmxldCByZWMgZm9yX2FsbF9zIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LnJldHVybl90cnVlXG4gIHwgeCA6OiBsIC0+XG4gICAgTHd0LmFwcGx5IGYgeCA+Pj0gZnVuY3Rpb25cbiAgICB8IHRydWUgLT5cbiAgICAgIChmb3JfYWxsX3MgW0BvY2FtbC50YWlsY2FsbF0pIGYgbFxuICAgIHwgZmFsc2UgLT5cbiAgICAgIEx3dC5yZXR1cm5fZmFsc2VcblxubGV0IGZvcl9hbGxfcCBmIGwgPVxuICBtYXBfcCBmIGwgPj49IGZ1biBibCAtPiBMaXN0LmZvcl9hbGwgKGZ1biB4IC0+IHgpIGJsIHw+IEx3dC5yZXR1cm5cblxubGV0IHJlYyBleGlzdHNfcyBmIGwgPVxuICBtYXRjaCBsIHdpdGhcbiAgfCBbXSAtPlxuICAgIEx3dC5yZXR1cm5fZmFsc2VcbiAgfCB4IDo6IGwgLT5cbiAgICBMd3QuYXBwbHkgZiB4ID4+PSBmdW5jdGlvblxuICAgIHwgdHJ1ZSAtPlxuICAgICAgTHd0LnJldHVybl90cnVlXG4gICAgfCBmYWxzZSAtPlxuICAgICAgKGV4aXN0c19zIFtAb2NhbWwudGFpbGNhbGxdKSBmIGxcblxubGV0IGV4aXN0c19wIGYgbCA9XG4gIG1hcF9wIGYgbCA+Pj0gZnVuIGJsIC0+IExpc3QuZXhpc3RzIChmdW4geCAtPiB4KSBibCB8PiBMd3QucmV0dXJuXG5cbmxldCByZWMgZmluZF9zIGYgbCA9XG4gIG1hdGNoIGwgd2l0aFxuICB8IFtdIC0+XG4gICAgTHd0LmZhaWwgTm90X2ZvdW5kXG4gIHwgeCA6OiBsIC0+XG4gICAgTHd0LmFwcGx5IGYgeCA+Pj0gZnVuY3Rpb25cbiAgICB8IHRydWUgLT5cbiAgICAgIEx3dC5yZXR1cm4geFxuICAgIHwgZmFsc2UgLT5cbiAgICAgIChmaW5kX3MgW0BvY2FtbC50YWlsY2FsbF0pIGYgbFxuXG5sZXQgX29wdGlvbmFsaXplIGYgeCA9XG4gIGYgeCA+Pj0gZnVuIGIgLT4gaWYgYiB0aGVuIEx3dC5yZXR1cm4gKFNvbWUgeCkgZWxzZSBMd3QucmV0dXJuX25vbmVcblxubGV0IGZpbHRlcl9zIGYgbCA9XG4gIGZpbHRlcl9tYXBfcyAoX29wdGlvbmFsaXplIGYpIGxcblxubGV0IGZpbHRlcl9wIGYgbCA9XG4gICBmaWx0ZXJfbWFwX3AgKF9vcHRpb25hbGl6ZSBmKSBsXG5cbmxldCBwYXJ0aXRpb25fcyBmIGwgPVxuICBsZXQgcmVjIGlubmVyIGFjYzEgYWNjMiA9IGZ1bmN0aW9uXG4gICAgfCBbXSAgICAgLT4gTHd0LnJldHVybiAoTGlzdC5yZXYgYWNjMSwgTGlzdC5yZXYgYWNjMilcbiAgICB8IGhkOjp0bCAtPiBMd3QuYXBwbHkgZiBoZCA+Pj0gZnVuIGIgLT5cbiAgICAgICAgaWYgYiB0aGVuXG4gICAgICAgICAgaW5uZXIgKGhkOjphY2MxKSBhY2MyIHRsXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBpbm5lciBhY2MxIChoZDo6YWNjMikgdGxcbiAgaW5cbiAgaW5uZXIgW10gW10gbFxuXG5sZXQgcGFydGl0aW9uX3AgZiBsID1cbiAgbGV0IGcgeCA9IEx3dC5hcHBseSBmIHggPj49IGZ1biBiIC0+IEx3dC5yZXR1cm4gKGIsIHgpIGluXG4gIG1hcF9wIGcgbCA+Pj0gZnVuIHRsIC0+XG4gIGxldCBncm91cDEgPSB0YWlsX3JlY3Vyc2l2ZV9tYXAgc25kIEBAIExpc3QuZmlsdGVyIGZzdCB0bCBpblxuICBsZXQgZ3JvdXAyID1cbiAgICB0YWlsX3JlY3Vyc2l2ZV9tYXAgc25kIEBAIExpc3QuZmlsdGVyIChmdW4geCAtPiBub3QgQEAgZnN0IHgpIHRsIGluXG4gIEx3dC5yZXR1cm4gKGdyb3VwMSwgZ3JvdXAyKVxuIiwiKCogVGhpcyBmaWxlIGlzIHBhcnQgb2YgTHd0LCByZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGZvclxuICAgZGV0YWlscywgb3IgdmlzaXQgaHR0cHM6Ly9naXRodWIuY29tL29jc2lnZW4vbHd0L2Jsb2IvbWFzdGVyL0xJQ0VOU0UubWQuICopXG5cblxuXG4oKiBbTHd0X3NlcXVlbmNlXSBpcyBkZXByZWNhdGVkIOKAkyB3ZSBkb24ndCB3YW50IHVzZXJzIG91dHNpZGUgTHd0IHVzaW5nIGl0LlxuICAgSG93ZXZlciwgaXQgaXMgc3RpbGwgdXNlZCBpbnRlcm5hbGx5IGJ5IEx3dC4gU28sIGJyaWVmbHkgZGlzYWJsZSB3YXJuaW5nIDNcbiAgIChcImRlcHJlY2F0ZWRcIiksIGFuZCBjcmVhdGUgYSBsb2NhbCwgbm9uLWRlcHJlY2F0ZWQgYWxpYXMgZm9yXG4gICBbTHd0X3NlcXVlbmNlXSB0aGF0IGNhbiBiZSByZWZlcnJlZCB0byBieSB0aGUgcmVzdCBvZiB0aGUgY29kZSBpbiB0aGlzXG4gICBtb2R1bGUgd2l0aG91dCB0cmlnZ2VyaW5nIGFueSBtb3JlIHdhcm5pbmdzLiAqKVxuW0BAQG9jYW1sLndhcm5pbmcgXCItM1wiXVxubW9kdWxlIEx3dF9zZXF1ZW5jZSA9IEx3dF9zZXF1ZW5jZVxuW0BAQG9jYW1sLndhcm5pbmcgXCIrM1wiXVxuXG5vcGVuIEx3dC5JbmZpeFxuXG50eXBlICdhIHQgPSB7XG4gIGNyZWF0ZSA6IHVuaXQgLT4gJ2EgTHd0LnQ7XG4gICgqIENyZWF0ZSBhIG5ldyBwb29sIG1lbWJlci4gKilcbiAgY2hlY2sgOiAnYSAtPiAoYm9vbCAtPiB1bml0KSAtPiB1bml0O1xuICAoKiBDaGVjayB2YWxpZGl0eSBvZiBhIHBvb2wgbWVtYmVyIHdoZW4gdXNlIHJlc3VsdGVkIGluIGZhaWxlZCBwcm9taXNlLiAqKVxuICB2YWxpZGF0ZSA6ICdhIC0+IGJvb2wgTHd0LnQ7XG4gICgqIFZhbGlkYXRlIGFuIGV4aXN0aW5nIGZyZWUgcG9vbCBtZW1iZXIgYmVmb3JlIHVzZS4gKilcbiAgZGlzcG9zZSA6ICdhIC0+IHVuaXQgTHd0LnQ7XG4gICgqIERpc3Bvc2Ugb2YgYSBwb29sIG1lbWJlci4gKilcbiAgY2xlYXJlZCA6IGJvb2wgcmVmIHJlZjtcbiAgKCogSGF2ZSB0aGUgY3VycmVudCBwb29sIGVsZW1lbnRzIGJlZW4gY2xlYXJlZCBvdXQ/ICopXG4gIG1heCA6IGludDtcbiAgKCogU2l6ZSBvZiB0aGUgcG9vbC4gKilcbiAgbXV0YWJsZSBjb3VudCA6IGludDtcbiAgKCogTnVtYmVyIG9mIGVsZW1lbnRzIGluIHRoZSBwb29sLiAqKVxuICBsaXN0IDogJ2EgUXVldWUudDtcbiAgKCogQXZhaWxhYmxlIHBvb2wgbWVtYmVycy4gKilcbiAgd2FpdGVycyA6ICdhIEx3dC51IEx3dF9zZXF1ZW5jZS50O1xuICAoKiBQcm9taXNlIHJlc29sdmVycyB3YWl0aW5nIGZvciBhIGZyZWUgbWVtYmVyLiAqKVxufVxuXG5sZXQgY3JlYXRlIG0gPyh2YWxpZGF0ZSA9IGZ1biBfIC0+IEx3dC5yZXR1cm5fdHJ1ZSkgPyhjaGVjayA9IGZ1biBfIGYgLT4gZiB0cnVlKSA/KGRpc3Bvc2UgPSBmdW4gXyAtPiBMd3QucmV0dXJuX3VuaXQpIGNyZWF0ZSA9XG4gIHsgbWF4ID0gbTtcbiAgICBjcmVhdGUgPSBjcmVhdGU7XG4gICAgdmFsaWRhdGUgPSB2YWxpZGF0ZTtcbiAgICBjaGVjayA9IGNoZWNrO1xuICAgIGRpc3Bvc2UgPSBkaXNwb3NlO1xuICAgIGNsZWFyZWQgPSByZWYgKHJlZiBmYWxzZSk7XG4gICAgY291bnQgPSAwO1xuICAgIGxpc3QgPSBRdWV1ZS5jcmVhdGUgKCk7XG4gICAgd2FpdGVycyA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCkgfVxuXG4oKiBDcmVhdGUgYSBwb29sIG1lbWJlci4gKilcbmxldCBjcmVhdGVfbWVtYmVyIHAgPVxuICBMd3QuY2F0Y2hcbiAgICAoZnVuICgpIC0+XG4gICAgICAgKCogTXVzdCBiZSBkb25lIGJlZm9yZSBwLmNyZWF0ZSB0byBwcmV2ZW50IG90aGVyIHJlc29sdmVycyBmcm9tXG4gICAgICAgICAgY3JlYXRpbmcgbmV3IG1lbWJlcnMgaWYgdGhlIGxpbWl0IGlzIHJlYWNoZWQuICopXG4gICAgICAgcC5jb3VudCA8LSBwLmNvdW50ICsgMTtcbiAgICAgICBwLmNyZWF0ZSAoKSlcbiAgICAoZnVuIGV4biAtPlxuICAgICAgICgqIENyZWF0aW9uIGZhaWxlZCwgc28gZG9uJ3QgaW5jcmVtZW50IGNvdW50LiAqKVxuICAgICAgIHAuY291bnQgPC0gcC5jb3VudCAtIDE7XG4gICAgICAgTHd0LmZhaWwgZXhuKVxuXG4oKiBSZWxlYXNlIGEgcG9vbCBtZW1iZXIuICopXG5sZXQgcmVsZWFzZSBwIGMgPVxuICBtYXRjaCBMd3Rfc2VxdWVuY2UudGFrZV9vcHRfbCBwLndhaXRlcnMgd2l0aFxuICB8IFNvbWUgd2FrZW5lciAtPlxuICAgICgqIEEgcHJvbWlzZSByZXNvbHZlciBpcyB3YWl0aW5nLCBnaXZlIGl0IHRoZSBwb29sIG1lbWJlci4gKilcbiAgICBMd3Qud2FrZXVwX2xhdGVyIHdha2VuZXIgY1xuICB8IE5vbmUgLT5cbiAgICAoKiBObyBvbmUgaXMgd2FpdGluZywgcXVldWUgaXQuICopXG4gICAgUXVldWUucHVzaCBjIHAubGlzdFxuXG4oKiBEaXNwb3NlIG9mIGEgcG9vbCBtZW1iZXIuICopXG5sZXQgZGlzcG9zZSBwIGMgPVxuICBwLmRpc3Bvc2UgYyA+Pj0gZnVuICgpIC0+XG4gIHAuY291bnQgPC0gcC5jb3VudCAtIDE7XG4gIEx3dC5yZXR1cm5fdW5pdFxuXG4oKiBDcmVhdGUgYSBuZXcgbWVtYmVyIHdoZW4gb25lIGlzIHRocm93biBhd2F5LiAqKVxubGV0IHJlcGxhY2VfZGlzcG9zZWQgcCA9XG4gIG1hdGNoIEx3dF9zZXF1ZW5jZS50YWtlX29wdF9sIHAud2FpdGVycyB3aXRoXG4gIHwgTm9uZSAtPlxuICAgICgqIE5vIG9uZSBpcyB3YWl0aW5nLCBkbyBub3QgY3JlYXRlIGEgbmV3IG1lbWJlciB0byBhdm9pZFxuICAgICAgIGxvc2luZyBhbiBlcnJvciBpZiBjcmVhdGlvbiBmYWlscy4gKilcbiAgICAoKVxuICB8IFNvbWUgd2FrZW5lciAtPlxuICAgIEx3dC5vbl9hbnlcbiAgICAgIChMd3QuYXBwbHkgcC5jcmVhdGUgKCkpXG4gICAgICAoZnVuIGMgLT5cbiAgICAgICAgIEx3dC53YWtldXBfbGF0ZXIgd2FrZW5lciBjKVxuICAgICAgKGZ1biBleG4gLT5cbiAgICAgICAgICgqIENyZWF0aW9uIGZhaWxlZCwgbm90aWZ5IHRoZSB3YWl0ZXIgb2YgdGhlIGZhaWx1cmUuICopXG4gICAgICAgICBMd3Qud2FrZXVwX2xhdGVyX2V4biB3YWtlbmVyIGV4bilcblxuKCogVmVyaWZ5IGEgbWVtYmVyIGlzIHN0aWxsIHZhbGlkIGJlZm9yZSB1c2luZyBpdC4gKilcbmxldCB2YWxpZGF0ZV9hbmRfcmV0dXJuIHAgYyA9XG4gIEx3dC50cnlfYmluZFxuICAgICAgKGZ1biAoKSAtPlxuICAgICAgICAgcC52YWxpZGF0ZSBjKVxuICAgICAgKGZ1bmN0aW9uXG4gICAgICAgIHwgdHJ1ZSAtPlxuICAgICAgICAgIEx3dC5yZXR1cm4gY1xuICAgICAgICB8IGZhbHNlIC0+XG4gICAgICAgICAgKCogUmVtb3ZlIHRoaXMgbWVtYmVyIGFuZCBjcmVhdGUgYSBuZXcgb25lLiAqKVxuICAgICAgICAgIGRpc3Bvc2UgcCBjID4+PSBmdW4gKCkgLT5cbiAgICAgICAgICBjcmVhdGVfbWVtYmVyIHApXG4gICAgICAoZnVuIGUgLT5cbiAgICAgICAgICgqIFZhbGlkYXRpb24gZmFpbGVkOiBjcmVhdGUgYSBuZXcgbWVtYmVyIGlmIGF0IGxlYXN0IG9uZVxuICAgICAgICAgICAgcmVzb2x2ZXIgaXMgd2FpdGluZy4gKilcbiAgICAgICAgIGRpc3Bvc2UgcCBjID4+PSBmdW4gKCkgLT5cbiAgICAgICAgIHJlcGxhY2VfZGlzcG9zZWQgcDtcbiAgICAgICAgIEx3dC5mYWlsIGUpXG5cbigqIEFjcXVpcmUgYSBwb29sIG1lbWJlci4gKilcbmxldCBhY3F1aXJlIHAgPVxuICBpZiBRdWV1ZS5pc19lbXB0eSBwLmxpc3QgdGhlblxuICAgICgqIE5vIG1vcmUgYXZhaWxhYmxlIG1lbWJlci4gKilcbiAgICBpZiBwLmNvdW50IDwgcC5tYXggdGhlblxuICAgICAgKCogTGltaXQgbm90IHJlYWNoZWQ6IGNyZWF0ZSBhIG5ldyBvbmUuICopXG4gICAgICBjcmVhdGVfbWVtYmVyIHBcbiAgICBlbHNlXG4gICAgICAoKiBMaW1pdCByZWFjaGVkOiB3YWl0IGZvciBhIGZyZWUgb25lLiAqKVxuICAgICAgKEx3dC5hZGRfdGFza19yIFtAb2NhbWwud2FybmluZyBcIi0zXCJdKSBwLndhaXRlcnMgPj49IHZhbGlkYXRlX2FuZF9yZXR1cm4gcFxuICBlbHNlXG4gICAgKCogVGFrZSB0aGUgZmlyc3QgZnJlZSBtZW1iZXIgYW5kIHZhbGlkYXRlIGl0LiAqKVxuICAgIGxldCBjID0gUXVldWUudGFrZSBwLmxpc3QgaW5cbiAgICB2YWxpZGF0ZV9hbmRfcmV0dXJuIHAgY1xuXG4oKiBSZWxlYXNlIGEgbWVtYmVyIHdoZW4gdXNlIHJlc3VsdGVkIGluIGZhaWxlZCBwcm9taXNlIGlmIHRoZSBtZW1iZXJcbiAgIGlzIHN0aWxsIHZhbGlkLiAqKVxubGV0IGNoZWNrX2FuZF9yZWxlYXNlIHAgYyBjbGVhcmVkID1cbiAgbGV0IG9rID0gcmVmIGZhbHNlIGluXG4gIHAuY2hlY2sgYyAoZnVuIHJlc3VsdCAtPiBvayA6PSByZXN1bHQpO1xuICBpZiBjbGVhcmVkIHx8IG5vdCAhb2sgdGhlbiAoXG4gICAgKCogRWxlbWVudCBpcyBub3Qgb2sgb3IgdGhlIHBvb2wgd2FzIGNsZWFyZWQgLSBkaXNwb3NlIG9mIGl0ICopXG4gICAgZGlzcG9zZSBwIGNcbiAgKVxuICBlbHNlIChcbiAgICAoKiBFbGVtZW50IGlzIG9rIC0gcmVsZWFzZSBpdCBiYWNrIHRvIHRoZSBwb29sICopXG4gICAgcmVsZWFzZSBwIGM7XG4gICAgTHd0LnJldHVybl91bml0XG4gIClcblxubGV0IHVzZSBwIGYgPVxuICBhY3F1aXJlIHAgPj49IGZ1biBjIC0+XG4gICgqIENhcHR1cmUgdGhlIGN1cnJlbnQgY2xlYXJlZCBzdGF0ZSBzbyB3ZSBjYW4gc2VlIGlmIGl0IGNoYW5nZXMgd2hpbGUgdGhpc1xuICAgICBlbGVtZW50IGlzIGluIHVzZSAqKVxuICBsZXQgY2xlYXJlZCA9ICEocC5jbGVhcmVkKSBpblxuICBsZXQgcHJvbWlzZSA9XG4gICAgTHd0LmNhdGNoXG4gICAgICAoZnVuICgpIC0+IGYgYylcbiAgICAgIChmdW4gZSAtPlxuICAgICAgICAgY2hlY2tfYW5kX3JlbGVhc2UgcCBjICFjbGVhcmVkID4+PSBmdW4gKCkgLT5cbiAgICAgICAgIEx3dC5mYWlsIGUpXG4gIGluXG4gIHByb21pc2UgPj49IGZ1biBfIC0+XG4gIGlmICFjbGVhcmVkIHRoZW4gKFxuICAgICgqIHAgd2FzIGNsZWFyZWQgd2hpbGUgcHJvbWlzZSB3YXMgcmVzb2x2aW5nIC0gZGlzcG9zZSBvZiB0aGlzIGVsZW1lbnQgKilcbiAgICBkaXNwb3NlIHAgYyA+Pj0gZnVuICgpIC0+XG4gICAgcHJvbWlzZVxuICApXG4gIGVsc2UgKFxuICAgIHJlbGVhc2UgcCBjO1xuICAgIHByb21pc2VcbiAgKVxuXG5sZXQgY2xlYXIgcCA9XG4gIGxldCBlbGVtZW50cyA9IFF1ZXVlLmZvbGQgKGZ1biBsIGVsZW1lbnQgLT4gZWxlbWVudCA6OiBsKSBbXSBwLmxpc3QgaW5cbiAgUXVldWUuY2xlYXIgcC5saXN0O1xuICAoKiBJbmRpY2F0ZSB0byBhbnkgY3VycmVudGx5IGluLXVzZSBlbGVtZW50cyB0aGF0IHdlIGNsZWFyZWQgdGhlIHBvb2wgKilcbiAgbGV0IG9sZF9jbGVhcmVkID0gIShwLmNsZWFyZWQpIGluXG4gIG9sZF9jbGVhcmVkIDo9IHRydWU7XG4gIHAuY2xlYXJlZCA6PSByZWYgZmFsc2U7XG4gIEx3dF9saXN0Lml0ZXJfcyAoZGlzcG9zZSBwKSBlbGVtZW50c1xuXG5sZXQgd2FpdF9xdWV1ZV9sZW5ndGggcCA9IEx3dF9zZXF1ZW5jZS5sZW5ndGggcC53YWl0ZXJzXG4iLCIoKiBPQ2FtbCBwcm9taXNlIGxpYnJhcnlcbiAqIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvbHd0XG4gKiBDb3B5cmlnaHQgKGMpIDIwMDksIE1ldGF3ZWIgVGVjaG5vbG9naWVzLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIE1FVEFXRUIgVEVDSE5PTE9HSUVTIGBgQVMgSVMnJyBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBNRVRBV0VCIFRFQ0hOT0xPR0lFUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUlxuICogQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRVxuICogT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTlxuICogSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKilcblxuKCogVGhpcyBjb2RlIGlzIGFkYXB0ZWQgZnJvbVxuICAgaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAxMDAxMjE1NDI1L2h0dHA6Ly9laWdlbmNsYXNzLm9yZzo4MC9oaWtpL2xpZ2h0d2VpZ2h0LXRocmVhZHMtd2l0aC1sd3QuICopXG5cbigqIFtMd3Rfc2VxdWVuY2VdIGlzIGRlcHJlY2F0ZWQg4oCTIHdlIGRvbid0IHdhbnQgdXNlcnMgb3V0c2lkZSBMd3QgdXNpbmcgaXQuXG4gICBIb3dldmVyLCBpdCBpcyBzdGlsbCB1c2VkIGludGVybmFsbHkgYnkgTHd0LiBTbywgYnJpZWZseSBkaXNhYmxlIHdhcm5pbmcgM1xuICAgKFwiZGVwcmVjYXRlZFwiKSwgYW5kIGNyZWF0ZSBhIGxvY2FsLCBub24tZGVwcmVjYXRlZCBhbGlhcyBmb3JcbiAgIFtMd3Rfc2VxdWVuY2VdIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSByZXN0IG9mIHRoZSBjb2RlIGluIHRoaXNcbiAgIG1vZHVsZSB3aXRob3V0IHRyaWdnZXJpbmcgYW55IG1vcmUgd2FybmluZ3MuICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5tb2R1bGUgTHd0X3NlcXVlbmNlID0gTHd0X3NlcXVlbmNlXG5bQEBAb2NhbWwud2FybmluZyBcIiszXCJdXG5cbnR5cGUgJ2EgdCA9IHtcbiAgbXV0YWJsZSBtdmFyX2NvbnRlbnRzIDogJ2Egb3B0aW9uO1xuICAoKiBDdXJyZW50IGNvbnRlbnRzICopXG5cbiAgd3JpdGVycyA6ICgnYSAqIHVuaXQgTHd0LnUpIEx3dF9zZXF1ZW5jZS50O1xuICAoKiBUaHJlYWRzIHdhaXRpbmcgdG8gcHV0IGEgdmFsdWUgKilcblxuICByZWFkZXJzIDogJ2EgTHd0LnUgTHd0X3NlcXVlbmNlLnQ7XG4gICgqIFRocmVhZHMgd2FpdGluZyBmb3IgYSB2YWx1ZSAqKVxufVxuXG5sZXQgY3JlYXRlX2VtcHR5ICgpID1cbiAgeyBtdmFyX2NvbnRlbnRzID0gTm9uZTtcbiAgICB3cml0ZXJzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKTtcbiAgICByZWFkZXJzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKSB9XG5cbmxldCBjcmVhdGUgdiA9XG4gIHsgbXZhcl9jb250ZW50cyA9IFNvbWUgdjtcbiAgICB3cml0ZXJzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKTtcbiAgICByZWFkZXJzID0gTHd0X3NlcXVlbmNlLmNyZWF0ZSAoKSB9XG5cbmxldCBwdXQgbXZhciB2ID1cbiAgbWF0Y2ggbXZhci5tdmFyX2NvbnRlbnRzIHdpdGhcbiAgfCBOb25lIC0+XG4gICAgYmVnaW4gbWF0Y2ggTHd0X3NlcXVlbmNlLnRha2Vfb3B0X2wgbXZhci5yZWFkZXJzIHdpdGhcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICBtdmFyLm12YXJfY29udGVudHMgPC0gU29tZSB2XG4gICAgICB8IFNvbWUgdyAtPlxuICAgICAgICBMd3Qud2FrZXVwX2xhdGVyIHcgdlxuICAgIGVuZDtcbiAgICBMd3QucmV0dXJuX3VuaXRcbiAgfCBTb21lIF8gLT5cbiAgICBsZXQgKHJlcywgdykgPSBMd3QudGFzayAoKSBpblxuICAgIGxldCBub2RlID0gTHd0X3NlcXVlbmNlLmFkZF9yICh2LCB3KSBtdmFyLndyaXRlcnMgaW5cbiAgICBMd3Qub25fY2FuY2VsIHJlcyAoZnVuIF8gLT4gTHd0X3NlcXVlbmNlLnJlbW92ZSBub2RlKTtcbiAgICByZXNcblxubGV0IG5leHRfd3JpdGVyIG12YXIgPVxuICBtYXRjaCBMd3Rfc2VxdWVuY2UudGFrZV9vcHRfbCBtdmFyLndyaXRlcnMgd2l0aFxuICB8IFNvbWUodicsIHcpIC0+XG4gICAgbXZhci5tdmFyX2NvbnRlbnRzIDwtIFNvbWUgdic7XG4gICAgTHd0Lndha2V1cF9sYXRlciB3ICgpXG4gIHwgTm9uZSAtPlxuICAgIG12YXIubXZhcl9jb250ZW50cyA8LSBOb25lXG5cbmxldCB0YWtlX2F2YWlsYWJsZSBtdmFyID1cbiAgbWF0Y2ggbXZhci5tdmFyX2NvbnRlbnRzIHdpdGhcbiAgfCBTb21lIHYgLT5cbiAgICBuZXh0X3dyaXRlciBtdmFyO1xuICAgIFNvbWUgdlxuICB8IE5vbmUgLT5cbiAgICBOb25lXG5cbmxldCB0YWtlIG12YXIgPVxuICBtYXRjaCB0YWtlX2F2YWlsYWJsZSBtdmFyIHdpdGhcbiAgfCBTb21lIHYgLT4gTHd0LnJldHVybiB2XG4gIHwgTm9uZSAtPiAoTHd0LmFkZF90YXNrX3IgW0BvY2FtbC53YXJuaW5nIFwiLTNcIl0pIG12YXIucmVhZGVyc1xuXG5sZXQgaXNfZW1wdHkgbXZhciA9XG4gIG1hdGNoIG12YXIubXZhcl9jb250ZW50cyB3aXRoXG4gIHwgU29tZSBfIC0+IGZhbHNlXG4gIHwgTm9uZSAtPiB0cnVlXG4iLCIoKiBUaGlzIGZpbGUgaXMgcGFydCBvZiBMd3QsIHJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UubWQgZm9yXG4gICBkZXRhaWxzLCBvciB2aXNpdCBodHRwczovL2dpdGh1Yi5jb20vb2NzaWdlbi9sd3QvYmxvYi9tYXN0ZXIvTElDRU5TRS5tZC4gKilcblxuXG5cbigqIFtMd3Rfc2VxdWVuY2VdIGlzIGRlcHJlY2F0ZWQg4oCTIHdlIGRvbid0IHdhbnQgdXNlcnMgb3V0c2lkZSBMd3QgdXNpbmcgaXQuXG4gICBIb3dldmVyLCBpdCBpcyBzdGlsbCB1c2VkIGludGVybmFsbHkgYnkgTHd0LiBTbywgYnJpZWZseSBkaXNhYmxlIHdhcm5pbmcgM1xuICAgKFwiZGVwcmVjYXRlZFwiKSwgYW5kIGNyZWF0ZSBhIGxvY2FsLCBub24tZGVwcmVjYXRlZCBhbGlhcyBmb3JcbiAgIFtMd3Rfc2VxdWVuY2VdIHRoYXQgY2FuIGJlIHJlZmVycmVkIHRvIGJ5IHRoZSByZXN0IG9mIHRoZSBjb2RlIGluIHRoaXNcbiAgIG1vZHVsZSB3aXRob3V0IHRyaWdnZXJpbmcgYW55IG1vcmUgd2FybmluZ3MuICopXG5bQEBAb2NhbWwud2FybmluZyBcIi0zXCJdXG5tb2R1bGUgTHd0X3NlcXVlbmNlID0gTHd0X3NlcXVlbmNlXG5bQEBAb2NhbWwud2FybmluZyBcIiszXCJdXG5cbm9wZW4gTHd0LkluZml4XG5cbnR5cGUgdCA9IHsgbXV0YWJsZSBsb2NrZWQgOiBib29sOyB3YWl0ZXJzIDogdW5pdCBMd3QudSBMd3Rfc2VxdWVuY2UudCAgfVxuXG5sZXQgY3JlYXRlICgpID0geyBsb2NrZWQgPSBmYWxzZTsgd2FpdGVycyA9IEx3dF9zZXF1ZW5jZS5jcmVhdGUgKCkgfVxuXG5sZXQgbG9jayBtID1cbiAgaWYgbS5sb2NrZWQgdGhlblxuICAgIChMd3QuYWRkX3Rhc2tfciBbQG9jYW1sLndhcm5pbmcgXCItM1wiXSkgbS53YWl0ZXJzXG4gIGVsc2UgYmVnaW5cbiAgICBtLmxvY2tlZCA8LSB0cnVlO1xuICAgIEx3dC5yZXR1cm5fdW5pdFxuICBlbmRcblxubGV0IHVubG9jayBtID1cbiAgaWYgbS5sb2NrZWQgdGhlbiBiZWdpblxuICAgIGlmIEx3dF9zZXF1ZW5jZS5pc19lbXB0eSBtLndhaXRlcnMgdGhlblxuICAgICAgbS5sb2NrZWQgPC0gZmFsc2VcbiAgICBlbHNlXG4gICAgICAoKiBXZSBkbyBub3QgdXNlIFtMd3Qud2FrZXVwXSBoZXJlIHRvIGF2b2lkIGEgc3RhY2sgb3ZlcmZsb3dcbiAgICAgICAgIHdoZW4gdW5sb2NraW5nIGEgbG90IG9mIHRocmVhZHMuICopXG4gICAgICBMd3Qud2FrZXVwX2xhdGVyIChMd3Rfc2VxdWVuY2UudGFrZV9sIG0ud2FpdGVycykgKClcbiAgZW5kXG5cbmxldCB3aXRoX2xvY2sgbSBmID1cbiAgbG9jayBtID4+PSBmdW4gKCkgLT5cbiAgTHd0LmZpbmFsaXplIGYgKGZ1biAoKSAtPiB1bmxvY2sgbTsgTHd0LnJldHVybl91bml0KVxuXG5sZXQgaXNfbG9ja2VkIG0gPSBtLmxvY2tlZFxubGV0IGlzX2VtcHR5IG0gPSBMd3Rfc2VxdWVuY2UuaXNfZW1wdHkgbS53YWl0ZXJzXG4iLCIoKiBPQ2FtbCBwcm9taXNlIGxpYnJhcnlcbiAqIGh0dHA6Ly93d3cub2NzaWdlbi5vcmcvbHd0XG4gKiBDb3B5cmlnaHQgKGMpIDIwMDksIE1ldGF3ZWIgVGVjaG5vbG9naWVzLCBJbmMuXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zXG4gKiBhcmUgbWV0OlxuICogICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcbiAqICAgICAgIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nXG4gKiAgICAgICBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWRcbiAqICAgICAgIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cbiAqXG4gKiBUSElTIFNPRlRXQVJFIElTIFBST1ZJREVEIEJZIE1FVEFXRUIgVEVDSE5PTE9HSUVTIGBgQVMgSVMnJyBBTkQgQU5ZXG4gKiBFWFBSRVNTIE9SIElNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRVxuICogSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSXG4gKiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBNRVRBV0VCIFRFQ0hOT0xPR0lFUyBCRVxuICogTElBQkxFIEZPUiBBTlkgRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUlxuICogQ09OU0VRVUVOVElBTCBEQU1BR0VTIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0ZcbiAqIFNVQlNUSVRVVEUgR09PRFMgT1IgU0VSVklDRVM7IExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUlxuICogQlVTSU5FU1MgSU5URVJSVVBUSU9OKSBIT1dFVkVSIENBVVNFRCBBTkQgT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksXG4gKiBXSEVUSEVSIElOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRVxuICogT1IgT1RIRVJXSVNFKSBBUklTSU5HIElOIEFOWSBXQVkgT1VUIE9GIFRIRSBVU0UgT0YgVEhJUyBTT0ZUV0FSRSwgRVZFTlxuICogSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXG4gKilcblxuKCogW0x3dF9zZXF1ZW5jZV0gaXMgZGVwcmVjYXRlZCDigJMgd2UgZG9uJ3Qgd2FudCB1c2VycyBvdXRzaWRlIEx3dCB1c2luZyBpdC5cbiAgIEhvd2V2ZXIsIGl0IGlzIHN0aWxsIHVzZWQgaW50ZXJuYWxseSBieSBMd3QuIFNvLCBicmllZmx5IGRpc2FibGUgd2FybmluZyAzXG4gICAoXCJkZXByZWNhdGVkXCIpLCBhbmQgY3JlYXRlIGEgbG9jYWwsIG5vbi1kZXByZWNhdGVkIGFsaWFzIGZvclxuICAgW0x3dF9zZXF1ZW5jZV0gdGhhdCBjYW4gYmUgcmVmZXJyZWQgdG8gYnkgdGhlIHJlc3Qgb2YgdGhlIGNvZGUgaW4gdGhpc1xuICAgbW9kdWxlIHdpdGhvdXQgdHJpZ2dlcmluZyBhbnkgbW9yZSB3YXJuaW5ncy4gKilcbltAQEBvY2FtbC53YXJuaW5nIFwiLTNcIl1cbm1vZHVsZSBMd3Rfc2VxdWVuY2UgPSBMd3Rfc2VxdWVuY2VcbltAQEBvY2FtbC53YXJuaW5nIFwiKzNcIl1cblxudHlwZSAnYSB0ID0gJ2EgTHd0LnUgTHd0X3NlcXVlbmNlLnRcblxubGV0IGNyZWF0ZSA9IEx3dF9zZXF1ZW5jZS5jcmVhdGVcblxubGV0IHdhaXQgP211dGV4IGN2YXIgPVxuICBsZXQgd2FpdGVyID0gKEx3dC5hZGRfdGFza19yIFtAb2NhbWwud2FybmluZyBcIi0zXCJdKSBjdmFyIGluXG4gIGxldCAoKSA9XG4gICAgbWF0Y2ggbXV0ZXggd2l0aFxuICAgIHwgU29tZSBtIC0+IEx3dF9tdXRleC51bmxvY2sgbVxuICAgIHwgTm9uZSAtPiAoKVxuICBpblxuICBMd3QuZmluYWxpemVcbiAgICAoZnVuICgpIC0+IHdhaXRlcilcbiAgICAoZnVuICgpIC0+XG4gICAgICAgbWF0Y2ggbXV0ZXggd2l0aFxuICAgICAgIHwgU29tZSBtIC0+IEx3dF9tdXRleC5sb2NrIG1cbiAgICAgICB8IE5vbmUgLT4gTHd0LnJldHVybl91bml0KVxuXG5sZXQgc2lnbmFsIGN2YXIgYXJnID1cbiAgdHJ5XG4gICAgTHd0Lndha2V1cF9sYXRlciAoTHd0X3NlcXVlbmNlLnRha2VfbCBjdmFyKSBhcmdcbiAgd2l0aCBMd3Rfc2VxdWVuY2UuRW1wdHkgLT5cbiAgICAoKVxuXG5sZXQgYnJvYWRjYXN0IGN2YXIgYXJnID1cbiAgbGV0IHdha2VuZXJzID0gTHd0X3NlcXVlbmNlLmZvbGRfciAoZnVuIHggbCAtPiB4IDo6IGwpIGN2YXIgW10gaW5cbiAgTHd0X3NlcXVlbmNlLml0ZXJfbm9kZV9sIEx3dF9zZXF1ZW5jZS5yZW1vdmUgY3ZhcjtcbiAgTGlzdC5pdGVyIChmdW4gd2FrZW5lciAtPiBMd3Qud2FrZXVwX2xhdGVyIHdha2VuZXIgYXJnKSB3YWtlbmVyc1xuXG5sZXQgYnJvYWRjYXN0X2V4biBjdmFyIGV4biA9XG4gIGxldCB3YWtlbmVycyA9IEx3dF9zZXF1ZW5jZS5mb2xkX3IgKGZ1biB4IGwgLT4geCA6OiBsKSBjdmFyIFtdIGluXG4gIEx3dF9zZXF1ZW5jZS5pdGVyX25vZGVfbCBMd3Rfc2VxdWVuY2UucmVtb3ZlIGN2YXI7XG4gIExpc3QuaXRlciAoZnVuIHdha2VuZXIgLT4gTHd0Lndha2V1cF9sYXRlcl9leG4gd2FrZW5lciBleG4pIHdha2VuZXJzXG4iXX0=
