// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Uri
//# unitInfo: Requires: Angstrom, CamlinternalLazy, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__Char, Stdlib__Format, Stdlib__Lazy, Stdlib__List, Stdlib__Option, Stdlib__Printf, Stdlib__Result, Stdlib__String, Stringext
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$34 = "",
    cst$37 = ",",
    cst$36 = ".",
    cst$39 = "..",
    cst$33 = "/",
    cst$38 = "//",
    cst$35 = ":",
    cst_http$0 = "http",
    cst_https$0 = "https",
    cst_int_of_hex_char$1 = "int_of_hex_char",
    cst_localhost$0 = "localhost",
    caml_check_bound = runtime.caml_check_bound,
    caml_int_of_string = runtime.caml_int_of_string,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_equal = runtime.caml_string_equal,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$32 = cst$33,
    cst$31 = cst$34,
    cst$30 = cst$33,
    cst$28 = cst$34,
    cst$24 = cst$35,
    cst$25 = cst$35,
    cst$26 = "::",
    cst$23 = cst$34,
    cst$21 = cst$36,
    cst$22 = cst$36,
    cst$20 = cst$34,
    cst$19 = cst$34,
    cst$18 = cst$33,
    cst$17 = cst$37,
    cst$16 = cst$33,
    cst$15 = cst$34,
    cst$13 = cst$34,
    cst$14 = cst$34,
    cst$12 = cst$34,
    cst$9 = cst$38,
    cst$10 = cst$35,
    cst$11 = "./",
    cst$8 = cst$37,
    cst$7 = "&",
    cst$6 = cst$33,
    cst$5 = cst$33,
    cst$4 = cst$34,
    cst$2 = cst$33,
    cst$3 = cst$33,
    cst$0 = cst$33,
    cst$1 = cst$33,
    cst = cst$34,
    cst$27 = cst$34,
    cst$29 = cst$38,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Stdlib_Option = global_data.Stdlib__Option,
    Stdlib_Printf = global_data.Stdlib__Printf,
    Angstrom = global_data.Angstrom,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Format = global_data.Stdlib__Format,
    Stringext = global_data.Stringext,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Stdlib_Lazy = global_data.Stdlib__Lazy,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Result = global_data.Stdlib__Result,
    _aS_ = [0, 0],
    _aN_ = [0, 3854881, "host is required for HTTP(S) uris"],
    _aP_ = [0, -1042355253],
    _aQ_ = [0, 804243368],
    _aO_ =
      [0,
       [11,
        "Only http and https URIs are supported. ",
        [2, 0, [11, " is invalid.", 0]]],
       "Only http and https URIs are supported. %s is invalid."],
    _aR_ = [1, [0, 3854881, "No scheme present in URI"]],
    cst_http = cst_http$0,
    cst_https = cst_https$0,
    _aM_ = [0, cst$34],
    _aL_ = [0, 0],
    _C_ = [0, 0, 0],
    cst_too_many_parts_in_IPv6_add = "too many parts in IPv6 address",
    _B_ = [0, cst$34, 0],
    cst_invalid_octect = "invalid octect",
    _k_ = [0, [11, "/?", [2, 0, 0]], "/?%s"],
    _j_ = [0, [2, 0, [12, 63, [2, 0, 0]]], "%s?%s"],
    cst_localhost = cst_localhost$0,
    _f_ = [0, cst$34, 0],
    _g_ = [0, cst$34, 0],
    _h_ = [0, 2],
    _i_ = [0, [0, cst$34, 0], 0],
    _c_ = [0, 2],
    _d_ = [0, cst$34, 0],
    cst_int_of_hex_char = cst_int_of_hex_char$1,
    cst_int_of_hex_char$0 = cst_int_of_hex_char$1,
    _b_ = [0, [12, 37, [4, 8, [0, 2, 2], 0, 0]], "%%%02X"],
    _a_ = [0, cst$33, 0],
    _ak_ = [0, 0, 0, 0];
   function iter_concat(fn, sep, buf, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var last = param$0[1];
     if(! param$0[2]) return caml_call2(fn, buf, last);
     var rest = param$0[2];
     caml_call2(fn, buf, last);
     caml_call2(Stdlib_Buffer[16], buf, sep);
     var param$0 = rest;
    }
   }
   function compare_opt(c, t$0, t){
    if(! t$0) return t ? -1 : 0;
    var a = t$0[1];
    if(! t) return 1;
    var b = t[1];
    return caml_call2(c, a, b);
   }
   function compare_list(f, t$0, t){
    var t$2 = t$0, t$1 = t;
    for(;;){
     if(! t$2) return t$1 ? -1 : 0;
     var xs = t$2[2], x = t$2[1];
     if(! t$1) return 1;
     var ys = t$1[2], y = t$1[1], c = caml_call2(f, x, y);
     if(0 !== c) return c;
     var t$2 = xs, t$1 = ys;
    }
   }
   function sub_delims(a){
    var i = 0;
    for(;;){
     var c = caml_string_get("!$&'()*+,;=", i);
     caml_check_bound(a, c)[1 + c] = 1;
     var _d3_ = i + 1 | 0;
     if(10 === i) return a;
     var i = _d3_;
    }
   }
   var safe_chars = caml_make_vect(256, 0), i = 0;
   for(;;){
    var
     c =
       caml_string_get
        ("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789_.-~",
         i);
    caml_check_bound(safe_chars, c)[1 + c] = 1;
    var _aT_ = i + 1 | 0;
    if(65 === i) break;
    var i = _aT_;
   }
   var pchar = sub_delims(caml_call1(Stdlib_Array[8], safe_chars));
   caml_check_bound(pchar, 58)[59] = 1;
   caml_check_bound(pchar, 64)[65] = 1;
   var safe_chars_for_scheme = caml_call1(Stdlib_Array[8], safe_chars);
   caml_check_bound(safe_chars_for_scheme, 43)[44] = 1;
   var safe_chars_for_path = sub_delims(caml_call1(Stdlib_Array[8], pchar));
   caml_check_bound(safe_chars_for_path, 47)[48] = 0;
   var safe_chars_for_query = caml_call1(Stdlib_Array[8], pchar);
   caml_check_bound(safe_chars_for_query, 47)[48] = 1;
   caml_check_bound(safe_chars_for_query, 63)[64] = 1;
   caml_check_bound(safe_chars_for_query, 38)[39] = 0;
   caml_check_bound(safe_chars_for_query, 59)[60] = 0;
   caml_check_bound(safe_chars_for_query, 43)[44] = 0;
   var
    safe_chars_for_query_key =
      caml_call1(Stdlib_Array[8], safe_chars_for_query);
   caml_check_bound(safe_chars_for_query_key, 61)[62] = 0;
   var
    safe_chars_for_query_value =
      caml_call1(Stdlib_Array[8], safe_chars_for_query);
   caml_check_bound(safe_chars_for_query_value, 44)[45] = 0;
   var safe_chars_for_userinfo = caml_call1(Stdlib_Array[8], safe_chars);
   caml_check_bound(safe_chars_for_userinfo, 58)[59] = 0;
   function safe_chars_for_component(param){
    if(typeof param === "number")
     if(-145160102 <= param){
      if(127343601 <= param){
       if(795008922 === param) return safe_chars_for_query_value;
       if(892015045 === param) return safe_chars_for_path;
      }
      else if(61643255 !== param && 127343600 <= param)
       return safe_chars_for_query;
     }
     else if(-250086679 <= param){
      if(-178940859 === param) return safe_chars_for_scheme;
      if(-145160103 <= param) return safe_chars_for_userinfo;
     }
     else{
      if(-911188600 === param) return safe_chars_for_query_key;
      if(-250086680 <= param) return safe_chars_for_query;
     }
    else if(-198771759 === param[1]){
     var
      match = param[2],
      unsafe = match[3],
      safe = match[2],
      component = match[1],
      _dW_ = safe_chars_for_component(component),
      safe_chars$0 = caml_call1(Stdlib_Array[8], _dW_),
      _dY_ = caml_ml_string_length(safe) - 1 | 0,
      _dX_ = 0;
     if(_dY_ >= 0){
      var i$0 = _dX_;
      for(;;){
       var c$0 = caml_string_get(safe, i$0);
       caml_check_bound(safe_chars$0, c$0)[1 + c$0] = 1;
       var _d2_ = i$0 + 1 | 0;
       if(_dY_ === i$0) break;
       var i$0 = _d2_;
      }
     }
     var _d0_ = caml_ml_string_length(unsafe) - 1 | 0, _dZ_ = 0;
     if(_d0_ >= 0){
      var i = _dZ_;
      for(;;){
       var c = caml_string_get(unsafe, i);
       caml_check_bound(safe_chars$0, c)[1 + c] = 0;
       var _d1_ = i + 1 | 0;
       if(_d0_ === i) break;
       var i = _d1_;
      }
     }
     return safe_chars$0;
    }
    return safe_chars;
   }
   function normalize_host(hso){return hso;}
   function canonicalize_port(port){return port;}
   function canonicalize_path(path){return path;}
   var
    Generic =
      [0,
       safe_chars_for_component,
       normalize_host,
       canonicalize_port,
       canonicalize_path],
    safe_chars_for_component$0 = Generic[1];
   function normalize_host$0(hs){return caml_call1(Stdlib_String[26], hs);}
   function canonicalize_port$0(param){
    if(! param) return 0;
    var x = param[1];
    return 80 === x ? 0 : [0, x];
   }
   function canonicalize_path$0(x){return x ? x : _a_;}
   var
    Http =
      [0,
       safe_chars_for_component$0,
       normalize_host$0,
       canonicalize_port$0,
       canonicalize_path$0],
    safe_chars_for_component$1 = Http[1],
    normalize_host$1 = Http[2],
    canonicalize_path$1 = Http[4];
   function canonicalize_port$1(param){
    if(! param) return 0;
    var x = param[1];
    return 443 === x ? 0 : [0, x];
   }
   var
    Https =
      [0,
       safe_chars_for_component$1,
       normalize_host$1,
       canonicalize_port$1,
       canonicalize_path$1],
    safe_chars_for_component$2 = Generic[1],
    canonicalize_port$2 = Generic[3],
    canonicalize_path$2 = Generic[4];
   function normalize_host$2(hs){
    var hs$0 = caml_call1(Stdlib_String[26], hs);
    return caml_string_equal(hs$0, cst_localhost$0) ? cst : hs$0;
   }
   var
    File =
      [0,
       safe_chars_for_component$2,
       normalize_host$2,
       canonicalize_port$2,
       canonicalize_path$2],
    safe_chars_for_component$3 = Generic[1],
    normalize_host$3 = Generic[2],
    canonicalize_port$3 = Generic[3],
    canonicalize_path$3 = Generic[4],
    Urn =
      [0,
       safe_chars_for_component$3,
       normalize_host$3,
       canonicalize_port$3,
       canonicalize_path$3];
   function module_of_scheme(param){
    if(! param) return Generic;
    var s = param[1], match = caml_call1(Stdlib_String[26], s);
    return caml_string_notequal(match, "file")
            ? caml_string_notequal
               (match, cst_http$0)
              ? caml_string_notequal
                 (match, cst_https$0)
                ? caml_string_notequal(match, "urn") ? Generic : Urn
                : Https
              : Http
            : File;
   }
   function encode(scheme, opt, b){
    if(opt) var sth = opt[1], component = sth; else var component = 892015045;
    var
     Scheme = module_of_scheme(scheme),
     safe_chars = Scheme[1].call(null, component),
     len = caml_ml_string_length(b),
     buf = caml_call1(Stdlib_Buffer[1], len),
     start = 0,
     cur = 0;
    for(;;){
     if(len <= cur){
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      return caml_call1(Stdlib_Buffer[2], buf);
     }
     var c = caml_string_get(b, cur);
     if(caml_check_bound(safe_chars, c)[1 + c])
      var cur$0 = cur + 1 | 0, cur = cur$0;
     else{
      if(start < cur)
       caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      var _dV_ = caml_call2(Stdlib_Printf[4], _b_, c);
      caml_call2(Stdlib_Buffer[16], buf, _dV_);
      var
       cur$1 = cur + 1 | 0,
       start$0 = cur + 1 | 0,
       start = start$0,
       cur = cur$1;
     }
    }
   }
   function int_of_hex_char(c){
    var c$0 = caml_call1(Stdlib_Char[6], c) - 48 | 0;
    if(9 >= c$0)
     return 0 <= c$0 ? c$0 : caml_call1(Stdlib[2], cst_int_of_hex_char$0);
    if(16 < c$0 && 23 > c$0) return c$0 - 7 | 0;
    return caml_call1(Stdlib[2], cst_int_of_hex_char);
   }
   function decode(b){
    var
     len = caml_ml_string_length(b),
     buf = caml_call1(Stdlib_Buffer[1], len),
     start = 0,
     cur = 0;
    for(;;){
     if(len <= cur)
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
     else{
      if(37 !== caml_string_get(b, cur)){
       var cur$1 = cur + 1 | 0, cur = cur$1;
       continue;
      }
      caml_call4(Stdlib_Buffer[18], buf, b, start, cur - start | 0);
      var start$0 = cur + 1 | 0;
      if(len <= start$0)
       caml_call2(Stdlib_Buffer[12], buf, 37);
      else{
       try{var highbits = int_of_hex_char(caml_string_get(b, start$0));}
       catch(_dU_){
        caml_call2(Stdlib_Buffer[12], buf, 37);
        var start = start$0, cur = start$0;
        continue;
       }
       var cur$0 = start$0 + 1 | 0;
       if(len > cur$0){
        a:
        {
         try{var lowbits = int_of_hex_char(caml_string_get(b, cur$0));}
         catch(_dT_){
          caml_call2(Stdlib_Buffer[12], buf, 37);
          var _dR_ = caml_string_get(b, cur$0 - 1 | 0);
          caml_call2(Stdlib_Buffer[12], buf, _dR_);
          var start_at = cur$0;
          break a;
         }
         var _dS_ = caml_call1(Stdlib_Char[1], (highbits << 4) + lowbits | 0);
         caml_call2(Stdlib_Buffer[12], buf, _dS_);
         var start_at = cur$0 + 1 | 0;
        }
        var start = start_at, cur = start_at;
        continue;
       }
       caml_call2(Stdlib_Buffer[12], buf, 37);
       var _dQ_ = caml_string_get(b, cur$0 - 1 | 0);
       caml_call2(Stdlib_Buffer[12], buf, _dQ_);
      }
     }
     return caml_call1(Stdlib_Buffer[2], buf);
    }
   }
   function pct_encode(scheme, opt, s){
    if(opt) var sth = opt[1], component = sth; else var component = 892015045;
    return encode(scheme, [0, component], s);
   }
   function pct_encoder(opt, _dP_, _dO_, _dN_, _dM_, _dL_, _dK_, param){
    if(opt) var sth = opt[1], scheme = sth; else var scheme = -178940859;
    if(_dP_)
     var sth$0 = _dP_[1], userinfo = sth$0;
    else
     var userinfo = -145160103;
    if(_dO_) var sth$1 = _dO_[1], host = sth$1; else var host = 803994504;
    if(_dN_) var sth$2 = _dN_[1], path = sth$2; else var path = 892015045;
    if(_dM_)
     var sth$3 = _dM_[1], query_key = sth$3;
    else
     var query_key = -911188600;
    if(_dL_)
     var sth$4 = _dL_[1], query_value = sth$4;
    else
     var query_value = 795008922;
    if(_dK_)
     var sth$5 = _dK_[1], fragment = sth$5;
    else
     var fragment = 127343600;
    return [0, scheme, userinfo, host, path, query_key, query_value, fragment];
   }
   function pct_decode(s){return decode(s);}
   function compare(param, _dJ_){
    var
     p = _dJ_[2],
     u = _dJ_[1],
     p$0 = param[2],
     u$0 = param[1],
     c = caml_call2(Stdlib_String[9], u$0, u);
    return 0 === c ? compare_opt(Stdlib_String[9], p$0, p) : c;
   }
   function userinfo_of_encoded(us){
    var match = caml_call3(Stringext[3], _c_, us, 58);
    if(! match) return _d_;
    var match$0 = match[2], u = match[1];
    if(! match$0) return [0, pct_decode(u), 0];
    var p = match$0[1], _dI_ = [0, pct_decode(p)];
    return [0, pct_decode(u), _dI_];
   }
   function encoded_of_userinfo(scheme, component){
    return function(param){
     var po = param[2], u = param[1];
     if(po) var p = po[1], _dF_ = caml_ml_string_length(p); else var _dF_ = 0;
     var
      len = (1 + caml_ml_string_length(u) | 0) + _dF_ | 0,
      buf = caml_call1(Stdlib_Buffer[1], len),
      _dG_ = pct_encode(scheme, [0, component], u);
     caml_call2(Stdlib_Buffer[16], buf, _dG_);
     if(po){
      var p$0 = po[1];
      caml_call2(Stdlib_Buffer[12], buf, 58);
      var _dH_ = pct_encode(scheme, [0, component], p$0);
      caml_call2(Stdlib_Buffer[16], buf, _dH_);
     }
     return caml_call1(Stdlib_Buffer[2], buf);};
   }
   var _e_ = Stdlib_String[9];
   function path_of_encoded(ps){
    var tokl = caml_call2(Stringext[4], ps, 47);
    return caml_call2(Stdlib_List[19], pct_decode, tokl);
   }
   function remove_dot_segments(p){
    var
     revp = caml_call1(Stdlib_List[9], p),
     ascension = 0,
     outp = 0,
     param$0 = revp;
    for(;;){
     a:
     {
      b:
      if(param$0){
       var _dB_ = param$0[1];
       c:
       {
        if(caml_string_notequal(_dB_, cst$36)){
         if(caml_string_notequal(_dB_, cst$39)){
          if(caml_string_notequal(_dB_, cst$33)) break a;
          var _dD_ = param$0[2];
          if(! _dD_) break b;
          var _dE_ = _dD_[1];
          if(! caml_string_notequal(_dE_, cst$36)){var r$3 = _dD_[2]; break c;}
          if(caml_string_notequal(_dE_, cst$39)){
           if(! caml_string_notequal(_dE_, cst$33)){
            var r$1 = _dD_[2];
            if(0 < ascension){
             var
              ascension$1 = ascension - 1 | 0,
              ascension = ascension$1,
              param$0 = [0, cst$2, r$1];
             continue;
            }
           }
           var r$0 = _dD_[2];
           if(0 >= ascension) break a;
           var
            ascension$0 = ascension - 1 | 0,
            ascension = ascension$0,
            param$0 = r$0;
           continue;
          }
          var r$2 = _dD_[2];
         }
         else
          var r$2 = param$0[2];
         var
          ascension$2 = ascension + 1 | 0,
          ascension = ascension$2,
          param$0 = r$2;
         continue;
        }
        var r$3 = param$0[2];
       }
       var param$0 = r$3;
       continue;
      }
      if
       (0 < caml_call1(Stdlib_List[1], p)
        && caml_string_equal(caml_call1(Stdlib_List[5], p), cst$33))
       return [0, cst$3, outp];
     }
     if(! param$0) break;
     var
      r = param$0[2],
      s = param$0[1],
      outp$0 = [0, s, outp],
      ascension = 0,
      outp = outp$0,
      param$0 = r;
    }
    if(0 >= ascension){
     if
      (0 < caml_call1(Stdlib_List[1], outp)
       && caml_string_equal(caml_call1(Stdlib_List[5], outp), cst$33))
      return caml_call1(Stdlib_List[6], outp);
     return outp;
    }
    var lst = caml_call1(Stdlib_Array[11], caml_make_vect(ascension, cst$39));
    if(lst){
     var t = lst[2], h = lst[1], acc$1 = [0, h, 0], acc = acc$1, param = t;
     for(;;){
      if(! param){var _dC_ = acc; break;}
      var
       xs = param[2],
       x = param[1],
       acc$0 = [0, x, [0, cst$0, acc]],
       acc = acc$0,
       param = xs;
     }
    }
    else
     var _dC_ = 0;
    return caml_call2(Stdlib_List[12], [0, cst$1, _dC_], outp);
   }
   function encoded_of_path(scheme, component){
    return function(p){
     var _dy_ = 0;
     function _dz_(c, tok){return caml_ml_string_length(tok) + c | 0;}
     var
      len = caml_call3(Stdlib_List[25], _dz_, _dy_, p),
      buf = caml_call1(Stdlib_Buffer[1], len);
     iter_concat
      (function(buf, seg){
        if(! caml_string_notequal(seg, cst$33))
         return caml_call2(Stdlib_Buffer[12], buf, 47);
        var _dA_ = pct_encode(scheme, [0, component], seg);
        return caml_call2(Stdlib_Buffer[16], buf, _dA_);
       },
       cst$4,
       buf,
       p);
     return caml_call1(Stdlib_Buffer[2], buf);};
   }
   function query_of_encoded(qs){
    var els = caml_call3(Stringext[3], 0, qs, 38);
    function plus_to_space(s){
     var
      s$0 = caml_call1(Stdlib_Bytes[49], s),
      _dw_ = runtime.caml_ml_bytes_length(s$0) - 1 | 0,
      _dv_ = 0;
     if(_dw_ >= 0){
      var i = _dv_;
      for(;;){
       if(43 === runtime.caml_bytes_get(s$0, i))
        runtime.caml_bytes_set(s$0, i, 32);
       var _dx_ = i + 1 | 0;
       if(_dw_ === i) break;
       var i = _dx_;
      }
     }
     return caml_call1(Stdlib_Bytes[48], s$0);
    }
    if(els){
     var
      _dr_ = function(el){return caml_call3(Stringext[3], _h_, el, 61);},
      acc = 0,
      param = caml_call2(Stdlib_List[21], _dr_, els);
     for(;;){
      if(! param){var _ds_ = acc; break;}
      var _dp_ = param[1];
      if(_dp_){
       var match = _dp_[2], k = _dp_[1];
       if(match)
        var
         tl = param[2],
         v = match[1],
         _dq_ = plus_to_space(v),
         l = caml_call3(Stringext[3], 0, _dq_, 44),
         l$0 = l || _f_,
         n = [0, plus_to_space(k), l$0],
         acc$0 = [0, n, acc],
         acc = acc$0,
         param = tl;
       else
        var
         tl$0 = param[2],
         n$0 = [0, plus_to_space(k), 0],
         acc$1 = [0, n$0, acc],
         acc = acc$1,
         param = tl$0;
      }
      else
       var tl$1 = param[2], acc$2 = [0, _g_, acc], acc = acc$2, param = tl$1;
     }
    }
    else
     var _ds_ = _i_;
    function _dt_(param){
     var
      v = param[2],
      k = param[1],
      _du_ = caml_call2(Stdlib_List[19], pct_decode, v);
     return [0, pct_decode(k), _du_];
    }
    return caml_call2(Stdlib_List[19], _dt_, _ds_);
   }
   function encoded_of_query(scheme, opt, l){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var _di_ = -1;
    function _dj_(a, param){
     var v = param[2], k = param[1], _dn_ = 0;
     function _do_(a, s){return (a + caml_ml_string_length(s) | 0) + 1 | 0;}
     return ((a + caml_ml_string_length(k) | 0)
            + caml_call3(Stdlib_List[25], _do_, _dn_, v)
            | 0)
            + 2
            | 0;
    }
    var
     len = caml_call3(Stdlib_List[25], _dj_, _di_, l),
     buf = caml_call1(Stdlib_Buffer[1], len);
    iter_concat
     (function(buf, param){
       var
        v = param[2],
        k = param[1],
        _dk_ = pct_encode(scheme, [0, pct_encoder$0[5]], k);
       caml_call2(Stdlib_Buffer[16], buf, _dk_);
       var _dl_ = 0 !== v ? 1 : 0;
       return _dl_
               ? (caml_call2
                  (Stdlib_Buffer[12], buf, 61),
                 iter_concat
                  (function(buf, s){
                    var _dm_ = pct_encode(scheme, [0, pct_encoder$0[6]], s);
                    return caml_call2(Stdlib_Buffer[16], buf, _dm_);
                   },
                   cst$8,
                   buf,
                   v))
               : _dl_;
      },
      cst$7,
      buf,
      l);
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function of_raw(qs){
    function _dh_(param){return query_of_encoded(qs);}
    var lazy_query = caml_call1(Stdlib_Lazy[6], _dh_);
    return [1, [0, qs], lazy_query];
   }
   function kv(param){
    if(0 === param[0])
     var kv = param[1];
    else
     var
      _de_ = param[2],
      _df_ = caml_obj_tag(_de_),
      _dg_ =
        250 === _df_
         ? _de_[1]
         : 246 === _df_ ? caml_call1(CamlinternalLazy[2], _de_) : _de_,
      kv = _dg_;
    return kv;
   }
   function encoded_of_query$0(scheme){
    return function(_dc_, _dd_){return encoded_of_query(scheme, _dc_, _dd_);};
   }
   var
    empty = [0, 0, 0, 0, 0, 0, [1, 0, caml_call1(Stdlib_Lazy[4], 0)], 0],
    compare_decoded = Stdlib_String[9];
   function compare_decoded_opt(_da_, _db_){
    return compare_opt(compare_decoded, _da_, _db_);
   }
   function compare_host(h1, h2){
    if(typeof h1 !== "number"){
     var _c$_ = h1[1];
     if(-367671627 === _c$_){
      if(typeof h2 !== "number" && -367671627 === h2[1]){
       var ip2 = h2[2], ip1 = h1[2];
       return caml_call2(Stdlib_String[9], ip1, ip2);
      }
     }
     else
      if(267950263 === _c$_){
       if(typeof h2 !== "number" && 267950263 === h2[1]){
        var ip2$0 = h2[2], ip1$0 = h1[2];
        return caml_call2(Stdlib_String[9], ip1$0, ip2$0);
       }
      }
      else if
       (803994504 === _c$_ && typeof h2 !== "number" && 803994504 === h2[1]){
       var h2$0 = h2[2], h1$0 = h1[2];
       return caml_call2(compare_decoded, h1$0, h2$0);
      }
    }
    return -1;
   }
   function compare$0(t$0, t){
    var c$3 = compare_opt(compare_host, t$0[3], t[3]);
    if(0 !== c$3) return c$3;
    var c = compare_decoded_opt(t$0[1], t[1]);
    if(0 !== c) return c;
    var
     _c8_ = t[4],
     _c9_ = t$0[4],
     c$0 =
       compare_opt
        (function(p$0, p){return p$0 < p ? -1 : p < p$0 ? 1 : 0;}, _c9_, _c8_);
    if(0 !== c$0) return c$0;
    var c$1 = compare_opt(compare, t$0[2], t[2]);
    if(0 !== c$1) return c$1;
    var c$4 = compare_list(_e_, t$0[5], t[5]);
    if(0 !== c$4) return c$4;
    var y = t[6], x = t$0[6];
    a:
    {
     if(0 === x[0]){
      var _c1_ = x[1];
      if(0 === y[0])
       var kvl$0 = y[1], kvl = _c1_;
      else
       var
        _c2_ = y[2],
        _c3_ = caml_obj_tag(_c2_),
        _c4_ =
          250 === _c3_
           ? _c2_[1]
           : 246 === _c3_ ? caml_call1(CamlinternalLazy[2], _c2_) : _c2_,
        kvl$0 = _c4_,
        kvl = _c1_;
     }
     else{
      var _c5_ = x[2], raw = x[1];
      if(0 !== y[0]){
       var raw$0 = y[1], c$2 = compare_opt(Stdlib_String[9], raw, raw$0);
       break a;
      }
      var
       _c6_ = caml_obj_tag(_c5_),
       _c7_ =
         250 === _c6_
          ? _c5_[1]
          : 246 === _c6_ ? caml_call1(CamlinternalLazy[2], _c5_) : _c5_,
       kvl$0 = y[1],
       kvl = _c7_;
     }
     var
      c$2 =
        compare_list
         (function(param, _c__){
           var
            vl = _c__[2],
            k = _c__[1],
            vl$0 = param[2],
            k$0 = param[1],
            c = caml_call2(Stdlib_String[9], k$0, k);
           return 0 === c ? compare_list(Stdlib_String[9], vl$0, vl) : c;
          },
          kvl,
          kvl$0);
    }
    return 0 === c$2 ? compare_decoded_opt(t$0[7], t[7]) : c$2;
   }
   function equal(t$0, t){return 0 === compare$0(t$0, t) ? 1 : 0;}
   function uncast_opt(param){
    if(! param) return 0;
    var h = param[1];
    return [0, h];
   }
   function normalize(schem, init){
    var
     Scheme = module_of_scheme(uncast_opt(schem)),
     _cV_ = init[3],
     _cR_ = init[7],
     _cS_ = init[6],
     _cT_ = init[5],
     _cU_ = init[4];
    if(_cV_){
     var match = _cV_[1], _cW_ = match[1];
     if(267950263 === _cW_)
      var
       host = match[2],
       _cX_ = [0, [0, 267950263, Scheme[2].call(null, host)]];
     else if(803994504 <= _cW_)
      var
       host$0 = match[2],
       _cX_ = [0, [0, 803994504, Scheme[2].call(null, host$0)]];
     else
      var
       host$1 = match[2],
       _cX_ = [0, [0, -367671627, Scheme[2].call(null, host$1)]];
     var _cY_ = _cX_;
    }
    else
     var _cY_ = 0;
    var param = init[1], f = Stdlib_String[26], _cZ_ = init[2];
    if(param)
     var x = param[1], _c0_ = [0, caml_call1(f, x)];
    else
     var _c0_ = 0;
    return [0, _c0_, _cZ_, _cY_, _cU_, _cT_, _cS_, _cR_];
   }
   function to_string(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[1];
    if(match) var s = match[1], scheme = [0, s]; else var scheme = 0;
    var buf = caml_call1(Stdlib_Buffer[1], 128);
    function add_pct_string(opt, x){
     if(opt)
      var sth = opt[1], component = sth;
     else
      var component = 892015045;
     var _cQ_ = encode(scheme, [0, component], x);
     return caml_call2(Stdlib_Buffer[16], buf, _cQ_);
    }
    var match$0 = uri[1];
    if(match$0){
     var x = match$0[1];
     add_pct_string([0, pct_encoder$0[1]], x);
     caml_call2(Stdlib_Buffer[12], buf, 58);
    }
    a:
    {
     var _cy_ = uri[3], _cz_ = uri[4];
     if(! uri[2] && ! _cy_ && ! _cz_){var _cA_ = 0; break a;}
     var _cA_ = 1;
    }
    if(_cA_) caml_call2(Stdlib_Buffer[16], buf, cst$9);
    var match$1 = uri[2];
    if(match$1){
     var
      userinfo = match$1[1],
      _cB_ = encoded_of_userinfo(scheme, pct_encoder$0[2])(userinfo);
     caml_call2(Stdlib_Buffer[16], buf, _cB_);
     caml_call2(Stdlib_Buffer[12], buf, 64);
    }
    var _cC_ = uri[3];
    if(_cC_){
     var match$2 = _cC_[1], _cD_ = match$2[1];
     if(267950263 === _cD_){
      var host = match$2[2];
      caml_call2(Stdlib_Buffer[12], buf, 91);
      caml_call2(Stdlib_Buffer[16], buf, host);
      caml_call2(Stdlib_Buffer[12], buf, 93);
     }
     else if(803994504 <= _cD_){
      var host$0 = match$2[2];
      add_pct_string([0, pct_encoder$0[3]], host$0);
     }
     else{var host$1 = match$2[2]; caml_call2(Stdlib_Buffer[16], buf, host$1);
     }
    }
    var match$3 = uri[4];
    if(match$3){
     var port = match$3[1];
     caml_call2(Stdlib_Buffer[12], buf, 58);
     var _cE_ = caml_call1(Stdlib[33], port);
     caml_call2(Stdlib_Buffer[16], buf, _cE_);
    }
    var _cF_ = uri[5];
    if(_cF_){
     var first_segment = _cF_[1];
     if(caml_string_notequal(first_segment, cst$33)){
      if(uri[3])
       caml_call2(Stdlib_Buffer[12], buf, 47);
      else if(caml_call3(Stringext[12], 0, first_segment, cst$10) && ! scheme)
       caml_call2(Stdlib_Buffer[16], buf, cst$11);
      var
       _cG_ = uri[5],
       _cH_ = encoded_of_path(scheme, pct_encoder$0[4])(_cG_);
      caml_call2(Stdlib_Buffer[16], buf, _cH_);
     }
     else{
      var
       _cO_ = uri[5],
       _cP_ = encoded_of_path(scheme, pct_encoder$0[4])(_cO_);
      caml_call2(Stdlib_Buffer[16], buf, _cP_);
     }
    }
    var _cI_ = uri[6];
    a:
    {
     b:
     {
      if(0 === _cI_[0]){
       var _cJ_ = _cI_[1];
       if(_cJ_){var q = _cJ_; break b;}
      }
      else if(_cI_[1]){
       var
        _cL_ = _cI_[2],
        _cM_ = caml_obj_tag(_cL_),
        _cN_ =
          250 === _cM_
           ? _cL_[1]
           : 246 === _cM_ ? caml_call1(CamlinternalLazy[2], _cL_) : _cL_,
        q = _cN_;
       break b;
      }
      break a;
     }
     caml_call2(Stdlib_Buffer[12], buf, 63);
     var _cK_ = encoded_of_query(scheme, [0, pct_encoder$0], q);
     caml_call2(Stdlib_Buffer[16], buf, _cK_);
    }
    var match$4 = uri[7];
    if(match$4){
     var f = match$4[1];
     caml_call2(Stdlib_Buffer[12], buf, 35);
     add_pct_string([0, pct_encoder$0[7]], f);
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function get_decoded_opt(param){
    if(! param) return 0;
    var x = param[1];
    return [0, x];
   }
   function scheme(uri){return get_decoded_opt(uri[1]);}
   function with_scheme(uri, param){
    if(! param) return [0, 0, uri[2], uri[3], uri[4], uri[5], uri[6], uri[7]];
    var scheme = param[1];
    return [0, [0, scheme], uri[2], uri[3], uri[4], uri[5], uri[6], uri[7]];
   }
   function host(uri){
    var _cx_ = uri[3];
    if(! _cx_) return 0;
    var match = _cx_[1];
    if(803994504 <= match[1]){var h = match[2]; return [0, h];}
    var h$0 = match[2];
    return [0, h$0];
   }
   function host_with_default(opt, uri){
    if(opt)
     var sth = opt[1], default$0 = sth;
    else
     var default$0 = cst_localhost;
    var match = host(uri);
    if(! match) return default$0;
    var h = match[1];
    return h;
   }
   function userinfo(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[2];
    if(! match) return 0;
    var userinfo = match[1], match$0 = uri[1];
    if(match$0)
     var
      s = match$0[1],
      _cw_ = encoded_of_userinfo([0, s], pct_encoder$0[2])(userinfo);
    else
     var _cw_ = encoded_of_userinfo(0, pct_encoder$0[2])(userinfo);
    return [0, _cw_];
   }
   function with_userinfo(uri, userinfo){
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    return host(uri)
            ? [0, uri[1], userinfo$0, uri[3], uri[4], uri[5], uri[6], uri[7]]
            : [0,
              uri[1],
              userinfo$0,
              [0, [0, 803994504, cst$12]],
              uri[4],
              uri[5],
              uri[6],
              uri[7]];
   }
   function user(uri){
    var _cv_ = uri[2];
    if(! _cv_) return 0;
    var user = _cv_[1][1];
    return [0, user];
   }
   function password(uri){
    var _cu_ = uri[2];
    if(_cu_){
     var match = _cu_[1][2];
     if(match){var pass = match[1]; return [0, pass];}
    }
    return 0;
   }
   function with_password(uri, password){
    function result(userinfo){
     return host(uri)
             ? [0, uri[1], userinfo, uri[3], uri[4], uri[5], uri[6], uri[7]]
             : [0,
               uri[1],
               userinfo,
               [0, [0, 803994504, cst$13]],
               uri[4],
               uri[5],
               uri[6],
               uri[7]];
    }
    var _ct_ = uri[2];
    if(! _ct_) return password ? result([0, [0, cst$14, password]]) : uri;
    var user = _ct_[1][1];
    return result([0, [0, user, password]]);
   }
   function port(uri){return uri[4];}
   function with_port(uri, port){
    return host(uri)
            ? [0, uri[1], uri[2], uri[3], port, uri[5], uri[6], uri[7]]
            : port
              ? [0,
                uri[1],
                uri[2],
                [0, [0, 803994504, cst$15]],
                port,
                uri[5],
                uri[6],
                uri[7]]
              : [0, uri[1], uri[2], 0, 0, uri[5], uri[6], uri[7]];
   }
   function path(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[1];
    if(match)
     var
      s = match[1],
      _cq_ = uri[5],
      _cr_ = encoded_of_path([0, s], pct_encoder$0[4])(_cq_);
    else
     var _cs_ = uri[5], _cr_ = encoded_of_path(0, pct_encoder$0[4])(_cs_);
    return _cr_;
   }
   function with_path(uri, path){
    var path$0 = path_of_encoded(path);
    if(host(uri) && path$0 && caml_string_notequal(path$0[1], cst$33))
     return [0,
             uri[1],
             uri[2],
             uri[3],
             uri[4],
             [0, cst$16, path$0],
             uri[6],
             uri[7]];
    return [0, uri[1], uri[2], uri[3], uri[4], path$0, uri[6], uri[7]];
   }
   function fragment(uri){return get_decoded_opt(uri[7]);}
   function with_fragment(uri, param){
    if(! param) return [0, uri[1], uri[2], uri[3], uri[4], uri[5], uri[6], 0];
    var frag = param[1];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], uri[6], [0, frag]];
   }
   function query(uri){return kv(uri[6]);}
   function verbatim_query(opt, uri){
    if(opt)
     var sth = opt[1], pct_encoder$0 = sth;
    else
     var pct_encoder$0 = pct_encoder(0, 0, 0, 0, 0, 0, 0, 0);
    var match = uri[6];
    if(0 === match[0]){
     var kv = match[1];
     return kv
             ? [0, encoded_of_query(scheme(uri), [0, pct_encoder$0], kv)]
             : 0;
    }
    var qs = match[1];
    return qs;
   }
   function get_query_param(uri, k){
    var q = kv(uri[6]);
    try{var _co_ = [0, caml_call2(Stdlib_List[46], k, q)]; return _co_;}
    catch(_cp_){
     var _cn_ = caml_wrap_exception(_cp_);
     if(_cn_ === Stdlib[8]) return 0;
     throw caml_maybe_attach_backtrace(_cn_, 0);
    }
   }
   function get_query_param$0(uri, k){
    var match = get_query_param(uri, k);
    if(! match) return 0;
    var v = match[1];
    return [0, caml_call2(Stdlib_String[6], cst$17, v)];
   }
   function with_query(uri, query){
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], [0, query], uri[7]];
   }
   function q_s(q){
    function _cm_(param){
     var v = param[2], k = param[1];
     return [0, k, [0, v, 0]];
    }
    return caml_call2(Stdlib_List[19], _cm_, q);
   }
   function with_query$0(uri, query){return with_query(uri, q_s(query));}
   function add_query_param(uri, p){
    var _ck_ = uri[7], _cl_ = [0, [0, p, kv(uri[6])]];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _cl_, _ck_];
   }
   function add_query_param$0(uri, param){
    var
     v = param[2],
     k = param[1],
     _ci_ = uri[7],
     _cj_ = [0, [0, [0, k, [0, v, 0]], kv(uri[6])]];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _cj_, _ci_];
   }
   function add_query_params(uri, ps){
    var
     _cf_ = uri[7],
     _cg_ = kv(uri[6]),
     _ch_ = [0, caml_call2(Stdlib[37], ps, _cg_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _ch_, _cf_];
   }
   function add_query_params$0(uri, ps){
    var
     _cb_ = uri[7],
     _cc_ = kv(uri[6]),
     _cd_ = q_s(ps),
     _ce_ = [0, caml_call2(Stdlib[37], _cd_, _cc_)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _ce_, _cb_];
   }
   function remove_query_param(uri, k){
    var _b9_ = uri[7], _b__ = kv(uri[6]);
    function _b$_(param){
     var k$0 = param[1];
     return caml_string_notequal(k, k$0);
    }
    var _ca_ = [0, caml_call2(Stdlib_List[41], _b$_, _b__)];
    return [0, uri[1], uri[2], uri[3], uri[4], uri[5], _ca_, _b9_];
   }
   function path_and_query(uri){
    var p = path(0, uri), match = query(uri);
    if(caml_string_notequal(p, cst$34)){
     if(! match) return p;
     var
      scheme = uncast_opt(uri[1]),
      _b7_ = encoded_of_query$0(scheme)(0, match);
     return caml_call3(Stdlib_Printf[4], _j_, p, _b7_);
    }
    if(! match) return cst$18;
    var
     scheme$0 = uncast_opt(uri[1]),
     _b8_ = encoded_of_query$0(scheme$0)(0, match);
    return caml_call2(Stdlib_Printf[4], _k_, _b8_);
   }
   function resolve(schem, base, uri){
    var match$0 = scheme(base);
    if(match$0)
     var scheme$0 = match$0[1], scheme$1 = scheme$0;
    else
     var scheme$1 = schem;
    var
     schem$0 = [0, scheme$1],
     match$1 = scheme(uri),
     match$2 = userinfo(0, uri);
    a:
    {
     var match$3 = host(uri);
     if(match$1)
      var
       _bQ_ = uri[7],
       _bR_ = uri[6],
       _bS_ = remove_dot_segments(uri[5]),
       _bT_ = [0, uri[1], uri[2], uri[3], uri[4], _bS_, _bR_, _bQ_];
     else{
      if(! match$2 && ! match$3){
       var
        init = [0, base[1], base[2], base[3], base[4], uri[5], uri[6], uri[7]],
        path_str = path(0, init);
       if(caml_string_equal(path_str, cst$34))
        var
         _bX_ = init[7],
         _bY_ = init[6][1] ? init[6] : base[6],
         _bZ_ = [0, init[1], init[2], init[3], init[4], base[5], _bY_, _bX_];
       else if(47 === caml_string_get(path_str, 0))
        var
         _b0_ = init[7],
         _b1_ = init[6],
         _b2_ = remove_dot_segments(init[5]),
         _bZ_ = [0, init[1], init[2], init[3], init[4], _b2_, _b1_, _b0_];
       else{
        var
         relpath = init[5],
         bpath = base[5],
         bhost = base[3],
         _b3_ = init[7],
         _b4_ = init[6],
         match = caml_call1(Stdlib_List[9], bpath);
        b:
        {
         if(bhost && ! match){var _b5_ = [0, cst$6, relpath]; break b;}
         c:
         if(match){
          if(caml_string_notequal(match[1], cst$33)){
           var _bP_ = match[2];
           if(! _bP_) break c;
           if(caml_string_notequal(_bP_[1], cst$33)) break c;
           var rbpath = _bP_[2];
          }
          else
           var rbpath = match[2];
          var _b5_ = caml_call2(Stdlib_List[12], [0, cst$5, rbpath], relpath);
          break b;
         }
         var _b5_ = relpath;
        }
        var
         _b6_ = remove_dot_segments(_b5_),
         _bZ_ = [0, init[1], init[2], init[3], init[4], _b6_, _b4_, _b3_];
       }
       var _bT_ = _bZ_;
       break a;
      }
      var
       _bU_ = uri[7],
       _bV_ = uri[6],
       _bW_ = remove_dot_segments(uri[5]),
       _bT_ = [0, base[1], uri[2], uri[3], uri[4], _bW_, _bV_, _bU_];
     }
    }
    return normalize(schem$0, _bT_);
   }
   function canonicalize(uri){
    var
     uri$0 = resolve(cst$19, empty, uri),
     Scheme = module_of_scheme(uncast_opt(uri$0[1])),
     _bL_ = uri$0[7],
     _bM_ = uri$0[6],
     _bN_ = Scheme[4].call(null, uri$0[5]),
     _bO_ = Scheme[3].call(null, uri$0[4]);
    return [0, uri$0[1], uri$0[2], uri$0[3], _bO_, _bN_, _bM_, _bL_];
   }
   function pp(ppf, uri){
    var _bK_ = to_string(0, uri);
    return caml_call2(Stdlib_Format[13], ppf, _bK_);
   }
   function pp_hum(ppf, uri){
    var _bJ_ = to_string(0, uri);
    return caml_call2(Stdlib_Format[13], ppf, _bJ_);
   }
   var string_of_char = caml_call1(Stdlib_String[1], 1);
   function string_of_char_list(chars){
    var _bI_ = caml_call2(Stdlib_List[19], string_of_char, chars);
    return caml_call2(Stdlib_String[6], cst$20, _bI_);
   }
   var _l_ = caml_call1(Angstrom[51], 0), _m_ = caml_call1(Angstrom[4], 58);
   function _n_(c){
    var _bE_ = 58 !== c ? 1 : 0;
    if(_bE_){
     var _bF_ = 47 !== c ? 1 : 0;
     if(_bF_)
      var _bG_ = 63 !== c ? 1 : 0, _bH_ = _bG_ ? 35 !== c ? 1 : 0 : _bG_;
     else
      var _bH_ = _bF_;
    }
    else
     var _bH_ = _bE_;
    return _bH_;
   }
   var
    _o_ = caml_call1(Angstrom[13], _n_),
    _p_ = caml_call2(Angstrom[59], _o_, _m_);
   function _q_(s){return [0, decode(s)];}
   var
    _r_ = caml_call2(Angstrom[60], _q_, _p_),
    scheme$0 = caml_call2(Angstrom[47], _r_, _l_);
   function is_digit(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   function _s_(param){
    var _bD_ = param - 48 | 0;
    a:
    {
     if(22 < _bD_ >>> 0){
      if(5 < _bD_ - 49 >>> 0) break a;
     }
     else if(6 >= _bD_ - 10 >>> 0) break a;
     return 1;
    }
    return 0;
   }
   var
    hex_digit = caml_call1(Angstrom[7], _s_),
    _t_ = caml_call1(Angstrom[38], hex_digit),
    hexadecimal = caml_call2(Angstrom[60], string_of_char_list, _t_),
    c_dot = caml_call1(Angstrom[4], 46),
    c_at = caml_call1(Angstrom[4], 64),
    c_colon = caml_call1(Angstrom[4], 58);
   function _u_(num){
    return 256 <= caml_int_of_string(num)
            ? caml_call1(Angstrom[52], cst_invalid_octect)
            : caml_call1(Angstrom[51], num);
   }
   function _v_(param){return 9 < param - 48 >>> 0 ? 0 : 1;}
   var
    _w_ = caml_call1(Angstrom[14], _v_),
    dec_octet = caml_call2(Angstrom[53], _w_, _u_),
    _x_ = caml_call2(Angstrom[59], dec_octet, c_dot),
    _y_ = caml_call2(Angstrom[37], 3, _x_);
   function _z_(three, one){
    var
     _bB_ = caml_call2(Stdlib[28], cst$21, one),
     _bC_ = caml_call2(Stdlib_String[6], cst$22, three);
    return caml_call2(Stdlib[28], _bC_, _bB_);
   }
   var ipv4_address = caml_call3(Angstrom[61], _z_, _y_, dec_octet);
   function _A_(f){
    var
     _bv_ = caml_call1(Angstrom[51], 0),
     _bw_ = caml_call2(Angstrom[58], c_colon, f),
     _bx_ = caml_call2(Angstrom[47], _bw_, _bv_);
    function _by_(x, y){return [0, x, y];}
    var
     _bz_ = caml_call3(Angstrom[61], _by_, hexadecimal, _bx_),
     _bA_ = caml_call1(Angstrom[36], [0, ipv4_address, 0]);
    return caml_call2(Angstrom[47], _bA_, _bz_);
   }
   var after_double_colon = caml_call1(Angstrom[45], _A_);
   function double_colon(count){
    var _bs_ = caml_call1(Angstrom[51], _B_);
    function _bt_(rest){
     var
      filler_length = (8 - count | 0) - caml_call1(Stdlib_List[1], rest) | 0;
     return 0 < filler_length
             ? caml_call1(Angstrom[51], [0, cst$23, rest])
             : caml_call1(Angstrom[52], cst_too_many_parts_in_IPv6_add);
    }
    var _bu_ = caml_call2(Angstrom[53], after_double_colon, _bt_);
    return caml_call2(Angstrom[47], _bu_, _bs_);
   }
   function part(n){
    if(6 === n){
     var
      _bp_ = hex_part(6),
      _bq_ = caml_call1(Angstrom[36], [0, ipv4_address, 0]);
     return caml_call2(Angstrom[47], _bq_, _bp_);
    }
    if(7 !== n) return hex_part(n);
    function _br_(x){return [0, x, 0];}
    return caml_call2(Angstrom[60], _br_, hexadecimal);
   }
   function hex_part(n){
    var
     _bj_ = part(n + 1 | 0),
     _bk_ = double_colon(n + 1 | 0),
     _bl_ = caml_call2(Angstrom[58], c_colon, _bk_),
     _bm_ = caml_call2(Angstrom[47], _bl_, _bj_),
     _bn_ = caml_call2(Angstrom[58], c_colon, _bm_);
    function _bo_(x, y){return [0, x, y];}
    return caml_call3(Angstrom[61], _bo_, hexadecimal, _bn_);
   }
   function split_with(f, xs){
    if(! xs) return _C_;
    var ys = xs[2], y = xs[1];
    if(! caml_call1(f, y)) return [0, 0, xs];
    var match = split_with(f, ys), ts = match[2], zs = match[1];
    return [0, [0, y, zs], ts];
   }
   function format_addr(segments){
    var
     match =
       split_with
        (function(segment){return caml_string_notequal(segment, cst$34);},
         segments),
     after_double_colon = match[2],
     before_double_colon = match[1],
     before = caml_call2(Stdlib_String[6], cst$24, before_double_colon);
    a:
    {
     if
      (after_double_colon
       && ! caml_string_notequal(after_double_colon[1], cst$34)){
      var
       xs = after_double_colon[2],
       _bh_ = caml_call2(Stdlib_String[6], cst$25, xs),
       _bi_ = caml_call2(Stdlib[28], cst$26, _bh_),
       res = caml_call2(Stdlib[28], before, _bi_);
      break a;
     }
     var res = before;
    }
    return res;
   }
   var
    _D_ = part(0),
    _E_ = double_colon(0),
    _F_ = caml_call2(Angstrom[58], c_colon, c_colon),
    _G_ = caml_call2(Angstrom[58], _F_, _E_),
    _H_ = caml_call2(Angstrom[47], _G_, _D_),
    ipv6 = caml_call2(Angstrom[60], format_addr, _H_),
    _I_ = caml_call1(Angstrom[4], 93),
    _J_ = caml_call1(Angstrom[4], 91),
    _K_ = caml_call2(Angstrom[58], _J_, ipv6),
    ipv6_address = caml_call2(Angstrom[59], _K_, _I_),
    _L_ = caml_call2(Angstrom[37], 2, hex_digit),
    _M_ = caml_call1(Angstrom[4], 37);
   function _N_(pct, digits){return string_of_char_list([0, pct, digits]);}
   var pct_encoded = caml_call3(Angstrom[61], _N_, _M_, _L_);
   function _O_(param){
    var _bf_ = param - 59 | 0;
    a:
    {
     if(2 < _bf_ >>> 0){
      var _bg_ = _bf_ + 26 | 0;
      if(11 < _bg_ >>> 0) break a;
      switch(_bg_){case 1:case 2:case 4: break a;
      }
     }
     else if(1 === _bf_) break a;
     return 1;
    }
    return 0;
   }
   var sub_delims$0 = caml_call1(Angstrom[7], _O_);
   function _P_(param){
    a:
    {
     if(91 <= param){
      var _bd_ = param - 95 | 0;
      if(27 < _bd_ >>> 0){
       if(31 !== _bd_) break a;
      }
      else if(1 === _bd_) break a;
     }
     else{
      var _be_ = param - 45 | 0;
      if(12 < _be_ >>> 0){if(20 > _be_) break a;} else if(2 === _be_) break a;
     }
     return 1;
    }
    return 0;
   }
   var
    unreserved = caml_call1(Angstrom[7], _P_),
    _Q_ =
      [0,
       pct_encoded,
       [0, caml_call2(Angstrom[57], string_of_char, sub_delims$0), 0]],
    _R_ = [0, caml_call2(Angstrom[57], string_of_char, unreserved), _Q_],
    _S_ = caml_call2(Angstrom[48], 0, _R_),
    _T_ = caml_call1(Angstrom[38], _S_),
    _U_ = caml_call1(Stdlib_String[6], cst$27),
    reg_name = caml_call2(Angstrom[60], _U_, _T_),
    _V_ = 0;
   function _W_(s){return [0, 803994504, decode(s)];}
   var _X_ = [0, caml_call2(Angstrom[55], reg_name, _W_), _V_];
   function _Y_(h){return [0, 267950263, h];}
   var _Z_ = [0, caml_call2(Angstrom[55], ipv6_address, _Y_), _X_];
   function ___(h){return [0, -367671627, h];}
   var
    _$_ = [0, caml_call2(Angstrom[55], ipv4_address, ___), _Z_],
    host$0 = caml_call2(Angstrom[48], 0, _$_),
    _aa_ = caml_call1(Angstrom[51], 0),
    _ab_ = [0, caml_call2(Angstrom[57], string_of_char, c_colon), 0],
    _ac_ =
      [0,
       pct_encoded,
       [0, caml_call2(Angstrom[57], string_of_char, sub_delims$0), _ab_]],
    _ad_ = [0, caml_call2(Angstrom[57], string_of_char, unreserved), _ac_],
    _ae_ = caml_call2(Angstrom[48], 0, _ad_),
    _af_ = caml_call1(Angstrom[38], _ae_),
    _ag_ = caml_call2(Angstrom[59], _af_, c_at);
   function _ah_(x){
    var s = caml_call2(Stdlib_String[6], cst$28, x);
    return [0, userinfo_of_encoded(s)];
   }
   var
    _ai_ = caml_call2(Angstrom[60], _ah_, _ag_),
    userinfo$0 = caml_call2(Angstrom[47], _ai_, _aa_);
   function _aj_(param){
    if(param && 58 === param[1]){
     var
      _a__ =
        function(port){
         var decoded = decode(port);
         try{var _bb_ = [0, caml_int_of_string(decoded)]; return _bb_;}
         catch(_bc_){return 0;}
        },
      _a$_ = caml_call1(Angstrom[13], is_digit),
      _ba_ = caml_call2(Angstrom[58], c_colon, _a$_);
     return caml_call2(Angstrom[55], _ba_, _a__);
    }
    return caml_call1(Angstrom[51], 0);
   }
   var
    port$0 = caml_call2(Angstrom[53], Angstrom[1], _aj_),
    _al_ = caml_call1(Angstrom[51], _ak_);
   function _am_(userinfo, host, port){return [0, userinfo, [0, host], port];}
   var
    _an_ = caml_call4(Angstrom[62], _am_, userinfo$0, host$0, port$0),
    _ao_ = caml_call1(Angstrom[8], cst$29),
    _ap_ = caml_call2(Angstrom[58], _ao_, _an_),
    authority = caml_call2(Angstrom[47], _ap_, _al_);
   function _aq_(param){if(35 !== param && 63 !== param) return 1; return 0;}
   var
    _ar_ = caml_call1(Angstrom[13], _aq_),
    path$0 = caml_call2(Angstrom[60], path_of_encoded, _ar_),
    _as_ = [1, 0, caml_call1(Stdlib_Lazy[4], 0)],
    _at_ = caml_call1(Angstrom[51], _as_);
   function _au_(param){return 35 === param ? 1 : 0;}
   var
    _av_ = caml_call1(Angstrom[15], _au_),
    _aw_ = caml_call1(Angstrom[4], 63),
    _ax_ = caml_call2(Angstrom[58], _aw_, _av_),
    _ay_ = caml_call2(Angstrom[60], of_raw, _ax_),
    query$0 = caml_call2(Angstrom[47], _ay_, _at_),
    _az_ = caml_call1(Angstrom[51], 0);
   function _aA_(param){return 1;}
   var
    _aB_ = caml_call1(Angstrom[13], _aA_),
    _aC_ = caml_call1(Angstrom[4], 35),
    _aD_ = caml_call2(Angstrom[58], _aC_, _aB_);
   function _aE_(s){return [0, decode(s)];}
   var
    _aF_ = caml_call2(Angstrom[60], _aE_, _aD_),
    fragment$0 = caml_call2(Angstrom[47], _aF_, _az_);
   function _aG_(scheme, param, path, query, fragment){
    var port = param[3], host = param[2], userinfo = param[1];
    return normalize
            (scheme, [0, scheme, userinfo, host, port, path, query, fragment]);
   }
   var
    _aH_ =
      caml_call5(Angstrom[63], _aG_, scheme$0, authority, path$0, query$0),
    uri_reference = caml_call2(Angstrom[56], _aH_, fragment$0);
   function _aI_(s){
    var match = caml_call3(Angstrom[75], 1, uri_reference, s);
    if(0 !== match[0]) return empty;
    var t = match[1];
    return t;
   }
   function _aJ_(param){return 10 === param ? 0 : 1;}
   var
    _aK_ = caml_call1(Angstrom[13], _aJ_),
    uri_reference$0 = caml_call2(Angstrom[55], _aK_, _aI_);
   function decode_host(host){
    var match = caml_call3(Angstrom[75], 1, host$0, host);
    if(0 === match[0]){var parsed = match[1]; return parsed;}
    var match$0 = caml_call3(Angstrom[75], 1, ipv6, host);
    if(0 !== match$0[0]) return [0, 803994504, host];
    var parsed$0 = match$0[1];
    return [0, 267950263, parsed$0];
   }
   function make(scheme, userinfo, host, port, path, query, fragment, param){
    function decode(param){
     if(! param) return 0;
     var x = param[1];
     return [0, x];
    }
    a:
    {
     b:
     if(! host){if(! port && ! userinfo) break b; var host$0 = _aM_; break a;}
     var host$0 = host;
    }
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    if(path){
     var p = path[1], path$0 = path_of_encoded(p);
     a:
     {
      if(host$0 && path$0 && caml_string_notequal(path$0[1], cst$33)){var _a7_ = [0, cst$30, path$0]; break a;}
      var _a7_ = path$0;
     }
     var path$1 = _a7_;
    }
    else
     var path$1 = 0;
    if(query) var p$0 = query[1], query$0 = [0, p$0]; else var query$0 = _aL_;
    var scheme$0 = decode(scheme), _a8_ = decode(fragment);
    if(host$0)
     var host$1 = host$0[1], _a9_ = [0, decode_host(host$1)];
    else
     var _a9_ = 0;
    return normalize
            (scheme$0,
             [0, scheme$0, userinfo$0, _a9_, port, path$1, query$0, _a8_]);
   }
   function with_host(init, host){
    var _a2_ = init[7], _a3_ = init[6], _a4_ = init[5], _a5_ = init[4];
    if(host)
     var host$0 = host[1], _a6_ = [0, decode_host(host$0)];
    else
     var _a6_ = 0;
    return [0, init[1], init[2], _a6_, _a5_, _a4_, _a3_, _a2_];
   }
   function with_uri(scheme, userinfo, host, port, path, query, fragment, uri){
    function with_path_opt(u, o){
     if(! o) return with_path(u, cst$31);
     var p = o[1];
     return with_path(u, p);
    }
    function with_query_opt(u, o){
     if(! o) return with_query(u, 0);
     var q = o[1];
     return with_query(u, q);
    }
    function with$0(f, o, u){
     if(! o) return u;
     var x = o[1];
     return caml_call2(f, u, x);
    }
    return with$0
            (with_fragment,
             fragment,
             with$0
              (with_query_opt,
               query,
               with$0
                (with_path_opt,
                 path,
                 with$0
                  (with_port,
                   port,
                   with$0
                    (with_host,
                     host,
                     with$0
                      (with_userinfo, userinfo, with$0(with_scheme, scheme, uri)))))));
   }
   function of_string(s){
    var match = caml_call3(Angstrom[75], 0, uri_reference$0, s);
    if(0 !== match[0]) return empty;
    var t = match[1];
    return t;
   }
   var let$0 = Stdlib_Result[6];
   function to_uri(param){
    var
     fragment = param[7],
     query = param[6],
     path = param[5],
     port = param[4],
     host = param[3],
     userinfo = param[2],
     scheme = param[1],
     scheme$0 = 804243368 <= scheme ? cst_http : cst_https;
    return [0,
            [0, scheme$0],
            userinfo,
            [0, host],
            port,
            path,
            query,
            fragment];
   }
   function of_uri(param){
    var
     fragment = param[7],
     query = param[6],
     path = param[5],
     port = param[4],
     host = param[3],
     userinfo = param[2],
     scheme = param[1];
    function _aY_(scheme){
     function _a1_(host){
      return [0, [0, scheme, userinfo, host, port, path, query, fragment]];
     }
     return caml_call2(let$0, caml_call2(Stdlib_Option[14], _aN_, host), _a1_);
    }
    if(scheme)
     var
      unsupported_scheme = scheme[1],
      _aZ_ =
        caml_string_notequal(unsupported_scheme, cst_http$0)
         ? caml_string_notequal
            (unsupported_scheme, cst_https$0)
           ? [1,
             [0,
              3854881,
              caml_call2(Stdlib_Printf[4], _aO_, unsupported_scheme)]]
           : _aP_
         : _aQ_,
      _a0_ = _aZ_;
    else
     var _a0_ = _aR_;
    return caml_call2(let$0, _a0_, _aY_);
   }
   function of_string$0(s){
    var match = of_uri(of_string(s));
    if(0 === match[0]){var t = match[1]; return t;}
    var error = match[1][2];
    return caml_call1(Stdlib[2], error);
   }
   function to_string$0(pct_encoder, t){
    return to_string(pct_encoder, to_uri(t));
   }
   function make$0
   (scheme, host$2, userinfo, port, path, query, fragment, param){
    if(userinfo)
     var u = userinfo[1], userinfo$0 = [0, userinfo_of_encoded(u)];
    else
     var userinfo$0 = 0;
    if(path){
     var p = path[1], path$0 = path_of_encoded(p);
     a:
     {
      if(path$0 && caml_string_notequal(path$0[1], cst$33)){var _aW_ = [0, cst$32, path$0]; break a;}
      var _aW_ = path$0;
     }
     var path$1 = _aW_;
    }
    else
     var path$1 = 0;
    if(query) var p$0 = query[1], query$0 = [0, p$0]; else var query$0 = _aS_;
    if(fragment) var x = fragment[1], _aX_ = [0, x]; else var _aX_ = 0;
    var match = decode_host(host$2), _aU_ = match[1];
    if(267950263 === _aU_)
     var
      host = match[2],
      _aV_ = [0, 267950263, caml_call1(Stdlib_String[26], host)];
    else if(803994504 <= _aU_)
     var
      host$0 = match[2],
      _aV_ = [0, 803994504, caml_call1(Stdlib_String[26], host$0)];
    else
     var
      host$1 = match[2],
      _aV_ = [0, -367671627, caml_call1(Stdlib_String[26], host$1)];
    return [0, scheme, userinfo$0, _aV_, port, path$1, query$0, _aX_];
   }
   function host$1(t){
    var match = t[3];
    if(803994504 <= match[1]){var h = match[2]; return h;}
    var h$0 = match[2];
    return h$0;
   }
   function scheme$1(t){return t[1];}
   var
    Uri =
      [0,
       empty,
       compare$0,
       equal,
       pct_encode,
       pct_encoder,
       pct_decode,
       of_string,
       to_string,
       resolve,
       canonicalize,
       make,
       with_uri,
       query,
       verbatim_query,
       encoded_of_query$0,
       query_of_encoded,
       with_query,
       with_query$0,
       get_query_param,
       get_query_param$0,
       add_query_param,
       add_query_param$0,
       add_query_params,
       add_query_params$0,
       remove_query_param,
       path,
       path_and_query,
       with_path,
       scheme,
       with_scheme,
       userinfo,
       with_userinfo,
       user,
       password,
       with_password,
       host,
       with_host,
       host_with_default,
       port,
       with_port,
       fragment,
       with_fragment,
       pp,
       pp_hum,
       [0, ipv6, uri_reference$0],
       [0, of_uri, to_uri, of_string$0, to_string$0, make$0, host$1, scheme$1]];
   runtime.caml_register_global(107, Uri, "Uri");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJ1cmkuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbImNzdCQwIiwiaXRlcl9jb25jYXQiLCJmbiIsInNlcCIsImJ1ZiIsImxhc3QiLCJyZXN0IiwiY29tcGFyZV9vcHQiLCJjIiwidCQwIiwidCIsImEiLCJiIiwiY29tcGFyZV9saXN0IiwiZiIsInQkMiIsInQkMSIsInhzIiwieCIsInlzIiwieSIsInN1Yl9kZWxpbXMiLCJpIiwic2FmZV9jaGFycyIsInBjaGFyIiwic2FmZV9jaGFyc19mb3Jfc2NoZW1lIiwic2FmZV9jaGFyc19mb3JfcGF0aCIsInNhZmVfY2hhcnNfZm9yX3F1ZXJ5Iiwic2FmZV9jaGFyc19mb3JfcXVlcnlfa2V5Iiwic2FmZV9jaGFyc19mb3JfcXVlcnlfdmFsdWUiLCJzYWZlX2NoYXJzX2Zvcl91c2VyaW5mbyIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCIsInVuc2FmZSIsInNhZmUiLCJjb21wb25lbnQiLCJzYWZlX2NoYXJzJDAiLCJpJDAiLCJjJDAiLCJub3JtYWxpemVfaG9zdCIsImhzbyIsImNhbm9uaWNhbGl6ZV9wb3J0IiwicG9ydCIsImNhbm9uaWNhbGl6ZV9wYXRoIiwicGF0aCIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQwIiwibm9ybWFsaXplX2hvc3QkMCIsImhzIiwiY2Fub25pY2FsaXplX3BvcnQkMCIsImNhbm9uaWNhbGl6ZV9wYXRoJDAiLCJzYWZlX2NoYXJzX2Zvcl9jb21wb25lbnQkMSIsIm5vcm1hbGl6ZV9ob3N0JDEiLCJjYW5vbmljYWxpemVfcGF0aCQxIiwiY2Fub25pY2FsaXplX3BvcnQkMSIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQyIiwiY2Fub25pY2FsaXplX3BvcnQkMiIsImNhbm9uaWNhbGl6ZV9wYXRoJDIiLCJub3JtYWxpemVfaG9zdCQyIiwiaHMkMCIsInNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCQzIiwibm9ybWFsaXplX2hvc3QkMyIsImNhbm9uaWNhbGl6ZV9wb3J0JDMiLCJjYW5vbmljYWxpemVfcGF0aCQzIiwibW9kdWxlX29mX3NjaGVtZSIsInMiLCJlbmNvZGUiLCJzY2hlbWUiLCJvcHQiLCJzdGgiLCJsZW4iLCJzdGFydCIsImN1ciIsImN1ciQwIiwiY3VyJDEiLCJzdGFydCQwIiwiaW50X29mX2hleF9jaGFyIiwiZGVjb2RlIiwiaGlnaGJpdHMiLCJsb3diaXRzIiwic3RhcnRfYXQiLCJwY3RfZW5jb2RlIiwicGN0X2VuY29kZXIiLCJzdGgkMCIsInVzZXJpbmZvIiwic3RoJDEiLCJob3N0Iiwic3RoJDIiLCJzdGgkMyIsInF1ZXJ5X2tleSIsInN0aCQ0IiwicXVlcnlfdmFsdWUiLCJzdGgkNSIsImZyYWdtZW50IiwicGN0X2RlY29kZSIsImNvbXBhcmUiLCJwIiwidSIsInAkMCIsInUkMCIsInVzZXJpbmZvX29mX2VuY29kZWQiLCJ1cyIsImVuY29kZWRfb2ZfdXNlcmluZm8iLCJwbyIsInBhdGhfb2ZfZW5jb2RlZCIsInBzIiwidG9rbCIsInJlbW92ZV9kb3Rfc2VnbWVudHMiLCJyZXZwIiwiYXNjZW5zaW9uIiwib3V0cCIsInIkMyIsInIkMSIsInIkMCIsInIkMiIsInIiLCJsc3QiLCJoIiwiYWNjIiwiZW5jb2RlZF9vZl9wYXRoIiwidG9rIiwic2VnIiwicXVlcnlfb2ZfZW5jb2RlZCIsInFzIiwiZWxzIiwicGx1c190b19zcGFjZSIsInMkMCIsImVsIiwiayIsInRsIiwidiIsImwiLCJsJDAiLCJuIiwidGwkMCIsIm4kMCIsInRsJDEiLCJlbmNvZGVkX29mX3F1ZXJ5IiwicGN0X2VuY29kZXIkMCIsIm9mX3JhdyIsImxhenlfcXVlcnkiLCJrdiIsImVuY29kZWRfb2ZfcXVlcnkkMCIsImVtcHR5IiwiY29tcGFyZV9kZWNvZGVkIiwiY29tcGFyZV9kZWNvZGVkX29wdCIsImNvbXBhcmVfaG9zdCIsImgxIiwiaDIiLCJpcDIiLCJpcDEiLCJpcDIkMCIsImlwMSQwIiwiaDIkMCIsImgxJDAiLCJjb21wYXJlJDAiLCJjJDMiLCJjJDEiLCJjJDQiLCJrdmwkMCIsImt2bCIsInJhdyIsInJhdyQwIiwiYyQyIiwidmwiLCJ2bCQwIiwiayQwIiwiZXF1YWwiLCJ1bmNhc3Rfb3B0Iiwibm9ybWFsaXplIiwic2NoZW0iLCJpbml0IiwiaG9zdCQwIiwiaG9zdCQxIiwidG9fc3RyaW5nIiwidXJpIiwiYWRkX3BjdF9zdHJpbmciLCJmaXJzdF9zZWdtZW50IiwicSIsImdldF9kZWNvZGVkX29wdCIsIndpdGhfc2NoZW1lIiwiaCQwIiwiaG9zdF93aXRoX2RlZmF1bHQiLCJkZWZhdWx0JDAiLCJ3aXRoX3VzZXJpbmZvIiwidXNlcmluZm8kMCIsInVzZXIiLCJwYXNzd29yZCIsInBhc3MiLCJ3aXRoX3Bhc3N3b3JkIiwicmVzdWx0Iiwid2l0aF9wb3J0Iiwid2l0aF9wYXRoIiwicGF0aCQwIiwid2l0aF9mcmFnbWVudCIsImZyYWciLCJxdWVyeSIsInZlcmJhdGltX3F1ZXJ5IiwiZ2V0X3F1ZXJ5X3BhcmFtIiwiZ2V0X3F1ZXJ5X3BhcmFtJDAiLCJ3aXRoX3F1ZXJ5IiwicV9zIiwid2l0aF9xdWVyeSQwIiwiYWRkX3F1ZXJ5X3BhcmFtIiwiYWRkX3F1ZXJ5X3BhcmFtJDAiLCJhZGRfcXVlcnlfcGFyYW1zIiwiYWRkX3F1ZXJ5X3BhcmFtcyQwIiwicmVtb3ZlX3F1ZXJ5X3BhcmFtIiwicGF0aF9hbmRfcXVlcnkiLCJtYXRjaCIsInNjaGVtZSQwIiwicmVzb2x2ZSIsImJhc2UiLCJzY2hlbWUkMSIsInNjaGVtJDAiLCJwYXRoX3N0ciIsInJlbHBhdGgiLCJicGF0aCIsImJob3N0IiwicmJwYXRoIiwiY2Fub25pY2FsaXplIiwidXJpJDAiLCJwcCIsInBwZiIsInBwX2h1bSIsInN0cmluZ19vZl9jaGFyIiwic3RyaW5nX29mX2NoYXJfbGlzdCIsImNoYXJzIiwiaXNfZGlnaXQiLCJoZXhfZGlnaXQiLCJoZXhhZGVjaW1hbCIsImNfZG90IiwiY19hdCIsImNfY29sb24iLCJudW0iLCJkZWNfb2N0ZXQiLCJ0aHJlZSIsIm9uZSIsImlwdjRfYWRkcmVzcyIsImFmdGVyX2RvdWJsZV9jb2xvbiIsImRvdWJsZV9jb2xvbiIsImNvdW50IiwiZmlsbGVyX2xlbmd0aCIsInBhcnQiLCJoZXhfcGFydCIsInNwbGl0X3dpdGgiLCJ0cyIsInpzIiwiZm9ybWF0X2FkZHIiLCJzZWdtZW50cyIsInNlZ21lbnQiLCJiZWZvcmVfZG91YmxlX2NvbG9uIiwiYmVmb3JlIiwicmVzIiwiaXB2NiIsImlwdjZfYWRkcmVzcyIsInBjdCIsImRpZ2l0cyIsInBjdF9lbmNvZGVkIiwic3ViX2RlbGltcyQwIiwidW5yZXNlcnZlZCIsInJlZ19uYW1lIiwiZGVjb2RlZCIsInBvcnQkMCIsImF1dGhvcml0eSIsInF1ZXJ5JDAiLCJmcmFnbWVudCQwIiwidXJpX3JlZmVyZW5jZSIsInVyaV9yZWZlcmVuY2UkMCIsImRlY29kZV9ob3N0IiwicGFyc2VkIiwicGFyc2VkJDAiLCJtYWtlIiwicGF0aCQxIiwid2l0aF9ob3N0Iiwid2l0aF91cmkiLCJ3aXRoX3BhdGhfb3B0IiwibyIsIndpdGhfcXVlcnlfb3B0Iiwid2l0aCQwIiwib2Zfc3RyaW5nIiwibGV0JDAiLCJ0b191cmkiLCJvZl91cmkiLCJ1bnN1cHBvcnRlZF9zY2hlbWUiLCJvZl9zdHJpbmckMCIsImVycm9yIiwidG9fc3RyaW5nJDAiLCJtYWtlJDAiLCJob3N0JDIiXSwic291cmNlcyI6WyIvVXNlcnMvcm9zdmFsaS8ub3BhbS80LjE0LjEvbGliL3VyaS91cmkubWwiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0lBb0RrQkE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O1lBUlZDLFlBQVlDLElBQUdDLEtBQUlDOzs7bUJBTWpCO1NBTE5DO3NCQUFZLE9BQUEsV0FESUgsSUFBT0UsS0FDdkJDO1NBQ0lDO0tBQ0osV0FIZ0JKLElBQU9FLEtBQ3ZCQztLQUdBLDhCQUp1QkQsS0FBSkQ7bUJBRWZHOzs7WUFjSkMsWUFBWUMsR0FBRUMsS0FBRUM7SUFBSyxLQUFQRCxZQUFFQztRQUlYQyxJQUpTRjtTQUFFQyxHQUVFO1FBRUxFLElBSkdGO0lBSUUsT0FBQSxXQUpORixHQUlQRyxHQUFRQztHQUFVO1lBRW5CQyxhQUFhQyxHQUFFTCxLQUFFQztJQUFLLElBQVBLLE1BQUFOLEtBQUVPLE1BQUFOO0lBQUs7VUFBUEssWUFBRUM7U0FBRkMsS0FBQUYsUUFJbkJHLElBSm1CSDtVQUFFQyxLQUVKO0tBR1gsSUFMZUcsS0FBQUgsUUFJZEksSUFKY0osUUFLd0JSLElBQXZDLFdBTFdNLEdBSWpCSSxHQUFPRTtjQUNzQ1osR0FBSyxPQUFMQTtTQUwxQk8sTUFBQUUsSUFBRUQsTUFBQUc7O0dBSzhCO1lBaUJqREUsV0FBV1Y7SUFDYixJQUNBVzs7S0FDb0IsSUFBZGQsSUFBYywrQkFEcEJjO0tBRUUsaUJBSldYLEdBR1BILE9BQUFBO0tBRE4sV0FBQWM7ZUFBQUEsR0FJQSxPQU5hWDtTQUViVzs7R0FJQztHQUdPLElBQUpDLGFBQUksd0JBR1JEOztJQUNvQjtLQUFkZDtPQUFjOztTQURwQmM7SUFFRSxpQkFMRUMsWUFJRWYsT0FBQUE7SUFETixXQUFBYztjQUFBQTtRQUFBQTs7R0FPUSxJQURORSxRQWxCQUgsV0FtQmlCLDRCQVZmRTtHQVdKLGlCQUZFQztHQUdGLGlCQUhFQTtHQU9NLElBRE5DLHdCQUNNLDRCQWhCSkY7R0FpQkosaUJBRkVFO0dBT00sSUFETkMsc0JBOUJBTCxXQStCaUIsNEJBYmpCRztHQWVGLGlCQUhFRTtHQVFNLElBRk5DLHVCQUVNLDRCQXBCTkg7R0FxQkYsaUJBSEVHO0dBSUYsaUJBSkVBO0dBT0YsaUJBUEVBO0dBU0YsaUJBVEVBO0dBVUYsaUJBVkVBO0dBY007SUFETkM7TUFDTSw0QkFkTkQ7R0FlRixpQkFGRUM7R0FNTTtJQUROQztNQUNNLDRCQW5CTkY7R0FvQkYsaUJBRkVFO0dBVU0sSUFETkMsMEJBQ00sNEJBdkRKUDtHQXlESixpQkFIRU87WUFNSUM7SUFBMkI7OzsrQkFiakMsT0FGRUY7K0JBckJGLE9BSEVIOzs7T0FnQkYsT0FWRUM7OzsrQkFWRixPQUZFRjs4QkEwQ0YsT0FIRUs7OzsrQkFaRixPQUZFRjs4QkFIRixPQVZFRDs7O0tBMEM2Qjs7TUFEV0s7TUFBTkM7TUFBeEJDO01BQ21CLE9BVHpCSCx5QkFRTUc7TUFDTEMsZUFBYTttQ0FEZ0JGO01BQ2hCOztVQUNqQkc7O09BQ29CLElBQWRDLE1BQWMsZ0JBSGFKLE1BRWpDRztPQUVFLGlCQUhFRCxjQUVFRSxTQUFBQTtPQUROLFdBQUFEO21CQUFBQTtXQUFBQTs7O0tBSUEsaUNBTnVDSixpQkFNdkM7O1VBQUFWOztPQUNvQixJQUFkZCxJQUFjLGdCQVBtQndCLFFBTXZDVjtPQUVFLGlCQVBFYSxjQU1FM0IsT0FBQUE7T0FETixXQUFBYzttQkFBQUE7V0FBQUE7OztLQUlBLE9BVElhOztJQTlEUCxPQVBJWjtHQWdGYTtZQUVmZSxlQUFlQyxLQUFNLE9BQU5BLElBQVM7WUFFeEJDLGtCQUFrQkMsTUFBTyxPQUFQQSxLQUFXO1lBQzdCQyxrQkFBa0JDLE1BQU8sT0FBUEEsS0FBVztHQS9GVDtJQUFBOztPQXNFaEJaO09Bc0JKTztPQUVBRTtPQUNBRTtJQXJHSkU7WUEyR0lDLGlCQUFlQyxJQUFLLE9BQUEsOEJBQUxBLElBQThCO1lBRTdDQztJQUFvQixZQUNaO1FBRUg3QjtrQkFBQUEsWUFBQUE7R0FBVztZQUVoQjhCLG9CQUVBOUIsR0FGb0IsT0FFcEJBLElBQUFBLFFBQU87R0FaVTtJQUFBOztPQXhHckIwQjtPQTJHSUM7T0FFQUU7T0FLQUM7SUFsSEpDO0lBQ0FDO0lBRUFDO1lBdUhJQztJQUFvQixZQUNaO1FBRUhsQzttQkFBQUEsWUFBQUE7R0FBVztHQU5FO0lBQUE7O09Bdkh0QitCO09BQ0FDO09BeUhJRTtPQXZISkQ7SUFIQUU7SUFFQUM7SUFDQUM7WUFnSUlDLGlCQUFlVjtJQUNSLElBQUxXLE9BQUssOEJBRFFYO0lBRWQsT0FBQSxrQkFEQ1csK0JBQUFBO0dBQzZCO0dBTGQ7SUFBQTs7T0FoSXJCSjtPQW1JSUc7T0FqSUpGO09BQ0FDO0lBSEFHO0lBQ0FDO0lBQ0FDO0lBQ0FDO0lBcUlvQjs7T0F4SXBCSDtPQUNBQztPQUNBQztPQUNBQztZQTBJRUM7SUFBbUIsWUF2SUc7SUF3SUEsSUFBakJDLGNBQWlCLFFBQUEsOEJBQWpCQTs7Ozs7Ozs7OztHQU80QjtZQWlEL0JDLE9BQVFDLFFBQVNDLEtBQWlCdEQ7SUFDcEMsR0FEbUJzRCxTQUFVQyxNQUFWRCxRQUFBaEMsWUFBVWlDLGNBQVZqQztJQUNNO0tBQUEsU0ExRHpCNEIsaUJBeURVRztLQUVOMUMsa0NBRmVXO0tBR2ZrQyxNQUFKLHNCQUhvQ3hEO0tBSWhDUixNQUFNLDZCQUROZ0U7S0FFU0M7S0FBTUM7SUFDakI7UUFIRUYsT0FFZUU7b0NBRGZsRSxLQUpnQ1EsR0FLdkJ5RCxPQUFNQyxNQUFORDtNQWNiLE9BQUEsNkJBZklqRTs7S0FLa0IsSUFBZEksSUFBYyxnQkFUY0ksR0FLakIwRDtLQUtaLG9CQVJIL0MsWUFPSWYsT0FBQUE7TUFFRixJQU5hK0QsUUFBQUQsYUFBQUEsTUFBQUM7O1NBQU5GLFFBQU1DO09BUU8sOEJBVHRCbEUsS0FKZ0NRLEdBS3ZCeUQsT0FBTUMsTUFBTkQ7TUFTZSxXQUFBLGtDQUxwQjdEO01BS0YsOEJBVkZKO01BVUU7T0FUYW9FLFFBQUFGO09BQU5HLFVBQU1IO09BQU5ELFFBQUFJO09BQU1ILE1BQUFFOzs7R0FlQTtZQUVqQkUsZ0JBQWdCbEU7SUFDRSxJQUFoQjZCLE1BQWdCLDJCQURGN0I7SUFFbEIsUUFESTZCO2lCQUFBQSxNQUFBQSxNQU9DO1lBUERBLFlBQUFBLEtBR0csT0FISEE7SUFJRyxPQUFBO0dBR3dCO1lBSTdCc0MsT0FBTy9EO0lBRVQ7S0FBSXdELDRCQUZLeEQ7S0FHTFIsTUFBTSw2QkFETmdFO0tBRVNDO0tBQU1DO0lBQ2pCO1FBSEVGLE9BRWVFO29DQURmbEUsS0FIS1EsR0FJSXlELE9BQU1DLE1BQU5EOztNQUVILFVBQUEsZ0JBTkR6RCxHQUlVMEQ7T0E0QlIsSUE1QlFFLFFBQUFGLGFBQUFBLE1BQUFFOzs7TUFHZiw4QkFKQXBFLEtBSEtRLEdBSUl5RCxPQUFNQyxNQUFORDtNQUdULElBQ0lJLFVBSldIO1NBRmZGLE9BTUlLO09BQ2UsOEJBTm5CckU7O09BT0ssSUFBTSxJQUlUd0UsV0ExQkpGLGdCQXNCNkIsZ0JBVnRCOUQsR0FRRDZEOztRQUlGLDhCQVRGckU7WUFDU2lFLFFBSUxJLFNBSldILE1BSVhHOzs7T0FESixJQVFNRixRQVBGRTtVQU5KTCxNQWFNRzs7O1NBSUssSUFFQyxJQUNKTSxVQWxDVkgsZ0JBaUM4QixnQkFyQnZCOUQsR0FlQzJEOztVQVdFLDhCQXZCUm5FO1VBd0I0QixXQUFBLGdCQTNCdkJRLEdBZUMyRDtVQVlFLDhCQXhCUm5FO2NBQ2UwRSxXQVdUUDs7O1NBUXNCLFdBQUEsNEJBVDFCSyxpQkFRTUM7U0FDQSw4QkFwQlJ6RTthQUNlMEUsV0FXVFA7O1lBWEdGLFFBQU1TLFVBQUFSLE1BQUFROzs7T0FhWCw4QkFkSjFFO09BZXdCLFdBQUEsZ0JBbEJuQlEsR0FlQzJEO09BR2tCLDhCQWZ4Qm5FOzs7S0ErQkosT0FBQSw2QkEvQklBOztHQWdDZTtZQUluQjJFLFdBQVlkLFFBQVNDLEtBQWlCSDtJQUN4QyxHQUR1QkcsU0FBVUMsTUFBVkQsUUFBQWhDLFlBQVVpQyxjQUFWakM7SUFDSCxPQTFFaEI4QixPQXlFVUMsWUFBUy9CLFlBQWlCNkI7R0FDeUI7WUFFL0RpQixZQUNJZDtJQVFOLEdBUk1BLFNBQU9DLE1BQVBELFFBQUFELFNBQU9FLGNBQVBGO0lBUU47U0FQZWdCLGlCQUFUQyxXQUFTRDs7U0FBVEM7SUFPTixhQU5XQyxpQkFBTEMsT0FBS0QsZ0JBQUxDO0lBTU4sYUFMV0MsaUJBQUwxQyxPQUFLMEMsZ0JBQUwxQztJQUtOO1NBSmdCMkMsaUJBQVZDLFlBQVVEOztTQUFWQztJQUlOO1NBSGtCQyxpQkFBWkMsY0FBWUQ7O1NBQVpDO0lBR047U0FGZUMsaUJBQVRDLFdBQVNEOztTQUFUQztJQUVOLFdBUk0xQixRQUNBaUIsVUFDQUUsTUFDQXpDLE1BQ0E0QyxXQUNBRSxhQUNBRTtHQUU0RDtZQUdoRUMsV0FBVzdCLEdBQUksT0F0RGJZLE9Bc0RTWixHQUFrRDtZQU0zRDhCO0lBQ0k7S0FEY0M7S0FBSEM7S0FBSkM7S0FBRkM7S0FHVHpGLElBRkksNkJBREt5RixLQUFNRjtpQkFHZnZGLElBNVRGRCw4QkF5VGF5RixLQUFPRixLQUdsQnRGOztZQXNCRjBGLG9CQXBCc0JDO0lBQ2hCLFlBQUEsOEJBRGdCQTtnQkFFZDs0QkFDTEo7a0JBQU0sV0FkVEgsV0FjR0c7SUFDd0IsSUFBdEJELGdCQUFzQixXQWYzQkYsV0FlS0U7SUFBUSxXQWZiRixXQWNHRztHQUM0QztZQWlCL0NLLG9CQUFxQm5DLFFBQVEvQjtJQUFZO1NBZkdtRSxlQUFGTjtLQUMxQyxHQUQ0Q00sUUFFT1AsSUFGUE8sY0FFWSxzQkFBTFA7S0FFekM7TUFITjFCLGlDQURzQzJCO01BSXRDM0YsTUFBTSw2QkFITmdFO01BSWtCLE9BckN0QlcsV0ErQ3FCZCxZQUFRL0IsWUFmYTZEO0tBSzFDLDhCQURJM0Y7UUFKd0NpRztVQU9yQ0wsTUFQcUNLO01BUTFDLDhCQUpFakc7TUFLb0IsV0F6Q3hCMkUsV0ErQ3FCZCxZQUFRL0IsWUFSdEI4RDtNQUVMLDhCQUxFNUY7O0tBT2EsT0FBQSw2QkFQYkE7R0FXb0Y7O1lBaUR4RmtHLGdCQXBDa0JDO0lBQ1AsSUFBUEMsT0FBTyx5QkFET0Q7SUFFbEIsT0FBQSw0QkEvQ0FYLFlBOENJWTtHQUNvQjtZQUd0QkMsb0JBQW9CWDtJQUN0QjtLQUFJWSxPQUFPLDJCQURXWjtLQUVUYTtLQUFVQztlQURuQkY7Ozs7Ozs7Ozs7Ozs7Ozt1REFHVUc7OztnQkFLQUM7WUFBTyxPQVBSSDs7NEJBQUFBO2NBQUFBO21DQU9DRzs7OztlQUNGQztXQUFPLFFBUk5KOzswQkFBQUE7WUFBQUE7c0JBUURJOzs7Y0FQR0M7OztjQUFBQTs7d0JBREZMO1VBQUFBO29CQUNFSzs7O1lBQ0RIOztxQkFBQUE7OztNQUM4QjtZQUFoQiwyQkFMTmY7V0FLc0Isa0JBQUEsMkJBTHRCQTtPQUtxQyxrQkFIcENjOzs7S0FTSjtNQUFaSztNQUFIbEQ7TUFBZSxhQUFmQSxHQVRtQjZDO01BQVZEO01BQVVDO2dCQVNoQks7O1lBVE1OO0tBTXlCO1dBQW5CLDJCQU5JQztVQU1lLGtCQUFBLDJCQU5mQTtNQU1rQyxPQUFBLDJCQU5sQ0E7S0FNK0MsT0FOL0NBOztJQUthLElBcFhwQk0sTUFvWG9CLDZCQUFRLGVBTC9CUDtPQS9XR087S0FNSixJQUFUeEcsSUFOYXdHLFFBTWhCQyxJQU5nQkQsUUFNSixZQUFaQyxPQUxVQyxxQkFLUDFHOzs2QkFMTzBHO01BRUs7T0FBVm5HO09BQUhDO09BQWEsWUFBYkEsT0FIWWxCLE9BQ0pvSDtPQUFBQTtlQUVMbkc7Ozs7O0lBZ1h3QixPQUFBLDhDQUpOMkY7R0FVTjtZQW9CakJTLGdCQUFpQnBELFFBQVEvQjtJQUFZLGdCQWxCQTREOzttQkFDUHRGLEdBQUU4RyxLQUFPLDZCQUFQQSxPQUFGOUcsTUFBOEI7S0FBbEQ7TUFBTjRELE1BQU0sd0NBRDJCMEI7TUFFakMxRixNQUFNLDZCQUROZ0U7S0FwWUFuRTtnQkFzWWFHLEtBRWZtSDtRQUZVLDBCQUVWQTtTQURPLE9BQUEsOEJBRFFuSDtRQUVjLFdBcEYvQjJFLFdBaUdpQmQsWUFBUS9CLFlBYnZCcUY7UUFBNkIsT0FBQSw4QkFGZG5IO09BR2hCOztPQUpHQTtPQUZpQzBGO0tBT3BCLE9BQUEsNkJBTGIxRjtHQWdCd0U7WUFvRjVFb0gsaUJBaENtQkM7SUEzQlQsSUFBTkMsTUFBTSw0QkEyQlNEO0lBekJuQixTQUFJRSxjQUFjNUQ7S0FDaEI7TUFBSTZELE1BQUksNkJBRFE3RDswQ0FDWjZEO01BQUk7O1VBQ1J0Rzs7aUJBQ0ssdUJBRkRzRyxLQUNKdEc7UUFDOEIsdUJBRjFCc0csS0FDSnRHO09BQzhCLFdBRDlCQTttQkFBQUE7V0FBQUE7OztLQUdBLE9BQUEsNkJBSklzRztJQUlvQjtPQVB0QkY7O3NCQXdCaUJHLElBQU0sT0FBQSw4QkFBTkEsUUFBdUM7TUFmL0NUO2NBZVgsa0NBeEJFTTs7NkJBU1NOOzs7NEJBTVJVOztRQUhzQztTQUY1QkM7U0FBUEM7U0FFbUMsT0FWdkNMLGNBUUlLO1NBR29CQyxJQURUO1NBQ1NDLE1BQUFEO1NBRnBCRSxRQVRKUixjQWFDRyxJQUZ1Qkk7U0FDbkIsWUFIREMsR0FGS2Y7U0FBQUE7aUJBQ0VXOztRQU1IO1NBREhLO1NBQ0RDLFVBZEpWLGNBYUNHO1NBRUksWUFERE8sS0FQS2pCO1NBQUFBO2lCQU1KZ0I7OztPQUdVLElBQVhFLGlCQUFXLGlCQVRObEIsTUFBQUEscUJBU0xrQjs7Ozs7O0tBV047TUFBU047TUFBSEY7TUFBd0IsT0FBQSw0QkF4SWhDbEMsWUF3SVdvQztLQUFNLFdBeElqQnBDLFdBd0lRa0M7SUFBK0M7SUFDckQsT0FBQTtHQUFnQjtZQU1oQlMsaUJBQWtCdEUsUUFBU0MsS0FBNEIrRDtJQUN6RCxHQUQ2Qi9EO1NBQVlDLE1BQVpELFFBQUFzRSxnQkFBWXJFOztTQUFacUUsZ0JBM0o3QnhEO0lBNEpBO2tCQUE4QnJFO0tBQUwsSUFBVXFILGNBQUZGLGNBQzdCO21CQUN1Qm5ILEdBQUVvRCxHQUFLLFFBQVBwRCwwQkFBRW9ELGdCQUEwQjtjQUZ6QnBELDBCQUFHbUg7Y0FFM0Isd0NBRjZCRTs7OztJQUUrQjtJQUZ4RDtLQUFONUQsTUFBTSx3Q0FEK0M2RDtLQUlyRDdILE1BQU0sNkJBSE5nRTtJQW5kQW5FO2VBdWRhRztPQUFMO1FBQVk0SDtRQUFGRjtRQUNJLE9BcEsxQi9DLFdBOEpvQmQsWUFBU3VFLG1CQUtQVjtPQUNsQiw4QkFEYTFIO3dCQUFPNEg7O2tCQUdsQjtzQ0FIVzVIO2lCQXZkYkg7NEJBMmRtQkcsS0FBSTJEO29CQUVmLFdBektaZ0IsV0E4Sm9CZCxZQUFTdUUsbUJBU0Z6RTtvQkFFZixPQUFBLDhCQUZXM0Q7bUJBRThDOzttQkFOcERBO21CQUFPNEg7O01BUXJCOztNQVRDNUg7TUFKcUQ2SDtJQUt6RCxPQUFBLDZCQURJN0g7R0FVZTtZQUVqQnFJLE9BQU9oQjt5QkFDaUMsT0FNMUNELGlCQVBTQyxJQUNvRDtJQUE1QyxJQUFiaUIsYUFBYTtJQUNqQixlQUZTakIsS0FDTGlCO0dBQ3FCO1lBRXZCQztJQUFLO1NBQXNCQTs7Ozs7Ozs7O01BQUFBO0lBQWUsT0FBZkE7R0FBaUI7WUFJOUNDLG1CQUFrQjNFO0lBQVMsNEIsT0F4QnpCc0UsaUJBd0JnQnRFO0dBQXVDO0dBZWpEO0lBQVI0RSxrQ0FNdUI7SUFJdkJDO0dBQ3NCLFNBQXRCQztJLE9BcGZBeEksWUFtZkF1STs7WUFFQUUsYUFBYUMsSUFBR0M7SUFDbEIsVUFEZUQ7Z0JBQUFBOztnQkFBR0Msa0NBQUFBO1dBRWlCQyxNQUZqQkQsT0FFRkUsTUFGREg7T0FFMkIsT0FBQSw2QkFBMUJHLEtBQW1CRDs7Ozs7aUJBRmpCRCxpQ0FBQUE7WUFHaUJHLFFBSGpCSCxPQUdGSSxRQUhETDtRQUcyQixPQUFBLDZCQUExQkssT0FBbUJEOzs7O3FDQUhqQkgsaUNBQUFBO1dBSUFLLE9BSkFMLE9BSVZNLE9BSk9QO09BSVMsT0FBQSxXQU50QkgsaUJBTU1VLE1BQVVEOzs7SUFDWDtHQUFFO1lBR1BFLFVBQVFoSixLQUFFQztJQUNaLElBY0VnSixNQTVnQkFuSixZQXFmQXlJLGNBUVF2SSxRQUFFQzthQWVWZ0osS0FBSyxPQUFMQTtJQWJZLElBWVZsSixJQXZCRnVJLG9CQVNRdEksUUFBRUM7YUFjUkYsR0FBSyxPQUFMQTtJQVhZO1lBSEpFO1lBQUZEO0tBYUo0QjtPQTFnQko5QjtrQkFnZ0IrQnlGLEtBQUVGLEdBQy9CLE9BRDZCRSxNQUFFRixTQUFBQSxJQUFGRSxZQUNpQjthQVM1QzNELEtBQUssT0FBTEE7SUFQWSxJQU1Wc0gsTUF6Z0JOcEosWUF5VEVzRixTQW9NTXBGLFFBQUVDO2FBWUppSixLQUFLLE9BQUxBO1FBREVDLE1BbGdCSi9JLGtCQXVmSUosUUFBRUM7YUFXRmtKLEtBQUssT0FBTEE7UUF4SEl4SSxJQTZHRlYsTUE3R0FRLElBNkdGVDs7O2NBN0dFUztpQkFBQUE7ZUFBRUU7V0FDQ3lJLFFBRER6SSxNQUNQMEk7OztlQURPMUk7Ozs7OztRQUNDeUk7UUFBUkM7OztpQkFESzVJLE1BU0g2SSxNQVRHN0k7ZUFBRUU7V0FTUTRJLFFBVFI1SSxNQXVIRjZJLE1BdmdCVjFKLDhCQXlaT3dKLEtBQWFDOzs7Ozs7Ozs7T0FSUEgsUUFERHpJO09BQ1AwSTs7O01Bc0hLRztRQWpnQk5wSjs7V0E4WVc7WUFBZ0JxSjtZQUFIcEM7WUFBTHFDO1lBQUZDO1lBR2Y1SixJQUZJLDZCQURXNEosS0FBT3RDO3dCQUd0QnRILElBalpGSywrQkE4WW1Cc0osTUFBUUQsTUFHekIxSjtVQUNIO1VBUEVzSjtVQUFRRDs7aUJBc0hISSxNQW5CVmxCLG9CQVNRdEksUUFBRUMsUUFVQXVKO0dBS0g7WUFFUEksTUFBTTVKLEtBQUVDLEdBQUssYUFqQmIrSSxVQWlCTWhKLEtBQUVDLFdBQXFCO1lBRTdCNEo7SUFBYSxZQUVMO1FBREhuRDtJQUFLLFdBQUxBO0dBQ087WUFFWm9ELFVBQVVDLE9BQU1DO0lBQ2xCO0tBQ08sU0FwWEwzRyxpQkE4V0F3RyxXQUlVRTtZQUFNQztZQUFBQTtZQUFBQTtZQUFBQTtZQUFBQTs7Ozs7T0FXU3JGO3NEQUFBQTs7O09BRVJzRjtzREFBQUE7OztPQUpRQzt1REFBQUE7Ozs7O2dCQVRURixTQUdWM0osOEJBSFUySjs7U0FJVHZKLHlCQUFVLFdBRFhKLEdBQ0NJOzs7SUFFTjtHQVVDO1lBS0YwSixVQUFZMUcsS0FBNEIyRztJQUMxQyxHQURjM0c7U0FBWUMsTUFBWkQsUUFBQXNFLGdCQUFZckU7O1NBQVpxRSxnQkFsUVp4RDtJQW1RRixZQUQwQzZGO2tCQUVqQzlHLGNBRExFLGFBQ0tGLGFBRExFO0lBR00sSUFBTjdELE1BQU07YUFFTjBLLGVBQWlCNUcsS0FBaUJoRDtLQUNwQyxHQURtQmdEO1VBQVVDLE1BQVZELFFBQUFoQyxZQUFVaUM7O1VBQVZqQztLQUN1QixXQXJWeEM4QixPQStVQUMsWUFLaUIvQixZQUFpQmhCO0tBQ2QsT0FBQSw4QkFIcEJkO0lBRzBFO0lBRTlFLGNBVDBDeUs7O1NBV25DM0o7S0FMSDRKLG1CQU5VdEMsbUJBV1B0SDtLQUVKLDhCQVRDZDs7OztnQkFKc0N5SyxlQUFBQTtVQUFBQTs7O2FBa0JyQyw4QkFkRHpLO2tCQUpzQ3lLOztLQXVCbEI7TUFGbEIzRjtNQUVrQixPQTdPdEJrQixvQkF1TkVuQyxRQURVdUUsa0JBcUJSdEQ7S0FDSiw4QkFsQkU5RTtLQW9CRiw4QkFwQkVBOztlQUpzQ3lLOzs7O1VBK0JyQnpGO01BQ2pCLDhCQTVCQWhGO01BNkJBLDhCQTdCQUEsS0EyQmlCZ0Y7TUFHakIsOEJBOUJBaEY7OztVQXdCU3NLO01BdEJUSSxtQkFOVXRDLG1CQTRCRGtDOztjQUVRQyxxQkFBUyw4QkExQjFCdkssS0EwQmlCdUs7OztrQkE5QnFCRTs7U0FzQ3BDcEk7S0FDSiw4QkFuQ0VyQztLQW9Db0IsV0FBQSx1QkFGbEJxQztLQUVKLDhCQXBDRXJDOztlQUpzQ3lLOztTQStDeENFOzZCQUFBQTtTQS9Dd0NGO09BaUQzQiw4QkE3Q1h6SztjQWdETyw2QkFMVDJLLDRCQTlDRTlHO09BdURhLDhCQXBEYjdEO01BdURvQjtjQTNEa0J5SztPQTJEbEIsT0EvTnRCeEQsZ0JBcUtFcEQsUUFEVXVFO01BMERaLDhCQXRERXBJOzs7TUEwQ3dCO2NBOUNjeUs7T0E4Q2QsT0FsTjFCeEQsZ0JBcUtFcEQsUUFEVXVFO01BNkNaLDhCQXpDRXBJOzs7ZUFKc0N5Szs7Ozs7OztvQkErRDFCRzs7Ozs7Ozs7OztRQUFBQTs7Ozs7S0FDWiw4QkE1REE1SztLQTZEc0IsV0F4S3RCbUksaUJBd0dBdEUsWUFEVXVFLGdCQStERXdDO0tBRVosOEJBN0RBNUs7O2tCQUpzQ3lLOztTQXFFbkMvSjtLQUFLLDhCQWpFUlY7S0FFQTBLLG1CQU5VdEMsbUJBcUVQMUg7O0lBRVAsT0FBQSw2QkFuRUlWO0dBbUVlO1lBR2pCNks7SUFBa0IsWUFBaUI7UUFBVy9KO0lBQUssV0FBTEE7R0FBZ0M7WUFDOUUrQyxPQUFPNEcsS0FBTSxPQURiSSxnQkFDT0osUUFBZ0M7WUFDdkNLLFlBQVlMO0ksWUFHTCxjQUhLQSxRQUFBQSxRQUFBQSxRQUFBQSxRQUFBQSxRQUFBQTtRQUVSNUc7SUFBVSxlQUFWQSxTQUZRNEcsUUFBQUEsUUFBQUEsUUFBQUEsUUFBQUEsUUFBQUE7O1lBS1p6RixLQUFLeUY7SUFDUCxXQURPQTtlQUVHOztrQ0FFSTFELGNBQU0sV0FBTkE7UUFEUWdFO0lBQXdCLFdBQXhCQTtHQUN5QjtZQUU3Q0Msa0JBQW9CbEgsS0FBcUIyRztJQUMzQyxHQURzQjNHO1NBQVFDLE1BQVJELFFBQUFtSCxZQUFRbEg7O1NBQVJrSDtJQUNoQixZQVBKakcsS0FNeUN5RjtnQkFFbEMsT0FGYVE7UUFHaEJsRTtJQUFLLE9BQUxBO0dBQU07WUFFVmpDLFNBQVdoQixLQUE0QjJHO0lBQU0sR0FBbEMzRztTQUFZQyxNQUFaRCxRQUFBc0UsZ0JBQVlyRTs7U0FBWnFFLGdCQTlWWHhEO0lBOFY2QyxZQUFONkY7Z0JBQy9CO0lBQ1MsSUFBWjNGLHFCQUFZLFVBRnNCMkY7OztNQUloQzlHO2FBdFRQcUMsd0JBc1RPckMsSUFKSXlFLGtCQUVOdEQ7O2dCQXBUTGtCLHVCQWtUV29DLGtCQUVOdEQ7SUFBWTtHQUV3RjtZQUN6R29HLGNBQWNULEtBQUkzRjtJQUNwQixHQURvQkE7U0FFWGEsSUFGV2IsYUFDaEJxRyxpQkF6VEZyRixvQkEwVE9IOztTQURMd0Y7V0FqQkZuRyxLQWdCY3lGO2tCQUFBQSxRQUNaVSxZQURZVixRQUFBQSxRQUFBQSxRQUFBQSxRQUFBQTs7Y0FBQUE7Y0FDWlU7O2NBRFlWO2NBQUFBO2NBQUFBO2NBQUFBO0dBTzBCO1lBRXhDVyxLQUFLWDtJQUFNLFdBQU5BO2VBQ0c7UUFDRlc7SUFBWSxXQUFaQTtHQUFxQjtZQUUzQkMsU0FBU1o7SUFBTSxXQUFOQTs7O21CQUVLYSxpQkFBUyxXQUFUQTs7SUFEVztHQUNPO1lBQ2hDQyxjQUFjZCxLQUFJWTthQUNoQkcsT0FBTzFHO0tBQVcsT0FqQ3BCRSxLQWdDY3lGO21CQUFBQSxRQUNMM0YsVUFESzJGLFFBQUFBLFFBQUFBLFFBQUFBLFFBQUFBOztlQUFBQTtlQUNMM0Y7O2VBREsyRjtlQUFBQTtlQUFBQTtlQUFBQTtJQUc0QjtJQUU1QyxXQUxnQkE7c0JBQUlZLFdBQ2hCRyx1QkFEZ0JILGNBQUpaO1FBUVJXO0lBQXFCLE9BUHpCSSxlQU9JSixNQVJZQztHQVFnQztZQUVsRGhKLEtBQUtvSSxLQUFNLE9BQU5BLE9BQWM7WUFDbkJnQixVQUFVaEIsS0FBSXBJO0lBQ2hCLE9BNUNFMkMsS0EyQ1V5RjtrQkFBQUEsUUFBQUEsUUFBQUEsUUFBSXBJLE1BQUpvSSxRQUFBQSxRQUFBQTtjQUFJcEk7O2dCQUFKb0k7Z0JBQUFBOztnQkFBSXBJO2dCQUFKb0k7Z0JBQUFBO2dCQUFBQTtvQkFBQUEsUUFBQUEsY0FBQUEsUUFBQUEsUUFBQUE7R0FPVDtZQUdEbEksS0FBT3VCLEtBQTRCMkc7SUFBTSxHQUFsQzNHO1NBQVlDLE1BQVpELFFBQUFzRSxnQkFBWXJFOztTQUFacUUsZ0JBeFlQeEQ7SUF3WXlDLFlBQU42Rjs7S0FFekI7TUFBTDlHO01BQUssT0FGeUI4RzthQTFTbkN4RCxvQkE0U0t0RCxJQUZFeUU7O2dCQUE0QnFDLGVBMVNuQ3hELG1CQTBTT21CO0lBRUc7R0FBb0Y7WUFDOUZzRCxVQUFVakIsS0FBSWxJO0lBQ0wsSUFBUG9KLFNBL1NGekYsZ0JBOFNjM0Q7T0F4RGR5QyxLQXdEVXlGLFFBQ1JrQiwrQkFBQUE7S0FHWTthQUpKbEI7YUFBQUE7YUFBQUE7YUFBQUE7eUJBQ1JrQjthQURRbEI7YUFBQUE7SUFHK0IsV0FIL0JBLFFBQUFBLFFBQUFBLFFBQUFBLFFBQ1JrQixRQURRbEIsUUFBQUE7R0FJK0I7WUFFekNsRixTQUFTa0YsS0FBTSxPQXJFZkksZ0JBcUVTSixRQUFrQztZQUMzQ21CLGNBQWNuQjtJLFlBRVAsV0FGT0EsUUFBQUEsUUFBQUEsUUFBQUEsUUFBQUEsUUFBQUE7UUFHVm9CO0lBQVEsV0FIRXBCLFFBQUFBLFFBQUFBLFFBQUFBLFFBQUFBLFFBQUFBLFlBR1ZvQjs7WUFFSkMsTUFBTXJCLEtBQU0sT0F4T1ZsQyxHQXdPSWtDLFFBQXdCO1lBQzlCc0IsZUFBaUJqSSxLQUE0QjJHO0lBQU0sR0FBbEMzRztTQUFZQyxNQUFaRCxRQUFBc0UsZ0JBQVlyRTs7U0FBWnFFLGdCQXhaakJ4RDtJQXdabUQsWUFBTjZGOztTQUcxQ2xDO1lBQUFBO21CQWhRREosaUJBa0xGdEUsT0EyRTZDNEcsVUFBNUJyQyxnQkFHZEc7OztRQUZFbEI7SUFBUyxPQUFUQTtHQUdSO1lBQ0cyRSxnQkFBaUJ2QixLQUFJL0M7SUFBZ0IsSUF6UzlCa0QsSUEyRExyQyxHQThPZWtDO0lBelNKLElBQUksZUFBSyw0QkF5U0QvQyxHQXpTZGtELEtBQVU7Ozs0QkFBd0M7OztHQXlTSDtZQUN0RHFCLGtCQUFnQnhCLEtBQUkvQztJQUNoQixZQUZKc0UsZ0JBQ2dCdkIsS0FBSS9DO2dCQUViO1FBQ0hFO0lBQUssV0FBSyxxQ0FBVkE7R0FBK0I7WUFFbkNzRSxXQUFXekIsS0FBSXFCO0lBQVEsV0FBWnJCLFFBQUFBLFFBQUFBLFFBQUFBLFFBQUFBLFlBQUlxQixRQUFKckI7R0FBNkM7WUFDeEQwQixJQUFJdkI7O0tBQWEsSUFBUWhELGNBQUZGO0tBQVEsV0FBUkEsT0FBRUU7SUFBWTtJQUE3QixPQUFBLGtDQUFKZ0Q7R0FBbUM7WUFDdkN3QixhQUFZM0IsS0FBSXFCLE9BQVEsT0FGeEJJLFdBRVl6QixLQURaMEIsSUFDZ0JMLFFBQWtDO1lBQ2xETyxnQkFBZ0I1QixLQUFJL0U7SUFBSSxXQUFSK0UsUUFBZ0MsZUFBNUIvRSxHQXZQbEI2QyxHQXVQY2tDO0lBQWUsV0FBZkEsUUFBQUEsUUFBQUEsUUFBQUEsUUFBQUE7R0FBeUQ7WUFDekU2QixrQkFBaUI3QjtJQUNLO0tBREU3QztLQUFGRjtZQUFMK0M7S0FDSyxtQkFEQS9DLE9BQUVFLFFBeFB0QlcsR0F3UGVrQztJQUNaLFdBRFlBLFFBQUFBLFFBQUFBLFFBQUFBLFFBQUFBOztZQUVqQjhCLGlCQUFpQjlCLEtBQUl0RTtJQUFLO1lBQVRzRTtLQUF3QyxPQTFQdkRsQyxHQTBQZWtDO0tBQWlDLFdBQUcsdUJBQWhDdEU7SUFBWSxXQUFoQnNFLFFBQUFBLFFBQUFBLFFBQUFBLFFBQUFBO0dBQTBEO1lBQzNFK0IsbUJBQWtCL0IsS0FBSXRFO0lBQ3hCO1lBRG9Cc0U7S0FDaUIsT0E1UGpDbEMsR0EyUGdCa0M7S0FDUSxPQVAxQjBCLElBTXNCaEc7S0FDQSxXQUFHO0lBQXBCLFdBRGFzRSxRQUFBQSxRQUFBQSxRQUFBQSxRQUFBQTtHQUNtQztZQUNyRGdDLG1CQUFtQmhDLEtBQUkvQztJQUFJLFdBQVIrQyxRQUNrQyxPQTlQbkRsQyxHQTZQaUJrQzs7S0FDWSxJQUFNVDtLQUFTLE9BQUEscUJBRHZCdEMsR0FDY3NDO0lBQWU7SUFBckMsZUFBRztJQUFwQixXQURxQlMsUUFBQUEsUUFBQUEsUUFBQUEsUUFBQUE7R0FFdEI7WUFHR2lDLGVBQWVqQztJQUNqQixJQUtDL0UsSUEvQ0NuRCxRQXlDZWtJLE1BR1prQyxRQTdCSGIsTUEwQmVyQjs0QkFNaEIvRTtVQUhJaUgsT0FHSyxPQUFUakg7S0FFYztNQUFUN0IsU0FoTkpxRyxXQXdNZU87TUFTVSxPQXZRekJqQyxtQkFzUUkzRSxXQUxEOEk7S0FNc0IsT0FBQSxrQ0FIMUJqSDs7U0FISWlILE9BRE07SUFFSTtLQUFUQyxXQTVNSjFDLFdBd01lTztLQUtPLE9BblF0QmpDLG1CQWtRSW9FLGFBREREO0lBRW1CLE9BQUE7R0FJK0I7WUFLckRFLFFBQVF6QyxPQUFNMEMsTUFBS3JDO0lBQ3FCLGNBbkh4QzVHLE9Ba0hjaUo7O1NBR0xGLHVCQUFBRyxXQUFBSDs7U0FBQUcsV0FIRDNDO0lBQ0U7S0FBUjRDLGNBRU9EO0tBR0csVUF4SFpsSixPQWtIbUI0RztLQU1LLFVBdkd4QjNGLFlBaUdtQjJGOzs7S0FNbUIsY0FsSHRDekYsS0E0R21CeUY7O01BUUY7Y0FSRUE7Y0FBQUE7T0FRRixPQXpZZnBFLG9CQWlZaUJvRTtrQkFBQUEsUUFBQUEsUUFBQUEsUUFBQUE7O01BTW1CO09BTzFCO1FBQU5KLFdBYlF5QyxTQUFBQSxTQUFBQSxTQUFBQSxTQUFLckMsUUFBQUEsUUFBQUE7UUFlYndDLFdBdEVOMUssUUFvRU04SDtPQUdELEdBQUEsa0JBREM0Qzs7Z0JBRkE1QztnQkFBQUEsYUFBQUEsVUFiUXlDO29CQWFSekMsU0FBQUEsU0FBQUEsU0FBQUEsU0FiUXlDO3NCQXVCSixnQkFSSkc7UUFTZ0I7Z0JBWGhCNUM7Z0JBQUFBO1NBV2dCLE9BelpwQmhFLG9CQThZSWdFO29CQUFBQSxTQUFBQSxTQUFBQSxTQUFBQTs7UUFyWE87U0FETzZDLFVBc1hkN0M7U0F0WFE4QyxRQXlXQUw7U0F6V05NLFFBeVdNTjtnQkFhUnpDO2dCQUFBQTtTQXJYTyxRQUFBLDJCQURDOEM7OztTQUNELEdBRExDLHdDQUFZRjs7Ozs7OztlQUdURzs7O2VBQUFBO3FCQUE0Qix1Q0FBNUJBLFNBSFNIOzs7b0JBQUFBOztRQW1ZWDtTQUFBLE9BM1pQN0c7b0JBOFlJZ0UsU0FBQUEsU0FBQUEsU0FBQUE7Ozs7O01BRitCO2NBWGxCSTtjQUFBQTtPQVdrQixPQTVZbkNwRSxvQkFpWWlCb0U7a0JBQUxxQyxTQUFLckMsUUFBQUEsUUFBQUE7OztJQVFqQixPQTFORk4sVUFtTkU2QztHQTJCRDtZQUVETSxhQUFhN0M7SUFDZjtLQUFJOEMsUUEvQkZWLGdCQTdQQXBFLE9BMlJhZ0M7S0FHUixTQXJtQkwvRyxpQkE4V0F3RyxXQXFQRXFEO1lBQUFBO1lBQUFBO0tBS0csNEJBTEhBO0tBSUcsNEJBSkhBO0lBR0osV0FISUEsVUFBQUEsVUFBQUE7R0FNSDtZQUVDQyxHQUFHQyxLQUFJaEQ7SUFBaUMsV0FwT3hDRCxhQW9PT0M7SUFBaUMsT0FBQSw4QkFBckNnRDtHQUFvRDtZQUN2REMsT0FBT0QsS0FBSWhEO0lBQWlDLFdBck81Q0QsYUFxT1dDO0lBQWlDLE9BQUEsOEJBQXJDZ0Q7R0FBb0Q7R0FLeEMsSUFBakJFLGlCQUFpQjtZQUVqQkMsb0JBQW9CQztJQUNMLFdBQUEsNEJBSGZGLGdCQUVvQkU7SUFDTCxPQUFBO0dBQStCO0dBTzVDLElBQUEsTUFBQSw2QkFEQyxNQUFBO2dCQURjek47SUFBSyxrQkFBTEE7O3VCQUFBQTs7d0JBQUFBLGdDQUFBQTs7Ozs7OztHQUFpRDtHQUFqRTtJQUFBLE1BQUE7SUFBRCxNQUFBO2dCQURLdUQsR0FBSyxXQTdoQlZZLE9BNmhCS1osSUFBMkM7R0FEbEQ7SUFBQSxNQUFBO0lBREVpSixXQUNGO1lBTUVrQixnQkFBVyxvQ0FBd0M7O0lBRzdDOzs7Ozs7O0tBRUY7O0lBRUE7R0FBTTtHQUpaO0lBREVDLFlBQ0Y7SUFNeUMsTUFBQSx5QkFQdkNBO0lBT0FDLGNBQWMseUJBbkJkSjtJQXFCQUssUUFBUTtJQUVSQyxPQUFPO0lBRVBDLFVBQVU7Z0JBR21EQztJQUMvRCxjQUFHLG1CQUQ0REE7Y0FJN0Q7Y0FGQSx5QkFGNkRBO0dBSXhDO3VCQUpYLG9DQUEwQztHQUF0RDtJQUFBLE1BQUE7SUFERUMsWUFDRjtJQVNXLE1BQUEseUJBVlRBLFdBTkFKO0lBZ0JBLE1BQUE7Z0JBREtLLE9BQU1DO0lBQU87S0FBMEIsT0FBQSwrQkFBakNBO0tBQU8sT0FBQSxxQ0FBYkQ7SUFBdUMsT0FBQTtHQUFTO0dBRHZELElBREVFLGVBQ0YsbUNBUkVIO2dCQWVPM047SUFDTDtLQUM0RCxPQUFBO0tBQWpCLE9BQUEseUJBbkI3Q3lOLFNBaUJPek47S0FFcUMsT0FBQTtrQkFBM0JJLEdBQUVFLEdBQUssV0FBUEYsR0FBRUUsR0FBVztJQUF4QjtLQUFBLE9BQUEsK0JBekJOZ047S0F3QkUsT0FBQSw2QkFURlE7SUFVTSxPQUFBO0dBQWtFO0dBRjFFLElBREVDLHFCQUNGO1lBSUVDLGFBQWFDO0lBT1gsV0FBQTtrQkFOd0J6TztLQUM1QjtNQUFJME8scUJBRldELGFBRWlCLDJCQURKek87S0FFNUIsV0FESTBPO2VBSUsscUNBTG1CMU87ZUFHMUI7SUFFbUI7SUFMckIsV0FBQSx5QkFORXVPO0lBWUUsT0FBQTtHQUFXO1lBRVRJLEtBT0o5RztJQVBXLFNBT1hBO0tBRDBCO01BQUEsT0FJMUIrRztNQUpBLE9BQUEsNkJBM0JBTjtLQTJCMEIsT0FBQTs7YUFDMUJ6RyxHQUNBLE9BRUErRyxTQUhBL0c7a0JBSlVqSCxHQUFLLFdBQUxBLE1BQVU7SUF2Q04sT0FBQSwrQkFBZGtOO0dBNENVO1lBRVZjLFNBQVMvRztJQUNYO0tBR21ELE9BZDdDOEcsS0FVSzlHO0tBSWUsT0F2QnhCMkcsYUFtQlMzRztLQUlJLE9BQUEseUJBNUNib0c7S0E0Q1ksT0FBQTtLQUFaLE9BQUEseUJBNUNBQTtrQkEwQ0tyTixHQUFFRSxHQUFLLFdBQVBGLEdBQUVFLEdBQVc7SUFFbEIsT0FBQSwrQkFsREFnTjtHQWtEK0Q7WUFFM0RlLFdBQVdyTyxHQUFFRztJQUNuQixLQURtQkEsSUFHakI7UUFDS0UsS0FKWUYsT0FJakJHLElBSmlCSDtJQUtkLEtBQUEsV0FMWUgsR0FJZk0sSUFLRSxjQVRlSDtJQU1GLElBQUEsUUFOWGtPLFdBQVdyTyxHQUlWSyxLQUVLaU8sZUFBSkM7SUFDSixlQUhGak8sR0FFTWlPLEtBQUlEO0dBR0Y7WUFHTkUsWUFBWUM7SUFDZDtLQUNFO09BZEVKO2tCQWNjSyxTQUFXLE9BQUEscUJBQVhBLGlCQUF3QjtTQUY1QkQ7S0FDV1Y7S0FBckJZO0tBR0FDLFNBQVMscUNBSFREOzs7O09BQXFCWjtpQ0FBQUE7TUFPTDtPQURWNU4sS0FOZTROO09BT0wsT0FBQSxxQ0FEVjVOO09BQ0csT0FBQTtPQUhUME8sTUFHQSx1QkFKQUQ7OztTQUNBQyxNQURBRDs7SUFRSixPQVBJQztHQU9EO0dBRXNEO0lBQUEsTUExQ3JEVjtJQTBDa0MsTUFuRHRDSDtJQW1EZ0IsTUFBQSx5QkF4RWhCUCxTQUFBQTtJQXdFZ0IsTUFBQTtJQUFELE1BQUE7SUFmZnFCLE9BZUYseUJBZElOO0lBaUJrQixNQUFBO0lBQXRCLE1BQUE7SUFBQSxNQUFBLDhCQWxCRU07SUFpQkFDLGVBQ0Y7SUFNRSxNQUFBLDRCQTlGQTFCO0lBNkZBLE1BQUE7Z0JBREsyQixLQUFJQyxRQUFVLE9BeEduQi9CLHdCQXdHSzhCLEtBQUlDLFNBQTZDO0dBRHhELElBREVDLGNBQ0Y7O0lBTVE7Ozs7TUFBQTs7Ozs7O0tBRUY7O0lBRUE7R0FBTTtHQUpaLElBREVDLGVBQ0Y7O0lBUVE7Ozs7Ozs7Ozs7Ozs7S0FFRjs7SUFFQTtHQUFNO0dBSlo7SUFGRUMsYUFFRjs7O09BZkVGO1dBNEJRLHlCQXBJUmpDLGdCQThHQWtDO0lBb0JNLFVBQUUseUJBbElSbEMsZ0JBcUhBbUM7SUFZRyxNQUFBO0lBREgsTUFBQTtJQURBLE1BQUE7SUFGQUMsV0FDRjtJQUFBO2dCQWFzQnBNLEdBQUssc0JBanFCekJZLE9BaXFCb0JaLElBQTRDO2lCQUE5RCx5QkFkRm9NO2dCQWF3QmhKLEdBQUssc0JBQUxBLEdBQW9CO2lCQUExQyx5QkFyQ0YwSTtnQkFvQ3dCMUksR0FBSyx1QkFBTEEsR0FBb0I7R0FBNUM7SUFBQSxVQUFFLHlCQXJHRnlIO0lBbUdBbEUsU0FDRjtJQTZCSSxPQUFBO2VBSE0seUJBbEtScUQsZ0JBMkJBUTs7O09BNkVBeUI7V0F5RFEseUJBaktSakMsZ0JBOEdBa0M7SUFpRE0sV0FBRSx5QkEvSlJsQyxnQkFxSEFtQztJQXlDRyxPQUFBO0lBREYsT0FBQTtJQUFELE9BQUEsK0JBcElBNUI7aUJBaUlLcE47SUFDSyxJQUFKNkMsSUFBSSxxQ0FETDdDO0lBRUgsV0E3bEJKZ0Ysb0JBNGxCUW5DO0dBQ2lDO0dBSHpDO0lBQUEsT0FBQTtJQURFd0gsYUFDRjs7SUFlYztLQUVEOztpQkFBNEI5STtTQUN6QixJQUFWMk4sVUFqc0JKekwsT0Fnc0J1Q2xDO1NBRXZDLElBQUssZUFBSyxtQkFETjJOLFdBQ0M7cUJBQTREO1FBQUs7TUFGM0QsT0FBQSx5QkE5SlhsQztNQThKQSxPQUFBLHlCQS9JQUs7S0ErSW1DLE9BQUE7O0lBSW5DLE9BQUE7R0FBVztHQU5iO0lBREU4QixTQUNGO0lBZ0JJLE9BQUE7aUJBTE1uTCxVQUFTRSxNQUFLM0MsTUFDakIsV0FER3lDLGNBQVNFLE9BQUszQyxNQUNRO0dBRjdCO0lBQUEsT0FBQSwrQkExQkQ4SSxZQWpCQWIsUUFnQ0EyRjtJQVVGLE9BQUE7SUFBQSxPQUFBO0lBREVDLFlBQ0Y7d0JBWWMsaUNBQW9DLFVBQWIsU0FBa0I7R0FBckQ7SUFBQSxPQUFBO0lBSEF2RSxTQUNGLHlCQTFrQkF6RjtJQWtsQlcsY0FBa0I7SUFBekIsT0FBQTt3QkFEcUIsNEJBQW1DO0dBQTdDO0lBQUEsT0FBQTtJQUFaLE9BQUE7SUFBRCxPQUFBO0lBRkYsT0FBQSx5QkFqZ0JFbUM7SUFnZ0JBOEgsVUFDRjtJQVNJLE9BQUE7d0JBRGdDLFNBQUk7R0FBekI7SUFBQSxPQUFBO0lBQVosT0FBQTtJQUFELE9BQUE7aUJBREt4TSxHQUFLLFdBN3RCVlksT0E2dEJLWixJQUEyQztHQURsRDtJQUFBLE9BQUE7SUFERXlNLGFBQ0Y7aUJBT092TSxlQUE4QnRCLE1BQUt1SixPQUFNdkc7SUFBOUMsSUFBNkJsRCxpQkFBTjJDLGlCQUFWRjtJQUNNLE9BN2NyQnFGO2FBNGNPdEcsWUFBQUEsUUFBUWlCLFVBQVVFLE1BQU0zQyxNQUFNRSxNQUFLdUosT0FBTXZHO0dBQzZCO0dBRjdFO0lBQUE7TUFBQSwrQkF2TUVxSCxVQTJLQXNELFdBVUF2RSxRQUtBd0U7SUFZQUUsZ0JBQ0YsK0JBUEVEO2lCQW9Cd0R6TTtJQUNsRCxZQUFBLDRCQWZOME0sZUFjd0QxTTt1QkFuZ0JsRCxPQUFSOEU7UUFxZ0JPbkk7SUFBSyxPQUFMQTtHQUdFO3dCQUxFLDRCQUFzQztHQUFqRDtJQUFBLE9BQUE7SUFERWdRLGtCQUNGO1lBUUFDLFlBQVl2TDtJQUNSLFlBQUEsNEJBM0ZGc0YsUUEwRlV0RjsyQkFFVHdMLG1CQUFVLE9BQVZBO0lBRUcsY0FBQSw0QkFqSkpoQixNQTZJVXhLO3lCQU1DLHNCQU5EQTtRQUtQeUw7SUFBVSxzQkFBVkE7R0FDdUM7WUFNNUNDLEtBQU03TSxRQUFRaUIsVUFBVUUsTUFBTTNDLE1BQU1FLE1BQU11SixPQUFPdkc7YUFDL0NoQjtLQUFTLFlBQ21DO1NBQXhDekQ7S0FBSyxXQUFMQTtJQUE0Qzs7OztVQUYxQmtFLFdBQU0zQyxVQUFoQnlDLHVCQUdad0Y7U0FBQUEsU0FIc0J0Rjs7SUFPMUIsR0FQZ0JGO1NBUVFhLElBUlJiLGFBT1pxRyxpQkFyckJGckYsb0JBc3JCc0JIOztTQURwQndGO0lBRUosR0FUc0M1STtLQVd2QixJQURNbUQsSUFWaUJuRCxTQVc5Qm9KLFNBdm9CTnpGLGdCQXNvQm1CUjs7O1NBUGpCNEUsVUFRSXFCLCtCQUFBQSwyQ0FBQUE7aUJBQUFBOztTQUZKZ0Y7OztTQUFBQTtJQU9KLEdBaEI0QzdFLFdBa0JuQ2xHLE1BbEJtQ2tHLFVBZ0J4Q3FFLGNBRUt2SyxlQUZMdUs7SUFJUyxJQUFUdkQsV0FuQkFySSxPQURJVixTQTJCd0IsT0ExQjVCVSxPQUQrQ2dCO09BRy9DK0U7U0FzQlNDLFNBdEJURCxzQkFmRmlHLFlBcUNXaEc7OztJQUhYLE9BbGdCQUo7YUFnZ0JFeUM7aUJBQUFBLFVBYkF6QixrQkFQNEI5SSxNQVM1QnNPLFFBT0FSO0dBVzZDO1lBRS9DUyxVQUFVdkcsTUFBSXJGO0lBQ2hCLFdBRFlxRixnQkFBQUEsZ0JBQUFBLGdCQUFBQTtPQUFJckY7U0FHQ3NGLFNBSER0RixvQkF6Q2R1TCxZQTRDZWpHOzs7SUFGakIsV0FEWUQsU0FBQUE7R0FLWDtZQUVDd0csU0FBVWhOLFFBQVFpQixVQUFVRSxNQUFNM0MsTUFBTUUsTUFBTXVKLE9BQU92RyxVQUFTa0Y7YUFDNURxRyxjQUFjbkwsR0FBRW9MO0tBQ2xCLEtBRGtCQSxHQUVSLE9BclhWckYsVUFtWGdCL0Y7U0FHVEQsSUFIV3FMO0tBR04sT0F0WFpyRixVQW1YZ0IvRixHQUdURDtJQUFrQjtJQUUzQixTQUFJc0wsZUFBZXJMLEdBQUVvTDtLQUNuQixLQURtQkEsR0FFVCxPQWxXVjdFLFdBZ1dpQnZHO1NBR1ZpRixJQUhZbUc7S0FHUCxPQW5XWjdFLFdBZ1dpQnZHLEdBR1ZpRjtJQUFtQjtJQUU1QixTQUFJcUcsT0FBTXZRLEdBQUVxUSxHQUFFcEw7S0FDWixLQURVb0wsR0FFQSxPQUZFcEw7U0FHTDdFLElBSEdpUTtLQUdFLE9BQUEsV0FISnJRLEdBQUlpRixHQUdMN0U7SUFBVTtXQUhmbVE7YUF0WEZyRjthQTJXcURyRzthQVduRDBMO2VBTEFEO2VBTjRDbEY7ZUFXNUNtRjtpQkFWQUg7aUJBRHNDdk87aUJBV3RDME87bUJBMVlGeEY7bUJBK1hrQ3BKO21CQVdoQzRPO3FCQWxCRkw7cUJBTzRCNUw7cUJBVzFCaU07dUJBcmFGL0YsZUEwWmtCcEcsVUFXaEJtTSxPQTFiRm5HLGFBK2FVakgsUUFBb0Q0RztHQXNCakM7WUFFN0J5RyxVQUFVdk47SUFHTixZQUFBLDRCQXBGRjJNLGlCQWlGUTNNOzhCQW5sQlY4RTtRQXVsQkduSTtJQUFLLE9BQUxBO0dBR0U7T0FnQkg2UTtZQUVBQztJQUNGO0tBRHNEN0w7S0FBUHVHO0tBQU52SjtLQUFORjtLQUFOMkM7S0FBVkY7S0FBUmpCO0tBQ1ArSSx3QkFETy9JO0lBTVY7Z0JBTEcrSTtZQURlOUg7Z0JBQVVFO1lBQU0zQztZQUFNRTtZQUFNdUo7WUFBT3ZHOztZQWVwRDhMOztLQUFxRDlMO0tBQVB1RztLQUFOdko7S0FBTkY7S0FBTjJDO0tBQVZGO0tBQVJqQjtrQkFDUEE7bUJBY0FtQjtNQUNMLGVBZktuQixRQURlaUIsVUFlZkUsTUFmK0IzQyxNQUFNRSxNQUFNdUosT0FBT3ZHO0tBZ0JHO0tBQTFELE9BQUEsV0FqQ0U0TCxPQWdDVSxvQ0Fma0JuTTtJQWdCNEI7T0FoQjlDbkI7O01BUUx5TixxQkFSS3pOOzs2QkFRTHlOOzthQUFBQTs7OztjQUdLLG1DQUhMQTs7Ozs7O0lBT1AsT0FBQSxXQWhDRUg7O1lBb0NBSSxZQUFVNU47SUFBVSxZQW5CcEIwTixPQXhDRkgsVUEyRFl2TjsyQkFDUHJELGNBQUssT0FBTEE7UUFDU2tSO0lBQVUsT0FBQSxzQkFBVkE7R0FBd0I7WUFFcENDLFlBQVc3TSxhQUFZdEU7SUFBSSxPQWxsQjdCa0ssVUFrbEJhNUYsYUF0Q1h3TSxPQXNDdUI5UTtHQUFzQztZQWE3RG9SO0lBQU03TixRQUFROE4sUUFBTTdNLFVBQVV6QyxNQUFNRSxNQUFNdUosT0FBT3ZHO0lBQ25ELEdBRHNCVDtTQUlFYSxJQUpGYixhQUdsQnFHLGlCQXp6QkpyRixvQkEwekJ3Qkg7O1NBRHBCd0Y7SUFFSixHQUxzQzVJO0tBT3ZCLElBRE1tRCxJQU5pQm5ELFNBTzlCb0osU0Ezd0JSekYsZ0JBMHdCcUJSOzs7U0FDYmlHLCtCQUFBQSwyQ0FBQUE7aUJBQUFBOztTQUZKZ0Y7OztTQUFBQTtJQU9KLEdBWjRDN0UsV0FjbkNsRyxNQWRtQ2tHLFVBWXhDcUUsY0FFS3ZLLGVBRkx1SztPQVorQzVLLGNBRTNDekUsSUFGMkN5RSx3QkFFM0N6RTtJQWlCRSxJQUFBLFFBdktWeVAsWUFvSmdCb0I7OztNQU5JM007NEJBQ0EsOEJBREFBOzs7TUFFUnNGOzRCQUNrQiw4QkFEbEJBOzs7TUFKUUM7NkJBQ0EsOEJBREFBO0lBRnBCLFdBVVExRyxRQUdKc0gsa0JBSDRCOUksTUFLNUJzTyxRQU9BUjtHQU9xRTtZQUV2RTVGLE9BQUtqSztJQUNQLFlBRE9BO2tDQUdFeUcsY0FBTSxPQUFOQTtRQURRZ0U7SUFBd0IsT0FBeEJBO0dBQ29CO1lBRW5DZ0MsU0FBT3pNLEdBQUksT0FBSkEsS0FBWTs7OztPQXpyQnJCbUk7T0FvQkFZO09BaUJBWTtPQTFPQXRGO09BR0FDO09BWUFZO09BeXdCQTBMO09BbmhCQTFHO09BNkxBcUM7T0E4QkFTO09BNFBBb0Q7T0FvQ0FHO09BdFdBL0U7T0FDQUM7T0FyT0F2RDtPQURBcEI7T0FpUEE4RTtPQUVBRTtPQVJBSjtPQUNBQztPQVFBSTtPQUNBQztPQUVBQztPQUNBQztPQUVBQztPQXBDQWxLO09BeUNBbUs7T0F0Q0FoQjtPQTlEQTdIO09BQ0FpSDtPQWdCQWhHO09BS0FvRztPQVNBRTtPQUlBQztPQUdBRTtPQWhDQXZHO09BbWFBNEw7T0E3WkE1RjtPQW9DQTNJO09BQ0FvSjtPQW1CQWxHO09BQ0FxRztPQW9GQTRCO09BQ0FFO1dBeUZFOEIsTUFvSUFjO1dBeUhBZSxRQWZBRCxRQWtDQUcsYUFJQUUsYUFhQUMsUUFxQkFuSCxRQUtBd0M7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCpcbiAqIENvcHlyaWdodCAoYykgMjAxMi0yMDE0IEFuaWwgTWFkaGF2YXBlZGR5IDxhbmlsQHJlY29pbC5vcmc+XG4gKiBDb3B5cmlnaHQgKGMpIDIwMTItMjAxNCBEYXZpZCBTaGVldHMgPHNoZWV0c0BhbHVtLm1pdC5lZHU+XG4gKlxuICogUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XG4gKiBwdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQsIHByb3ZpZGVkIHRoYXQgdGhlIGFib3ZlXG4gKiBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIGFwcGVhciBpbiBhbGwgY29waWVzLlxuICpcbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTXG4gKiBXSVRIIFJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GXG4gKiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUlxuICogQU5ZIFNQRUNJQUwsIERJUkVDVCwgSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFU1xuICogV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTSBMT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOXG4gKiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1IgT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRlxuICogT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1IgUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cbiAqXG4gKilcblxuW0BAQG9jYW1sLndhcm5pbmcgXCItMzJcIl1cblxudHlwZSBjb21wb25lbnQgPSBbXG4gIHwgYFNjaGVtZVxuICB8IGBBdXRob3JpdHlcbiAgfCBgVXNlcmluZm8gKCogc3ViY29tcG9uZW50IG9mIGF1dGhvcml0eSBpbiBzb21lIHNjaGVtZXMgKilcbiAgfCBgSG9zdCAoKiBzdWJjb21wb25lbnQgb2YgYXV0aG9yaXR5IGluIHNvbWUgc2NoZW1lcyAqKVxuICB8IGBQYXRoXG4gIHwgYFF1ZXJ5XG4gIHwgYFF1ZXJ5X2tleVxuICB8IGBRdWVyeV92YWx1ZVxuICB8IGBGcmFnbWVudFxuICB8IGBHZW5lcmljXG4gIHwgYEN1c3RvbSBvZiAoY29tcG9uZW50ICogc3RyaW5nICogc3RyaW5nKSAoKiAoY29tcG9uZW50ICogc2FmZSBjaGFycyAqIHVuc2FmZSBjaGFycykgKilcbl1cblxudHlwZSBwY3RfZW5jb2RlciA9IHtcbiAgICBzY2hlbWU6IGNvbXBvbmVudDtcbiAgICB1c2VyaW5mbzogY29tcG9uZW50O1xuICAgIGhvc3Q6IGNvbXBvbmVudDtcbiAgICBwYXRoOiBjb21wb25lbnQ7XG4gICAgcXVlcnlfa2V5OiBjb21wb25lbnQ7XG4gICAgcXVlcnlfdmFsdWU6IGNvbXBvbmVudDtcbiAgICBmcmFnbWVudDogY29tcG9uZW50O1xuICB9XG5cbmxldCByZWMgaXRlcl9jb25jYXQgZm4gc2VwIGJ1ZiA9IGZ1bmN0aW9uXG4gIHwgbGFzdDo6W10gLT4gZm4gYnVmIGxhc3RcbiAgfCBlbDo6cmVzdCAtPlxuICAgIGZuIGJ1ZiBlbDtcbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWYgc2VwO1xuICAgIGl0ZXJfY29uY2F0IGZuIHNlcCBidWYgcmVzdFxuICB8IFtdIC0+ICgpXG5cbmxldCByZXZfaW50ZXJqZWN0IGUgbHN0ID1cbiAgbGV0IHJlYyBhdXggYWNjID0gZnVuY3Rpb25cbiAgICB8IFtdICAtPiBhY2NcbiAgICB8IHg6OnhzIC0+IGF1eCAoeDo6ZTo6YWNjKSB4c1xuICBpbiBtYXRjaCBsc3Qgd2l0aFxuICB8IFtdICAtPiBbXVxuICB8IGg6OnQgLT4gYXV4IFtoXSB0XG5cbmxldCBjb21wYXJlX29wdCBjIHQgdCcgPSBtYXRjaCB0LCB0JyB3aXRoXG4gIHwgTm9uZSwgICBOb25lICAgLT4gMFxuICB8IFNvbWUgXywgTm9uZSAgIC0+IDFcbiAgfCBOb25lLCAgIFNvbWUgXyAtPiAtMVxuICB8IFNvbWUgYSwgU29tZSBiIC0+IGMgYSBiXG5cbmxldCByZWMgY29tcGFyZV9saXN0IGYgdCB0JyA9IG1hdGNoIHQsIHQnIHdpdGhcbiAgfCBbXSwgICAgW10gICAgLT4gIDBcbiAgfCBfOjpfLCAgW10gICAgLT4gIDFcbiAgfCBbXSwgICAgXzo6XyAgLT4gLTFcbiAgfCB4Ojp4cywgeTo6eXMgLT5cbiAgICBtYXRjaCBmIHggeSB3aXRoIDAgLT4gY29tcGFyZV9saXN0IGYgeHMgeXMgfCBjIC0+IGNcblxuKCoqIFNhZmUgY2hhcmFjdGVycyB0aGF0IGFyZSBhbHdheXMgYWxsb3dlZCBpbiBhIFVSSVxuICAqIFVuZm9ydHVuYXRlbHksIHRoaXMgdmFyaWVzIGRlcGVuZGluZyBvbiB3aGljaCBiaXQgb2YgdGhlIFVSSVxuICAqIGlzIGJlaW5nIHBhcnNlZCwgc28gdGhlcmUgYXJlIG11bHRpcGxlIHZhcmlhbnRzIChhbmQgdGhpc1xuICAqIHNldCBpcyBwcm9iYWJseSBub3QgZXhoYXVzdGl2ZS4gVE9ETzogY2hlY2suXG4qKVxudHlwZSBzYWZlX2NoYXJzID0gYm9vbCBhcnJheVxuXG5tb2R1bGUgdHlwZSBTY2hlbWUgPSBzaWdcbiAgdmFsIHNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCA6IGNvbXBvbmVudCAtPiBzYWZlX2NoYXJzXG4gIHZhbCBub3JtYWxpemVfaG9zdCA6IHN0cmluZyAtPiBzdHJpbmdcbiAgdmFsIGNhbm9uaWNhbGl6ZV9wb3J0IDogaW50IG9wdGlvbiAtPiBpbnQgb3B0aW9uXG4gIHZhbCBjYW5vbmljYWxpemVfcGF0aCA6IHN0cmluZyBsaXN0IC0+IHN0cmluZyBsaXN0XG5lbmRcblxubW9kdWxlIEdlbmVyaWMgOiBTY2hlbWUgPSBzdHJ1Y3RcbiAgbGV0IHN1Yl9kZWxpbXMgYSA9XG4gICAgbGV0IHN1YmQgPSBcIiEkJicoKSorLDs9XCIgaW5cbiAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzdWJkIC0gMSBkb1xuICAgICAgbGV0IGMgPSBDaGFyLmNvZGUgc3ViZC5baV0gaW5cbiAgICAgIGEuKGMpIDwtIHRydWVcbiAgICBkb25lO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFycyA6IHNhZmVfY2hhcnMgPVxuICAgIGxldCBhID0gQXJyYXkubWFrZSAyNTYgZmFsc2UgaW5cbiAgICBsZXQgYWx3YXlzX3NhZmUgPVxuICAgICAgXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OV8uLX5cIiBpblxuICAgIGZvciBpID0gMCB0byBTdHJpbmcubGVuZ3RoIGFsd2F5c19zYWZlIC0gMSBkb1xuICAgICAgbGV0IGMgPSBDaGFyLmNvZGUgYWx3YXlzX3NhZmUuW2ldIGluXG4gICAgICBhLihjKSA8LSB0cnVlXG4gICAgZG9uZTtcbiAgICBhXG5cbiAgbGV0IHBjaGFyIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBzdWJfZGVsaW1zIChBcnJheS5jb3B5IHNhZmVfY2hhcnMpIGluXG4gICAgYS4oQ2hhci5jb2RlICc6JykgPC0gdHJ1ZTtcbiAgICBhLihDaGFyLmNvZGUgJ0AnKSA8LSB0cnVlO1xuICAgIGFcblxuICBsZXQgc2FmZV9jaGFyc19mb3Jfc2NoZW1lIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBBcnJheS5jb3B5IHNhZmVfY2hhcnMgaW5cbiAgICBhLihDaGFyLmNvZGUgJysnKSA8LSB0cnVlO1xuICAgIGFcblxuICAoKiogU2FmZSBjaGFyYWN0ZXJzIGZvciB0aGUgcGF0aCBjb21wb25lbnQgb2YgYSBVUkkgKilcbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3BhdGggOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IHN1Yl9kZWxpbXMgKEFycmF5LmNvcHkgcGNoYXIpIGluXG4gICAgKCogZGVsaW1pdGVyOiBub24tc2VnbWVudCBkZWxpbWl0aW5nIHVzZXMgc2hvdWxkIGJlIHBjdCBlbmNvZGVkICopXG4gICAgYS4oQ2hhci5jb2RlICcvJykgPC0gZmFsc2U7XG4gICAgYVxuXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9xdWVyeSA6IHNhZmVfY2hhcnMgPVxuICAgICgqIFRPRE86IFdoYXQgYWJvdXQge1wiIVwiLFwiJFwiLFwiLFwifT8gU2VlIDxodHRwczovL2dpdGh1Yi5jb20vYXZzbS9vY2FtbC11cmkvY29tbWl0LzFlZjNmMWRmYjQxYmRiNGYzM2YyMjNmZmUxNmU2MmEzMzk3NTY2MWEjZGlmZi03NDBmMmRlNTNjOWViMzZlOTY3MGRkZmJkYjliYTkxNFIxNzE+ICopXG4gICAgbGV0IGEgPSBBcnJheS5jb3B5IHBjaGFyIGluXG4gICAgYS4oQ2hhci5jb2RlICcvJykgPC0gdHJ1ZTtcbiAgICBhLihDaGFyLmNvZGUgJz8nKSA8LSB0cnVlO1xuICAgICgqICcmJyBpcyBzYWZlIGJ1dCB3ZSBzaG91bGQgZW5jb2RlIGxpdGVyYWxzIHRvIGF2b2lkIGFtYmlndWl0eVxuICAgICAgIHdpdGggdGhlIGFscmVhZHkgcGFyc2VkIHFzIHBhcmFtcyAqKVxuICAgIGEuKENoYXIuY29kZSAnJicpIDwtIGZhbHNlO1xuICAgICgqICc7JyBpcyBzYWZlIGJ1dCBzb21lIHN5c3RlbXMgdHJlYXQgaXQgbGlrZSAnJicuICopXG4gICAgYS4oQ2hhci5jb2RlICc7JykgPC0gZmFsc2U7XG4gICAgYS4oQ2hhci5jb2RlICcrJykgPC0gZmFsc2U7XG4gICAgYVxuXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9xdWVyeV9rZXkgOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IEFycmF5LmNvcHkgc2FmZV9jaGFyc19mb3JfcXVlcnkgaW5cbiAgICBhLihDaGFyLmNvZGUgJz0nKSA8LSBmYWxzZTtcbiAgICBhXG5cbiAgbGV0IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5X3ZhbHVlIDogc2FmZV9jaGFycyA9XG4gICAgbGV0IGEgPSBBcnJheS5jb3B5IHNhZmVfY2hhcnNfZm9yX3F1ZXJ5IGluXG4gICAgYS4oQ2hhci5jb2RlICcsJykgPC0gZmFsc2U7XG4gICAgYVxuXG4gIGxldCBzYWZlX2NoYXJzX2Zvcl9mcmFnbWVudCA6IHNhZmVfY2hhcnMgPSBzYWZlX2NoYXJzX2Zvcl9xdWVyeVxuXG4gICgqKiBTYWZlIGNoYXJhY3RlcnMgZm9yIHRoZSB1c2VyaW5mbyBzdWJjb21wb25lbnQgb2YgYSBVUkkuXG4gICAgICBUT0RPOiB0aGlzIG5lZWRzIG1vcmUgcmVzZXJ2ZWQgY2hhcmFjdGVycyBhZGRlZCAqKVxuICBsZXQgc2FmZV9jaGFyc19mb3JfdXNlcmluZm8gOiBzYWZlX2NoYXJzID1cbiAgICBsZXQgYSA9IEFycmF5LmNvcHkgc2FmZV9jaGFycyBpblxuICAgICgqIGRlbGltaXRlcjogbm9uLXNlZ21lbnQgZGVsaW1pdGluZyB1c2VzIHNob3VsZCBiZSBwY3QgZW5jb2RlZCAqKVxuICAgIGEuKENoYXIuY29kZSAnOicpIDwtIGZhbHNlO1xuICAgIGFcblxuICBsZXQgcmVjIHNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCA9IGZ1bmN0aW9uXG4gICAgfCBgUGF0aCAtPiBzYWZlX2NoYXJzX2Zvcl9wYXRoXG4gICAgfCBgVXNlcmluZm8gLT4gc2FmZV9jaGFyc19mb3JfdXNlcmluZm9cbiAgICB8IGBRdWVyeSAtPiBzYWZlX2NoYXJzX2Zvcl9xdWVyeVxuICAgIHwgYFF1ZXJ5X2tleSAtPiBzYWZlX2NoYXJzX2Zvcl9xdWVyeV9rZXlcbiAgICB8IGBRdWVyeV92YWx1ZSAtPiBzYWZlX2NoYXJzX2Zvcl9xdWVyeV92YWx1ZVxuICAgIHwgYEZyYWdtZW50IC0+IHNhZmVfY2hhcnNfZm9yX2ZyYWdtZW50XG4gICAgfCBgU2NoZW1lIC0+IHNhZmVfY2hhcnNfZm9yX3NjaGVtZVxuICAgIHwgYEN1c3RvbSAoKGNvbXBvbmVudCA6IGNvbXBvbmVudCksIHNhZmUsIHVuc2FmZSkgLT5cbiAgICAgICBsZXQgc2FmZV9jaGFycyA9IEFycmF5LmNvcHkgKHNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCBjb21wb25lbnQpIGluXG4gICAgICAgZm9yIGkgPSAwIHRvIFN0cmluZy5sZW5ndGggc2FmZSAtIDEgZG9cbiAgICAgICAgIGxldCBjID0gQ2hhci5jb2RlIHNhZmUuW2ldIGluXG4gICAgICAgICBzYWZlX2NoYXJzLihjKSA8LSB0cnVlXG4gICAgICAgZG9uZTtcbiAgICAgICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCB1bnNhZmUgLSAxIGRvXG4gICAgICAgICBsZXQgYyA9IENoYXIuY29kZSB1bnNhZmUuW2ldIGluXG4gICAgICAgICBzYWZlX2NoYXJzLihjKSA8LSBmYWxzZVxuICAgICAgIGRvbmU7XG4gICAgICAgc2FmZV9jaGFyc1xuICAgIHwgYEdlbmVyaWNcbiAgICB8IF8gLT4gc2FmZV9jaGFyc1xuXG4gIGxldCBub3JtYWxpemVfaG9zdCBoc28gPSBoc29cblxuICBsZXQgY2Fub25pY2FsaXplX3BvcnQgcG9ydCA9IHBvcnRcbiAgbGV0IGNhbm9uaWNhbGl6ZV9wYXRoIHBhdGggPSBwYXRoXG5lbmRcblxubW9kdWxlIEh0dHAgOiBTY2hlbWUgPSBzdHJ1Y3RcbiAgaW5jbHVkZSBHZW5lcmljXG5cbiAgbGV0IG5vcm1hbGl6ZV9ob3N0IGhzID0gU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBoc1xuXG4gIGxldCBjYW5vbmljYWxpemVfcG9ydCA9IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgODAgLT4gTm9uZVxuICAgIHwgU29tZSB4IC0+IFNvbWUgeFxuXG4gIGxldCBjYW5vbmljYWxpemVfcGF0aCA9IGZ1bmN0aW9uXG4gICAgfCBbXSAtPiBbXCIvXCJdXG4gICAgfCB4ICAtPiB4XG5lbmRcblxubW9kdWxlIEh0dHBzIDogU2NoZW1lID0gc3RydWN0XG4gIGluY2x1ZGUgSHR0cFxuXG4gIGxldCBjYW5vbmljYWxpemVfcG9ydCA9IGZ1bmN0aW9uXG4gICAgfCBOb25lIC0+IE5vbmVcbiAgICB8IFNvbWUgNDQzIC0+IE5vbmVcbiAgICB8IFNvbWUgeCAtPiBTb21lIHhcbmVuZFxuXG5tb2R1bGUgRmlsZSA6IFNjaGVtZSA9IHN0cnVjdFxuICBpbmNsdWRlIEdlbmVyaWNcblxuICBsZXQgbm9ybWFsaXplX2hvc3QgaHMgPVxuICAgIGxldCBocyA9IFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgaHMgaW5cbiAgICBpZiBocz1cImxvY2FsaG9zdFwiIHRoZW4gXCJcIiBlbHNlIGhzXG5lbmRcblxubW9kdWxlIFVybiA6IFNjaGVtZSA9IHN0cnVjdFxuICBpbmNsdWRlIEdlbmVyaWNcblxuZW5kXG5cbmxldCBtb2R1bGVfb2Zfc2NoZW1lID0gZnVuY3Rpb25cbiAgfCBTb21lIHMgLT4gYmVnaW4gbWF0Y2ggU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSBzIHdpdGhcbiAgICAgIHwgXCJodHRwXCIgLT4gKG1vZHVsZSBIdHRwIDogU2NoZW1lKVxuICAgICAgfCBcImh0dHBzXCIgIC0+IChtb2R1bGUgSHR0cHMgOiBTY2hlbWUpXG4gICAgICB8IFwiZmlsZVwiIC0+IChtb2R1bGUgRmlsZSA6IFNjaGVtZSlcbiAgICAgIHwgXCJ1cm5cIiAgLT4gKG1vZHVsZSBVcm4gOiBTY2hlbWUpXG4gICAgICB8IF8gLT4gKG1vZHVsZSBHZW5lcmljIDogU2NoZW1lKVxuICAgIGVuZFxuICB8IE5vbmUgLT4gKG1vZHVsZSBHZW5lcmljIDogU2NoZW1lKVxuXG4oKiogUG9ydGlvbnMgb2YgdGhlIFVSTCBtdXN0IGJlIGNvbnZlcnRlZCB0by1hbmQtZnJvbSBwZXJjZW50LWVuY29kaW5nXG4gICogYW5kIHRoaXMgcmVhbGx5LCByZWFsbHkgc2hvdWxkbid0IGJlIG1peGVkIHVwLiBTbyB0aGlzIFBjdCBtb2R1bGVcbiAgKiBkZWZpbmVzIGFic3RyYWN0IFBjdC5lbmNvZGVkIGFuZCBQY3QuZGVjb2RlZCB0eXBlcyB3aGljaCBzZXRzIHRoZVxuICAqIHN0YXRlIG9mIHRoZSB1bmRlcmx5aW5nIHN0cmluZy4gIFRoZXJlIGFyZSBmdW5jdGlvbnMgdG8gXCJjYXN0XCIgdG9cbiAgKiBhbmQgZnJvbSB0aGVzZSBhbmQgbm9ybWFsIHN0cmluZ3MsIGFuZCB0aGlzIHByb21vdGVzIGEgYml0IG9mXG4gICogaW50ZXJuYWwgc2FmZXR5LiAgVGhlc2UgdHlwZXMgYXJlIG5vdCBleHBvc2VkIHRvIHRoZSBleHRlcm5hbFxuICAqIGludGVyZmFjZSwgYXMgY2FzdGluZyB0by1hbmQtZnJvbSBpcyBxdWl0ZSBhIGJpdCBvZiBoYXNzbGUgYW5kXG4gICogcHJvYmFibHkgbm90IGEgbG90IG9mIHVzZSB0byB0aGUgYXZlcmFnZSBjb25zdW1lciBvZiB0aGlzIGxpYnJhcnlcbiopXG5tb2R1bGUgUGN0IDogc2lnXG4gIHR5cGUgZW5jb2RlZFxuICB0eXBlIGRlY29kZWRcblxuICB2YWwgZW5jb2RlIDogP3NjaGVtZTpzdHJpbmcgLT4gP2NvbXBvbmVudDpjb21wb25lbnQgLT4gZGVjb2RlZCAtPiBlbmNvZGVkXG4gIHZhbCBkZWNvZGUgOiBlbmNvZGVkIC0+IGRlY29kZWRcblxuICAoKiBUaGUgZW1wdHkgZGVjb2RlZCBzdHJpbmcgKilcbiAgdmFsIGVtcHR5X2RlY29kZWQgOiBkZWNvZGVkXG4gICgqIElkZW50aXR5IGZ1bmN0aW9ucyBzbyB3ZSBuZWVkIHRvIGV4cGxpY2l0bHkgY2FzdCB3aGVuIHVzaW5nIHRoZW0gYmVsb3cgKilcbiAgdmFsIGNhc3RfZW5jb2RlZCA6IHN0cmluZyAtPiBlbmNvZGVkXG4gIHZhbCBjYXN0X2RlY29kZWQgOiBzdHJpbmcgLT4gZGVjb2RlZFxuICB2YWwgdW5jYXN0X2VuY29kZWQgOiBlbmNvZGVkIC0+IHN0cmluZ1xuICB2YWwgdW5jYXN0X2RlY29kZWQgOiBkZWNvZGVkIC0+IHN0cmluZ1xuICAoKiBMaWZ0IEhPRnMgZm9yIG1hcHMgb3ZlciBlbmNvZGluZ3MsIGRlY29kaW5ncywgYW5kIHN0cmluZ3MgKilcbiAgdmFsIGxpZnRfZW5jb2RlZCA6IChlbmNvZGVkIC0+IGVuY29kZWQpIC0+IHN0cmluZyAtPiBzdHJpbmdcbiAgdmFsIGxpZnRfZGVjb2RlZCA6IChkZWNvZGVkIC0+IGRlY29kZWQpIC0+IHN0cmluZyAtPiBzdHJpbmdcbiAgdmFsIHVubGlmdF9lbmNvZGVkIDogKHN0cmluZyAtPiBzdHJpbmcpIC0+IGVuY29kZWQgLT4gZW5jb2RlZFxuICB2YWwgdW5saWZ0X2RlY29kZWQgOiAoc3RyaW5nIC0+IHN0cmluZykgLT4gZGVjb2RlZCAtPiBkZWNvZGVkXG4gIHZhbCB1bmxpZnRfZGVjb2RlZDIgOiAoc3RyaW5nIC0+IHN0cmluZyAtPiAnYSkgLT4gZGVjb2RlZCAtPiBkZWNvZGVkIC0+ICdhXG5lbmQgPSBzdHJ1Y3RcbiAgdHlwZSBlbmNvZGVkID0gc3RyaW5nXG4gIHR5cGUgZGVjb2RlZCA9IHN0cmluZ1xuICBsZXQgY2FzdF9lbmNvZGVkIHggPSB4XG4gIGxldCBjYXN0X2RlY29kZWQgeCA9IHhcbiAgbGV0IGVtcHR5X2RlY29kZWQgPSBcIlwiXG4gIGxldCB1bmNhc3RfZGVjb2RlZCB4ID0geFxuICBsZXQgdW5jYXN0X2VuY29kZWQgeCA9IHhcblxuICBsZXQgbGlmdF9lbmNvZGVkIGYgPSBmXG4gIGxldCBsaWZ0X2RlY29kZWQgZiA9IGZcbiAgbGV0IHVubGlmdF9lbmNvZGVkIGYgPSBmXG4gIGxldCB1bmxpZnRfZGVjb2RlZCBmID0gZlxuICBsZXQgdW5saWZ0X2RlY29kZWQyIGYgPSBmXG5cbiAgKCoqIFNjYW4gZm9yIHJlc2VydmVkIGNoYXJhY3RlcnMgYW5kIHJlcGxhY2UgdGhlbSB3aXRoXG4gICAgICBwZXJjZW50LWVuY29kZWQgZXF1aXZhbGVudHMuXG4gICAgICBAcmV0dXJuIGEgcGVyY2VudC1lbmNvZGVkIHN0cmluZyAqKVxuICBsZXQgZW5jb2RlID9zY2hlbWUgPyhjb21wb25lbnQ9YFBhdGgpIGIgPVxuICAgIGxldCBtb2R1bGUgU2NoZW1lID0gKHZhbCAobW9kdWxlX29mX3NjaGVtZSBzY2hlbWUpIDogU2NoZW1lKSBpblxuICAgIGxldCBzYWZlX2NoYXJzID0gU2NoZW1lLnNhZmVfY2hhcnNfZm9yX2NvbXBvbmVudCBjb21wb25lbnQgaW5cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBiIGluXG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgbGVuIGluXG4gICAgbGV0IHJlYyBzY2FuIHN0YXJ0IGN1ciA9XG4gICAgICBpZiBjdXIgPj0gbGVuIHRoZW4gYmVnaW5cbiAgICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIGIgc3RhcnQgKGN1ci1zdGFydCk7XG4gICAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgICBsZXQgYyA9IENoYXIuY29kZSBiLltjdXJdIGluXG4gICAgICAgIGlmIHNhZmVfY2hhcnMuKGMpIHRoZW5cbiAgICAgICAgICBzY2FuIHN0YXJ0IChjdXIrMSlcbiAgICAgICAgZWxzZSBiZWdpblxuICAgICAgICAgIGlmIGN1ciA+IHN0YXJ0IHRoZW4gQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIGIgc3RhcnQgKGN1ci1zdGFydCk7XG4gICAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChQcmludGYuc3ByaW50ZiBcIiUlJTAyWFwiIGMpO1xuICAgICAgICAgIHNjYW4gKGN1cisxKSAoY3VyKzEpXG4gICAgICAgIGVuZFxuICAgICAgZW5kXG4gICAgaW5cbiAgICBzY2FuIDAgMDtcbiAgICBCdWZmZXIuY29udGVudHMgYnVmXG5cbiAgbGV0IGludF9vZl9oZXhfY2hhciBjID1cbiAgICBsZXQgYyA9IGludF9vZl9jaGFyIChDaGFyLnVwcGVyY2FzZV9hc2NpaSBjKSAtIDQ4IGluXG4gICAgaWYgYyA+IDlcbiAgICB0aGVuIGlmIGMgPiAxNiAmJiBjIDwgMjNcbiAgICAgIHRoZW4gYyAtIDdcbiAgICAgIGVsc2UgZmFpbHdpdGggXCJpbnRfb2ZfaGV4X2NoYXJcIlxuICAgIGVsc2UgaWYgYyA+PSAwXG4gICAgdGhlbiBjXG4gICAgZWxzZSBmYWlsd2l0aCBcImludF9vZl9oZXhfY2hhclwiXG5cbiAgKCoqIFNjYW4gZm9yIHBlcmNlbnQtZW5jb2RpbmcgYW5kIGNvbnZlcnQgdGhlbSBpbnRvIEFTQ0lJLlxuICAgICAgQHJldHVybiBhIHBlcmNlbnQtZGVjb2RlZCBzdHJpbmcgKilcbiAgbGV0IGRlY29kZSBiID1cbiAgICAoKiBUT0RPOiBTaG91bGQgYm90aCBzdHJpY3QgYW5kIG5vbi1zdHJpY3QgdmVyc2lvbnMgYmUgZXhwb3NlZD8gKilcbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBiIGluXG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgbGVuIGluXG4gICAgbGV0IHJlYyBzY2FuIHN0YXJ0IGN1ciA9XG4gICAgICBpZiBjdXIgPj0gbGVuIHRoZW4gQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIGIgc3RhcnQgKGN1ci1zdGFydClcbiAgICAgIGVsc2UgaWYgYi5bY3VyXSA9ICclJyB0aGVuIGJlZ2luXG4gICAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBiIHN0YXJ0IChjdXItc3RhcnQpO1xuICAgICAgICBsZXQgY3VyID0gY3VyICsgMSBpblxuICAgICAgICBpZiBjdXIgPj0gbGVuIHRoZW4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnJSdcbiAgICAgICAgZWxzZSBtYXRjaCBpbnRfb2ZfaGV4X2NoYXIgYi5bY3VyXSB3aXRoXG4gICAgICAgIHwgZXhjZXB0aW9uIF8gLT5cbiAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICclJztcbiAgICAgICAgICBzY2FuIGN1ciBjdXJcbiAgICAgICAgfCBoaWdoYml0cyAtPiBiZWdpblxuICAgICAgICAgIGxldCBjdXIgPSBjdXIgKyAxIGluXG4gICAgICAgICAgaWYgY3VyID49IGxlbiB0aGVuIGJlZ2luXG4gICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICclJztcbiAgICAgICAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgYi5bY3VyLTFdXG4gICAgICAgICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgICAgICAgIGxldCBzdGFydF9hdCA9XG4gICAgICAgICAgICAgIG1hdGNoIGludF9vZl9oZXhfY2hhciBiLltjdXJdIHdpdGhcbiAgICAgICAgICAgICAgfCBsb3diaXRzIC0+XG4gICAgICAgICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAoQ2hhci5jaHIgKGhpZ2hiaXRzIGxzbCA0ICsgbG93Yml0cykpO1xuICAgICAgICAgICAgICAgIGN1cisxXG4gICAgICAgICAgICAgIHwgZXhjZXB0aW9uIF8gLT5cbiAgICAgICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICclJztcbiAgICAgICAgICAgICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmIGIuW2N1ci0xXTtcbiAgICAgICAgICAgICAgICBjdXJcbiAgICAgICAgICAgIGluIHNjYW4gc3RhcnRfYXQgc3RhcnRfYXRcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZSBzY2FuIHN0YXJ0IChjdXIrMSlcbiAgICBpblxuICAgIHNjYW4gMCAwO1xuICAgIEJ1ZmZlci5jb250ZW50cyBidWZcbmVuZFxuXG4oKiBQZXJjZW50IGVuY29kZSBhIHN0cmluZyAqKVxubGV0IHBjdF9lbmNvZGUgP3NjaGVtZSA/KGNvbXBvbmVudD1gUGF0aCkgcyA9XG4gIFBjdC4odW5jYXN0X2VuY29kZWQgKGVuY29kZSA/c2NoZW1lIH5jb21wb25lbnQgKGNhc3RfZGVjb2RlZCBzKSkpXG5cbmxldCBwY3RfZW5jb2RlclxuICAgICAgPyhzY2hlbWU9YFNjaGVtZSlcbiAgICAgID8odXNlcmluZm89YFVzZXJpbmZvKVxuICAgICAgPyhob3N0PWBIb3N0KVxuICAgICAgPyhwYXRoPWBQYXRoKVxuICAgICAgPyhxdWVyeV9rZXk9YFF1ZXJ5X2tleSlcbiAgICAgID8ocXVlcnlfdmFsdWU9YFF1ZXJ5X3ZhbHVlKVxuICAgICAgPyhmcmFnbWVudD1gRnJhZ21lbnQpXG4gICAgICAoKSA9XG4gIHsgc2NoZW1lOyB1c2VyaW5mbzsgaG9zdDsgcGF0aDsgcXVlcnlfa2V5OyBxdWVyeV92YWx1ZTsgZnJhZ21lbnQgfVxuXG4oKiBQZXJjZW50IGRlY29kZSBhIHN0cmluZyAqKVxubGV0IHBjdF9kZWNvZGUgcyA9IFBjdC4odW5jYXN0X2RlY29kZWQgKGRlY29kZSAoY2FzdF9lbmNvZGVkIHMpKSlcblxuKCogVXNlcmluZm8gc3RyaW5nIGhhbmRsaW5nLCB0byBhbmQgZnJvbSBhbiBpZCAqIGNyZWRlbnRpYWwgcGFpciAqKVxubW9kdWxlIFVzZXJpbmZvID0gc3RydWN0XG4gIHR5cGUgdCA9IHN0cmluZyAqIHN0cmluZyBvcHRpb25cblxuICBsZXQgY29tcGFyZSAodSxwKSAodScscCcpID1cbiAgICBtYXRjaCBTdHJpbmcuY29tcGFyZSB1IHUnIHdpdGhcbiAgICB8IDAgLT4gY29tcGFyZV9vcHQgU3RyaW5nLmNvbXBhcmUgcCBwJ1xuICAgIHwgYyAtPiBjXG5cbiAgbGV0IHVzZXJpbmZvX29mX2VuY29kZWQgdXMgPVxuICAgIG1hdGNoIFN0cmluZ2V4dC5zcGxpdCB+bWF4OjIgfm9uOic6JyB1cyB3aXRoXG4gICAgfCBbXSAtPiAoXCJcIixOb25lKVxuICAgIHwgW3VdIC0+IChwY3RfZGVjb2RlIHUsTm9uZSlcbiAgICB8IHU6OnA6Ol8gLT4gKHBjdF9kZWNvZGUgdSxTb21lIChwY3RfZGVjb2RlIHApKVxuXG4gIGxldCBlbmNvZGVkX29mX3VzZXJpbmZvID9zY2hlbWUgfmNvbXBvbmVudCAodSxwbykgPVxuICAgIGxldCBsZW4gPSBTdHJpbmcuKFxuICAgICAgMSArIChsZW5ndGggdSkgKyAobWF0Y2ggcG8gd2l0aCBOb25lIC0+IDAgfCBTb21lIHAgLT4gbGVuZ3RoIHApKVxuICAgIGluXG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgbGVuIGluXG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChwY3RfZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudCB1KTtcbiAgICBiZWdpbiBtYXRjaCBwbyB3aXRoIE5vbmUgLT4gKCk7XG4gICAgfCBTb21lIHAgLT5cbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJzonO1xuICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChwY3RfZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudCBwKVxuICAgIGVuZDtcbiAgICBQY3QuY2FzdF9lbmNvZGVkIChCdWZmZXIuY29udGVudHMgYnVmKVxuZW5kXG5cbmxldCB1c2VyaW5mb19vZl9lbmNvZGVkID0gVXNlcmluZm8udXNlcmluZm9fb2ZfZW5jb2RlZFxubGV0IGVuY29kZWRfb2ZfdXNlcmluZm8gP3NjaGVtZSB+Y29tcG9uZW50ID0gVXNlcmluZm8uZW5jb2RlZF9vZl91c2VyaW5mbyA/c2NoZW1lIH5jb21wb25lbnRcblxuKCogUGF0aCBzdHJpbmcgaGFuZGxpbmcsIHRvIGFuZCBmcm9tIGEgbGlzdCBvZiBwYXRoIHRva2VucyAqKVxubW9kdWxlIFBhdGggPSBzdHJ1Y3RcbiAgKCogSW52YXJpYW50OiBldmVyeSBlbGVtZW50IGlzIG5vbi16ZXJvLCBzbGFzaGVzICgvKSBvbmx5IG9jY3VyIGFsb25lLiAqKVxuICAoKiBZZXMsIGl0J3MgYmV0dGVyIHRoaXMgd2F5LiBUaGlzIG1lYW5zIHlvdSBjYW4gcmV0YWluIHNlcGFyYXRvclxuICAgICBjb250ZXh0IGluIHJlY3Vyc2lvbiAoZS5nLiByZW1vdmVfZG90X3NlZ21lbnRzIGZvciByZWxhdGl2ZSByZXNvbHV0aW9uKS4gKilcblxuICB0eXBlIHQgPSBzdHJpbmcgbGlzdFxuXG4gIGxldCBjb21wYXJlID0gY29tcGFyZV9saXN0IFN0cmluZy5jb21wYXJlXG5cbiAgKCogTWFrZSBhIHBhdGggdG9rZW4gbGlzdCBmcm9tIGEgcGVyY2VudC1lbmNvZGVkIHN0cmluZyAqKVxuICBsZXQgcGF0aF9vZl9lbmNvZGVkIHBzID1cbiAgICBsZXQgdG9rbCA9IFN0cmluZ2V4dC5mdWxsX3NwbGl0IHBzIH5vbjonLycgaW5cbiAgICBMaXN0Lm1hcCBwY3RfZGVjb2RlIHRva2xcblxuICAoKiBTdWJyb3V0aW5lIGZvciByZXNvbHZlIDxodHRwOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzOTg2I3NlY3Rpb24tNS4yLjQ+ICopXG4gIGxldCByZW1vdmVfZG90X3NlZ21lbnRzIHAgPVxuICAgIGxldCByZXZwID0gTGlzdC5yZXYgcCBpblxuICAgIGxldCByZWMgbG9vcCBhc2NlbnNpb24gb3V0cCA9IGZ1bmN0aW9uXG4gICAgICB8IFwiL1wiOjpcIi4uXCI6OnIgfCBcIi4uXCI6OnIgLT4gbG9vcCAoYXNjZW5zaW9uICsgMSkgb3V0cCByXG4gICAgICB8IFwiL1wiOjpcIi5cIjo6ciAgfCBcIi5cIjo6ciAgLT4gbG9vcCBhc2NlbnNpb24gb3V0cCByXG4gICAgICB8IFwiL1wiOjpbXSB8IFtdIHdoZW4gTGlzdC4obGVuZ3RoIHAgPiAwICYmIGhkIHAgPSBcIi9cIikgLT4gXCIvXCI6Om91dHBcbiAgICAgIHwgW10gd2hlbiBhc2NlbnNpb24gPiAwIC0+IExpc3QucmV2X2FwcGVuZFxuICAgICAgICAoXCIvXCI6OihyZXZfaW50ZXJqZWN0IFwiL1wiIEFycmF5Lih0b19saXN0IChtYWtlIGFzY2Vuc2lvbiBcIi4uXCIpKSkpIG91dHBcbiAgICAgIHwgW10gLT4gTGlzdC4oaWYgbGVuZ3RoIG91dHAgPiAwICYmIGhkIG91dHAgPSBcIi9cIiB0aGVuIHRsIG91dHAgZWxzZSBvdXRwKVxuICAgICAgfCBcIi9cIjo6XCIvXCI6OnIgd2hlbiBhc2NlbnNpb24gPiAwIC0+IGxvb3AgKGFzY2Vuc2lvbiAtIDEpIG91dHAgKFwiL1wiOjpyKVxuICAgICAgfCBcIi9cIjo6Xzo6ciB3aGVuIGFzY2Vuc2lvbiA+IDAgLT4gbG9vcCAoYXNjZW5zaW9uIC0gMSkgb3V0cCByXG4gICAgICB8IHM6OnIgLT4gbG9vcCAwIChzOjpvdXRwKSByXG4gICAgaW4gbG9vcCAwIFtdIHJldnBcblxuICBsZXQgZW5jb2RlZF9vZl9wYXRoID9zY2hlbWUgfmNvbXBvbmVudCBwID1cbiAgICBsZXQgbGVuID0gTGlzdC5mb2xkX2xlZnQgKGZ1biBjIHRvayAtPiBTdHJpbmcubGVuZ3RoIHRvayArIGMpIDAgcCBpblxuICAgIGxldCBidWYgPSBCdWZmZXIuY3JlYXRlIGxlbiBpblxuICAgIGl0ZXJfY29uY2F0IChmdW4gYnVmIC0+IGZ1bmN0aW9uXG4gICAgfCBcIi9cIiAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmICcvJ1xuICAgIHwgc2VnIC0+IEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAocGN0X2VuY29kZSA/c2NoZW1lIH5jb21wb25lbnQgc2VnKVxuICAgICkgXCJcIiBidWYgcDtcbiAgICBQY3QuY2FzdF9lbmNvZGVkIChCdWZmZXIuY29udGVudHMgYnVmKVxuXG4gICgqIFN1YnJvdXRpbmUgZm9yIHJlc29sdmUgPGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjIuMz4gKilcbiAgbGV0IG1lcmdlIGJob3N0IGJwYXRoIHJlbHBhdGggPVxuICAgIG1hdGNoIGJob3N0LCBMaXN0LnJldiBicGF0aCB3aXRoXG4gICAgfCBTb21lIF8sIFtdIC0+IFwiL1wiOjpyZWxwYXRoXG4gICAgfCBfLCAoXCIvXCI6OnJicGF0aCB8IF86OlwiL1wiOjpyYnBhdGgpIC0+IExpc3QucmV2X2FwcGVuZCAoXCIvXCI6OnJicGF0aCkgcmVscGF0aFxuICAgIHwgXywgXyAtPiByZWxwYXRoXG5lbmRcblxubGV0IHBhdGhfb2ZfZW5jb2RlZCA9IFBhdGgucGF0aF9vZl9lbmNvZGVkXG5sZXQgZW5jb2RlZF9vZl9wYXRoID9zY2hlbWUgfmNvbXBvbmVudCA9IFBhdGguZW5jb2RlZF9vZl9wYXRoID9zY2hlbWUgfmNvbXBvbmVudFxuXG4oKiBRdWVyeSBzdHJpbmcgaGFuZGxpbmcsIHRvIGFuZCBmcm9tIGFuIGFzc29jIGxpc3Qgb2Yga2V5L3ZhbHVlcyAqKVxubW9kdWxlIFF1ZXJ5ID0gc3RydWN0XG5cbiAgdHlwZSBrdiA9IChzdHJpbmcgKiBzdHJpbmcgbGlzdCkgbGlzdFxuXG4gIHR5cGUgdCA9XG4gICAgfCBLViBvZiBrdlxuICAgIHwgUmF3IG9mIHN0cmluZyBvcHRpb24gKiBrdiBMYXp5LnRcblxuICBsZXQgY29tcGFyZSB4IHkgPSBtYXRjaCB4LCB5IHdpdGhcbiAgICB8IEtWIGt2bCwgS1Yga3ZsJ1xuICAgIHwgUmF3IChfLCBsYXp5IGt2bCksIEtWIGt2bCdcbiAgICB8IEtWIGt2bCwgUmF3IChfLCBsYXp5IGt2bCcpIC0+XG4gICAgICBjb21wYXJlX2xpc3QgKGZ1biAoayx2bCkgKGsnLHZsJykgLT5cbiAgICAgICAgbWF0Y2ggU3RyaW5nLmNvbXBhcmUgayBrJyB3aXRoXG4gICAgICAgIHwgMCAtPiBjb21wYXJlX2xpc3QgU3RyaW5nLmNvbXBhcmUgdmwgdmwnXG4gICAgICAgIHwgYyAtPiBjXG4gICAgICApIGt2bCBrdmwnXG4gICAgfCBSYXcgKHJhdyxfKSwgUmF3IChyYXcnLF8pIC0+IGNvbXBhcmVfb3B0IFN0cmluZy5jb21wYXJlIHJhdyByYXcnXG5cbiAgbGV0IGZpbmQgcSBrID0gdHJ5IFNvbWUgKExpc3QuYXNzb2MgayBxKSB3aXRoIE5vdF9mb3VuZCAtPiBOb25lXG5cbiAgbGV0IHNwbGl0X3F1ZXJ5IHFzID1cbiAgICBsZXQgZWxzID0gU3RyaW5nZXh0LnNwbGl0IH5vbjonJicgcXMgaW5cbiAgICAoKiBSZXBsYWNlIGEgKyBpbiBhIHF1ZXJ5IHN0cmluZyB3aXRoIGEgc3BhY2UgaW4tcGxhY2UgKilcbiAgICBsZXQgcGx1c190b19zcGFjZSBzID1cbiAgICAgIGxldCBzID0gQnl0ZXMudW5zYWZlX29mX3N0cmluZyBzIGluXG4gICAgICBmb3IgaSA9IDAgdG8gQnl0ZXMubGVuZ3RoIHMgLSAxIGRvXG4gICAgICAgIGlmIEJ5dGVzLmdldCBzIGkgPSAnKycgdGhlbiBCeXRlcy5zZXQgcyBpICcgJ1xuICAgICAgZG9uZTtcbiAgICAgIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgc1xuICAgIGluXG4gICAgbGV0IHJlYyBsb29wIGFjYyA9IGZ1bmN0aW9uXG4gICAgICB8IChrOjp2OjpfKTo6dGwgLT5cbiAgICAgICAgbGV0IG4gPSBwbHVzX3RvX3NwYWNlIGssXG4gICAgICAgICAgICAgICAgKG1hdGNoIFN0cmluZ2V4dC5zcGxpdCB+b246JywnIChwbHVzX3RvX3NwYWNlIHYpIHdpdGhcbiAgICAgICAgICAgICAgICAgfCBbXSAtPiBbXCJcIl0gfCBsIC0+IGwpIGluXG4gICAgICAgIGxvb3AgKG46OmFjYykgdGxcbiAgICAgIHwgW2tdOjp0bCAtPlxuICAgICAgICBsZXQgbiA9IHBsdXNfdG9fc3BhY2UgaywgW10gaW5cbiAgICAgICAgbG9vcCAobjo6YWNjKSB0bFxuICAgICAgfCBbXTo6dGwgLT4gbG9vcCAoKFwiXCIsIFtdKTo6YWNjKSB0bFxuICAgICAgfCBbXSAtPiBhY2NcbiAgICBpblxuICAgIG1hdGNoIGVscyB3aXRoXG4gICAgfCBbXSAgLT4gW1wiXCIsW11dXG4gICAgfCBlbHMgLT4gbG9vcCBbXVxuICAgICAgKExpc3QucmV2X21hcCAoZnVuIGVsIC0+IFN0cmluZ2V4dC5zcGxpdCB+b246Jz0nIGVsIH5tYXg6MikgZWxzKVxuXG4gICgqIE1ha2UgYSBxdWVyeSB0dXBsZSBsaXN0IGZyb20gYSBwZXJjZW50LWVuY29kZWQgc3RyaW5nICopXG4gIGxldCBxdWVyeV9vZl9lbmNvZGVkIHFzID1cbiAgICBMaXN0Lm1hcFxuICAgICAgKGZ1biAoaywgdikgLT4gKHBjdF9kZWNvZGUgaywgTGlzdC5tYXAgcGN0X2RlY29kZSB2KSlcbiAgICAgIChzcGxpdF9xdWVyeSBxcylcblxuICAoKiBBc3NlbWJsZSBhIHF1ZXJ5IHN0cmluZyBzdWl0YWJsZSBmb3IgcHV0dGluZyBpbnRvIGEgVVJJLlxuICAgKiBUdXBsZSBpbnB1dHMgYXJlIHBlcmNlbnQgZGVjb2RlZCBhbmQgd2lsbCBiZSBlbmNvZGVkIGJ5XG4gICAqIHRoaXMgZnVuY3Rpb24uXG4gICopXG4gIGxldCBlbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWUgPyhwY3RfZW5jb2Rlcj1wY3RfZW5jb2RlciAoKSkgbCA9XG4gICAgbGV0IGxlbiA9IExpc3QuZm9sZF9sZWZ0IChmdW4gYSAoayx2KSAtPlxuICAgICAgICBhICsgKFN0cmluZy5sZW5ndGggaylcbiAgICAgICAgKyAoTGlzdC5mb2xkX2xlZnQgKGZ1biBhIHMgLT4gYSsoU3RyaW5nLmxlbmd0aCBzKSsxKSAwIHYpICsgMikgKC0xKSBsIGluXG4gICAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgbGVuIGluXG4gICAgaXRlcl9jb25jYXQgKGZ1biBidWYgKGssdikgLT5cbiAgICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChwY3RfZW5jb2RlID9zY2hlbWUgfmNvbXBvbmVudDpwY3RfZW5jb2Rlci5xdWVyeV9rZXkgayk7XG4gICAgICAgIGlmIHYgPD4gW10gdGhlbiAoXG4gICAgICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnPSc7XG4gICAgICAgICAgaXRlcl9jb25jYXQgKGZ1biBidWYgcyAtPlxuICAgICAgICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBidWZcbiAgICAgICAgICAgICAgICAocGN0X2VuY29kZSA/c2NoZW1lIH5jb21wb25lbnQ6cGN0X2VuY29kZXIucXVlcnlfdmFsdWUgcylcbiAgICAgICAgICAgICkgXCIsXCIgYnVmIHYpXG4gICAgICApIFwiJlwiIGJ1ZiBsO1xuICAgIEJ1ZmZlci5jb250ZW50cyBidWZcblxuICBsZXQgb2ZfcmF3IHFzID1cbiAgICBsZXQgbGF6eV9xdWVyeSA9IExhenkuZnJvbV9mdW4gKGZ1biAoKSAtPiBxdWVyeV9vZl9lbmNvZGVkIHFzKSBpblxuICAgIFJhdyAoU29tZSBxcywgbGF6eV9xdWVyeSlcblxuICBsZXQga3YgPSBmdW5jdGlvbiBSYXcgKF8sIGxhenkga3YpIHwgS1Yga3YgLT4ga3ZcbmVuZFxuXG5sZXQgcXVlcnlfb2ZfZW5jb2RlZCA9IFF1ZXJ5LnF1ZXJ5X29mX2VuY29kZWRcbmxldCBlbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWUgPSBRdWVyeS5lbmNvZGVkX29mX3F1ZXJ5ID9zY2hlbWVcblxuKCogVHlwZSBvZiB0aGUgVVJJLCB3aXRoIG1vc3QgYml0cyBiZWluZyBvcHRpb25hbCAqKVxudHlwZSB0ID0ge1xuICBzY2hlbWU6IFBjdC5kZWNvZGVkIG9wdGlvbjtcbiAgdXNlcmluZm86IFVzZXJpbmZvLnQgb3B0aW9uO1xuICBob3N0OiBbIGBJcHY0X2xpdGVyYWwgb2Ygc3RyaW5nXG4gICAgICAgIHwgYElwdjZfbGl0ZXJhbCBvZiBzdHJpbmdcbiAgICAgICAgfCBgSG9zdCBvZiBQY3QuZGVjb2RlZF0gb3B0aW9uIDtcbiAgcG9ydDogaW50IG9wdGlvbjtcbiAgcGF0aDogUGF0aC50O1xuICBxdWVyeTogUXVlcnkudDtcbiAgZnJhZ21lbnQ6IFBjdC5kZWNvZGVkIG9wdGlvbjtcbn1cblxubGV0IGVtcHR5ID0ge1xuICBzY2hlbWUgPSBOb25lO1xuICB1c2VyaW5mbyA9IE5vbmU7XG4gIGhvc3QgPSBOb25lO1xuICBwb3J0ID0gTm9uZTtcbiAgcGF0aCA9IFtdO1xuICBxdWVyeSA9IFF1ZXJ5LlJhdyAoTm9uZSwgTGF6eS5mcm9tX3ZhbCBbXSk7XG4gIGZyYWdtZW50ID0gTm9uZTtcbn1cblxubGV0IGNvbXBhcmVfZGVjb2RlZCA9IFBjdC51bmxpZnRfZGVjb2RlZDIgU3RyaW5nLmNvbXBhcmVcbmxldCBjb21wYXJlX2RlY29kZWRfb3B0ID0gY29tcGFyZV9vcHQgY29tcGFyZV9kZWNvZGVkXG5sZXQgY29tcGFyZV9ob3N0IGgxIGgyID1cbiAgbWF0Y2ggaDEsIGgyIHdpdGhcbiAgfCBgSXB2NF9saXRlcmFsIGlwMSwgYElwdjRfbGl0ZXJhbCBpcDIgLT4gU3RyaW5nLmNvbXBhcmUgaXAxIGlwMlxuICB8IGBJcHY2X2xpdGVyYWwgaXAxLCBgSXB2Nl9saXRlcmFsIGlwMiAtPiBTdHJpbmcuY29tcGFyZSBpcDEgaXAyXG4gIHwgYEhvc3QgaDEsIGBIb3N0IGgyIC0+IGNvbXBhcmVfZGVjb2RlZCBoMSBoMlxuICB8IF8gLT4gLTFcbmxldCBjb21wYXJlX2hvc3Rfb3B0ID0gY29tcGFyZV9vcHQgY29tcGFyZV9ob3N0XG5cbmxldCBjb21wYXJlIHQgdCcgPVxuICAobWF0Y2ggY29tcGFyZV9ob3N0X29wdCB0Lmhvc3QgdCcuaG9zdCB3aXRoXG4gIHwgMCAtPiAobWF0Y2ggY29tcGFyZV9kZWNvZGVkX29wdCB0LnNjaGVtZSB0Jy5zY2hlbWUgd2l0aFxuICAgIHwgMCAtPiAobWF0Y2ggY29tcGFyZV9vcHQgKGZ1biBwIHAnIC0+XG4gICAgICBpZiBwIDwgcCcgdGhlbiAtMSBlbHNlIGlmIHAgPiBwJyB0aGVuIDEgZWxzZSAwXG4gICAgKSB0LnBvcnQgdCcucG9ydCB3aXRoXG4gICAgICB8IDAgLT4gKG1hdGNoIGNvbXBhcmVfb3B0IFVzZXJpbmZvLmNvbXBhcmUgdC51c2VyaW5mbyB0Jy51c2VyaW5mbyB3aXRoXG4gICAgICAgIHwgMCAtPiAobWF0Y2ggUGF0aC5jb21wYXJlIHQucGF0aCB0Jy5wYXRoIHdpdGhcbiAgICAgICAgICB8IDAgLT4gKG1hdGNoIFF1ZXJ5LmNvbXBhcmUgdC5xdWVyeSB0Jy5xdWVyeSB3aXRoXG4gICAgICAgICAgICB8IDAgLT4gY29tcGFyZV9kZWNvZGVkX29wdCB0LmZyYWdtZW50IHQnLmZyYWdtZW50XG4gICAgICAgICAgICB8IGMgLT4gYylcbiAgICAgICAgICB8IGMgLT4gYylcbiAgICAgICAgfCBjIC0+IGMpXG4gICAgICB8IGMgLT4gYylcbiAgICB8IGMgLT4gYylcbiAgfCBjIC0+IGMpXG5cbmxldCBlcXVhbCB0IHQnID0gY29tcGFyZSB0IHQnID0gMFxuXG5sZXQgdW5jYXN0X29wdCA9IGZ1bmN0aW9uXG4gIHwgU29tZSBoIC0+IFNvbWUgKFBjdC51bmNhc3RfZGVjb2RlZCBoKVxuICB8IE5vbmUgLT4gTm9uZVxuXG5sZXQgbm9ybWFsaXplIHNjaGVtIHVyaSA9XG4gIGxldCBtb2R1bGUgU2NoZW1lID1cbiAgICAodmFsIChtb2R1bGVfb2Zfc2NoZW1lICh1bmNhc3Rfb3B0IHNjaGVtKSkgOiBTY2hlbWUpIGluXG4gIGxldCBkb2IgZiA9IGZ1bmN0aW9uXG4gICAgfCBTb21lIHggLT4gU29tZSAoUGN0LnVubGlmdF9kZWNvZGVkIGYgeClcbiAgICB8IE5vbmUgLT4gTm9uZVxuICBpbiB7dXJpIHdpdGhcbiAgICAgIHNjaGVtZT1kb2IgU3RyaW5nLmxvd2VyY2FzZV9hc2NpaSB1cmkuc2NoZW1lO1xuICAgICAgaG9zdD0gbWF0Y2ggdXJpLmhvc3Qgd2l0aFxuICAgICAgIHwgU29tZSAoYElwdjRfbGl0ZXJhbCBob3N0KSAtPlxuICAgICAgICAgU29tZSAoYElwdjRfbGl0ZXJhbCAoU2NoZW1lLm5vcm1hbGl6ZV9ob3N0IGhvc3QpKVxuICAgICAgIHwgU29tZSAoYElwdjZfbGl0ZXJhbCBob3N0KSAtPlxuICAgICAgICAgU29tZSAoYElwdjZfbGl0ZXJhbCAoU2NoZW1lLm5vcm1hbGl6ZV9ob3N0IGhvc3QpKVxuICAgICAgIHwgU29tZSAoYEhvc3QgaG9zdCkgLT5cbiAgICAgICAgIFNvbWUgKGBIb3N0IChQY3QuY2FzdF9kZWNvZGVkIChTY2hlbWUubm9ybWFsaXplX2hvc3QgKFBjdC51bmNhc3RfZGVjb2RlZCBob3N0KSkpKVxuICAgICAgIHwgTm9uZSAtPiBOb25lXG4gICAgIH1cblxuKCoqIENvbnZlcnQgYSBVUkkgc3RydWN0dXJlIGludG8gYSBwZXJjZW50LWVuY29kZWQgc3RyaW5nXG4gICAgPGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjM+XG4qKVxubGV0IHRvX3N0cmluZyA/KHBjdF9lbmNvZGVyPXBjdF9lbmNvZGVyICgpKSB1cmkgPVxuICBsZXQgc2NoZW1lID0gbWF0Y2ggdXJpLnNjaGVtZSB3aXRoXG4gICAgfCBTb21lIHMgLT4gU29tZSAoUGN0LnVuY2FzdF9kZWNvZGVkIHMpXG4gICAgfCBOb25lIC0+IE5vbmUgaW5cbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgMTI4IGluXG4gICgqIFBlcmNlbnQgZW5jb2RlIGEgZGVjb2RlZCBzdHJpbmcgYW5kIGFkZCBpdCB0byB0aGUgYnVmZmVyICopXG4gIGxldCBhZGRfcGN0X3N0cmluZyA/KGNvbXBvbmVudD1gUGF0aCkgeCA9XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChQY3QudW5jYXN0X2VuY29kZWQgKFBjdC5lbmNvZGUgP3NjaGVtZSB+Y29tcG9uZW50IHgpKVxuICBpblxuICAobWF0Y2ggdXJpLnNjaGVtZSB3aXRoXG4gICB8Tm9uZSAtPiAoKVxuICAgfFNvbWUgeCAtPlxuICAgICBhZGRfcGN0X3N0cmluZyB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnNjaGVtZSB4O1xuICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICc6J1xuICApO1xuICAoKiBVUkkgaGFzIGEgaG9zdCBpZiBhbnkgaG9zdC1yZWxhdGVkIGNvbXBvbmVudCBpcyBzZXQuIERlZmF1bHRzIHRvIFwiXCIuICopXG4gIGlmIChtYXRjaCB1cmkudXNlcmluZm8sIHVyaS5ob3N0LCB1cmkucG9ydCB3aXRoXG4gIHwgU29tZSBfLCBfLCBfIHwgXywgU29tZSBfLCBfIHwgXywgXywgU29tZSBfIC0+IHRydWUgfCBfIC0+IGZhbHNlKVxuICB0aGVuIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiBcIi8vXCI7XG4gIChtYXRjaCB1cmkudXNlcmluZm8gd2l0aFxuICB8Tm9uZSAtPiAoKVxuICB8U29tZSB1c2VyaW5mbyAtPlxuICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZlxuICAgICAgKFBjdC51bmNhc3RfZW5jb2RlZCAoZW5jb2RlZF9vZl91c2VyaW5mbyA/c2NoZW1lIH5jb21wb25lbnQ6cGN0X2VuY29kZXIudXNlcmluZm8gdXNlcmluZm8pKTtcbiAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICdAJ1xuICApO1xuICAobWF0Y2ggdXJpLmhvc3Qgd2l0aFxuICB8Tm9uZSAtPiAoKVxuICB8U29tZSAoYEhvc3QgaG9zdCkgLT5cbiAgICBhZGRfcGN0X3N0cmluZyB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLmhvc3QgaG9zdDtcbiAgfFNvbWUgKGBJcHY0X2xpdGVyYWwgaG9zdCkgLT4gQnVmZmVyLmFkZF9zdHJpbmcgYnVmIGhvc3RcbiAgfFNvbWUgKGBJcHY2X2xpdGVyYWwgaG9zdCkgLT5cbiAgICAgIEJ1ZmZlci5hZGRfY2hhciBidWYgJ1snO1xuICAgICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIGhvc3Q7XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICddJ1xuICApO1xuICAobWF0Y2ggdXJpLnBvcnQgd2l0aFxuICB8Tm9uZSAtPiAoKVxuICB8U29tZSBwb3J0IC0+XG4gICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnOic7XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChzdHJpbmdfb2ZfaW50IHBvcnQpXG4gICk7XG4gIChtYXRjaCB1cmkucGF0aCB3aXRoICgqIEhhbmRsZSByZWxhdGl2ZSBwYXRocyBjb3JyZWN0bHkgKilcbiAgfCBbXSAtPiAoKVxuICB8IFwiL1wiOjpfIC0+XG4gICAgQnVmZmVyLmFkZF9zdHJpbmcgYnVmIChQY3QudW5jYXN0X2VuY29kZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlbmNvZGVkX29mX3BhdGggP3NjaGVtZSB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLnBhdGggdXJpLnBhdGgpKVxuICB8IGZpcnN0X3NlZ21lbnQ6Ol8gLT5cbiAgICAobWF0Y2ggdXJpLmhvc3Qgd2l0aFxuICAgICB8IFNvbWUgXyAtPiBCdWZmZXIuYWRkX2NoYXIgYnVmICcvJ1xuICAgICB8IE5vbmUgLT5cbiAgICAgICAoKiBlbnN1cmUgcm91bmR0cmlwIGJ5IGZvcmNpbmcgcmVsYXRpdmUgcGF0aCBpbnRlcnByZXRhdGlvbiBub3Qgc2NoZW1lICopXG4gICAgICAgbWF0Y2ggU3RyaW5nZXh0LmZpbmRfZnJvbSBmaXJzdF9zZWdtZW50IH5wYXR0ZXJuOlwiOlwiIHdpdGhcbiAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgICB8IFNvbWUgXyAtPiBtYXRjaCBzY2hlbWUgd2l0aFxuICAgICAgICAgfCBTb21lIF8gLT4gKClcbiAgICAgICAgIHwgTm9uZSAtPiBCdWZmZXIuYWRkX3N0cmluZyBidWYgXCIuL1wiXG4gICAgKTtcbiAgICBCdWZmZXIuYWRkX3N0cmluZyBidWZcbiAgICAgIChQY3QudW5jYXN0X2VuY29kZWQgKGVuY29kZWRfb2ZfcGF0aCA/c2NoZW1lIH5jb21wb25lbnQ6cGN0X2VuY29kZXIucGF0aCB1cmkucGF0aCkpXG4gICk7XG4gIFF1ZXJ5LihtYXRjaCB1cmkucXVlcnkgd2l0aFxuICAgIHwgUmF3IChOb25lLF8pIHwgS1YgW10gLT4gKClcbiAgICB8IFJhdyAoXyxsYXp5IHEpIHwgS1YgcSAtPiAoKiBub3JtYWxpemUgZS5nLiBwZXJjZW50IGNhcGl0YWxpemF0aW9uICopXG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmICc/JztcbiAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiAoZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lIH5wY3RfZW5jb2RlciBxKVxuICApO1xuICAobWF0Y2ggdXJpLmZyYWdtZW50IHdpdGhcbiAgIHxOb25lIC0+ICgpXG4gICB8U29tZSBmIC0+IEJ1ZmZlci5hZGRfY2hhciBidWYgJyMnOyBhZGRfcGN0X3N0cmluZyB+Y29tcG9uZW50OnBjdF9lbmNvZGVyLmZyYWdtZW50IGZcbiAgKTtcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuXG4oKiBWYXJpb3VzIGFjY2Vzc29yIGZ1bmN0aW9ucywgYXMgdGhlIGV4dGVybmFsIHVyaSB0eXBlIGlzIGFic3RyYWN0ICAqKVxubGV0IGdldF9kZWNvZGVkX29wdCA9IGZ1bmN0aW9uIE5vbmUgLT4gTm9uZSB8U29tZSB4IC0+IFNvbWUgKFBjdC51bmNhc3RfZGVjb2RlZCB4KVxubGV0IHNjaGVtZSB1cmkgPSBnZXRfZGVjb2RlZF9vcHQgdXJpLnNjaGVtZVxubGV0IHdpdGhfc2NoZW1lIHVyaSA9XG4gIGZ1bmN0aW9uXG4gIHxTb21lIHNjaGVtZSAtPiB7IHVyaSB3aXRoIHNjaGVtZT1Tb21lIChQY3QuY2FzdF9kZWNvZGVkIHNjaGVtZSkgfVxuICB8Tm9uZSAtPiB7IHVyaSB3aXRoIHNjaGVtZT1Ob25lIH1cblxubGV0IGhvc3QgdXJpID1cbiAgbWF0Y2ggdXJpLmhvc3Qgd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgKGBJcHY0X2xpdGVyYWwgaCB8IGBJcHY2X2xpdGVyYWwgaCkgLT4gU29tZSBoXG4gIHwgU29tZSAoYEhvc3QgaCkgLT4gU29tZSAoUGN0LnVuY2FzdF9kZWNvZGVkIGgpXG5cbmxldCBob3N0X3dpdGhfZGVmYXVsdCA/KGRlZmF1bHQ9XCJsb2NhbGhvc3RcIikgdXJpID1cbiAgbWF0Y2ggaG9zdCB1cmkgd2l0aFxuICB8Tm9uZSAtPiBkZWZhdWx0XG4gIHxTb21lIGggLT4gaFxuXG5sZXQgdXNlcmluZm8gPyhwY3RfZW5jb2Rlcj1wY3RfZW5jb2RlciAoKSkgdXJpID0gbWF0Y2ggdXJpLnVzZXJpbmZvIHdpdGhcbiAgfCBOb25lIC0+IE5vbmVcbiAgfCBTb21lIHVzZXJpbmZvIC0+IFNvbWUgKFBjdC51bmNhc3RfZW5jb2RlZCAobWF0Y2ggdXJpLnNjaGVtZSB3aXRoXG4gICAgfCBOb25lIC0+IGVuY29kZWRfb2ZfdXNlcmluZm8gfmNvbXBvbmVudDpwY3RfZW5jb2Rlci51c2VyaW5mbyB1c2VyaW5mb1xuICAgIHwgU29tZSBzIC0+IGVuY29kZWRfb2ZfdXNlcmluZm8gfnNjaGVtZTooUGN0LnVuY2FzdF9kZWNvZGVkIHMpIH5jb21wb25lbnQ6cGN0X2VuY29kZXIudXNlcmluZm8gdXNlcmluZm8pKVxubGV0IHdpdGhfdXNlcmluZm8gdXJpIHVzZXJpbmZvID1cbiAgbGV0IHVzZXJpbmZvID0gbWF0Y2ggdXNlcmluZm8gd2l0aFxuICAgIHwgU29tZSB1IC0+IFNvbWUgKHVzZXJpbmZvX29mX2VuY29kZWQgdSlcbiAgICB8IE5vbmUgLT4gTm9uZVxuICBpblxuICBtYXRjaCBob3N0IHVyaSB3aXRoXG4gIHwgTm9uZSAtPiB7IHVyaSB3aXRoIGhvc3Q9U29tZSAoYEhvc3QgKFBjdC5jYXN0X2RlY29kZWQgXCJcIikpOyB1c2VyaW5mbz11c2VyaW5mbyB9XG4gIHwgU29tZSBfIC0+IHsgdXJpIHdpdGggdXNlcmluZm89dXNlcmluZm8gfVxuXG5sZXQgdXNlciB1cmkgPSBtYXRjaCB1cmkudXNlcmluZm8gd2l0aFxuICB8IE5vbmUgLT4gTm9uZVxuICB8IFNvbWUgKHVzZXIsIF8pIC0+IFNvbWUgdXNlclxuXG5sZXQgcGFzc3dvcmQgdXJpID0gbWF0Y2ggdXJpLnVzZXJpbmZvIHdpdGhcbiAgfCBOb25lIHwgU29tZSAoXywgTm9uZSkgLT4gTm9uZVxuICB8IFNvbWUgKF8sIFNvbWUgcGFzcykgLT4gU29tZSBwYXNzXG5sZXQgd2l0aF9wYXNzd29yZCB1cmkgcGFzc3dvcmQgPVxuICBsZXQgcmVzdWx0IHVzZXJpbmZvID0gbWF0Y2ggaG9zdCB1cmkgd2l0aFxuICAgIHwgTm9uZSAtPiB7IHVyaSB3aXRoIGhvc3Q9U29tZSAoYEhvc3QgKFBjdC5jYXN0X2RlY29kZWQgXCJcIikpOyB1c2VyaW5mbz11c2VyaW5mbyB9XG4gICAgfCBTb21lIF8gLT4geyB1cmkgd2l0aCB1c2VyaW5mbz11c2VyaW5mbyB9XG4gIGluXG4gIG1hdGNoIHVyaS51c2VyaW5mbywgcGFzc3dvcmQgd2l0aFxuICB8IE5vbmUsIE5vbmUgLT4gdXJpXG4gIHwgTm9uZSwgU29tZSBfIC0+IHJlc3VsdCAoU29tZSAoXCJcIixwYXNzd29yZCkpXG4gIHwgU29tZSAodXNlcixfKSwgXyAtPiByZXN1bHQgKFNvbWUgKHVzZXIsIHBhc3N3b3JkKSlcblxubGV0IHBvcnQgdXJpID0gdXJpLnBvcnRcbmxldCB3aXRoX3BvcnQgdXJpIHBvcnQgPVxuICBtYXRjaCBob3N0IHVyaSB3aXRoXG4gIHwgU29tZSBfIC0+IHsgdXJpIHdpdGggcG9ydD1wb3J0IH1cbiAgfCBOb25lIC0+IGJlZ2luXG4gICAgIG1hdGNoIHBvcnQgd2l0aFxuICAgICB8IE5vbmUgLT4geyB1cmkgd2l0aCBob3N0PU5vbmU7IHBvcnQ9Tm9uZSB9XG4gICAgIHwgU29tZSBfIC0+IHsgdXJpIHdpdGggaG9zdD1Tb21lIChgSG9zdCAoUGN0LmNhc3RfZGVjb2RlZCBcIlwiKSk7IHBvcnQ9cG9ydCB9XG4gIGVuZFxuXG4oKiBSZXR1cm4gdGhlIHBhdGggY29tcG9uZW50ICopXG5sZXQgcGF0aCA/KHBjdF9lbmNvZGVyPXBjdF9lbmNvZGVyICgpKSB1cmkgPSBQY3QudW5jYXN0X2VuY29kZWQgKG1hdGNoIHVyaS5zY2hlbWUgd2l0aFxuICB8IE5vbmUgLT4gZW5jb2RlZF9vZl9wYXRoIH5jb21wb25lbnQ6cGN0X2VuY29kZXIucGF0aCB1cmkucGF0aFxuICB8IFNvbWUgcyAtPiBlbmNvZGVkX29mX3BhdGggfnNjaGVtZTooUGN0LnVuY2FzdF9kZWNvZGVkIHMpIH5jb21wb25lbnQ6cGN0X2VuY29kZXIucGF0aCB1cmkucGF0aClcbmxldCB3aXRoX3BhdGggdXJpIHBhdGggPVxuICBsZXQgcGF0aCA9IHBhdGhfb2ZfZW5jb2RlZCBwYXRoIGluXG4gIG1hdGNoIGhvc3QgdXJpLCBwYXRoIHdpdGhcbiAgfCBOb25lLCBfIHwgU29tZSBfLCBcIi9cIjo6XyB8IFNvbWUgXywgW10gLT4geyB1cmkgd2l0aCBwYXRoPXBhdGggfVxuICB8IFNvbWUgXywgXyAgLT4geyB1cmkgd2l0aCBwYXRoPVwiL1wiOjpwYXRoIH1cblxubGV0IGZyYWdtZW50IHVyaSA9IGdldF9kZWNvZGVkX29wdCB1cmkuZnJhZ21lbnRcbmxldCB3aXRoX2ZyYWdtZW50IHVyaSA9XG4gIGZ1bmN0aW9uXG4gIHxOb25lIC0+IHsgdXJpIHdpdGggZnJhZ21lbnQ9Tm9uZSB9XG4gIHxTb21lIGZyYWcgLT4geyB1cmkgd2l0aCBmcmFnbWVudD1Tb21lIChQY3QuY2FzdF9kZWNvZGVkIGZyYWcpIH1cblxubGV0IHF1ZXJ5IHVyaSA9IFF1ZXJ5Lmt2IHVyaS5xdWVyeVxubGV0IHZlcmJhdGltX3F1ZXJ5ID8ocGN0X2VuY29kZXI9cGN0X2VuY29kZXIgKCkpIHVyaSA9IFF1ZXJ5LihtYXRjaCB1cmkucXVlcnkgd2l0aFxuICB8IFJhdyAocXMsXykgLT4gcXNcbiAgfCBLViBbXSAtPiBOb25lXG4gIHwgS1Yga3YgLT4gU29tZSAoZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lOihzY2hlbWUgdXJpKSB+cGN0X2VuY29kZXIga3YpXG4pXG5sZXQgZ2V0X3F1ZXJ5X3BhcmFtJyB1cmkgayA9IFF1ZXJ5LihmaW5kIChrdiB1cmkucXVlcnkpIGspXG5sZXQgZ2V0X3F1ZXJ5X3BhcmFtIHVyaSBrID1cbiAgbWF0Y2ggZ2V0X3F1ZXJ5X3BhcmFtJyB1cmkgayB3aXRoXG4gIHxOb25lIC0+IE5vbmVcbiAgfFNvbWUgdiAtPiBTb21lIChTdHJpbmcuY29uY2F0IFwiLFwiIHYpXG5cbmxldCB3aXRoX3F1ZXJ5IHVyaSBxdWVyeSA9IHsgdXJpIHdpdGggcXVlcnk9UXVlcnkuS1YgcXVlcnkgfVxubGV0IHFfcyBxID0gTGlzdC5tYXAgKGZ1biAoayx2KSAtPiBrLFt2XSkgcVxubGV0IHdpdGhfcXVlcnknIHVyaSBxdWVyeSA9IHdpdGhfcXVlcnkgdXJpIChxX3MgcXVlcnkpXG5sZXQgYWRkX3F1ZXJ5X3BhcmFtIHVyaSBwID0gUXVlcnkuKHsgdXJpIHdpdGggcXVlcnk9S1YgKHA6OihrdiB1cmkucXVlcnkpKSB9KVxubGV0IGFkZF9xdWVyeV9wYXJhbScgdXJpIChrLHYpID1cbiAgUXVlcnkuKHsgdXJpIHdpdGggcXVlcnk9S1YgKChrLFt2XSk6OihrdiB1cmkucXVlcnkpKSB9KVxubGV0IGFkZF9xdWVyeV9wYXJhbXMgdXJpIHBzID0gUXVlcnkuKHsgdXJpIHdpdGggcXVlcnk9S1YgKHBzQChrdiB1cmkucXVlcnkpKSB9KVxubGV0IGFkZF9xdWVyeV9wYXJhbXMnIHVyaSBwcyA9XG4gIFF1ZXJ5Lih7IHVyaSB3aXRoIHF1ZXJ5PUtWICgocV9zIHBzKUAoa3YgdXJpLnF1ZXJ5KSkgfSlcbmxldCByZW1vdmVfcXVlcnlfcGFyYW0gdXJpIGsgPSBRdWVyeS4oXG4gIHsgdXJpIHdpdGggcXVlcnk9S1YgKExpc3QuZmlsdGVyIChmdW4gKGsnLF8pIC0+IGs8PmsnKSAoa3YgdXJpLnF1ZXJ5KSkgfVxuKVxuXG4oKiBDb25zdHJ1Y3QgZW5jb2RlZCBwYXRoIGFuZCBxdWVyeSBjb21wb25lbnRzICopXG5sZXQgcGF0aF9hbmRfcXVlcnkgdXJpID1cbiAgbWF0Y2ggKHBhdGggdXJpKSwgKHF1ZXJ5IHVyaSkgd2l0aFxuICB8XCJcIiwgW10gLT4gXCIvXCIgKCogVE9ETzogV2hhdCBhYm91dCBzYW1lIGRvY3VtZW50PyAoLykgKilcbiAgfFwiXCIsIHEgLT4gKCogVE9ETzogV2hhdCBhYm91dCBzYW1lIGRvY3VtZW50PyAoLykgKilcbiAgICBsZXQgc2NoZW1lID0gdW5jYXN0X29wdCB1cmkuc2NoZW1lIGluXG4gICAgUHJpbnRmLnNwcmludGYgXCIvPyVzXCIgKGVuY29kZWRfb2ZfcXVlcnkgP3NjaGVtZSBxKVxuICB8cCwgW10gLT4gcFxuICB8cCwgcSAtPlxuICAgIGxldCBzY2hlbWUgPSB1bmNhc3Rfb3B0IHVyaS5zY2hlbWUgaW5cbiAgICBQcmludGYuc3ByaW50ZiBcIiVzPyVzXCIgcCAoZW5jb2RlZF9vZl9xdWVyeSA/c2NoZW1lIHEpXG5cbigqIFRPRE86IGZ1bmN0aW9ucyB0byBhZGQgYW5kIHJlbW92ZSBmcm9tIGEgVVJJICopXG5cbigqIFJlc29sdmUgYSBVUkkgd3J0IGEgYmFzZSBVUkkgPGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzM5ODYjc2VjdGlvbi01LjI+ICopXG5sZXQgcmVzb2x2ZSBzY2hlbSBiYXNlIHVyaSA9XG4gIGxldCBzY2hlbSA9IFNvbWUgKFBjdC5jYXN0X2RlY29kZWQgKG1hdGNoIHNjaGVtZSBiYXNlIHdpdGhcbiAgICAgIHwgTm9uZSAtPiAgc2NoZW1cbiAgICAgIHwgU29tZSBzY2hlbWUgLT4gc2NoZW1lXG4gICAgKSkgaW5cbiAgbm9ybWFsaXplIHNjaGVtXG4gICAgUGF0aC4obWF0Y2ggc2NoZW1lIHVyaSwgdXNlcmluZm8gdXJpLCBob3N0IHVyaSB3aXRoXG4gICAgfCBTb21lIF8sIF8sIF8gLT5cbiAgICAgIHt1cmkgd2l0aCBwYXRoPXJlbW92ZV9kb3Rfc2VnbWVudHMgdXJpLnBhdGh9XG4gICAgfCBOb25lLCBTb21lIF8sIF9cbiAgICB8IE5vbmUsIF8sIFNvbWUgXyAtPlxuICAgICAge3VyaSB3aXRoIHNjaGVtZT1iYXNlLnNjaGVtZTsgcGF0aD1yZW1vdmVfZG90X3NlZ21lbnRzIHVyaS5wYXRofVxuICAgIHwgTm9uZSwgTm9uZSwgTm9uZSAtPlxuICAgICAgbGV0IHVyaSA9IHt1cmkgd2l0aCBzY2hlbWU9YmFzZS5zY2hlbWU7IHVzZXJpbmZvPWJhc2UudXNlcmluZm87XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGhvc3Q9YmFzZS5ob3N0OyBwb3J0PWJhc2UucG9ydH0gaW5cbiAgICAgIGxldCBwYXRoX3N0ciA9IHBhdGggdXJpIGluXG4gICAgICBpZiBwYXRoX3N0cj1cIlwiXG4gICAgICB0aGVuIHsgdXJpIHdpdGhcbiAgICAgICAgICAgICBwYXRoPWJhc2UucGF0aDtcbiAgICAgICAgICAgICBxdWVyeT1tYXRjaCB1cmkucXVlcnkgd2l0aFxuICAgICAgICAgICAgICAgfCBRdWVyeS5SYXcgKE5vbmUsXykgfCBRdWVyeS5LViBbXSAtPiBiYXNlLnF1ZXJ5XG4gICAgICAgICAgICAgICB8IF8gLT4gdXJpLnF1ZXJ5XG4gICAgICAgICAgIH1cbiAgICAgIGVsc2UgaWYgcGF0aF9zdHIuWzBdPScvJ1xuICAgICAgdGhlbiB7dXJpIHdpdGggcGF0aD1yZW1vdmVfZG90X3NlZ21lbnRzIHVyaS5wYXRofVxuICAgICAgZWxzZSB7dXJpIHdpdGhcbiAgICAgICAgcGF0aD1yZW1vdmVfZG90X3NlZ21lbnRzIChtZXJnZSBiYXNlLmhvc3QgYmFzZS5wYXRoIHVyaS5wYXRoKTtcbiAgICAgIH1cbiAgICApXG5cbmxldCBjYW5vbmljYWxpemUgdXJpID1cbiAgbGV0IHVyaSA9IHJlc29sdmUgXCJcIiBlbXB0eSB1cmkgaW5cbiAgbGV0IG1vZHVsZSBTY2hlbWUgPVxuICAgICh2YWwgKG1vZHVsZV9vZl9zY2hlbWUgKHVuY2FzdF9vcHQgdXJpLnNjaGVtZSkpIDogU2NoZW1lKSBpblxuICB7IHVyaSB3aXRoXG4gICAgcG9ydD1TY2hlbWUuY2Fub25pY2FsaXplX3BvcnQgdXJpLnBvcnQ7XG4gICAgcGF0aD1TY2hlbWUuY2Fub25pY2FsaXplX3BhdGggdXJpLnBhdGg7XG4gIH1cblxubGV0IHBwIHBwZiB1cmkgPSBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIHBwZiAodG9fc3RyaW5nIHVyaSlcbmxldCBwcF9odW0gcHBmIHVyaSA9IEZvcm1hdC5wcF9wcmludF9zdHJpbmcgcHBmICh0b19zdHJpbmcgdXJpKVxuXG5tb2R1bGUgUGFyc2VyID0gc3RydWN0XG4gIG9wZW4gQW5nc3Ryb21cblxuICBsZXQgc3RyaW5nX29mX2NoYXIgPSBTdHJpbmcubWFrZSAxXG5cbiAgbGV0IHN0cmluZ19vZl9jaGFyX2xpc3QgY2hhcnMgPVxuICAgIFN0cmluZy5jb25jYXQgXCJcIiAoTGlzdC5tYXAgc3RyaW5nX29mX2NoYXIgY2hhcnMpXG5cbiAgbGV0IHNjaGVtZSA9XG4gICAgbGlmdFxuICAgICAgKGZ1biBzIC0+IFNvbWUgKFBjdC5kZWNvZGUgKFBjdC5jYXN0X2VuY29kZWQgcykpKVxuICAgICAgKHRha2Vfd2hpbGUgKGZ1biBjIC0+IGMgPD4gJzonICYmIGMgPD4gJy8nICYmIGMgPD4gJz8nICYmIGMgPD4gJyMnKVxuICAgICAgPCogY2hhciAnOicpXG4gICAgPHw+IHJldHVybiBOb25lXG5cbiAgbGV0IGlzX2RpZ2l0ID0gZnVuY3Rpb24gJzAnIC4uICc5JyAtPiB0cnVlIHwgXyAtPiBmYWxzZVxuXG4gIGxldCBoZXhfZGlnaXQgPVxuICAgIHNhdGlzZnkgKGZ1bmN0aW9uXG4gICAgICAgIHwgJzAnIC4uICc5JyB8ICdBJyAuLiAnRicgfCAnYScgLi4gJ2YnIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBmYWxzZSlcblxuICBsZXQgaGV4YWRlY2ltYWwgPSBsaWZ0IHN0cmluZ19vZl9jaGFyX2xpc3QgKG1hbnkgaGV4X2RpZ2l0KVxuXG4gIGxldCBjX2RvdCA9IGNoYXIgJy4nXG5cbiAgbGV0IGNfYXQgPSBjaGFyICdAJ1xuXG4gIGxldCBjX2NvbG9uID0gY2hhciAnOidcblxuICBsZXQgZGVjX29jdGV0ID1cbiAgICB0YWtlX3doaWxlMSAoZnVuY3Rpb24gJzAnIC4uICc5JyAtPiB0cnVlIHwgXyAtPiBmYWxzZSkgPj49IGZ1biBudW0gLT5cbiAgICBpZiBpbnRfb2Zfc3RyaW5nIG51bSA8IDI1NiB0aGVuXG4gICAgICByZXR1cm4gbnVtXG4gICAgZWxzZVxuICAgICAgZmFpbCBcImludmFsaWQgb2N0ZWN0XCJcblxuICBsZXQgaXB2NF9hZGRyZXNzID1cbiAgICBsaWZ0MlxuICAgICAgKGZ1biB0aHJlZSBvbmUgLT4gU3RyaW5nLmNvbmNhdCBcIi5cIiB0aHJlZSBeIFwiLlwiIF4gb25lKVxuICAgICAgKGNvdW50IDMgKGRlY19vY3RldCA8KiBjX2RvdCkpXG4gICAgICBkZWNfb2N0ZXRcblxuICAoKiAtLSBhZnRlciBkb3VibGUgY29sb24sIElQdjQgZG90dGVkIG5vdGF0aW9uIGNvdWxkIGFwcGVhciBhbnl3aGVyZSAqKVxuICBsZXQgYWZ0ZXJfZG91YmxlX2NvbG9uID1cbiAgICBmaXggKGZ1biBmIC0+XG4gICAgICAgIGxpc3QgWyBpcHY0X2FkZHJlc3MgXVxuICAgICAgICA8fD4gbGlmdDIgKGZ1biB4IHkgLT4geCA6OiB5KSBoZXhhZGVjaW1hbCAoY19jb2xvbiAqPiBmIDx8PiByZXR1cm4gW10pKVxuXG4gIGxldCBkb3VibGVfY29sb24gY291bnQgPVxuICAgIGFmdGVyX2RvdWJsZV9jb2xvbiA+Pj0gKGZ1biByZXN0IC0+XG4gICAgbGV0IGZpbGxlcl9sZW5ndGggPSA4IC0gY291bnQgLSBMaXN0Lmxlbmd0aCByZXN0IGluXG4gICAgaWYgZmlsbGVyX2xlbmd0aCA8PSAwIHRoZW5cbiAgICAgIGZhaWwgXCJ0b28gbWFueSBwYXJ0cyBpbiBJUHY2IGFkZHJlc3NcIlxuICAgIGVsc2VcbiAgICAgIHJldHVybiAoXCJcIiA6OiByZXN0KSlcbiAgICA8fD4gcmV0dXJuIFtcIlwiXVxuXG4gIGxldCByZWMgcGFydCA9IGZ1bmN0aW9uXG4gICAgfCA3IC0+XG4gICAgICAoKiBtYXggOCBwYXJ0cyBpbiBhbiBJUHY2IGFkZHJlc3MgKilcbiAgICAgIGxpZnQgKGZ1biB4IC0+IFsgeCBdKSBoZXhhZGVjaW1hbFxuICAgIHwgNiAtPlxuICAgICAgKCogYWZ0ZXIgNiBwYXJ0cyBpdCBjb3VsZCBlbmQgaW4gSVB2NCBkb3R0ZWQgbm90YXRpb24gKilcbiAgICAgIGxpc3QgWyBpcHY0X2FkZHJlc3MgXSA8fD4gaGV4X3BhcnQgNlxuICAgIHwgbiAtPlxuICAgICAgaGV4X3BhcnQgblxuXG4gIGFuZCBoZXhfcGFydCBuID1cbiAgICBsaWZ0MlxuICAgICAgKGZ1biB4IHkgLT4geCA6OiB5KVxuICAgICAgaGV4YWRlY2ltYWxcbiAgICAgIChjX2NvbG9uICo+IChjX2NvbG9uICo+IGRvdWJsZV9jb2xvbiAobiArIDEpIDx8PiBwYXJ0IChuICsgMSkpKVxuXG4gIGxldCByZWMgc3BsaXRfd2l0aCBmIHhzID1cbiAgICBtYXRjaCB4cyB3aXRoXG4gICAgfCBbXSAtPlxuICAgICAgW10sIFtdXG4gICAgfCB5IDo6IHlzIC0+XG4gICAgICBpZiBmIHkgdGhlblxuICAgICAgICBsZXQgenMsIHRzID0gc3BsaXRfd2l0aCBmIHlzIGluXG4gICAgICAgIHkgOjogenMsIHRzXG4gICAgICBlbHNlXG4gICAgICAgIFtdLCB4c1xuXG4gIGxldCBpcHY2ID1cbiAgICBsZXQgZm9ybWF0X2FkZHIgc2VnbWVudHMgPVxuICAgICAgbGV0IGJlZm9yZV9kb3VibGVfY29sb24sIGFmdGVyX2RvdWJsZV9jb2xvbiA9XG4gICAgICAgIHNwbGl0X3dpdGggKGZ1biBzZWdtZW50IC0+IHNlZ21lbnQgPD4gXCJcIikgc2VnbWVudHNcbiAgICAgIGluXG4gICAgICBsZXQgYmVmb3JlID0gU3RyaW5nLmNvbmNhdCBcIjpcIiBiZWZvcmVfZG91YmxlX2NvbG9uIGluXG4gICAgICBsZXQgcmVzID1cbiAgICAgICAgbWF0Y2ggYWZ0ZXJfZG91YmxlX2NvbG9uIHdpdGhcbiAgICAgICAgfCBcIlwiIDo6IHhzIC0+XG4gICAgICAgICAgYmVmb3JlIF4gXCI6OlwiIF4gU3RyaW5nLmNvbmNhdCBcIjpcIiB4c1xuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBiZWZvcmVcbiAgICAgIGluXG4gICAgICByZXNcbiAgICBpblxuICAgIGxpZnQgZm9ybWF0X2FkZHIgKGNfY29sb24gKj4gY19jb2xvbiAqPiBkb3VibGVfY29sb24gMCA8fD4gcGFydCAwKVxuXG4gIGxldCBpcHY2X2FkZHJlc3MgPVxuICAgIChjaGFyICdbJykgKj4gaXB2NiA8KiAoY2hhciAnXScpXG5cbiAgbGV0IHBjdF9lbmNvZGVkID1cbiAgICBsaWZ0MlxuICAgICAgKGZ1biBwY3QgZGlnaXRzIC0+IHN0cmluZ19vZl9jaGFyX2xpc3QgKHBjdCA6OiBkaWdpdHMpKVxuICAgICAgKGNoYXIgJyUnKVxuICAgICAgKGNvdW50IDIgaGV4X2RpZ2l0KVxuXG4gIGxldCBzdWJfZGVsaW1zID1cbiAgICBzYXRpc2Z5IChmdW5jdGlvblxuICAgICAgICB8ICchJyB8ICckJyB8ICcmJyB8ICdcXCcnIHwgJygnIHwgJyknIHwgJyonIHwgJysnIHwgJywnIHwgJzsnIHwgJz0nIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBmYWxzZSlcblxuICBsZXQgdW5yZXNlcnZlZCA9XG4gICAgKCogXCJbQS1aYS16MC05LS5ffl1cIiAqKVxuICAgIHNhdGlzZnkgKGZ1bmN0aW9uXG4gICAgICAgIHwgJ0EnIC4uICdaJyB8ICdhJyAuLiAneicgfCAnMCcgLi4gJzknIHwgJy0nIHwgJy4nIHwgJ18nIHwgJ34nIC0+XG4gICAgICAgICAgdHJ1ZVxuICAgICAgICB8IF8gLT5cbiAgICAgICAgICBmYWxzZSlcblxuICBsZXQgcmVnX25hbWUgPVxuICAgIGxpZnRcbiAgICAgIChTdHJpbmcuY29uY2F0IFwiXCIpXG4gICAgICAobWFueVxuICAgICAgICAgKGNob2ljZVxuICAgICAgICAgICAgWyBzdHJpbmdfb2ZfY2hhciA8JD4gdW5yZXNlcnZlZFxuICAgICAgICAgICAgOyBwY3RfZW5jb2RlZFxuICAgICAgICAgICAgOyBzdHJpbmdfb2ZfY2hhciA8JD4gc3ViX2RlbGltc1xuICAgICAgICAgICAgXSkpXG5cbiAgbGV0IGhvc3QgPVxuICAgIGNob2ljZVxuICAgICAgWyBpcHY0X2FkZHJlc3MgPj58IChmdW4gaCAtPiBgSXB2NF9saXRlcmFsIGgpXG4gICAgICA7IGlwdjZfYWRkcmVzcyA+PnwgKGZ1biBoIC0+IGBJcHY2X2xpdGVyYWwgaClcbiAgICAgIDsgcmVnX25hbWUgPj58IChmdW4gcyAtPiBgSG9zdCAoUGN0LmRlY29kZSAoUGN0LmNhc3RfZW5jb2RlZCBzKSkpXG4gICAgICAoKiBUT0RPKGRpbm9zYXVyZSk6IEFjY29yZGluZyB0byBSRkMzOTg2OlxuXG4gICAgICAgICBob3N0ICAgICAgICA9IElQLWxpdGVyYWwgLyBJUHY0YWRkcmVzcyAvIHJlZy1uYW1lXG4gICAgICAgICBJUC1saXRlcmFsICA9IFwiW1wiICggSVB2NmFkZHJlc3MgLyBJUHZGdXR1cmUgICkgXCJdXCJcbiAgICAgICAgIElQdkZ1dHVyZSAgID0gXCJ2XCIgMSpIRVhESUcgXCIuXCIgMSooIHVucmVzZXJ2ZWQgLyBzdWItZGVsaW1zIC8gXCI6XCIgKVxuXG4gICAgICAgICBJUHZGdXR1cmUgaXMgbm90IGltcGxlbWVudGVkLiBXZSBzaG91bGQgaGFuZGxlIGl0OlxuXG4gICAgICAgICBJUHZGdXR1cmUgICA9IFwidlwiIDEqSEVYRElHIFwiLlwiIDEqKCB1bnJlc2VydmVkIC8gc3ViLWRlbGltcyAvIFwiOlwiIClcbiAgICAgICAqKVxuICAgICAgXVxuXG4gIGxldCB1c2VyaW5mbyA9XG4gICAgbGlmdFxuICAgICAgKGZ1biB4IC0+XG4gICAgICAgIGxldCBzID0gU3RyaW5nLmNvbmNhdCBcIlwiIHggaW5cbiAgICAgICAgU29tZSAoVXNlcmluZm8udXNlcmluZm9fb2ZfZW5jb2RlZCBzKSlcbiAgICAgIChtYW55XG4gICAgICAgICAoY2hvaWNlXG4gICAgICAgICAgICBbIHN0cmluZ19vZl9jaGFyIDwkPiB1bnJlc2VydmVkXG4gICAgICAgICAgICA7IHBjdF9lbmNvZGVkXG4gICAgICAgICAgICA7IHN0cmluZ19vZl9jaGFyIDwkPiBzdWJfZGVsaW1zXG4gICAgICAgICAgICA7IHN0cmluZ19vZl9jaGFyIDwkPiBjX2NvbG9uXG4gICAgICAgICAgICBdKVxuICAgICAgPCogY19hdClcbiAgICA8fD4gcmV0dXJuIE5vbmVcblxuICBsZXQgcG9ydCA9XG4gICAgcGVla19jaGFyID4+PSBmdW5jdGlvblxuICAgIHwgU29tZSAnOicgLT5cbiAgICAgIGNfY29sb24gKj4gdGFrZV93aGlsZSBpc19kaWdpdCA+PnwgZnVuIHBvcnQgLT5cbiAgICAgIGxldCBkZWNvZGVkID0gUGN0LmRlY29kZSAoUGN0LmNhc3RfZW5jb2RlZCBwb3J0KSBpblxuICAgICAgKHRyeSBTb21lIChpbnRfb2Zfc3RyaW5nIChQY3QudW5jYXN0X2RlY29kZWQgZGVjb2RlZCkpIHdpdGggXyAtPiBOb25lKVxuICAgIHwgU29tZSBfIHwgTm9uZSAtPlxuICAgICAgcmV0dXJuIE5vbmVcblxuICBsZXQgYXV0aG9yaXR5ID1cbiAgICBzdHJpbmcgXCIvL1wiXG4gICAgKj4gbGlmdDNcbiAgICAgICAgIChmdW4gdXNlcmluZm8gaG9zdCBwb3J0IC0+XG4gICAgICAgICAgIHVzZXJpbmZvLCBTb21lIGhvc3QsIHBvcnQpXG4gICAgICAgICB1c2VyaW5mb1xuICAgICAgICAgaG9zdFxuICAgICAgICAgcG9ydFxuICAgIDx8PiByZXR1cm4gKE5vbmUsIE5vbmUsIE5vbmUpXG5cbiAgbGV0IHBhdGggPVxuICAgIGxpZnRcbiAgICAgIFBhdGgucGF0aF9vZl9lbmNvZGVkXG4gICAgICAodGFrZV93aGlsZSAoZnVuY3Rpb24gJz8nIHwgJyMnIC0+IGZhbHNlIHwgXyAtPiB0cnVlKSlcblxuICBsZXQgcXVlcnkgPVxuICAgIGxpZnRcbiAgICAgIFF1ZXJ5Lm9mX3Jhd1xuICAgICAgKGNoYXIgJz8nICo+IHRha2VfdGlsbCAoZnVuY3Rpb24gJyMnIC0+IHRydWUgfCBfIC0+IGZhbHNlKSlcbiAgICA8fD4gcmV0dXJuIChRdWVyeS5SYXcgKE5vbmUsIExhenkuZnJvbV92YWwgW10pKVxuXG4gIGxldCBmcmFnbWVudCA9XG4gICAgbGlmdFxuICAgICAgKGZ1biBzIC0+IFNvbWUgKFBjdC5kZWNvZGUgKFBjdC5jYXN0X2VuY29kZWQgcykpKVxuICAgICAgKGNoYXIgJyMnICo+IHRha2Vfd2hpbGUgKGZ1biBfIC0+IHRydWUpKVxuICAgIDx8PiByZXR1cm4gTm9uZVxuXG4gIGxldCBfdXJpX3JlZmVyZW5jZSA9XG4gICAgbGlmdDRcbiAgICAgIChmdW4gc2NoZW1lICh1c2VyaW5mbywgaG9zdCwgcG9ydCkgcGF0aCBxdWVyeSBmcmFnbWVudCAtPlxuICAgICAgICBub3JtYWxpemUgc2NoZW1lIHsgc2NoZW1lOyB1c2VyaW5mbzsgaG9zdDsgcG9ydDsgcGF0aDsgcXVlcnk7IGZyYWdtZW50IH0pXG4gICAgICBzY2hlbWVcbiAgICAgIGF1dGhvcml0eVxuICAgICAgcGF0aFxuICAgICAgcXVlcnlcbiAgICA8Kj4gZnJhZ21lbnRcblxuICAoKiBYWFgoYW5tb250ZWlybyk6IEZvciBjb21wYXRpYmlsaXR5IHJlYXNvbnMgd2l0aCB0aGUgb2xkIHJlZ2V4IHBhcnNlciwgd2VcbiAgICogb25seSBwYXJzZSB1bnRpbCB0aGUgZmlyc3QgbmV3bGluZSBjaGFyYWN0ZXIgYW5kIGRyb3AgZXZlcnl0aGluZyBlbHNlXG4gICAqIGFmdGVyIHRoYXQgKilcbiAgbGV0IHVyaV9yZWZlcmVuY2UgPVxuICAgIHRha2Vfd2hpbGUgKGZ1bmN0aW9uIHwgJ1xcbicgLT4gZmFsc2UgfCBfIC0+IHRydWUpID4+fCBmdW4gcyAtPlxuICAgICAgbWF0Y2ggQW5nc3Ryb20ucGFyc2Vfc3RyaW5nIH5jb25zdW1lOkFsbCBfdXJpX3JlZmVyZW5jZSBzIHdpdGhcbiAgICAgIHwgT2sgdCAtPiB0XG4gICAgICB8IEVycm9yIF8gLT5cbiAgICAgICAgKCogU2hvdWxkbid0IHJlYWxseSBoYXBwZW4gaWYgdGhlIHBhcnNlciBpcyBmb3JnaXZpbmcuICopXG4gICAgICAgIGVtcHR5XG5lbmRcblxubGV0IGRlY29kZV9ob3N0IGhvc3QgPVxuICBtYXRjaCBBbmdzdHJvbS5wYXJzZV9zdHJpbmcgfmNvbnN1bWU6QWxsIFBhcnNlci5ob3N0IGhvc3Qgd2l0aFxuICB8IE9rIHBhcnNlZCAtPiBwYXJzZWRcbiAgfCBFcnJvciBfIC0+XG4gICAgbWF0Y2ggQW5nc3Ryb20ucGFyc2Vfc3RyaW5nIH5jb25zdW1lOkFsbCBQYXJzZXIuaXB2NiBob3N0IHdpdGhcbiAgICB8IE9rIHBhcnNlZCAtPiAoYElwdjZfbGl0ZXJhbCBwYXJzZWQpXG4gICAgfCBFcnJvciBfIC0+IChgSG9zdCAoUGN0LmNhc3RfZGVjb2RlZCBob3N0KSlcblxuKCogTWFrZSBhIFVSSSByZWNvcmQuIFRoaXMgaXMgYSBiaXQgbW9yZSBpbmVmZmljaWVudCB0aGFuIGl0IG5lZWRzIHRvIGJlIGR1ZSB0byB0aGVcbiAqIGNhc3RpbmcvdW5jYXN0aW5nICh3aGljaCBpc24ndCBmdWxseSBpZGVudGl0eSBkdWUgdG8gdGhlIG9wdGlvbiBib3gpLCBidXQgaXQgaXNcbiAqIG5vIGJpZyBkZWFsIGZvciBub3cuXG4qKVxubGV0IG1ha2UgP3NjaGVtZSA/dXNlcmluZm8gP2hvc3QgP3BvcnQgP3BhdGggP3F1ZXJ5ID9mcmFnbWVudCAoKSA9XG4gIGxldCBkZWNvZGUgPSBmdW5jdGlvblxuICAgIHxTb21lIHggLT4gU29tZSAoUGN0LmNhc3RfZGVjb2RlZCB4KSB8Tm9uZSAtPiBOb25lIGluXG4gIGxldCBob3N0ID0gbWF0Y2ggdXNlcmluZm8sIGhvc3QsIHBvcnQgd2l0aFxuICAgIHwgXywgU29tZSBfLCBfIHwgTm9uZSwgTm9uZSwgTm9uZSAtPiBob3N0XG4gICAgfCBTb21lIF8sIE5vbmUsIF8gfCBfLCBOb25lLCBTb21lIF8gLT4gU29tZSBcIlwiXG4gIGluXG4gIGxldCB1c2VyaW5mbyA9IG1hdGNoIHVzZXJpbmZvIHdpdGhcbiAgICB8IE5vbmUgLT4gTm9uZSB8IFNvbWUgdSAtPiBTb21lICh1c2VyaW5mb19vZl9lbmNvZGVkIHUpIGluXG4gIGxldCBwYXRoID0gbWF0Y2ggcGF0aCB3aXRoXG4gICAgfE5vbmUgLT4gW10gfCBTb21lIHAgLT5cbiAgICAgIGxldCBwYXRoID0gcGF0aF9vZl9lbmNvZGVkIHAgaW5cbiAgICAgIG1hdGNoIGhvc3QsIHBhdGggd2l0aFxuICAgICAgfCBOb25lLCBfIHwgU29tZSBfLCBcIi9cIjo6XyB8IFNvbWUgXywgW10gLT4gcGF0aFxuICAgICAgfCBTb21lIF8sIF8gIC0+IFwiL1wiOjpwYXRoXG4gIGluXG4gIGxldCBxdWVyeSA9IG1hdGNoIHF1ZXJ5IHdpdGhcbiAgICB8IE5vbmUgLT4gUXVlcnkuS1YgW11cbiAgICB8IFNvbWUgcCAtPiBRdWVyeS5LViBwXG4gIGluXG4gIGxldCBzY2hlbWUgPSBkZWNvZGUgc2NoZW1lIGluXG4gIG5vcm1hbGl6ZSBzY2hlbWVcbiAgICB7IHNjaGVtZTsgdXNlcmluZm87XG4gICAgICBob3N0ID1cbiAgICAgICAgKG1hdGNoIGhvc3Qgd2l0aFxuICAgICAgICB8IFNvbWUgaG9zdCAtPiBTb21lIChkZWNvZGVfaG9zdCBob3N0KVxuICAgICAgICB8IE5vbmUgLT4gTm9uZSk7XG4gICAgICBwb3J0OyBwYXRoOyBxdWVyeTsgZnJhZ21lbnQ9ZGVjb2RlIGZyYWdtZW50IH1cblxubGV0IHdpdGhfaG9zdCB1cmkgaG9zdCA9XG4gIHsgdXJpIHdpdGhcbiAgICBob3N0ID0gKG1hdGNoIGhvc3Qgd2l0aFxuICAgICAgICAgICAgfCBTb21lIGhvc3QgLT4gU29tZSAoZGVjb2RlX2hvc3QgaG9zdClcbiAgICAgICAgICAgIHwgTm9uZSAtPiBOb25lKVxuICB9XG5cbmxldCB3aXRoX3VyaSA/c2NoZW1lID91c2VyaW5mbyA/aG9zdCA/cG9ydCA/cGF0aCA/cXVlcnkgP2ZyYWdtZW50IHVyaSA9XG4gIGxldCB3aXRoX3BhdGhfb3B0IHUgbyA9XG4gICAgbWF0Y2ggbyB3aXRoXG4gICAgfCBOb25lIC0+IHdpdGhfcGF0aCB1IFwiXCJcbiAgICB8IFNvbWUgcCAtPiB3aXRoX3BhdGggdSBwXG4gIGluXG4gIGxldCB3aXRoX3F1ZXJ5X29wdCB1IG8gPVxuICAgIG1hdGNoIG8gd2l0aFxuICAgIHwgTm9uZSAtPiB3aXRoX3F1ZXJ5IHUgW11cbiAgICB8IFNvbWUgcSAtPiB3aXRoX3F1ZXJ5IHUgcVxuICBpblxuICBsZXQgd2l0aF8gZiBvIHUgPVxuICAgIG1hdGNoIG8gd2l0aFxuICAgIHwgTm9uZSAtPiB1XG4gICAgfCBTb21lIHggLT4gZiB1IHhcbiAgaW5cbiAgd2l0aF8gd2l0aF9zY2hlbWUgc2NoZW1lIHVyaVxuICB8PiB3aXRoXyB3aXRoX3VzZXJpbmZvIHVzZXJpbmZvXG4gIHw+IHdpdGhfIHdpdGhfaG9zdCBob3N0XG4gIHw+IHdpdGhfIHdpdGhfcG9ydCBwb3J0XG4gIHw+IHdpdGhfIHdpdGhfcGF0aF9vcHQgcGF0aFxuICB8PiB3aXRoXyB3aXRoX3F1ZXJ5X29wdCBxdWVyeVxuICB8PiB3aXRoXyB3aXRoX2ZyYWdtZW50IGZyYWdtZW50XG5cbmxldCBvZl9zdHJpbmcgcyA9XG4gICgqIFRvIHByZXNlcnZlIHRoZSBvbGQgcmVnZXggcGFyc2VyJ3MgYmVoYXZpb3IsIHdlIG9ubHkgcGFyc2UgYSBwcmVmaXgsIGFuZFxuICAgKiBzdG9wIHdoZW5ldmVyIHdlIGNhbid0IHBhcnNlIG1vcmUuICopXG4gIG1hdGNoIEFuZ3N0cm9tLnBhcnNlX3N0cmluZyB+Y29uc3VtZTpQcmVmaXggUGFyc2VyLnVyaV9yZWZlcmVuY2UgcyB3aXRoXG4gIHwgT2sgdCAtPiB0XG4gIHwgRXJyb3IgXyAtPlxuICAgICgqIFNob3VsZG4ndCByZWFsbHkgaGFwcGVuIGlmIHRoZSBwYXJzZXIgaXMgZm9yZ2l2aW5nLiAqKVxuICAgIGVtcHR5XG5cbm1vZHVsZSBBYnNvbHV0ZV9odHRwID0gc3RydWN0XG4gIHR5cGUgdXJpID0gdFxuICB0eXBlIHQgPVxuICAgIHsgc2NoZW1lIDogWyBgSHR0cCB8IGBIdHRwcyBdO1xuICAgICAgdXNlcmluZm86IFVzZXJpbmZvLnQgb3B0aW9uO1xuICAgICAgaG9zdDogWyBgSXB2NF9saXRlcmFsIG9mIHN0cmluZ1xuICAgICAgICAgICAgfCBgSXB2Nl9saXRlcmFsIG9mIHN0cmluZ1xuICAgICAgICAgICAgfCBgSG9zdCBvZiBQY3QuZGVjb2RlZF07XG4gICAgICBwb3J0IDogaW50IG9wdGlvbjtcbiAgICAgIHBhdGggOiBQYXRoLnQ7XG4gICAgICBxdWVyeSA6IFF1ZXJ5LnQ7XG4gICAgICBmcmFnbWVudCA6IFBjdC5kZWNvZGVkIG9wdGlvblxuICAgIH1cblxuICBsZXQgKCBsZXQqICkgPSBSZXN1bHQuYmluZFxuXG4gIGxldCB0b191cmkgeyBzY2hlbWU7IHVzZXJpbmZvOyBob3N0OyBwb3J0OyBwYXRoOyBxdWVyeTsgZnJhZ21lbnQgfSA9XG4gICAgbGV0IHNjaGVtZSA9XG4gICAgICBtYXRjaCBzY2hlbWUgd2l0aFxuICAgICAgfCBgSHR0cCAtPiBQY3QuY2FzdF9kZWNvZGVkIFwiaHR0cFwiXG4gICAgICB8IGBIdHRwcyAtPiBQY3QuY2FzdF9kZWNvZGVkIFwiaHR0cHNcIlxuICAgIGluXG4gICAgKHsgc2NoZW1lID0gU29tZSBzY2hlbWU7XG4gICAgICAgdXNlcmluZm87XG4gICAgICAgaG9zdCA9IFNvbWUgaG9zdDtcbiAgICAgICBwb3J0O1xuICAgICAgIHBhdGg7XG4gICAgICAgcXVlcnk7XG4gICAgICAgZnJhZ21lbnQgfSA6IHVyaSlcbiAgOztcblxuICBsZXQgb2ZfdXJpICh7IHNjaGVtZTsgdXNlcmluZm87IGhvc3Q7IHBvcnQ7IHBhdGg7IHF1ZXJ5OyBmcmFnbWVudCB9OiB1cmkpID1cbiAgICBsZXQqIHNjaGVtZSA9XG4gICAgICBtYXRjaCBzY2hlbWUgd2l0aFxuICAgICAgfCBOb25lIC0+IEVycm9yIChgTXNnIFwiTm8gc2NoZW1lIHByZXNlbnQgaW4gVVJJXCIpXG4gICAgICB8IFNvbWUgc2NoZW1lIC0+XG4gICAgICAgIChtYXRjaCBQY3QudW5jYXN0X2RlY29kZWQgc2NoZW1lIHdpdGhcbiAgICAgICAgIHwgXCJodHRwXCIgLT4gT2sgYEh0dHBcbiAgICAgICAgIHwgXCJodHRwc1wiIC0+IE9rIGBIdHRwc1xuICAgICAgICAgfCB1bnN1cHBvcnRlZF9zY2hlbWUgLT5cbiAgICAgICAgICAgRXJyb3JcbiAgICAgICAgICAgICAoYE1zZ1xuICAgICAgICAgICAgICAgIChQcmludGYuc3ByaW50ZlxuICAgICAgICAgICAgICAgICAgIFwiT25seSBodHRwIGFuZCBodHRwcyBVUklzIGFyZSBzdXBwb3J0ZWQuICVzIGlzIGludmFsaWQuXCJcbiAgICAgICAgICAgICAgICAgICB1bnN1cHBvcnRlZF9zY2hlbWUpKSlcbiAgICBpblxuICAgIGxldCogaG9zdCA9IE9wdGlvbi50b19yZXN1bHQgfm5vbmU6KGBNc2cgXCJob3N0IGlzIHJlcXVpcmVkIGZvciBIVFRQKFMpIHVyaXNcIikgaG9zdCBpblxuICAgIE9rIHsgc2NoZW1lOyB1c2VyaW5mbzsgaG9zdDsgcG9ydDsgcGF0aDsgcXVlcnk7IGZyYWdtZW50IH1cbiAgOztcblxuICBsZXQgb2Zfc3RyaW5nIHMgPSBtYXRjaCBvZl9zdHJpbmcgcyB8PiBvZl91cmkgd2l0aFxuICAgIHwgT2sgdCAtPiB0XG4gICAgfCBFcnJvciAoYE1zZyBlcnJvcikgLT4gZmFpbHdpdGggZXJyb3JcblxuICBsZXQgdG9fc3RyaW5nID9wY3RfZW5jb2RlciB0ID0gdG9fdXJpIHQgfD4gdG9fc3RyaW5nID9wY3RfZW5jb2RlclxuXG4gIGxldCBub3JtYWxpemUgdCA9XG4gICAgeyB0IHdpdGhcbiAgICAgIGhvc3QgPSBtYXRjaCB0Lmhvc3Qgd2l0aFxuICAgICAgIHwgKGBJcHY0X2xpdGVyYWwgaG9zdCkgLT5cbiAgICAgICAgIChgSXB2NF9saXRlcmFsIChTdHJpbmcubG93ZXJjYXNlX2FzY2lpIGhvc3QpKVxuICAgICAgIHwgKGBJcHY2X2xpdGVyYWwgaG9zdCkgLT5cbiAgICAgICAgIChgSXB2Nl9saXRlcmFsIChTdHJpbmcubG93ZXJjYXNlX2FzY2lpIGhvc3QpKVxuICAgICAgIHwgKGBIb3N0IGhvc3QpIC0+XG4gICAgICAgICAoYEhvc3QgKFBjdC5jYXN0X2RlY29kZWQgKFN0cmluZy5sb3dlcmNhc2VfYXNjaWkgKFBjdC51bmNhc3RfZGVjb2RlZCBob3N0KSkpKVxuICAgIH1cblxuICBsZXQgbWFrZSB+c2NoZW1lIH5ob3N0ID91c2VyaW5mbyA/cG9ydCA/cGF0aCA/cXVlcnkgP2ZyYWdtZW50ICgpID1cbiAgICBsZXQgZGVjb2RlID0gZnVuY3Rpb25cbiAgICAgIHxTb21lIHggLT4gU29tZSAoUGN0LmNhc3RfZGVjb2RlZCB4KSB8Tm9uZSAtPiBOb25lIGluXG4gICAgbGV0IHVzZXJpbmZvID0gbWF0Y2ggdXNlcmluZm8gd2l0aFxuICAgICAgfCBOb25lIC0+IE5vbmUgfCBTb21lIHUgLT4gU29tZSAodXNlcmluZm9fb2ZfZW5jb2RlZCB1KSBpblxuICAgIGxldCBwYXRoID0gbWF0Y2ggcGF0aCB3aXRoXG4gICAgICB8Tm9uZSAtPiBbXSB8IFNvbWUgcCAtPlxuICAgICAgICBsZXQgcGF0aCA9IHBhdGhfb2ZfZW5jb2RlZCBwIGluXG4gICAgICAgIG1hdGNoIHBhdGggd2l0aFxuICAgICAgICB8ICBcIi9cIjo6XyB8ICBbXSAtPiBwYXRoXG4gICAgICAgIHwgXyAgLT4gXCIvXCI6OnBhdGhcbiAgICBpblxuICAgIGxldCBxdWVyeSA9IG1hdGNoIHF1ZXJ5IHdpdGhcbiAgICAgIHwgTm9uZSAtPiBRdWVyeS5LViBbXVxuICAgICAgfCBTb21lIHAgLT4gUXVlcnkuS1YgcFxuICAgIGluXG4gICAgbm9ybWFsaXplXG4gICAgICB7IHNjaGVtZTtcbiAgICAgICAgdXNlcmluZm87XG4gICAgICAgIGhvc3Q9IGRlY29kZV9ob3N0IGhvc3Q7IHBvcnQ7IHBhdGg7IHF1ZXJ5OyBmcmFnbWVudD1kZWNvZGUgZnJhZ21lbnQgfVxuXG4gIGxldCBob3N0IHQgPVxuICAgIG1hdGNoIHQuaG9zdCB3aXRoXG4gICAgfCAoYElwdjRfbGl0ZXJhbCBoIHwgYElwdjZfbGl0ZXJhbCBoKSAtPiBoXG4gICAgfCAoYEhvc3QgaCkgLT4gKFBjdC51bmNhc3RfZGVjb2RlZCBoKVxuXG4gIGxldCBzY2hlbWUgdCA9IHQuc2NoZW1lXG5lbmRcbiJdfQ==
