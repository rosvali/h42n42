// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Polytables
//# unitInfo: Requires: Stdlib, Stdlib__Map
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_Map = global_data.Stdlib__Map,
    compare = runtime.caml_compare,
    T = caml_call1(Stdlib_Map[1], [0, compare]),
    cst_Polytables_get = "Polytables.get";
   function create(param){return [0, T[1]];}
   var c = [0, -1];
   function make_key(param){c[1] = c[1] + 1 | 0; return [0, c[1], [0, 0]];}
   function set(table, param, value){
    var r = param[2], k = param[1], _a_ = table[1];
    function _b_(param){r[1] = [0, value]; return 0;}
    table[1] = caml_call3(T[4], k, _b_, _a_);
    return 0;
   }
   function get(table, param){
    var r = param[2], k = param[1];
    caml_call1(caml_call2(T[28], k, table[1]), 0);
    var match = r[1];
    if(! match) return caml_call1(Stdlib[2], cst_Polytables_get);
    var v = match[1];
    r[1] = 0;
    return v;
   }
   function remove(table, param){
    var k = param[1];
    table[1] = caml_call2(T[7], k, table[1]);
    return 0;
   }
   function clear(table){table[1] = T[1]; return 0;}
   var Polytables = [0, create, make_key, set, get, remove, clear];
   runtime.caml_register_global(3, Polytables, "Polytables");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJwb2x5dGFibGVzLmNtYS5qcyIsInNvdXJjZVJvb3QiOiIiLCJuYW1lcyI6WyJjb21wYXJlIiwiY3JlYXRlIiwiYyIsIm1ha2Vfa2V5Iiwic2V0IiwidGFibGUiLCJ2YWx1ZSIsInIiLCJrIiwiZ2V0IiwidiIsInJlbW92ZSIsImNsZWFyIl0sInNvdXJjZXMiOlsiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9vY3NpZ2Vuc2VydmVyL3BvbHl0YWJsZXMvcG9seXRhYmxlcy5tbCJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0c7Ozs7O0c7Ozs7O0c7Ozs7Ozs7OztJQTJCTUE7c0NBQUFBOztZQUtGQyxjQUFZLGlCQUFXO0dBQ25CLElBQUpDO1lBRUFDLGdCQUZBRCxPQUFBQSxjQUlGLFdBSkVBLGNBSVU7WUFFVkUsSUFBTUMsY0FBb0NDO0lBQzVDLElBRDZCQyxjQUFIQyxjQUMxQixNQURRSDt3QkFBcUJFLFdBQWVELGlCQUNEO0lBRG5DRCxXQUNDLGlCQURpQkc7OztZQUd4QkMsSUFBTUo7UUFBcUJFLGNBQUhDO0lBQzFCLFdBQUEsa0JBRDBCQSxHQUFsQkg7Z0JBQXFCRTtnQkFNbkIsT0FBQTtRQUhIRztJQUhzQkg7SUFLekIsT0FGR0c7O1lBS0xDLE9BQVNOO1FBQWtCRztJQUFsQkgsV0FBOEMsaUJBQTVCRyxHQUFsQkg7OztZQUNUTyxNQUFRUCxPQUFBQSwwQkFBNkI7d0JBbkJyQ0osUUFHQUUsVUFJQUMsS0FHQUssS0FRQUUsUUFDQUM7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCogT2NzaWdlblxuICogQ29weXJpZ2h0IChDKSAyMDA5XG4gKlxuICogVGhpcyBwcm9ncmFtIGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vciBtb2RpZnlcbiAqIGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieVxuICogdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aCBsaW5raW5nIGV4Y2VwdGlvbjtcbiAqIGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0IHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cbiAqXG4gKiBUaGlzIHByb2dyYW0gaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAqIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gKiBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlXG4gKiBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cbiAqXG4gKiBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2VcbiAqIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtOyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gKiBGb3VuZGF0aW9uLCBJbmMuLCA1OSBUZW1wbGUgUGxhY2UgLSBTdWl0ZSAzMzAsIEJvc3RvbiwgTUEgMDIxMTEtMTMwNywgVVNBLlxuICopXG4oKipcbiAgIEBhdXRob3IgVmluY2VudCBCYWxhdFxuICAgQGF1dGhvciBKw6lyw7RtZSBWb3VpbGxvblxuKilcblxudHlwZSAnYSBrZXkgPSBpbnQgKiAnYSBvcHRpb24gcmVmXG5cbm1vZHVsZSBUID0gTWFwLk1ha2UgKHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcblxuICBsZXQgY29tcGFyZSA9IGNvbXBhcmVcbmVuZClcblxudHlwZSB0ID0gKHVuaXQgLT4gdW5pdCkgVC50IHJlZlxuXG5sZXQgY3JlYXRlICgpID0gcmVmIFQuZW1wdHlcbmxldCBjID0gcmVmICgtMSlcblxubGV0IG1ha2Vfa2V5ICgpID1cbiAgYyA6PSAhYyArIDE7XG4gICFjLCByZWYgTm9uZVxuXG5sZXQgc2V0IH4odGFibGUgOiB0KSB+a2V5OigoaywgcikgOiAnYSBrZXkpIH4odmFsdWUgOiAnYSkgPVxuICB0YWJsZSA6PSBULmFkZCBrIChmdW4gKCkgLT4gciA6PSBTb21lIHZhbHVlKSAhdGFibGVcblxubGV0IGdldCB+KHRhYmxlIDogdCkgfmtleTooKGssIHIpIDogJ2Ega2V5KSA9XG4gIChULmZpbmQgayAhdGFibGUpICgpO1xuICBtYXRjaCAhciB3aXRoXG4gIHwgU29tZSB2IC0+XG4gICAgICByIDo9IE5vbmU7XG4gICAgICB2XG4gIHwgTm9uZSAtPiBmYWlsd2l0aCBcIlBvbHl0YWJsZXMuZ2V0XCJcblxubGV0IHJlbW92ZSB+KHRhYmxlIDogdCkgfmtleTooKGssIF9yKSA6ICdhIGtleSkgPSB0YWJsZSA6PSBULnJlbW92ZSBrICF0YWJsZVxubGV0IGNsZWFyIH4odGFibGUgOiB0KSA9IHRhYmxlIDo9IFQuZW1wdHlcbiJdfQ==
