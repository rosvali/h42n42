// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Base64__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base64 = [0];
   runtime.caml_register_global(0, Base64, "Base64__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base64__Unsafe
(function(globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Base64_Unsafe = [0];
   runtime.caml_register_global(0, Base64_Unsafe, "Base64__Unsafe");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Base64
//# unitInfo: Requires: Assert_failure, Stdlib, Stdlib__Array, Stdlib__Bytes, Stdlib__Char, Stdlib__Format, Stdlib__String, Stdlib__Sys
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_Invalid_bounds = "Invalid bounds",
    cst_Malformed_input = "Malformed input",
    cst_Too_much_input = "Too much input",
    cst_Wrong_padding = "Wrong padding",
    caml_bytes_set16 = runtime.caml_bytes_set16,
    caml_check_bound = runtime.caml_check_bound,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_bytes_length = runtime.caml_ml_bytes_length,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get16 = runtime.caml_string_get16,
    caml_string_unsafe_get = runtime.caml_string_unsafe_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Assert_failure = global_data.Assert_failure,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Sys = global_data.Stdlib__Sys,
    _e_ = [0, [11, cst_Invalid_bounds, 0], cst_Invalid_bounds],
    _f_ = [0, [11, cst_Wrong_padding, 0], cst_Wrong_padding],
    _g_ = [0, [11, cst_Malformed_input, 0], cst_Malformed_input],
    _h_ = [0, [11, cst_Too_much_input, 0], cst_Too_much_input],
    _c_ = [0, "src/base64.ml", 157, 15],
    _b_ = [0, [11, cst_Invalid_bounds, 0], cst_Invalid_bounds],
    cst_Length_of_alphabet_must_be = "Length of alphabet must be 64",
    cst_Alphabet_can_not_contain_p =
      "Alphabet can not contain padding character",
    cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
    cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ$0 =
      "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_",
    cst_Base64_Out_of_bounds = "Base64.Out_of_bounds",
    cst_Base64_Too_much_input = "Base64.Too_much_input";
   function symbol(x, y){
    if(y < 1) throw caml_maybe_attach_backtrace(Stdlib[13], 1);
    return 0 < x ? 1 + runtime.caml_div(x - 1 | 0, y) | 0 : 0;
   }
   function unsafe_set_uint8(t, off, v){
    runtime.caml_bytes_unsafe_set(t, off, caml_call1(Stdlib_Char[1], v));
    return;
   }
   function make_alphabet(alphabet){
    if(64 !== caml_ml_string_length(alphabet))
     caml_call1(Stdlib[1], cst_Length_of_alphabet_must_be);
    if(caml_call2(Stdlib_String[14], alphabet, 61))
     caml_call1(Stdlib[1], cst_Alphabet_can_not_contain_p);
    function _C_(i){return runtime.caml_string_get(alphabet, i);}
    var
     emap = caml_call2(Stdlib_Array[2], caml_ml_string_length(alphabet), _C_),
     dmap = runtime.caml_make_vect(256, -1);
    function _D_(idx, chr){
     caml_check_bound(dmap, chr)[1 + chr] = idx;
     return 0;
    }
    caml_call2(Stdlib_String[30], _D_, alphabet);
    return [0, emap, dmap];
   }
   function length_alphabet(param){
    var emap = param[1];
    return emap.length - 1;
   }
   function alphabet(param){
    var emap = param[1];
    function _A_(i){
     var _B_ = caml_check_bound(emap, i)[1 + i];
     return caml_call1(Stdlib_Char[1], _B_);
    }
    return caml_call2(Stdlib_String[2], emap.length - 1, _A_);
   }
   var
    default_alphabet = make_alphabet(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ),
    uri_safe_alphabet = make_alphabet(cst_ABCDEFGHIJKLMNOPQRSTUVWXYZ$0),
    unsafe_set_be_uint16 =
      Stdlib_Sys[11]
       ? caml_bytes_set16
       : function
        (t, off, v){
         caml_bytes_set16(t, off, runtime.caml_bswap16(v));
         return;
        },
    Out_of_bounds = [248, cst_Base64_Out_of_bounds, caml_fresh_oo_id(0)],
    Too_much_input = [248, cst_Base64_Too_much_input, caml_fresh_oo_id(0)];
   function get_uint8(t, off){
    var
     _y_ = off < 0 ? 1 : 0,
     _z_ = _y_ || (caml_ml_string_length(t) <= off ? 1 : 0);
    if(_z_) throw caml_maybe_attach_backtrace(Out_of_bounds, 1);
    return caml_string_unsafe_get(t, off);
   }
   var padding = 61;
   function error_msgf(fmt){
    function _x_(err){return [1, [0, 3854881, err]];}
    return caml_call2(Stdlib_Format[139], _x_, fmt);
   }
   function _a_(pad, param, opt, len, input){
    var emap = param[1];
    if(opt) var sth = opt[1], off = sth; else var off = 0;
    if(len)
     var len$0 = len[1], len$1 = len$0;
    else
     var len$1 = caml_ml_string_length(input) - off | 0;
    if
     (0 <= len$1
      && 0 <= off && (caml_ml_string_length(input) - len$1 | 0) >= off){
     var
      n = symbol(len$1, 3) * 4 | 0,
      res = caml_create_bytes(n),
      emap$0 = function(i){return emap[1 + i];},
      emit =
        function(b1, b2, b3, i){
         var _v_ = emap$0((b1 << 4 | b2 >>> 4 | 0) & 63);
         unsafe_set_be_uint16(res, i, emap$0((b1 >>> 2 | 0) & 63) << 8 | _v_);
         var _w_ = emap$0(b3 & 63);
         return unsafe_set_be_uint16
                 (res,
                  i + 2 | 0,
                  emap$0((b2 << 2 | b3 >>> 6 | 0) & 63) << 8 | _w_);
        };
     a:
     b:
     {
      c:
      {
       var j = 0, i = 0;
       for(;;){
        if(i === len$1) break b;
        if(i === (len$1 - 1 | 0)) break c;
        if(i === (len$1 - 2 | 0)) break;
        emit
         (caml_string_unsafe_get(input, off + i | 0),
          caml_string_unsafe_get(input, (off + i | 0) + 1 | 0),
          caml_string_unsafe_get(input, (off + i | 0) + 2 | 0),
          j);
        var i$0 = i + 3 | 0, j$0 = j + 4 | 0, j = j$0, i = i$0;
       }
       emit
        (caml_string_unsafe_get(input, off + i | 0),
         caml_string_unsafe_get(input, (off + i | 0) + 1 | 0),
         0,
         j);
       break a;
      }
      emit(caml_string_unsafe_get(input, off + i | 0), 0, 0, j);
      break a;
     }
     var pad_to_write = (3 - (len$1 % 3 | 0) | 0) % 3 | 0;
     if(! pad)
      return [0,
              [0, caml_call1(Stdlib_Bytes[48], res), 0, n - pad_to_write | 0]];
     var i$1 = pad_to_write;
     for(;;){
      if(0 === i$1) return [0, [0, caml_call1(Stdlib_Bytes[48], res), 0, n]];
      unsafe_set_uint8(res, n - i$1 | 0, padding);
      var i$2 = i$1 - 1 | 0, i$1 = i$2;
     }
    }
    return error_msgf(_b_);
   }
   function encode(opt, _u_, off, len, input){
    if(opt) var sth = opt[1], pad = sth; else var pad = 1;
    if(_u_)
     var sth$0 = _u_[1], alphabet = sth$0;
    else
     var alphabet = default_alphabet;
    var err = _a_(pad, alphabet, off, len, input);
    if(0 !== err[0]) return err;
    var match = err[1], len$0 = match[3], off$0 = match[2], res = match[1];
    return [0, caml_call3(Stdlib_String[15], res, off$0, len$0)];
   }
   function encode_string(pad, alphabet, input){
    var match = encode(pad, alphabet, 0, 0, input);
    if(0 !== match[0])
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    var res = match[1];
    return res;
   }
   function encode_sub(opt, _t_, off, len, input){
    if(opt) var sth = opt[1], pad = sth; else var pad = 1;
    if(_t_)
     var sth$0 = _t_[1], alphabet = sth$0;
    else
     var alphabet = default_alphabet;
    return _a_(pad, alphabet, off, len, input);
   }
   function encode_exn(pad, alphabet, off, len, input){
    var match = encode(pad, alphabet, off, len, input);
    if(0 === match[0]){var v = match[1]; return v;}
    var err = match[1][2];
    return caml_call1(Stdlib[1], err);
   }
   function _d_(opt, param){
    if(opt)
     var sth = opt[1], invalid_pad_overflow = sth;
    else
     var invalid_pad_overflow = 1;
    var dmap = param[2];
    return function(opt, len, input){
     if(opt) var sth = opt[1], off = sth; else var off = 0;
     if(len)
      var len$0 = len[1], len$1 = len$0;
     else
      var len$1 = caml_ml_string_length(input) - off | 0;
     if
      (0 <= len$1
       && 0 <= off && (caml_ml_string_length(input) - len$1 | 0) >= off){
      var
       n = symbol(len$1, 4) * 4 | 0,
       n$0 = symbol(n, 4) * 3 | 0,
       res = caml_create_bytes(n$0),
       get_uint8_or_padding =
         invalid_pad_overflow
          ? function
           (t, i){
            if(len$1 <= i)
             throw caml_maybe_attach_backtrace(Out_of_bounds, 1);
            return get_uint8(t, off + i | 0);
           }
          : function
           (t, i){
            try{
             var _r_ = i < len$1 ? get_uint8(t, off + i | 0) : padding;
             return _r_;
            }
            catch(_s_){
             var _q_ = caml_wrap_exception(_s_);
             if(_q_ === Out_of_bounds) return padding;
             throw caml_maybe_attach_backtrace(_q_, 0);
            }
           },
       dmap$0 =
         function(i){
          var x = dmap[1 + i];
          if(x === -1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
          return x;
         },
       only_padding =
         function(pad, idx){
          var pad$0 = [0, pad + 3 | 0], idx$0 = [0, idx];
          for(;;){
           if((idx$0[1] + 4 | 0) >= len$1) break;
           var
            _o_ =
              15677 !== caml_string_get16(input, off + idx$0[1] | 0) ? 1 : 0,
            _p_ =
              _o_
              ||
               (15677
                 !== caml_string_get16(input, (off + idx$0[1] | 0) + 2 | 0)
                 ? 1
                 : 0);
           if(_p_) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
           idx$0[1] = idx$0[1] + 4 | 0;
           pad$0[1] = pad$0[1] + 3 | 0;
          }
          for(;;){
           if(idx$0[1] >= len$1) return pad$0[1];
           if(caml_string_unsafe_get(input, off + idx$0[1] | 0) !== 61)
            throw caml_maybe_attach_backtrace(Stdlib[8], 1);
           idx$0[1]++;
          }
         };
      try{
       a:
       {
        b:
        {
         var off$1 = 0, i = 0;
         for(;;){
          if(i === n){var pad$4 = 0; break a;}
          var x$0 = get_uint8_or_padding(input, i + 3 | 0);
          c:
          try{var pad$3 = 0, _l_ = dmap$0(x$0), pad = pad$3, d = _l_;}
          catch(exn$0){
           var exn = caml_wrap_exception(exn$0);
           if(exn === Stdlib[8] && x$0 === 61){var pad = 1, d = 0; break c;}
           throw caml_maybe_attach_backtrace(exn, 0);
          }
          var x$1 = get_uint8_or_padding(input, i + 2 | 0);
          c:
          try{var _k_ = dmap$0(x$1), pad$0 = pad, c = _k_;}
          catch(exn){
           var exn$0 = caml_wrap_exception(exn);
           if(exn$0 === Stdlib[8] && x$1 === 61 && 1 === pad){var pad$0 = 2, c = 0; break c;}
           throw caml_maybe_attach_backtrace(exn$0, 0);
          }
          var x$2 = get_uint8_or_padding(input, i + 1 | 0);
          c:
          try{var _j_ = dmap$0(x$2), pad$1 = pad$0, b = _j_;}
          catch(exn){
           var exn$1 = caml_wrap_exception(exn);
           if(exn$1 === Stdlib[8] && x$2 === 61 && 2 === pad$0){var pad$1 = 3, b = 0; break c;}
           throw caml_maybe_attach_backtrace(exn$1, 0);
          }
          var x$3 = get_uint8_or_padding(input, i);
          c:
          try{var _i_ = dmap$0(x$3), pad$2 = pad$1, a = _i_;}
          catch(exn){
           var exn$2 = caml_wrap_exception(exn);
           if(exn$2 === Stdlib[8] && x$3 === 61 && 3 === pad$1){var pad$2 = 4, a = 0; break c;}
           throw caml_maybe_attach_backtrace(exn$2, 0);
          }
          var x = a << 18 | b << 12 | c << 6 | d, v = x >>> 8 | 0;
          c:
          if(0 <= off$1 && caml_ml_bytes_length(res) >= (off$1 + 1 | 0)){
           if(0 <= off$1 && caml_ml_bytes_length(res) >= (off$1 + 2 | 0)){unsafe_set_be_uint16(res, off$1, v); break c;}
           unsafe_set_uint8(res, off$1, v >>> 8 | 0);
           break c;
          }
          var v$0 = x & 255, off$0 = off$1 + 2 | 0;
          c:
          if(0 <= off$0 && caml_ml_bytes_length(res) > off$0){unsafe_set_uint8(res, off$0, v$0); break c;}
          if((i + 4 | 0) === n) break b;
          if(0 !== pad$2) break;
          var i$0 = i + 4 | 0, j = off$1 + 3 | 0, off$1 = j, i = i$0;
         }
         if(4 === pad$2){var pad$4 = only_padding(3, i + 4 | 0); break a;}
         if(1 === invalid_pad_overflow)
          throw caml_maybe_attach_backtrace(Too_much_input, 1);
         var pad$4 = only_padding(pad$2, i + 4 | 0);
         break a;
        }
        var pad$4 = 0 === pad$2 ? 0 : 4 === pad$2 ? 3 : pad$2;
       }
      }
      catch(_n_){
       var _m_ = caml_wrap_exception(_n_);
       if(_m_ === Out_of_bounds) return error_msgf(_f_);
       if(_m_ === Stdlib[8]) return error_msgf(_g_);
       if(_m_ === Too_much_input) return error_msgf(_h_);
       throw caml_maybe_attach_backtrace(_m_, 0);
      }
      return 0 === pad$4
              ? [0, [0, caml_call1(Stdlib_Bytes[48], res), 0, n$0]]
              : [0,
                [0, caml_call1(Stdlib_Bytes[48], res), 0, n$0 - pad$4 | 0]];
     }
     return error_msgf(_e_);};
   }
   function decode(pad, opt, off, len, input){
    if(opt)
     var sth = opt[1], alphabet = sth;
    else
     var alphabet = default_alphabet;
    var err = _d_(pad, alphabet)(off, len, input);
    if(0 !== err[0]) return err;
    var match = err[1], len$0 = match[3], off$0 = match[2], res = match[1];
    return [0, caml_call3(Stdlib_String[15], res, off$0, len$0)];
   }
   function decode_sub(pad, opt, off, len, input){
    if(opt)
     var sth = opt[1], alphabet = sth;
    else
     var alphabet = default_alphabet;
    return _d_(pad, alphabet)(off, len, input);
   }
   function decode_exn(pad, alphabet, off, len, input){
    var match = decode(pad, alphabet, off, len, input);
    if(0 === match[0]){var res = match[1]; return res;}
    var err = match[1][2];
    return caml_call1(Stdlib[1], err);
   }
   var
    Base64 =
      [0,
       default_alphabet,
       uri_safe_alphabet,
       make_alphabet,
       length_alphabet,
       alphabet,
       decode_exn,
       decode_sub,
       decode,
       encode,
       encode_string,
       encode_sub,
       encode_exn];
   runtime.caml_register_global(20, Base64, "Base64");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJiYXNlNjQuY21hLmpzIiwic291cmNlUm9vdCI6IiIsIm5hbWVzIjpbInN5bWJvbCIsIngiLCJ5IiwidW5zYWZlX3NldF91aW50OCIsInQiLCJvZmYiLCJ2IiwibWFrZV9hbHBoYWJldCIsImFscGhhYmV0IiwiaSIsImVtYXAiLCJkbWFwIiwiaWR4IiwiY2hyIiwibGVuZ3RoX2FscGhhYmV0IiwiZGVmYXVsdF9hbHBoYWJldCIsInVyaV9zYWZlX2FscGhhYmV0IiwidW5zYWZlX3NldF9iZV91aW50MTYiLCJnZXRfdWludDgiLCJwYWRkaW5nIiwiZXJyb3JfbXNnZiIsImZtdCIsImVyciIsInBhZCIsIm9wdCIsImxlbiIsImlucHV0Iiwic3RoIiwibGVuJDAiLCJsZW4kMSIsIm4iLCJyZXMiLCJlbWFwJDAiLCJlbWl0IiwiYjEiLCJiMiIsImIzIiwiaiIsImkkMCIsImokMCIsInBhZF90b193cml0ZSIsImkkMSIsImVuY29kZSIsInN0aCQwIiwib2ZmJDAiLCJlbmNvZGVfc3RyaW5nIiwiZW5jb2RlX3N1YiIsImVuY29kZV9leG4iLCJpbnZhbGlkX3BhZF9vdmVyZmxvdyIsIm4kMCIsImdldF91aW50OF9vcl9wYWRkaW5nIiwiZG1hcCQwIiwib25seV9wYWRkaW5nIiwicGFkJDAiLCJpZHgkMCIsIm9mZiQxIiwicGFkJDQiLCJ4JDAiLCJkIiwieCQxIiwiYyIsIngkMiIsInBhZCQxIiwiYiIsIngkMyIsInBhZCQyIiwiYSIsInYkMCIsImRlY29kZSIsImRlY29kZV9zdWIiLCJkZWNvZGVfZXhuIl0sInNvdXJjZXMiOlsiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9iYXNlNjQvYmFzZTY0Lm1sIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0U7Ozs7Ozs7OztFOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Rzs7Ozs7Rzs7Ozs7Rzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztZQXlCSUEsT0FBT0MsR0FBRUM7SUFDWCxHQURXQSxPQUNHLE1BQUE7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QUFoQixXQUFXbUI7O1NBQVhuQixXQWhQbEJPO0lBaVBGLFdBRGNRLEtBQU1mLFVBQThCSCxLQUFLb0IsS0FBSUM7R0FDbkI7WUFFdEM0QyxXQUFZL0MsS0FBS2YsVUFBVUgsS0FBS29CLEtBQUlDO0lBQ2hDLFlBVEowQyxPQVFZN0MsS0FBS2YsVUFBVUgsS0FBS29CLEtBQUlDOzJCQUVqQ0ssZ0JBQU8sT0FBUEE7UUFDU1Q7SUFBUSxPQUFBLHNCQUFSQTtHQUF1Qjs7OztPQXRQbkNQO09BSUFDO09BcEJBVDtPQVdBTztPQUVBTjtPQXNQQThEO09BSEFEO09BTEFEO09BckpBMUI7T0FLQUc7T0FLQUM7T0FHQUM7OztFIiwic291cmNlc0NvbnRlbnQiOlsiKCpcbiAqIENvcHlyaWdodCAoYykgMjAwNi0yMDA5IENpdHJpeCBTeXN0ZW1zIEluYy5cbiAqIENvcHlyaWdodCAoYykgMjAxMCBUaG9tYXMgR2F6YWduYWlyZSA8dGhvbWFzQGdhemFnbmFpcmUuY29tPlxuICogQ29weXJpZ2h0IChjKSAyMDE0LTIwMTYgQW5pbCBNYWRoYXZhcGVkZHkgPGFuaWxAcmVjb2lsLm9yZz5cbiAqIENvcHlyaWdodCAoYykgMjAxNiBEYXZpZCBLYWxvcGVyIE1lcsWhaW5qYWtcbiAqIENvcHlyaWdodCAoYykgMjAxOCBSb21haW4gQ2FsYXNjaWJldHRhIDxyb21haW4uY2FsYXNjaWJldHRhQGdtYWlsLmNvbT5cbiAqXG4gKiBQZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcbiAqIHB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZCwgcHJvdmlkZWQgdGhhdCB0aGUgYWJvdmVcbiAqIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2UgYXBwZWFyIGluIGFsbCBjb3BpZXMuXG4gKlxuICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVNcbiAqIFdJVEggUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0ZcbiAqIE1FUkNIQU5UQUJJTElUWSBBTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SXG4gKiBBTlkgU1BFQ0lBTCwgRElSRUNULCBJTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTXG4gKiBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NIExPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU5cbiAqIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUiBPVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GXG4gKiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUiBQRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxuICpcbiAqKVxuXG50eXBlIGFscGhhYmV0ID0geyBlbWFwIDogaW50IGFycmF5OyBkbWFwIDogaW50IGFycmF5IH1cblxudHlwZSBzdWIgPSBzdHJpbmcgKiBpbnQgKiBpbnRcblxubGV0ICggLy8gKSB4IHkgPVxuICBpZiB5IDwgMSB0aGVuIHJhaXNlIERpdmlzaW9uX2J5X3plcm8gO1xuICBpZiB4ID4gMCB0aGVuIDEgKyAoKHggLSAxKSAvIHkpIGVsc2UgMFxuICBbQEBpbmxpbmVdXG5cbmxldCB1bnNhZmVfZ2V0X3VpbnQ4IHQgb2ZmID0gQ2hhci5jb2RlIChTdHJpbmcudW5zYWZlX2dldCB0IG9mZilcblxubGV0IHVuc2FmZV9zZXRfdWludDggdCBvZmYgdiA9IEJ5dGVzLnVuc2FmZV9zZXQgdCBvZmYgKENoYXIuY2hyIHYpXG5cbmxldCB1bnNhZmVfc2V0X3VpbnQxNiA9IFVuc2FmZS51bnNhZmVfc2V0X3VpbnQxNlxuXG5leHRlcm5hbCB1bnNhZmVfZ2V0X3VpbnQxNiA6IHN0cmluZyAtPiBpbnQgLT4gaW50ID0gXCIlY2FtbF9zdHJpbmdfZ2V0MTZ1XCJcbiAgW0BAbm9hbGxvY11cblxuZXh0ZXJuYWwgc3dhcDE2IDogaW50IC0+IGludCA9IFwiJWJzd2FwMTZcIiBbQEBub2FsbG9jXVxuXG5sZXQgbm9uZSA9IC0xXG5cbigqIFdlIG1vc3RseSB3YW50IHRvIGhhdmUgYW4gb3B0aW9uYWwgYXJyYXkgZm9yIFtkbWFwXSAoZS5nLiBbaW50IG9wdGlvblxuICAgYXJyYXldKS4gU28gd2UgY29uc2lkZXIgdGhlIFtub25lXSB2YWx1ZSBhcyBbLTFdLiAqKVxuXG5sZXQgbWFrZV9hbHBoYWJldCBhbHBoYWJldCA9XG4gIGlmIFN0cmluZy5sZW5ndGggYWxwaGFiZXQgPD4gNjRcbiAgdGhlbiBpbnZhbGlkX2FyZyBcIkxlbmd0aCBvZiBhbHBoYWJldCBtdXN0IGJlIDY0XCIgO1xuICBpZiBTdHJpbmcuY29udGFpbnMgYWxwaGFiZXQgJz0nXG4gIHRoZW4gaW52YWxpZF9hcmcgXCJBbHBoYWJldCBjYW4gbm90IGNvbnRhaW4gcGFkZGluZyBjaGFyYWN0ZXJcIiA7XG4gIGxldCBlbWFwID1cbiAgICBBcnJheS5pbml0IChTdHJpbmcubGVuZ3RoIGFscGhhYmV0KSAoZnVuIGkgLT4gQ2hhci5jb2RlIGFscGhhYmV0LltpXSkgaW5cbiAgbGV0IGRtYXAgPSBBcnJheS5tYWtlIDI1NiBub25lIGluXG4gIFN0cmluZy5pdGVyaSAoZnVuIGlkeCBjaHIgLT4gZG1hcC4oQ2hhci5jb2RlIGNocikgPC0gaWR4KSBhbHBoYWJldCA7XG4gIHsgZW1hcDsgZG1hcCB9XG5cbmxldCBsZW5ndGhfYWxwaGFiZXQgeyBlbWFwOyBfIH0gPSBBcnJheS5sZW5ndGggZW1hcFxuXG5sZXQgYWxwaGFiZXQgeyBlbWFwOyBfIH0gPVxuICBTdHJpbmcuaW5pdCAoQXJyYXkubGVuZ3RoIGVtYXApIChmdW4gaSAtPiBDaGFyLmNociBlbWFwLihpKSlcblxubGV0IGRlZmF1bHRfYWxwaGFiZXQgPVxuICBtYWtlX2FscGhhYmV0XG4gICAgXCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCJcblxubGV0IHVyaV9zYWZlX2FscGhhYmV0ID1cbiAgbWFrZV9hbHBoYWJldFxuICAgIFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODktX1wiXG5cbmxldCB1bnNhZmVfc2V0X2JlX3VpbnQxNiA9XG4gIGlmIFN5cy5iaWdfZW5kaWFuXG4gIHRoZW4gZnVuIHQgb2ZmIHYgLT4gdW5zYWZlX3NldF91aW50MTYgdCBvZmYgdlxuICBlbHNlIGZ1biB0IG9mZiB2IC0+IHVuc2FmZV9zZXRfdWludDE2IHQgb2ZmIChzd2FwMTYgdilcblxuKCogV2UgbWFrZSB0aGlzIGV4Y2VwdGlvbiB0byBlbnN1cmUgdG8ga2VlcCBhIGNvbnRyb2wgYWJvdXQgd2hpY2ggZXhjZXB0aW9uIHdlXG4gICBjYW4gcmFpc2UgYW5kIGF2b2lkIGFwcGVhcmFuY2Ugb2YgdW5rbm93biBleGNlcHRpb25zIGxpa2UgYW4gZXgtbmloaWxvXG4gICBtYWdpYyByYWJiaXQgKG9yIG1hZ2ljIG1vbmV5PykuICopXG5leGNlcHRpb24gT3V0X29mX2JvdW5kc1xuXG5leGNlcHRpb24gVG9vX211Y2hfaW5wdXRcblxubGV0IGdldF91aW50OCB0IG9mZiA9XG4gIGlmIG9mZiA8IDAgfHwgb2ZmID49IFN0cmluZy5sZW5ndGggdCB0aGVuIHJhaXNlIE91dF9vZl9ib3VuZHMgO1xuICB1bnNhZmVfZ2V0X3VpbnQ4IHQgb2ZmXG5cbmxldCBwYWRkaW5nID0gaW50X29mX2NoYXIgJz0nXG5cbmxldCBlcnJvcl9tc2dmIGZtdCA9IEZvcm1hdC5rc3ByaW50ZiAoZnVuIGVyciAtPiBFcnJvciAoYE1zZyBlcnIpKSBmbXRcblxubGV0IGVuY29kZV9zdWIgcGFkIHsgZW1hcDsgXyB9ID8ob2ZmID0gMCkgP2xlbiBpbnB1dCA9XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoIFNvbWUgbGVuIC0+IGxlbiB8IE5vbmUgLT4gU3RyaW5nLmxlbmd0aCBpbnB1dCAtIG9mZiBpblxuXG4gIGlmIGxlbiA8IDAgfHwgb2ZmIDwgMCB8fCBvZmYgPiBTdHJpbmcubGVuZ3RoIGlucHV0IC0gbGVuXG4gIHRoZW4gZXJyb3JfbXNnZiBcIkludmFsaWQgYm91bmRzXCJcbiAgZWxzZVxuICAgIGxldCBuID0gbGVuIGluXG4gICAgbGV0IG4nID0gbiAvLyAzICogNCBpblxuICAgIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgbicgaW5cblxuICAgIGxldCBlbWFwIGkgPSBBcnJheS51bnNhZmVfZ2V0IGVtYXAgaSBpblxuXG4gICAgbGV0IGVtaXQgYjEgYjIgYjMgaSA9XG4gICAgICB1bnNhZmVfc2V0X2JlX3VpbnQxNiByZXMgaVxuICAgICAgICAoKGVtYXAgKChiMSBsc3IgMikgbGFuZCAweDNmKSBsc2wgOClcbiAgICAgICAgbG9yIGVtYXAgKChiMSBsc2wgNCkgbG9yIChiMiBsc3IgNCkgbGFuZCAweDNmKSkgO1xuICAgICAgdW5zYWZlX3NldF9iZV91aW50MTYgcmVzIChpICsgMilcbiAgICAgICAgKChlbWFwICgoYjIgbHNsIDIpIGxvciAoYjMgbHNyIDYpIGxhbmQgMHgzZikgbHNsIDgpXG4gICAgICAgIGxvciBlbWFwIChiMyBsYW5kIDB4M2YpKSBpblxuXG4gICAgbGV0IHJlYyBlbmMgaiBpID1cbiAgICAgIGlmIGkgPSBuXG4gICAgICB0aGVuICgpXG4gICAgICBlbHNlIGlmIGkgPSBuIC0gMVxuICAgICAgdGhlbiBlbWl0ICh1bnNhZmVfZ2V0X3VpbnQ4IGlucHV0IChvZmYgKyBpKSkgMCAwIGpcbiAgICAgIGVsc2UgaWYgaSA9IG4gLSAyXG4gICAgICB0aGVuXG4gICAgICAgIGVtaXRcbiAgICAgICAgICAodW5zYWZlX2dldF91aW50OCBpbnB1dCAob2ZmICsgaSkpXG4gICAgICAgICAgKHVuc2FmZV9nZXRfdWludDggaW5wdXQgKG9mZiArIGkgKyAxKSlcbiAgICAgICAgICAwIGpcbiAgICAgIGVsc2UgKFxuICAgICAgICBlbWl0XG4gICAgICAgICAgKHVuc2FmZV9nZXRfdWludDggaW5wdXQgKG9mZiArIGkpKVxuICAgICAgICAgICh1bnNhZmVfZ2V0X3VpbnQ4IGlucHV0IChvZmYgKyBpICsgMSkpXG4gICAgICAgICAgKHVuc2FmZV9nZXRfdWludDggaW5wdXQgKG9mZiArIGkgKyAyKSlcbiAgICAgICAgICBqIDtcbiAgICAgICAgZW5jIChqICsgNCkgKGkgKyAzKSkgaW5cblxuICAgIGxldCByZWMgdW5zYWZlX2ZpeCA9IGZ1bmN0aW9uXG4gICAgICB8IDAgLT4gKClcbiAgICAgIHwgaSAtPlxuICAgICAgICAgIHVuc2FmZV9zZXRfdWludDggcmVzIChuJyAtIGkpIHBhZGRpbmcgO1xuICAgICAgICAgIHVuc2FmZV9maXggKGkgLSAxKSBpblxuXG4gICAgZW5jIDAgMCA7XG5cbiAgICBsZXQgcGFkX3RvX3dyaXRlID0gKDMgLSAobiBtb2QgMykpIG1vZCAzIGluXG5cbiAgICBpZiBwYWRcbiAgICB0aGVuIChcbiAgICAgIHVuc2FmZV9maXggcGFkX3RvX3dyaXRlIDtcbiAgICAgIE9rIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlcywgMCwgbicpKVxuICAgIGVsc2UgT2sgKEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzLCAwLCBuJyAtIHBhZF90b193cml0ZSlcblxuKCogW3BhZCA9IGZhbHNlXSwgd2UgZG9uJ3Qgd2FudCB0byB3cml0ZSB0aGVtLiAqKVxuXG5sZXQgZW5jb2RlID8ocGFkID0gdHJ1ZSkgPyhhbHBoYWJldCA9IGRlZmF1bHRfYWxwaGFiZXQpID9vZmYgP2xlbiBpbnB1dCA9XG4gIG1hdGNoIGVuY29kZV9zdWIgcGFkIGFscGhhYmV0ID9vZmYgP2xlbiBpbnB1dCB3aXRoXG4gIHwgT2sgKHJlcywgb2ZmLCBsZW4pIC0+IE9rIChTdHJpbmcuc3ViIHJlcyBvZmYgbGVuKVxuICB8IEVycm9yIF8gYXMgZXJyIC0+IGVyclxuXG5sZXQgZW5jb2RlX3N0cmluZyA/cGFkID9hbHBoYWJldCBpbnB1dCA9XG4gIG1hdGNoIGVuY29kZSA/cGFkID9hbHBoYWJldCBpbnB1dCB3aXRoXG4gIHwgT2sgcmVzIC0+IHJlc1xuICB8IEVycm9yIF8gLT4gYXNzZXJ0IGZhbHNlXG5cbmxldCBlbmNvZGVfc3ViID8ocGFkID0gdHJ1ZSkgPyhhbHBoYWJldCA9IGRlZmF1bHRfYWxwaGFiZXQpID9vZmYgP2xlbiBpbnB1dCA9XG4gIGVuY29kZV9zdWIgcGFkIGFscGhhYmV0ID9vZmYgP2xlbiBpbnB1dFxuXG5sZXQgZW5jb2RlX2V4biA/cGFkID9hbHBoYWJldCA/b2ZmID9sZW4gaW5wdXQgPVxuICBtYXRjaCBlbmNvZGUgP3BhZCA/YWxwaGFiZXQgP29mZiA/bGVuIGlucHV0IHdpdGhcbiAgfCBPayB2IC0+IHZcbiAgfCBFcnJvciAoYE1zZyBlcnIpIC0+IGludmFsaWRfYXJnIGVyclxuXG5sZXQgZGVjb2RlX3N1YiA/KHBhZCA9IHRydWUpIHsgZG1hcDsgXyB9ID8ob2ZmID0gMCkgP2xlbiBpbnB1dCA9XG4gIGxldCBsZW4gPVxuICAgIG1hdGNoIGxlbiB3aXRoIFNvbWUgbGVuIC0+IGxlbiB8IE5vbmUgLT4gU3RyaW5nLmxlbmd0aCBpbnB1dCAtIG9mZiBpblxuXG4gIGlmIGxlbiA8IDAgfHwgb2ZmIDwgMCB8fCBvZmYgPiBTdHJpbmcubGVuZ3RoIGlucHV0IC0gbGVuXG4gIHRoZW4gZXJyb3JfbXNnZiBcIkludmFsaWQgYm91bmRzXCJcbiAgZWxzZVxuICAgIGxldCBuID0gbGVuIC8vIDQgKiA0IGluXG4gICAgbGV0IG4nID0gbiAvLyA0ICogMyBpblxuICAgIGxldCByZXMgPSBCeXRlcy5jcmVhdGUgbicgaW5cbiAgICBsZXQgaW52YWxpZF9wYWRfb3ZlcmZsb3cgPSBwYWQgaW5cblxuICAgIGxldCBnZXRfdWludDhfb3JfcGFkZGluZyA9XG4gICAgICBpZiBwYWRcbiAgICAgIHRoZW4gKGZ1biB0IGkgLT5cbiAgICAgICAgaWYgaSA+PSBsZW4gdGhlbiByYWlzZSBPdXRfb2ZfYm91bmRzIDtcbiAgICAgICAgZ2V0X3VpbnQ4IHQgKG9mZiArIGkpKVxuICAgICAgZWxzZVxuICAgICAgICBmdW4gdCBpIC0+XG4gICAgICAgIHRyeSBpZiBpIDwgbGVuIHRoZW4gZ2V0X3VpbnQ4IHQgKG9mZiArIGkpIGVsc2UgcGFkZGluZ1xuICAgICAgICB3aXRoIE91dF9vZl9ib3VuZHMgLT4gcGFkZGluZyBpblxuXG4gICAgbGV0IHNldF9iZV91aW50MTYgdCBvZmYgdiA9XG4gICAgICAoKiBjYW4gbm90IHdyaXRlIDIgYnl0ZXMuICopXG4gICAgICBpZiBvZmYgPCAwIHx8IG9mZiArIDEgPiBCeXRlcy5sZW5ndGggdFxuICAgICAgdGhlbiAoKSAoKiBjYW4gbm90IHdyaXRlIDEgYnl0ZSBidXQgY2FuIHdyaXRlIDEgYnl0ZSAqKVxuICAgICAgZWxzZSBpZiBvZmYgPCAwIHx8IG9mZiArIDIgPiBCeXRlcy5sZW5ndGggdFxuICAgICAgdGhlbiB1bnNhZmVfc2V0X3VpbnQ4IHQgb2ZmICh2IGxzciA4KSAoKiBjYW4gd3JpdGUgMiBieXRlcy4gKilcbiAgICAgIGVsc2UgdW5zYWZlX3NldF9iZV91aW50MTYgdCBvZmYgdiBpblxuXG4gICAgbGV0IHNldF91aW50OCB0IG9mZiB2ID1cbiAgICAgIGlmIG9mZiA8IDAgfHwgb2ZmID49IEJ5dGVzLmxlbmd0aCB0IHRoZW4gKCkgZWxzZSB1bnNhZmVfc2V0X3VpbnQ4IHQgb2ZmIHZcbiAgICBpblxuXG4gICAgbGV0IGVtaXQgYSBiIGMgZCBqID1cbiAgICAgIGxldCB4ID0gKGEgbHNsIDE4KSBsb3IgKGIgbHNsIDEyKSBsb3IgKGMgbHNsIDYpIGxvciBkIGluXG4gICAgICBzZXRfYmVfdWludDE2IHJlcyBqICh4IGxzciA4KSA7XG4gICAgICBzZXRfdWludDggcmVzIChqICsgMikgKHggbGFuZCAweGZmKSBpblxuXG4gICAgbGV0IGRtYXAgaSA9XG4gICAgICBsZXQgeCA9IEFycmF5LnVuc2FmZV9nZXQgZG1hcCBpIGluXG4gICAgICBpZiB4ID0gbm9uZSB0aGVuIHJhaXNlIE5vdF9mb3VuZCA7XG4gICAgICB4IGluXG5cbiAgICBsZXQgb25seV9wYWRkaW5nIHBhZCBpZHggPVxuICAgICAgKCogYmVjYXVzZSB3ZSByb3VuZCBsZW5ndGggb2YgW3Jlc10gdG8gdGhlIHVwcGVyIGJvdW5kIG9mIGhvdyBtYW55XG4gICAgICAgICBjaGFyYWN0ZXJzIHdlIHNob3VsZCBoYXZlIGZyb20gW2lucHV0XSwgd2UgZ290IGF0IHRoaXMgc3RhZ2Ugb25seSBwYWRkaW5nXG4gICAgICAgICBjaGFyYWN0ZXJzIGFuZCB3ZSBuZWVkIHRvIGRlbGV0ZSB0aGVtLCBzbyBmb3IgZWFjaCBbPT09PV0sIHdlIGRlbGV0ZSAzXG4gICAgICAgICBieXRlcy4gKilcbiAgICAgIGxldCBwYWQgPSByZWYgKHBhZCArIDMpIGluXG4gICAgICBsZXQgaWR4ID0gcmVmIGlkeCBpblxuXG4gICAgICB3aGlsZSAhaWR4ICsgNCA8IGxlbiBkb1xuICAgICAgICAoKiB1c2UgW3Vuc2FmZV9nZXRfdWludDE2XSBpbnN0ZWFkIFt1bnNhZmVfZ2V0X3VpbnQzMl0gdG8gYXZvaWQgYWxsb2NhdGlvblxuICAgICAgICAgICBvZiBbaW50MzJdLiBPZiBjb3Vyc2UsIFszZDNkM2QzZF0gaXMgWz09PT1dLiAqKVxuICAgICAgICBpZiB1bnNhZmVfZ2V0X3VpbnQxNiBpbnB1dCAob2ZmICsgIWlkeCkgPD4gMHgzZDNkXG4gICAgICAgICAgIHx8IHVuc2FmZV9nZXRfdWludDE2IGlucHV0IChvZmYgKyAhaWR4ICsgMikgPD4gMHgzZDNkXG4gICAgICAgIHRoZW4gcmFpc2UgTm90X2ZvdW5kIDtcblxuICAgICAgICAoKiBXZSBnb3Qgc29tZXRoaW5nIGJhZCwgc2hvdWxkIGJlIGEgdmFsaWQgY2hhcmFjdGVyIGFjY29yZGluZyB0b1xuICAgICAgICAgICBbYWxwaGFiZXRdIGJ1dCBvdXRzaWRlIHRoZSBzY29wZS4gKilcbiAgICAgICAgaWR4IDo9ICFpZHggKyA0IDtcbiAgICAgICAgcGFkIDo9ICFwYWQgKyAzXG4gICAgICBkb25lIDtcbiAgICAgIHdoaWxlICFpZHggPCBsZW4gZG9cbiAgICAgICAgaWYgdW5zYWZlX2dldF91aW50OCBpbnB1dCAob2ZmICsgIWlkeCkgPD4gcGFkZGluZyB0aGVuIHJhaXNlIE5vdF9mb3VuZCA7XG5cbiAgICAgICAgaW5jciBpZHhcbiAgICAgIGRvbmUgO1xuICAgICAgIXBhZCBpblxuXG4gICAgbGV0IHJlYyBkZWMgaiBpID1cbiAgICAgIGlmIGkgPSBuXG4gICAgICB0aGVuIDBcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IGQsIHBhZCA9XG4gICAgICAgICAgbGV0IHggPSBnZXRfdWludDhfb3JfcGFkZGluZyBpbnB1dCAoaSArIDMpIGluXG4gICAgICAgICAgdHJ5IChkbWFwIHgsIDApIHdpdGggTm90X2ZvdW5kIHdoZW4geCA9IHBhZGRpbmcgLT4gKDAsIDEpIGluXG4gICAgICAgICgqIFtOb3RfZm91bmRdIGlmZiBbeCDiiIkgYWxwaGFiZXQgYW5kIHggPD4gJz0nXSBjYW4gbGVhay4gKilcbiAgICAgICAgbGV0IGMsIHBhZCA9XG4gICAgICAgICAgbGV0IHggPSBnZXRfdWludDhfb3JfcGFkZGluZyBpbnB1dCAoaSArIDIpIGluXG4gICAgICAgICAgdHJ5IChkbWFwIHgsIHBhZClcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCB3aGVuIHggPSBwYWRkaW5nICYmIHBhZCA9IDEgLT4gKDAsIDIpIGluXG4gICAgICAgICgqIFtOb3RfZm91bmRdIGlmZiBbeCDiiIkgYWxwaGFiZXQgYW5kIHggPD4gJz0nXSBjYW4gbGVhay4gKilcbiAgICAgICAgbGV0IGIsIHBhZCA9XG4gICAgICAgICAgbGV0IHggPSBnZXRfdWludDhfb3JfcGFkZGluZyBpbnB1dCAoaSArIDEpIGluXG4gICAgICAgICAgdHJ5IChkbWFwIHgsIHBhZClcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCB3aGVuIHggPSBwYWRkaW5nICYmIHBhZCA9IDIgLT4gKDAsIDMpIGluXG4gICAgICAgICgqIFtOb3RfZm91bmRdIGlmZiBbeCDiiIkgYWxwaGFiZXQgYW5kIHggPD4gJz0nXSBjYW4gbGVhay4gKilcbiAgICAgICAgbGV0IGEsIHBhZCA9XG4gICAgICAgICAgbGV0IHggPSBnZXRfdWludDhfb3JfcGFkZGluZyBpbnB1dCBpIGluXG4gICAgICAgICAgdHJ5IChkbWFwIHgsIHBhZClcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCB3aGVuIHggPSBwYWRkaW5nICYmIHBhZCA9IDMgLT4gKDAsIDQpIGluXG5cbiAgICAgICAgKCogW05vdF9mb3VuZF0gaWZmIFt4IOKIiSBhbHBoYWJldCBhbmQgeCA8PiAnPSddIGNhbiBsZWFrLiAqKVxuICAgICAgICBlbWl0IGEgYiBjIGQgaiA7XG5cbiAgICAgICAgaWYgaSArIDQgPSBuICgqIGVuZCBvZiBpbnB1dCBpbiBhbnl3YXkgKilcbiAgICAgICAgdGhlblxuICAgICAgICAgIG1hdGNoIHBhZCB3aXRoXG4gICAgICAgICAgfCAwIC0+IDBcbiAgICAgICAgICB8IDQgLT5cbiAgICAgICAgICAgICAgKCogYXNzZXJ0IChpbnZhbGlkX3BhZF9vdmVyZmxvdyA9IGZhbHNlKSA7ICopXG4gICAgICAgICAgICAgIDNcbiAgICAgICAgICAoKiBbZ2V0X3VpbnQ4XSBsaWVzIGFuZCBpZiB3ZSBnZXQgWzRdLCB0aGF0IG1lYW4gd2UgZ290IG9uZSBvciBtb3JlIChhdFxuICAgICAgICAgICAgIG1vc3QgNCkgcGFkZGluZyBjaGFyYWN0ZXIuIEluIHRoaXMgc2l0dWF0aW9uLCBiZWNhdXNlIHdlIHJvdW5kIGxlbmd0aFxuICAgICAgICAgICAgIG9mIFtyZXNdIChzZWUgW24gLy8gNF0pLCB3ZSBuZWVkIHRvIGRlbGV0ZSAzIGJ5dGVzLiAqKVxuICAgICAgICAgIHwgcGFkIC0+IHBhZFxuICAgICAgICBlbHNlXG4gICAgICAgICAgbWF0Y2ggcGFkIHdpdGhcbiAgICAgICAgICB8IDAgLT4gZGVjIChqICsgMykgKGkgKyA0KVxuICAgICAgICAgIHwgNCAtPlxuICAgICAgICAgICAgICAoKiBhc3NlcnQgKGludmFsaWRfcGFkX292ZXJmbG93ID0gZmFsc2UpIDsgKilcbiAgICAgICAgICAgICAgb25seV9wYWRkaW5nIDMgKGkgKyA0KVxuICAgICAgICAgICgqIFNhbWUgc2l0dWF0aW9uIHRoYW4gYWJvdmUgYnV0IHdlIHNob3VsZCBnZXQgb25seSBtb3JlIHBhZGRpbmdcbiAgICAgICAgICAgICBjaGFyYWN0ZXJzIHRoZW4uICopXG4gICAgICAgICAgfCBwYWQgLT5cbiAgICAgICAgICAgICAgaWYgaW52YWxpZF9wYWRfb3ZlcmZsb3cgPSB0cnVlIHRoZW4gcmFpc2UgVG9vX211Y2hfaW5wdXQgO1xuICAgICAgICAgICAgICBvbmx5X3BhZGRpbmcgcGFkIChpICsgNCkgaW5cblxuICAgIG1hdGNoIGRlYyAwIDAgd2l0aFxuICAgIHwgMCAtPiBPayAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyByZXMsIDAsIG4nKVxuICAgIHwgcGFkIC0+IE9rIChCeXRlcy51bnNhZmVfdG9fc3RyaW5nIHJlcywgMCwgbicgLSBwYWQpXG4gICAgfCBleGNlcHRpb24gT3V0X29mX2JvdW5kcyAtPlxuICAgICAgICBlcnJvcl9tc2dmIFwiV3JvbmcgcGFkZGluZ1wiXG4gICAgICAgICgqIGFwcGVhciBvbmx5IHdoZW4gW3BhZCA9IHRydWVdIGFuZCB3aGVuIGxlbmd0aCBvZiBpbnB1dCBpcyBub3QgYSBtdWx0aXBsZSBvZiA0LiAqKVxuICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPlxuICAgICAgICAoKiBhcHBlYXIgd2hlbiBvbmUgY2hhcmFjdGVyIG9mIFtpbnB1dF0g4oiJIFthbHBoYWJldF0gYW5kIHRoaXMgY2hhcmFjdGVyIDw+ICc9JyAqKVxuICAgICAgICBlcnJvcl9tc2dmIFwiTWFsZm9ybWVkIGlucHV0XCJcbiAgICB8IGV4Y2VwdGlvbiBUb29fbXVjaF9pbnB1dCAtPiBlcnJvcl9tc2dmIFwiVG9vIG11Y2ggaW5wdXRcIlxuXG5sZXQgZGVjb2RlID9wYWQgPyhhbHBoYWJldCA9IGRlZmF1bHRfYWxwaGFiZXQpID9vZmYgP2xlbiBpbnB1dCA9XG4gIG1hdGNoIGRlY29kZV9zdWIgP3BhZCBhbHBoYWJldCA/b2ZmID9sZW4gaW5wdXQgd2l0aFxuICB8IE9rIChyZXMsIG9mZiwgbGVuKSAtPiBPayAoU3RyaW5nLnN1YiByZXMgb2ZmIGxlbilcbiAgfCBFcnJvciBfIGFzIGVyciAtPiBlcnJcblxubGV0IGRlY29kZV9zdWIgP3BhZCA/KGFscGhhYmV0ID0gZGVmYXVsdF9hbHBoYWJldCkgP29mZiA/bGVuIGlucHV0ID1cbiAgZGVjb2RlX3N1YiA/cGFkIGFscGhhYmV0ID9vZmYgP2xlbiBpbnB1dFxuXG5sZXQgZGVjb2RlX2V4biA/cGFkID9hbHBoYWJldCA/b2ZmID9sZW4gaW5wdXQgPVxuICBtYXRjaCBkZWNvZGUgP3BhZCA/YWxwaGFiZXQgP29mZiA/bGVuIGlucHV0IHdpdGhcbiAgfCBPayByZXMgLT4gcmVzXG4gIHwgRXJyb3IgKGBNc2cgZXJyKSAtPiBpbnZhbGlkX2FyZyBlcnJcbiJdfQ==
