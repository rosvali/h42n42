// Generated by js_of_ocaml
//# buildInfo:effects=false, kind=cma, use-js-string=true, version=5.6.0

//# unitInfo: Provides: Re__
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, Re = [0];
   runtime.caml_register_global(0, Re, "Re__");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Category
//# unitInfo: Requires: Stdlib__Format
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format;
   function equal(x, y){return x === y ? 1 : 0;}
   var compare = runtime.caml_int_compare;
   function to_int(x){return x;}
   var pp = Stdlib_Format[19];
   function intersect(x, y){return 0 !== (x & y) ? 1 : 0;}
   function symbol(x, y){return x | y;}
   var
    dummy = -1,
    inexistant = 1,
    letter = 2,
    not_letter = 4,
    newline = 8,
    lastnewline = 16,
    search_boundary = 32;
   function from_char(param){
    a:
    {
     if(170 <= param)
      if(187 <= param){
       var _a_ = param - 192 | 0;
       if(54 < _a_ >>> 0){if(56 <= _a_) break a;} else if(23 !== _a_) break a;
      }
      else{
       var _b_ = param - 171 | 0;
       if(14 < _b_ >>> 0 || 10 === _b_) break a;
      }
     else if(65 <= param){
      var _c_ = param - 91 | 0;
      if(5 < _c_ >>> 0){if(32 > _c_) break a;} else if(4 === _c_) break a;
     }
     else
      if(48 <= param){
       if(58 > param) break a;
      }
      else if(10 === param) return 12;
     return not_letter;
    }
    return letter;
   }
   var
    Re_Category =
      [0,
       symbol,
       from_char,
       dummy,
       inexistant,
       letter,
       not_letter,
       newline,
       lastnewline,
       search_boundary,
       to_int,
       equal,
       compare,
       intersect,
       pp];
   runtime.caml_register_global(1, Re_Category, "Re__Category");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Fmt
//# unitInfo: Requires: Stdlib__Buffer, Stdlib__Format
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime, cst_3 = "<3>", cst = "@ ";
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Format = global_data.Stdlib__Format,
    pp_open_box = Stdlib_Format[1],
    open_box = Stdlib_Format[2],
    pp_close_box = Stdlib_Format[3],
    close_box = Stdlib_Format[4],
    pp_open_hbox = Stdlib_Format[5],
    open_hbox = Stdlib_Format[6],
    pp_open_vbox = Stdlib_Format[7],
    open_vbox = Stdlib_Format[8],
    pp_open_hvbox = Stdlib_Format[9],
    open_hvbox = Stdlib_Format[10],
    pp_open_hovbox = Stdlib_Format[11],
    open_hovbox = Stdlib_Format[12],
    pp_print_string = Stdlib_Format[13],
    print_string = Stdlib_Format[14],
    pp_print_bytes = Stdlib_Format[15],
    print_bytes = Stdlib_Format[16],
    pp_print_as = Stdlib_Format[17],
    print_as = Stdlib_Format[18],
    pp_print_int = Stdlib_Format[19],
    print_int = Stdlib_Format[20],
    pp_print_float = Stdlib_Format[21],
    print_float = Stdlib_Format[22],
    pp_print_char = Stdlib_Format[23],
    print_char = Stdlib_Format[24],
    pp_print_bool = Stdlib_Format[25],
    print_bool = Stdlib_Format[26],
    pp_print_space = Stdlib_Format[27],
    print_space = Stdlib_Format[28],
    pp_print_cut = Stdlib_Format[29],
    print_cut = Stdlib_Format[30],
    pp_print_break = Stdlib_Format[31],
    print_break = Stdlib_Format[32],
    pp_print_custom_break = Stdlib_Format[33],
    pp_force_newline = Stdlib_Format[34],
    force_newline = Stdlib_Format[35],
    pp_print_if_newline = Stdlib_Format[36],
    print_if_newline = Stdlib_Format[37],
    pp_print_flush = Stdlib_Format[38],
    print_flush = Stdlib_Format[39],
    pp_print_newline = Stdlib_Format[40],
    print_newline = Stdlib_Format[41],
    pp_set_margin = Stdlib_Format[42],
    set_margin = Stdlib_Format[43],
    pp_get_margin = Stdlib_Format[44],
    get_margin = Stdlib_Format[45],
    pp_set_max_indent = Stdlib_Format[46],
    set_max_indent = Stdlib_Format[47],
    pp_get_max_indent = Stdlib_Format[48],
    get_max_indent = Stdlib_Format[49],
    check_geometry = Stdlib_Format[50],
    pp_set_geometry = Stdlib_Format[51],
    set_geometry = Stdlib_Format[52],
    pp_safe_set_geometry = Stdlib_Format[53],
    safe_set_geometry = Stdlib_Format[54],
    pp_update_geometry = Stdlib_Format[55],
    update_geometry = Stdlib_Format[56],
    pp_get_geometry = Stdlib_Format[57],
    get_geometry = Stdlib_Format[58],
    pp_set_max_boxes = Stdlib_Format[59],
    set_max_boxes = Stdlib_Format[60],
    pp_get_max_boxes = Stdlib_Format[61],
    get_max_boxes = Stdlib_Format[62],
    pp_over_max_boxes = Stdlib_Format[63],
    over_max_boxes = Stdlib_Format[64],
    pp_open_tbox = Stdlib_Format[65],
    open_tbox = Stdlib_Format[66],
    pp_close_tbox = Stdlib_Format[67],
    close_tbox = Stdlib_Format[68],
    pp_set_tab = Stdlib_Format[69],
    set_tab = Stdlib_Format[70],
    pp_print_tab = Stdlib_Format[71],
    print_tab = Stdlib_Format[72],
    pp_print_tbreak = Stdlib_Format[73],
    print_tbreak = Stdlib_Format[74],
    pp_set_ellipsis_text = Stdlib_Format[75],
    set_ellipsis_text = Stdlib_Format[76],
    pp_get_ellipsis_text = Stdlib_Format[77],
    get_ellipsis_text = Stdlib_Format[78],
    String_tag = Stdlib_Format[79],
    pp_open_stag = Stdlib_Format[80],
    open_stag = Stdlib_Format[81],
    pp_close_stag = Stdlib_Format[82],
    close_stag = Stdlib_Format[83],
    pp_set_tags = Stdlib_Format[84],
    set_tags = Stdlib_Format[85],
    pp_set_print_tags = Stdlib_Format[86],
    set_print_tags = Stdlib_Format[87],
    pp_set_mark_tags = Stdlib_Format[88],
    set_mark_tags = Stdlib_Format[89],
    pp_get_print_tags = Stdlib_Format[90],
    get_print_tags = Stdlib_Format[91],
    pp_get_mark_tags = Stdlib_Format[92],
    get_mark_tags = Stdlib_Format[93],
    pp_set_formatter_out_channel = Stdlib_Format[94],
    set_formatter_out_channel = Stdlib_Format[95],
    pp_set_formatter_output_functi = Stdlib_Format[96],
    set_formatter_output_functions = Stdlib_Format[97],
    pp_get_formatter_output_functi = Stdlib_Format[98],
    get_formatter_output_functions = Stdlib_Format[99],
    pp_set_formatter_out_functions = Stdlib_Format[100],
    set_formatter_out_functions = Stdlib_Format[101],
    pp_get_formatter_out_functions = Stdlib_Format[102],
    get_formatter_out_functions = Stdlib_Format[103],
    pp_set_formatter_stag_function = Stdlib_Format[104],
    set_formatter_stag_functions = Stdlib_Format[105],
    pp_get_formatter_stag_function = Stdlib_Format[106],
    get_formatter_stag_functions = Stdlib_Format[107],
    formatter_of_out_channel = Stdlib_Format[108],
    std_formatter = Stdlib_Format[109],
    err_formatter = Stdlib_Format[110],
    formatter_of_buffer = Stdlib_Format[111],
    stdbuf = Stdlib_Format[112],
    str_formatter = Stdlib_Format[113],
    flush_str_formatter = Stdlib_Format[114],
    make_formatter = Stdlib_Format[115],
    formatter_of_out_functions = Stdlib_Format[116],
    make_symbolic_output_buffer = Stdlib_Format[117],
    clear_symbolic_output_buffer = Stdlib_Format[118],
    get_symbolic_output_buffer = Stdlib_Format[119],
    flush_symbolic_output_buffer = Stdlib_Format[120],
    add_symbolic_output_item = Stdlib_Format[121],
    formatter_of_symbolic_output_b = Stdlib_Format[122],
    pp_print_list = Stdlib_Format[123],
    pp_print_seq = Stdlib_Format[124],
    pp_print_text = Stdlib_Format[125],
    pp_print_option = Stdlib_Format[126],
    pp_print_result = Stdlib_Format[127],
    pp_print_either = Stdlib_Format[128],
    fprintf = Stdlib_Format[129],
    printf = Stdlib_Format[130],
    eprintf = Stdlib_Format[131],
    sprintf = Stdlib_Format[132],
    asprintf = Stdlib_Format[133],
    dprintf = Stdlib_Format[134],
    ifprintf = Stdlib_Format[135],
    kfprintf = Stdlib_Format[136],
    kdprintf = Stdlib_Format[137],
    ikfprintf = Stdlib_Format[138],
    ksprintf = Stdlib_Format[139],
    kasprintf = Stdlib_Format[140],
    bprintf = Stdlib_Format[141],
    kprintf = Stdlib_Format[142],
    set_all_formatter_output_funct = Stdlib_Format[143],
    get_all_formatter_output_funct = Stdlib_Format[144],
    pp_set_all_formatter_output_fu = Stdlib_Format[145],
    pp_get_all_formatter_output_fu = Stdlib_Format[146],
    pp_open_tag = Stdlib_Format[147],
    open_tag = Stdlib_Format[148],
    pp_close_tag = Stdlib_Format[149],
    close_tag = Stdlib_Format[150],
    pp_set_formatter_tag_functions = Stdlib_Format[151],
    set_formatter_tag_functions = Stdlib_Format[152],
    pp_get_formatter_tag_functions = Stdlib_Format[153],
    get_formatter_tag_functions = Stdlib_Format[154],
    _d_ = [0, [12, 59, [17, [0, cst, 1, 0], 0]], ";@ "],
    _e_ =
      [0,
       [18,
        [1, [0, [11, cst_3, 0], cst_3]],
        [12,
         91,
         [17,
          [0, cst, 1, 0],
          [15, [17, [0, cst, 1, 0], [12, 93, [17, 0, 0]]]]]]],
       "@[<3>[@ %a@ ]@]"],
    _c_ = [0, [12, 34, [2, 0, [12, 34, 0]]], '"%s"'],
    _b_ = [0, [17, [0, cst, 1, 0], [4, 0, 0, 0, 0]], "@ %d"],
    _a_ =
      [0,
       [18,
        [1, [0, [11, cst_3, 0], cst_3]],
        [12, 40, [2, 0, [17, [0, cst, 1, 0], [15, [12, 41, [17, 0, 0]]]]]]],
       "@[<3>(%s@ %a)@]"];
   function sexp(fmt, s, pp, x){
    return caml_call5(fprintf, fmt, _a_, s, pp, x);
   }
   function pair(pp1, pp2, fmt, param){
    var v2 = param[2], v1 = param[1];
    caml_call2(pp1, fmt, v1);
    caml_call2(pp_print_space, fmt, 0);
    return caml_call2(pp2, fmt, v2);
   }
   function triple(pp1, pp2, pp3, fmt, param){
    var v3 = param[3], v2 = param[2], v1 = param[1];
    caml_call2(pp1, fmt, v1);
    caml_call2(pp_print_space, fmt, 0);
    caml_call2(pp2, fmt, v2);
    caml_call2(pp_print_space, fmt, 0);
    return caml_call2(pp3, fmt, v3);
   }
   function optint(fmt, param){
    if(! param) return 0;
    var i = param[1];
    return caml_call3(fprintf, fmt, _b_, i);
   }
   function quote(fmt, s){return caml_call3(Stdlib_Format[129], fmt, _c_, s);}
   function pp_olist(pp_elem, fmt){
    var
     _g_ =
       caml_call2
        (pp_print_list,
         [0, function(fmt, param){return caml_call2(fprintf, fmt, _d_);}],
         pp_elem);
    return caml_call3(Stdlib_Format[129], fmt, _e_, _g_);
   }
   function pp_str_list(_f_){return pp_olist(quote, _f_);}
   function to_to_string(pp, x){
    var
     b = caml_call1(Stdlib_Buffer[1], 16),
     fmt = caml_call1(Stdlib_Format[111], b);
    caml_call2(pp, fmt, x);
    return caml_call1(Stdlib_Buffer[2], b);
   }
   var
    Re_Fmt =
      [0,
       pp_open_box,
       open_box,
       pp_close_box,
       close_box,
       pp_open_hbox,
       open_hbox,
       pp_open_vbox,
       open_vbox,
       pp_open_hvbox,
       open_hvbox,
       pp_open_hovbox,
       open_hovbox,
       pp_print_string,
       print_string,
       pp_print_bytes,
       print_bytes,
       pp_print_as,
       print_as,
       pp_print_int,
       print_int,
       pp_print_float,
       print_float,
       pp_print_char,
       print_char,
       pp_print_bool,
       print_bool,
       pp_print_space,
       print_space,
       pp_print_cut,
       print_cut,
       pp_print_break,
       print_break,
       pp_print_custom_break,
       pp_force_newline,
       force_newline,
       pp_print_if_newline,
       print_if_newline,
       pp_print_flush,
       print_flush,
       pp_print_newline,
       print_newline,
       pp_set_margin,
       set_margin,
       pp_get_margin,
       get_margin,
       pp_set_max_indent,
       set_max_indent,
       pp_get_max_indent,
       get_max_indent,
       check_geometry,
       pp_set_geometry,
       set_geometry,
       pp_safe_set_geometry,
       safe_set_geometry,
       pp_update_geometry,
       update_geometry,
       pp_get_geometry,
       get_geometry,
       pp_set_max_boxes,
       set_max_boxes,
       pp_get_max_boxes,
       get_max_boxes,
       pp_over_max_boxes,
       over_max_boxes,
       pp_open_tbox,
       open_tbox,
       pp_close_tbox,
       close_tbox,
       pp_set_tab,
       set_tab,
       pp_print_tab,
       print_tab,
       pp_print_tbreak,
       print_tbreak,
       pp_set_ellipsis_text,
       set_ellipsis_text,
       pp_get_ellipsis_text,
       get_ellipsis_text,
       String_tag,
       pp_open_stag,
       open_stag,
       pp_close_stag,
       close_stag,
       pp_set_tags,
       set_tags,
       pp_set_print_tags,
       set_print_tags,
       pp_set_mark_tags,
       set_mark_tags,
       pp_get_print_tags,
       get_print_tags,
       pp_get_mark_tags,
       get_mark_tags,
       pp_set_formatter_out_channel,
       set_formatter_out_channel,
       pp_set_formatter_output_functi,
       set_formatter_output_functions,
       pp_get_formatter_output_functi,
       get_formatter_output_functions,
       pp_set_formatter_out_functions,
       set_formatter_out_functions,
       pp_get_formatter_out_functions,
       get_formatter_out_functions,
       pp_set_formatter_stag_function,
       set_formatter_stag_functions,
       pp_get_formatter_stag_function,
       get_formatter_stag_functions,
       formatter_of_out_channel,
       std_formatter,
       err_formatter,
       formatter_of_buffer,
       stdbuf,
       str_formatter,
       flush_str_formatter,
       make_formatter,
       formatter_of_out_functions,
       make_symbolic_output_buffer,
       clear_symbolic_output_buffer,
       get_symbolic_output_buffer,
       flush_symbolic_output_buffer,
       add_symbolic_output_item,
       formatter_of_symbolic_output_b,
       pp_print_list,
       pp_print_seq,
       pp_print_text,
       pp_print_option,
       pp_print_result,
       pp_print_either,
       fprintf,
       printf,
       eprintf,
       sprintf,
       asprintf,
       dprintf,
       ifprintf,
       kfprintf,
       kdprintf,
       ikfprintf,
       ksprintf,
       kasprintf,
       bprintf,
       kprintf,
       set_all_formatter_output_funct,
       get_all_formatter_output_funct,
       pp_set_all_formatter_output_fu,
       pp_get_all_formatter_output_fu,
       pp_open_tag,
       open_tag,
       pp_close_tag,
       close_tag,
       pp_set_formatter_tag_functions,
       set_formatter_tag_functions,
       pp_get_formatter_tag_functions,
       get_formatter_tag_functions,
       pp_print_list,
       pp_print_string,
       sexp,
       pair,
       triple,
       pp_print_int,
       optint,
       quote,
       pp_olist,
       pp_str_list,
       to_to_string];
   runtime.caml_register_global(7, Re_Fmt, "Re__Fmt");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Cset
//# unitInfo: Requires: Assert_failure, Re__Fmt, Stdlib, Stdlib__Format, Stdlib__List, Stdlib__Map
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_compare = runtime.caml_compare,
    caml_lessthan = runtime.caml_lessthan,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cany = [0, [0, 0, 255], 0],
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Format = global_data.Stdlib__Format,
    Re_Fmt = global_data.Re__Fmt,
    Stdlib_Map = global_data.Stdlib__Map,
    _c_ = [0, "lib/cset.ml", 153, 9],
    cst_Re_cset_pick = "Re_cset.pick",
    _a_ = [0, [4, 0, 0, 0, 0], "%d"],
    _b_ = [0, [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]], "%d-%d"];
   function union(l$0, l){
    var l$2 = l$0, l$1 = l;
    for(;;){
     if(! l$1) return l$2;
     if(! l$2) return l$1;
     var
      r = l$1[2],
      _n_ = l$1[1],
      c2 = _n_[2],
      c1 = _n_[1],
      r$0 = l$2[2],
      match = l$2[1],
      c2$0 = match[2],
      c1$0 = match[1];
     if((c2$0 + 1 | 0) < c1) return [0, [0, c1$0, c2$0], union(r$0, l$1)];
     if((c2 + 1 | 0) < c1$0) return [0, [0, c1, c2], union(l$2, r)];
     if(c2$0 < c2)
      var
       l$3 = [0, [0, caml_call2(Stdlib[16], c1$0, c1), c2], r],
       l$2 = r$0,
       l$1 = l$3;
     else
      var
       l$4 = [0, [0, caml_call2(Stdlib[16], c1$0, c1), c2$0], r$0],
       l$2 = l$4,
       l$1 = r;
    }
   }
   function inter(l$0, l){
    var l$2 = l$0, l$1 = l;
    for(;;){
     if(! l$1) return 0;
     if(! l$2) return 0;
     var
      r = l$1[2],
      _k_ = l$1[1],
      c2 = _k_[2],
      c1 = _k_[1],
      r$0 = l$2[2],
      match = l$2[1],
      c2$0 = match[2],
      c1$0 = match[1];
     if(caml_lessthan(c2$0, c1))
      var l$2 = r$0;
     else{
      if(! caml_lessthan(c2, c1$0)){
       if(caml_lessthan(c2$0, c2)){
        var _l_ = inter(r$0, l$1);
        return [0, [0, caml_call2(Stdlib[17], c1$0, c1), c2$0], _l_];
       }
       var _m_ = inter(l$2, r);
       return [0, [0, caml_call2(Stdlib[17], c1$0, c1), c2], _m_];
      }
      var l$1 = r;
     }
    }
   }
   function diff(l$0, l){
    var l$2 = l$0, l$1 = l;
    for(;;){
     if(! l$1) return l$2;
     if(! l$2) return 0;
     var
      r = l$1[2],
      _j_ = l$1[1],
      c2 = _j_[2],
      c1 = _j_[1],
      r$0 = l$2[2],
      match = l$2[1],
      c2$0 = match[2],
      c1$0 = match[1];
     if(c2$0 < c1) return [0, [0, c1$0, c2$0], diff(r$0, l$1)];
     if(c2 < c1$0)
      var l$1 = r;
     else{
      var r$1 = c2 < c2$0 ? [0, [0, c2 + 1 | 0, c2$0], r$0] : r$0;
      if(c1$0 < c1) return [0, [0, c1$0, c1 - 1 | 0], diff(r$1, r)];
      var l$2 = r$1, l$1 = r;
     }
    }
   }
   function single(c){return [0, [0, c, c], 0];}
   function add(c, l){return union(single(c), l);}
   function seq(c$0, c){
    return runtime.caml_lessequal(c$0, c)
            ? [0, [0, c$0, c], 0]
            : [0, [0, c, c$0], 0];
   }
   function offset(o, l){
    if(! l) return 0;
    var r = l[2], match = l[1], c2 = match[2], c1 = match[1];
    return [0, [0, c1 + o | 0, c2 + o | 0], offset(o, r)];
   }
   var empty = 0;
   function mem(c, s){
    var s$0 = s;
    for(;;){
     if(! s$0) return 0;
     var rem = s$0[2], match = s$0[1], c2 = match[2], c1 = match[1];
     if(c <= c2) return c1 <= c ? 1 : 0;
     var s$0 = rem;
    }
   }
   function hash_rec(param){
    if(! param) return 0;
    var r = param[2], match = param[1], j = match[2], i = match[1];
    return (i + (13 * j | 0) | 0) + (257 * hash_rec(r) | 0) | 0;
   }
   function hash(l){return hash_rec(l) & 1073741823;}
   function print_one(ch, param){
    var c2 = param[2], c1 = param[1];
    return c1 === c2
            ? caml_call3(Stdlib_Format[129], ch, _a_, c1)
            : caml_call4(Stdlib_Format[129], ch, _b_, c1, c2);
   }
   var pp = caml_call2(Re_Fmt[155], 0, print_one);
   function iter(t, f){
    var t$0 = t;
    for(;;){
     if(! t$0) return 0;
     var xs = t$0[2], match = t$0[1], y = match[2], x = match[1];
     caml_call2(f, x, y);
     var t$0 = xs;
    }
   }
   function one_char(param){
    if(param && ! param[2]){
     var match = param[1], j = match[2], i = match[1];
     if(runtime.caml_equal(i, j)) return [0, i];
    }
    return 0;
   }
   function compare(param, _i_){
    var
     v = _i_[2],
     j = _i_[1],
     u = param[2],
     i = param[1],
     c = caml_compare(i, j);
    return 0 === c ? caml_compare(u, v) : c;
   }
   var CSetMap = caml_call1(Stdlib_Map[1], [0, compare]);
   function fold_right(t, init, f){
    return caml_call3(Stdlib_List[26], f, t, init);
   }
   function csingle(c){return single(c);}
   function is_empty(param){return param ? 0 : 1;}
   function prepend(s, x, l){
    var s$0 = s;
    for(;;){
     if(! s$0) return l;
     if(! l) return 0;
     var _d_ = l[1], _e_ = _d_[1];
     if(_e_ && ! _e_[2]){
      var
       x$0 = _d_[2],
       _f_ = _e_[1],
       d = _f_[2],
       d$0 = _f_[1],
       r = s$0[2],
       match = s$0[1],
       c = match[2],
       c$0 = match[1];
      if(c < d$0){var s$0 = r; continue;}
      var r$0 = l[2];
      if(c$0 > d$0)
       return d < c$0
               ? [0, [0, [0, [0, d$0, d], 0], x$0], prepend(s$0, x, r$0)]
               : [0,
                 [0, [0, [0, d$0, c$0 - 1 | 0], 0], x$0],
                 prepend(s$0, x, [0, [0, [0, [0, c$0, d], 0], x$0], r$0])];
      if(c < d){
       var _g_ = prepend(r, x, [0, [0, [0, [0, c + 1 | 0, d], 0], x$0], r$0]);
       return [0,
               [0, [0, [0, d$0, c], 0], caml_call2(Stdlib[37], x, x$0)],
               _g_];
      }
      var _h_ = prepend(s$0, x, r$0);
      return [0,
              [0, [0, [0, d$0, d], 0], caml_call2(Stdlib[37], x, x$0)],
              _h_];
     }
     throw caml_maybe_attach_backtrace([0, Assert_failure, _c_], 1);
    }
   }
   function pick(param){
    if(! param) return caml_call1(Stdlib[1], cst_Re_cset_pick);
    var x = param[1][1];
    return x;
   }
   var
    Re_Cset =
      [0,
       iter,
       union,
       inter,
       diff,
       offset,
       empty,
       single,
       seq,
       add,
       mem,
       hash,
       pp,
       one_char,
       fold_right,
       hash_rec,
       CSetMap,
       cany,
       csingle,
       is_empty,
       prepend,
       pick];
   runtime.caml_register_global(11, Re_Cset, "Re__Cset");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Pmark
//# unitInfo: Requires: Stdlib__Format, Stdlib__Set
(function
  (globalThis){
   "use strict";
   var runtime = globalThis.jsoo_runtime;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Set = global_data.Stdlib__Set;
   function equal(x, y){return x === y ? 1 : 0;}
   var compare = runtime.caml_int_compare, r = [0, 0];
   function gen(param){r[1]++; return r[1];}
   var
    pp = Stdlib_Format[19],
    Set = caml_call1(Stdlib_Set[1], [0, compare]),
    Re_Pmark = [0, equal, compare, gen, pp, Set];
   runtime.caml_register_global(2, Re_Pmark, "Re__Pmark");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Automata
//# unitInfo: Requires: Assert_failure, Re__Category, Re__Cset, Re__Fmt, Re__Pmark, Stdlib, Stdlib__Array, Stdlib__Format, Stdlib__Hashtbl, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "()",
    cst_Exp = "(Exp",
    cst_2 = "<2>",
    cst$0 = "@ ",
    caml_check_bound = runtime.caml_check_bound,
    caml_compare = runtime.caml_compare,
    caml_equal = runtime.caml_equal,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_trampoline = runtime.caml_trampoline,
    caml_trampoline_return = runtime.caml_trampoline_return;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    partial = [17, 0, 0],
    partial$0 = [12, 41, [17, 0, 0]],
    eps_expr = [0, 0, 0],
    Re_Fmt = global_data.Re__Fmt,
    Re_Cset = global_data.Re__Cset,
    Re_Category = global_data.Re__Category,
    Stdlib_List = global_data.Stdlib__List,
    Assert_failure = global_data.Assert_failure,
    Re_Pmark = global_data.Re__Pmark,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_Format = global_data.Stdlib__Format,
    Stdlib_Hashtbl = global_data.Stdlib__Hashtbl,
    cst_eps = "eps",
    cst_cst = "cst",
    cst_alt = "alt",
    cst_seq = "seq",
    cst_rep = "rep",
    cst_mark = "mark",
    cst_erase = "erase",
    cst_before = "before",
    cst_after = "after",
    cst_pmark = "pmark",
    _n_ = [0, "lib/automata.ml", 360, 21],
    _e_ =
      [0,
       [18,
        [1, [0, [11, cst_2, 0], cst_2]],
        [11, "(Seq", [17, [0, cst$0, 1, 0], 0]]],
       "@[<2>(Seq@ "],
    _f_ = [0, [17, [0, cst$0, 1, 0], [15, [12, 41, [17, 0, 0]]]], "@ %a)@]"],
    _g_ =
      [0,
       [18,
        [1, [0, [11, cst_2, 0], cst_2]],
        [11,
         cst_Exp,
         [17,
          [0, cst$0, 1, 0],
          [4,
           0,
           0,
           0,
           [17,
            [0, cst$0, 1, 0],
            [12,
             40,
             [15, [12, 41, [17, [0, cst$0, 1, 0], [11, "(eps))", partial]]]]]]]]]],
       "@[<2>(Exp@ %d@ (%a)@ (eps))@]"],
    _h_ =
      [0,
       [18,
        [1, [0, [11, cst_2, 0], cst_2]],
        [11,
         cst_Exp,
         [17,
          [0, cst$0, 1, 0],
          [4,
           0,
           0,
           0,
           [17,
            [0, cst$0, 1, 0],
            [12, 40, [15, [12, 41, [17, [0, cst$0, 1, 0], [15, partial$0]]]]]]]]]],
       "@[<2>(Exp@ %d@ (%a)@ %a)@]"],
    _i_ =
      [0,
       [18,
        [1, [0, [11, cst_2, 0], cst_2]],
        [11, "(Match", [17, [0, cst$0, 1, 0], [15, [12, 41, [17, 0, 0]]]]]],
       "@[<2>(Match@ %a)@]"],
    _j_ = [0, [17, [0, cst$0, 1, 0], [11, "| ", 0]], "@ | "],
    _k_ = [0, [11, cst$1, 0], cst$1],
    _l_ = [0, 0, 0],
    _d_ = [1, 0],
    cst_Non_greedy = "Non_greedy",
    cst_Greedy = "Greedy",
    cst_first = "first",
    cst_short = "short",
    cst_long = "long",
    _c_ = [0, [12, 32, [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]]], " %d-%d"],
    _b_ = [0, [4, 0, 0, 0, [12, 45, [4, 0, 0, 0, 0]]], "%d-%d"];
   function hash_combine(h, accu){return (accu * 65599 | 0) + h | 0;}
   var empty = [0, 0, Re_Pmark[5][1]];
   function merge_marks_offset(old, param){
    if(! param) return old;
    var
     rem = param[2],
     match = param[1],
     v = match[2],
     i = match[1],
     nw = merge_marks_offset(caml_call2(Stdlib_List[53], i, old), rem);
    return -2 === v ? nw : [0, [0, i, v], nw];
   }
   function merge(old, nw){
    var _aV_ = caml_call2(Re_Pmark[5][7], old[2], nw[2]);
    return [0, merge_marks_offset(old[1], nw[1]), _aV_];
   }
   function hash(m, accu$1){
    var
     accu$2 = hash_combine(caml_call1(Stdlib_Hashtbl[28], m[2]), accu$1),
     l$0 = m[1],
     l = l$0,
     accu = accu$2;
    for(;;){
     if(! l) return accu;
     var
      r = l[2],
      match = l[1],
      i = match[2],
      a = match[1],
      accu$0 = hash_combine(a, hash_combine(i, accu)),
      l = r,
      accu = accu$0;
    }
   }
   function _a_(idx, marks){
    if(marks){
     var _aU_ = marks[1];
     if(-1 === _aU_[2]){
      var rem = marks[2], a = _aU_[1];
      return [0, [0, a, idx], _a_(idx, rem)];
     }
    }
    return marks;
   }
   function marks_set_idx(marks, idx){
    var _aT_ = marks[2];
    return [0, _a_(idx, marks[1]), _aT_];
   }
   function pp_marks(ch, t){
    var _aR_ = t[1];
    if(! _aR_) return 0;
    var r = _aR_[2], match = _aR_[1], i = match[2], a = match[1];
    caml_call4(Stdlib_Format[129], ch, _b_, a, i);
    function _aS_(param){
     var i = param[2], a = param[1];
     return caml_call4(Stdlib_Format[129], ch, _c_, a, i);
    }
    return caml_call2(Stdlib_List[17], _aS_, r);
   }
   function pp_sem(ch, k){
    var
     _aQ_ =
       -730718166 === k ? cst_long : 332064784 <= k ? cst_first : cst_short;
    return caml_call2(Stdlib_Format[13], ch, _aQ_);
   }
   function pp_rep_kind(fmt, param){
    return 620821490 <= param
            ? caml_call2(Stdlib_Format[13], fmt, cst_Non_greedy)
            : caml_call2(Stdlib_Format[13], fmt, cst_Greedy);
   }
   function pp(ch, e){
    var match = e[2];
    if(typeof match === "number") return caml_call2(Re_Fmt[156], ch, cst_eps);
    switch(match[0]){
      case 0:
       var l = match[1];
       return caml_call4(Re_Fmt[157], ch, cst_cst, Re_Cset[12], l);
      case 1:
       var l$0 = match[1], _aM_ = caml_call2(Re_Fmt[155], 0, pp);
       return caml_call4(Re_Fmt[157], ch, cst_alt, _aM_, l$0);
      case 2:
       var
        e$0 = match[3],
        e$1 = match[2],
        k = match[1],
        _aN_ = caml_call3(Re_Fmt[159], pp_sem, pp, pp);
       return caml_call4(Re_Fmt[157], ch, cst_seq, _aN_, [0, k, e$1, e$0]);
      case 3:
       var
        e$2 = match[3],
        k$0 = match[2],
        _aO_ = caml_call2(Re_Fmt[158], pp_sem, pp);
       return caml_call4(Re_Fmt[157], ch, cst_rep, _aO_, [0, k$0, e$2]);
      case 4:
       var i = match[1];
       return caml_call4(Re_Fmt[157], ch, cst_mark, Re_Fmt[160], i);
      case 5:
       var
        e$3 = match[2],
        b = match[1],
        _aP_ = caml_call2(Re_Fmt[158], Re_Fmt[160], Re_Fmt[160]);
       return caml_call4(Re_Fmt[157], ch, cst_erase, _aP_, [0, b, e$3]);
      case 6:
       var c = match[1];
       return caml_call4(Re_Fmt[157], ch, cst_before, Re_Category[14], c);
      case 7:
       var c$0 = match[1];
       return caml_call4(Re_Fmt[157], ch, cst_after, Re_Category[14], c$0);
      default:
       var i$0 = match[1];
       return caml_call4(Re_Fmt[157], ch, cst_pmark, Re_Fmt[160], i$0);
    }
   }
   function first(f, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var r = param$0[2], x = param$0[1], res = caml_call1(f, x);
     if(res) return res;
     var param$0 = r;
    }
   }
   function create_ids(param){return [0, 0];}
   function mk_expr(ids, def){ids[1]++; return [0, ids[1], def];}
   function empty$0(ids){return mk_expr(ids, _d_);}
   function cst(ids, s){
    return caml_call1(Re_Cset[19], s) ? empty$0(ids) : mk_expr(ids, [0, s]);
   }
   function alt(ids, l){
    if(! l) return empty$0(ids);
    if(l[2]) return mk_expr(ids, [1, l]);
    var c = l[1];
    return c;
   }
   function seq(ids, kind, x, y){
    var _aK_ = x[2], _aL_ = y[2];
    if(typeof _aK_ !== "number" && 1 === _aK_[0] && ! _aK_[1]) return x;
    if(typeof _aL_ !== "number" && 1 === _aL_[0] && ! _aL_[1]) return y;
    if(typeof _aK_ === "number") return y;
    if(typeof _aL_ === "number" && 332064784 === kind) return x;
    return mk_expr(ids, [2, kind, x, y]);
   }
   function is_eps(expr){return typeof expr[2] === "number" ? 1 : 0;}
   function eps(ids){return mk_expr(ids, 0);}
   function rep(ids, kind, sem, x){return mk_expr(ids, [3, kind, sem, x]);}
   function mark(ids, m){return mk_expr(ids, [4, m]);}
   function pmark(ids, i){return mk_expr(ids, [8, i]);}
   function erase(ids, m$0, m){return mk_expr(ids, [5, m$0, m]);}
   function before(ids, c){return mk_expr(ids, [6, c]);}
   function after(ids, c){return mk_expr(ids, [7, c]);}
   function rename(ids, x){
    var match = x[2];
    if(typeof match !== "number")
     switch(match[0]){
       case 1:
        var l = match[1], _aH_ = function(_aJ_){return rename(ids, _aJ_);};
        return mk_expr(ids, [1, caml_call2(Stdlib_List[19], _aH_, l)]);
       case 2:
        var z = match[3], y = match[2], k = match[1], _aI_ = rename(ids, z);
        return mk_expr(ids, [2, k, rename(ids, y), _aI_]);
       case 3:
        var y$0 = match[3], k$0 = match[2], g = match[1];
        return mk_expr(ids, [3, g, k$0, rename(ids, y$0)]);
     }
    return mk_expr(ids, x[2]);
   }
   function equal(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      var _az_ = l1$0[1];
      switch(_az_[0]){
        case 0:
         if(l2$0){
          var match = l2$0[1], r1 = l1$0[2], e1 = _az_[2], l1$1 = _az_[1];
          if(0 === match[0]){
           var
            r2 = l2$0[2],
            e2 = match[2],
            l2$1 = match[1],
            _aA_ = e1[1] === e2[1] ? 1 : 0;
           if(_aA_){
            var _aB_ = equal(l1$1, l2$1);
            if(_aB_){var l1$0 = r1, l2$0 = r2; continue;}
            var _aC_ = _aB_;
           }
           else
            var _aC_ = _aA_;
           return _aC_;
          }
         }
         break;
        case 1:
         if(l2$0){
          var
           match$0 = l2$0[1],
           r1$0 = l1$0[2],
           e1$0 = _az_[2],
           marks1 = _az_[1];
          if(1 === match$0[0]){
           var
            r2$0 = l2$0[2],
            e2$0 = match$0[2],
            marks2 = match$0[1],
            _aD_ = e1$0[1] === e2$0[1] ? 1 : 0;
           if(_aD_){
            var _aE_ = caml_equal(marks1, marks2);
            if(_aE_){var l1$0 = r1$0, l2$0 = r2$0; continue;}
            var _aF_ = _aE_;
           }
           else
            var _aF_ = _aD_;
           return _aF_;
          }
         }
         break;
        default:
         if(l2$0){
          var match$1 = l2$0[1], r1$1 = l1$0[2], marks1$0 = _az_[1];
          if(2 === match$1[0]){
           var
            r2$1 = l2$0[2],
            marks2$0 = match$1[1],
            _aG_ = caml_equal(marks1$0, marks2$0);
           if(! _aG_) return _aG_;
           var l1$0 = r1$1, l2$0 = r2$1;
           continue;
          }
         }
      }
     }
     else if(! l2$0) return 1;
     return 0;
    }
   }
   function hash$0(l, accu){
    var l$0 = l, accu$0 = accu;
    for(;;){
     if(! l$0) return accu$0;
     var match = l$0[1];
     switch(match[0]){
       case 0:
        var
         r = l$0[2],
         e = match[2],
         l$1 = match[1],
         _ax_ = hash$0(l$1, accu$0),
         accu$1 = hash_combine(388635598, hash_combine(e[1], _ax_)),
         l$0 = r,
         accu$0 = accu$1;
        break;
       case 1:
        var
         r$0 = l$0[2],
         e$0 = match[2],
         marks = match[1],
         _ay_ = hash(marks, accu$0),
         accu$2 = hash_combine(726404471, hash_combine(e$0[1], _ay_)),
         l$0 = r$0,
         accu$0 = accu$2;
        break;
       default:
        var
         r$1 = l$0[2],
         marks$0 = match[1],
         accu$3 = hash_combine(471882453, hash(marks$0, accu$0)),
         l$0 = r$1,
         accu$0 = accu$3;
     }
    }
   }
   function tseq(kind, x, y, rem){
    if(! x) return rem;
    var _aw_ = x[1];
    if(1 === _aw_[0] && typeof _aw_[2][2] === "number" && ! x[2]){var marks = _aw_[1]; return [0, [1, marks, y], rem];}
    return [0, [0, x, y, kind], rem];
   }
   function print_state_rec(ch, e, y){
    switch(e[0]){
      case 0:
       var x = e[2], l = e[1];
       caml_call2(Stdlib_Format[129], ch, _e_);
       print_state_lst(ch, l, x);
       return caml_call4(Stdlib_Format[129], ch, _f_, pp, x);
      case 1:
       var marks = e[1];
       if(typeof e[2][2] === "number")
        return caml_call5(Stdlib_Format[129], ch, _g_, y[1], pp_marks, marks);
       var x$0 = e[2];
       return caml_call7
               (Stdlib_Format[129], ch, _h_, x$0[1], pp_marks, marks, pp, x$0);
      default:
       var marks$0 = e[1];
       return caml_call4(Stdlib_Format[129], ch, _i_, pp_marks, marks$0);
    }
   }
   function print_state_lst(ch, l, y){
    if(! l) return caml_call2(Stdlib_Format[129], ch, _k_);
    var rem = l[2], e = l[1];
    print_state_rec(ch, e, y);
    function _av_(e){
     caml_call2(Stdlib_Format[129], ch, _j_);
     return print_state_rec(ch, e, y);
    }
    return caml_call2(Stdlib_List[17], _av_, rem);
   }
   function pp$0(ch, t){return print_state_lst(ch, [0, t, 0], _l_);}
   var dummy = [0, -1, Re_Category[3], 0, 0, -1];
   function mk(idx, cat, desc){
    return [0,
            idx,
            cat,
            desc,
            0,
            hash$0
             (desc,
              hash_combine
               (idx, hash_combine(caml_call1(Re_Category[10], cat), 0)))
            & 1073741823];
   }
   function create(cat, e){return mk(0, cat, [0, [1, empty, e], 0]);}
   function equal$0(x, y){
    var _ar_ = x[5] === y[5] ? 1 : 0;
    if(_ar_){
     var _as_ = x[1] === y[1] ? 1 : 0;
     if(_as_){
      var _at_ = caml_call2(Re_Category[11], x[2], y[2]);
      if(_at_) return equal(x[3], y[3]);
      var _au_ = _at_;
     }
     else
      var _au_ = _as_;
    }
    else
     var _au_ = _ar_;
    return _au_;
   }
   function hash$1(t){return t[5];}
   var Table = caml_call1(Stdlib_Hashtbl[26], [0, equal$0, hash$1]);
   function create_working_area(param){return [0, [0, 0]];}
   function index_count(w){return w[1].length - 1;}
   function mark_used_indices(tbl){
    function _am_(param){
     if(0 === param[0]){
      var l = param[1];
      return caml_call1(mark_used_indices(tbl), l);
     }
     var marks = param[1], _an_ = marks[1];
     function _ao_(param){
      var
       i = param[2],
       _ap_ = 0 <= i ? 1 : 0,
       _aq_ = _ap_ ? (caml_check_bound(tbl, i)[1 + i] = 1, 0) : _ap_;
      return _aq_;
     }
     return caml_call2(Stdlib_List[17], _ao_, _an_);
    }
    return caml_call1(Stdlib_List[17], _am_);
   }
   function free_index(tbl_ref, l){
    var tbl = tbl_ref[1];
    caml_call4(Stdlib_Array[9], tbl, 0, tbl.length - 1, 0);
    caml_call1(mark_used_indices(tbl), l);
    var len = tbl.length - 1, idx = 0;
    for(;;){
     if(idx !== len && caml_check_bound(tbl, idx)[1 + idx]){var idx$0 = idx + 1 | 0, idx = idx$0; continue;}
     if(idx === len) tbl_ref[1] = caml_make_vect(2 * len | 0, 0);
     return idx;
    }
   }
   function _m_(param){return 2 === param[0] ? 0 : 1;}
   var remove_matches = caml_call1(Stdlib_List[41], _m_);
   function split_at_match(l$1){
    var l = 0, param = l$1;
    for(;;){
     if(! param)
      throw caml_maybe_attach_backtrace([0, Assert_failure, _n_], 1);
     var x = param[1];
     if(2 === x[0]){
      var r$0 = param[2], _al_ = caml_call1(remove_matches, r$0);
      return [0, caml_call1(Stdlib_List[9], l), _al_];
     }
     var r = param[2], l$0 = [0, x, l], l = l$0, param = r;
    }
   }
   function remove_duplicates(prev, l, y){
    var l$0 = l;
    for(;;){
     if(! l$0) return [0, 0, prev];
     var x = l$0[1];
     switch(x[0]){
       case 0:
        var
         r = l$0[2],
         kind = x[3],
         x$0 = x[2],
         l$1 = x[1],
         match = remove_duplicates(prev, l$1, x$0),
         prev$0 = match[2],
         l$2 = match[1],
         match$0 = remove_duplicates(prev$0, r, y),
         prev$1 = match$0[2],
         r$0 = match$0[1];
        return [0, tseq(kind, l$2, x$0, r$0), prev$1];
       case 1:
        if(typeof x[2][2] === "number"){
         var r$1 = l$0[2];
         if(! caml_call2(Stdlib_List[37], y[1], prev)){
          var
           match$1 = remove_duplicates([0, y[1], prev], r$1, y),
           prev$2 = match$1[2],
           r$2 = match$1[1];
          return [0, [0, x, r$2], prev$2];
         }
         var l$0 = r$1;
        }
        else{
         var r$3 = l$0[2], x$1 = x[2];
         if(! caml_call2(Stdlib_List[37], x$1[1], prev)){
          var
           match$2 = remove_duplicates([0, x$1[1], prev], r$3, y),
           prev$3 = match$2[2],
           r$4 = match$2[1];
          return [0, [0, x, r$4], prev$3];
         }
         var l$0 = r$3;
        }
        break;
       default: return [0, [0, x, 0], prev];
     }
    }
   }
   function set_idx(idx, param){
    if(! param) return 0;
    var match = param[1];
    switch(match[0]){
      case 0:
       var
        r = param[2],
        kind = match[3],
        x = match[2],
        l = match[1],
        _ai_ = set_idx(idx, r);
       return [0, [0, set_idx(idx, l), x, kind], _ai_];
      case 1:
       var
        r$0 = param[2],
        x$0 = match[2],
        marks = match[1],
        _aj_ = set_idx(idx, r$0);
       return [0, [1, marks_set_idx(marks, idx), x$0], _aj_];
      default:
       var r$1 = param[2], marks$0 = match[1], _ak_ = set_idx(idx, r$1);
       return [0, [2, marks_set_idx(marks$0, idx)], _ak_];
    }
   }
   function filter_marks(b, e, marks){
    var _ad_ = marks[2], _ae_ = marks[1];
    function _af_(param){
     var i = param[1], _ag_ = i < b ? 1 : 0, _ah_ = _ag_ || (e < i ? 1 : 0);
     return _ah_;
    }
    return [0, caml_call2(Stdlib_List[41], _af_, _ae_), _ad_];
   }
   function delta_1$0(counter, marks, c, next_cat, prev_cat, x, rem){
    var match = x[2];
    if(typeof match === "number") return [0, [2, marks], rem];
    switch(match[0]){
      case 0:
       var s = match[1];
       return caml_call2(Re_Cset[10], c, s)
               ? [0, [1, marks, eps_expr], rem]
               : rem;
      case 1:
       var l = match[1];
       if(counter >= 50)
        return caml_trampoline_return
                (delta_2$0, [0, marks, c, next_cat, prev_cat, l, rem]);
       var counter$0 = counter + 1 | 0;
       return delta_2$0(counter$0, marks, c, next_cat, prev_cat, l, rem);
      case 2:
       var
        z = match[3],
        y = match[2],
        kind = match[1],
        y$0 = delta_1(marks, c, next_cat, prev_cat, y, 0);
       if(counter >= 50)
        return caml_trampoline_return
                (delta_seq$0, [0, c, next_cat, prev_cat, kind, y$0, z, rem]);
       var counter$1 = counter + 1 | 0;
       return delta_seq$0(counter$1, c, next_cat, prev_cat, kind, y$0, z, rem);
      case 3:
       var
        y$1 = match[3],
        kind$0 = match[2],
        rep_kind = match[1],
        y$2 = delta_1(marks, c, next_cat, prev_cat, y$1, 0),
        match$0 =
          first
           (function(param){
             if(2 !== param[0]) return 0;
             var marks = param[1];
             return [0, marks];
            },
            y$2);
       if(match$0)
        var
         marks$0 = match$0[1],
         marks$1 = marks$0,
         y$3 = caml_call1(remove_matches, y$2);
       else
        var marks$1 = marks, y$3 = y$2;
       return 620821490 <= rep_kind
               ? [0, [2, marks], tseq(kind$0, y$3, x, rem)]
               : tseq(kind$0, y$3, x, [0, [2, marks$1], rem]);
      case 4:
       var
        i = match[1],
        _ab_ = marks[2],
        marks$2 =
          [0, [0, [0, i, -1], caml_call2(Stdlib_List[53], i, marks[1])], _ab_];
       return [0, [2, marks$2], rem];
      case 5:
       var e = match[2], b = match[1];
       return [0, [2, filter_marks(b, e, marks)], rem];
      case 6:
       var cat = match[1];
       return caml_call2(Re_Category[13], next_cat, cat)
               ? [0, [2, marks], rem]
               : rem;
      case 7:
       var cat$0 = match[1];
       return caml_call2(Re_Category[13], prev_cat, cat$0)
               ? [0, [2, marks], rem]
               : rem;
      default:
       var
        i$0 = match[1],
        _ac_ = caml_call2(Re_Pmark[5][4], i$0, marks[2]),
        marks$3 = [0, marks[1], _ac_];
       return [0, [2, marks$3], rem];
    }
   }
   function delta_2$0(counter, marks, c, next_cat, prev_cat, l, rem){
    if(! l) return rem;
    var
     r = l[2],
     y = l[1],
     _aa_ = delta_2(marks, c, next_cat, prev_cat, r, rem);
    if(counter >= 50)
     return caml_trampoline_return
             (delta_1$0, [0, marks, c, next_cat, prev_cat, y, _aa_]);
    var counter$0 = counter + 1 | 0;
    return delta_1$0(counter$0, marks, c, next_cat, prev_cat, y, _aa_);
   }
   function delta_seq$0(counter, c, next_cat, prev_cat, kind, y, z, rem){
    var
     match =
       first
        (function(param){
          if(2 !== param[0]) return 0;
          var marks = param[1];
          return [0, marks];
         },
         y);
    if(! match) return tseq(kind, y, z, rem);
    var marks = match[1];
    if(-730718166 === kind){
     var ___ = delta_1(marks, c, next_cat, prev_cat, z, rem);
     return tseq(kind, caml_call1(remove_matches, y), z, ___);
    }
    if(332064784 <= kind){
     var match$0 = split_at_match(y), y$0 = match$0[2], y$1 = match$0[1];
     return tseq
             (kind,
              y$1,
              z,
              delta_1
               (marks, c, next_cat, prev_cat, z, tseq(kind, y$0, z, rem)));
    }
    var _$_ = tseq(kind, caml_call1(remove_matches, y), z, rem);
    if(counter >= 50)
     return caml_trampoline_return
             (delta_1$0, [0, marks, c, next_cat, prev_cat, z, _$_]);
    var counter$0 = counter + 1 | 0;
    return delta_1$0(counter$0, marks, c, next_cat, prev_cat, z, _$_);
   }
   function delta_1(marks, c, next_cat, prev_cat, x, rem){
    return caml_trampoline(delta_1$0(0, marks, c, next_cat, prev_cat, x, rem));
   }
   function delta_2(marks, c, next_cat, prev_cat, l, rem){
    return caml_trampoline(delta_2$0(0, marks, c, next_cat, prev_cat, l, rem));
   }
   function delta_seq(c, next_cat, prev_cat, kind, y, z, rem){
    return caml_trampoline
            (delta_seq$0(0, c, next_cat, prev_cat, kind, y, z, rem));
   }
   function delta_4(c, next_cat, prev_cat, l, rem){
    if(! l) return rem;
    var r = l[2], y$1 = l[1], rem$0 = delta_4(c, next_cat, prev_cat, r, rem);
    switch(y$1[0]){
      case 0:
       var
        kind = y$1[3],
        z = y$1[2],
        y = y$1[1],
        y$0 = delta_4(c, next_cat, prev_cat, y, 0);
       return delta_seq(c, next_cat, prev_cat, kind, y$0, z, rem$0);
      case 1:
       var e = y$1[2], marks = y$1[1];
       return delta_1(marks, c, next_cat, prev_cat, e, rem$0);
      default: return [0, y$1, rem$0];
    }
   }
   function delta(tbl_ref, next_cat, char$0, st){
    var
     prev_cat = st[2],
     expr =
       remove_duplicates
         (0, delta_4(char$0, next_cat, prev_cat, st[3], 0), eps_expr)
        [1],
     idx = free_index(tbl_ref, expr),
     expr$0 = set_idx(idx, expr);
    return mk(idx, next_cat, expr$0);
   }
   function red_tr(l){
    var l$0 = l;
    for(;;){
     if(l$0){
      var match = l$0[2];
      if(match){
       var
        rem = match[2],
        tr2 = match[1],
        st2 = tr2[2],
        s2 = tr2[1],
        tr1 = l$0[1],
        st1 = tr1[2],
        s1 = tr1[1];
       if(! equal$0(st1, st2)) return [0, tr1, red_tr([0, tr2, rem])];
       var
        l$1 = [0, [0, caml_call2(Re_Cset[2], s1, s2), st1], rem],
        l$0 = l$1;
       continue;
      }
     }
     return l$0;
    }
   }
   function _o_(param, l){
    var x = param[2], s = param[1];
    return caml_call3(Re_Cset[20], s, x, l);
   }
   var prepend_deriv = caml_call1(Stdlib_List[26], _o_);
   function restrict(s, param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var
      rem = param$0[2],
      match = param$0[1],
      x = match[2],
      s$0 = match[1],
      s$1 = caml_call2(Re_Cset[3], s, s$0);
     if(! caml_call1(Re_Cset[19], s$1))
      return [0, [0, s$1, x], restrict(s, rem)];
     var param$0 = rem;
    }
   }
   function prepend_marks_expr_lst(m, l){
    function _Z_(param){
     switch(param[0]){
       case 0:
        var s = param[3], e = param[2], l = param[1];
        return [0, prepend_marks_expr_lst(m, l), e, s];
       case 1:
        var e$0 = param[2], m$0 = param[1]; return [1, merge(m, m$0), e$0];
       default: var m$1 = param[1]; return [2, merge(m, m$1)];
     }
    }
    return caml_call2(Stdlib_List[19], _Z_, l);
   }
   function deriv_1$0(counter, all_chars, categories, marks, cat, x, rem$1){
    var match = x[2];
    if(typeof match === "number")
     return caml_call3(Re_Cset[20], all_chars, [0, [2, marks], 0], rem$1);
    switch(match[0]){
      case 0:
       var s = match[1];
       return caml_call3(Re_Cset[20], s, [0, [1, marks, eps_expr], 0], rem$1);
      case 1:
       var l = match[1];
       if(counter >= 50)
        return caml_trampoline_return
                (deriv_2$0, [0, all_chars, categories, marks, cat, l, rem$1]);
       var counter$0 = counter + 1 | 0;
       return deriv_2$0
               (counter$0, all_chars, categories, marks, cat, l, rem$1);
      case 2:
       var
        z = match[3],
        y = match[2],
        kind = match[1],
        y$0 =
          deriv_1
           (all_chars, categories, marks, cat, y, [0, [0, all_chars, 0], 0]);
       return deriv_seq(all_chars, categories, cat, kind, y$0, z, rem$1);
      case 3:
       var
        y$1 = match[3],
        kind$0 = match[2],
        rep_kind = match[1],
        y$2 =
          deriv_1
           (all_chars, categories, marks, cat, y$1, [0, [0, all_chars, 0], 0]),
        _S_ =
          function(param, rem){
           var
            z = param[2],
            s = param[1],
            match =
              first
               (function(param){
                 if(2 !== param[0]) return 0;
                 var marks = param[1];
                 return [0, marks];
                },
                z);
           if(match)
            var
             marks$0 = match[1],
             marks$1 = marks$0,
             z$0 = caml_call1(remove_matches, z);
           else
            var marks$1 = marks, z$0 = z;
           var
            _Y_ =
              620821490 <= rep_kind
               ? [0, [2, marks], tseq(kind$0, z$0, x, 0)]
               : tseq(kind$0, z$0, x, [0, [2, marks$1], 0]);
           return caml_call3(Re_Cset[20], s, _Y_, rem);
          };
       return caml_call3(Stdlib_List[26], _S_, y$2, rem$1);
      case 4:
       var
        i = match[1],
        _T_ = marks[2],
        _U_ =
          [0,
           [2,
            [0,
             [0, [0, i, -1], caml_call2(Stdlib_List[53], i, marks[1])],
             _T_]],
           0];
       return caml_call3(Re_Cset[20], all_chars, _U_, rem$1);
      case 5:
       var
        e$1 = match[2],
        b = match[1],
        _W_ = marks[2],
        rem$2 = filter_marks(b, e$1, marks)[1],
        e = e$1,
        rem = rem$2,
        _V_ = 0;
       for(;;){
        if(e < b)
         return caml_call3
                 (Re_Cset[20], all_chars, [0, [2, [0, rem, _W_]], _V_], rem$1);
        var
         rem$0 = [0, [0, e, -2], rem],
         e$0 = e - 1 | 0,
         e = e$0,
         rem = rem$0;
       }
       break;
      case 6:
       var
        cat$0 = match[1],
        _X_ = caml_call2(Stdlib_List[48], cat$0, categories);
       return caml_call3(Re_Cset[20], _X_, [0, [2, marks], 0], rem$1);
      case 7:
       var cat$1 = match[1];
       return caml_call2(Re_Category[13], cat, cat$1)
               ? caml_call3(Re_Cset[20], all_chars, [0, [2, marks], 0], rem$1)
               : rem$1;
      default:
       return caml_call3(Re_Cset[20], all_chars, [0, [2, marks], 0], rem$1);
    }
   }
   function deriv_2$0(counter, all_chars, categories, marks, cat, l, rem){
    if(! l) return rem;
    var
     r = l[2],
     y = l[1],
     _R_ = deriv_2(all_chars, categories, marks, cat, r, rem);
    if(counter >= 50)
     return caml_trampoline_return
             (deriv_1$0, [0, all_chars, categories, marks, cat, y, _R_]);
    var counter$0 = counter + 1 | 0;
    return deriv_1$0(counter$0, all_chars, categories, marks, cat, y, _R_);
   }
   function deriv_1(all_chars, categories, marks, cat, x, rem){
    return caml_trampoline
            (deriv_1$0(0, all_chars, categories, marks, cat, x, rem));
   }
   function deriv_2(all_chars, categories, marks, cat, l, rem){
    return caml_trampoline
            (deriv_2$0(0, all_chars, categories, marks, cat, l, rem));
   }
   function deriv_seq(all_chars, categories, cat, kind, y, z, rem){
    function _C_(param){
     var xl = param[2];
     function _Q_(param){return 2 === param[0] ? 1 : 0;}
     return caml_call2(Stdlib_List[33], _Q_, xl);
    }
    if(caml_call2(Stdlib_List[33], _C_, y)){
     var
      z$0 =
        deriv_1
         (all_chars, categories, empty, cat, z, [0, [0, all_chars, 0], 0]),
      _D_ =
        function(param, rem){
         var
          y = param[2],
          s = param[1],
          match =
            first
             (function(param){
               if(2 !== param[0]) return 0;
               var marks = param[1];
               return [0, marks];
              },
              y);
         if(! match){
          var _P_ = tseq(kind, y, z, 0);
          return caml_call3(Re_Cset[20], s, _P_, rem);
         }
         var marks = match[1];
         function _G_(param){
          var x = param[2], s = param[1];
          return [0, s, prepend_marks_expr_lst(marks, x)];
         }
         var z$1 = caml_call1(caml_call1(Stdlib_List[19], _G_), z$0);
         if(-730718166 === kind){
          var
           _H_ = caml_call2(prepend_deriv, restrict(s, z$1), rem),
           _I_ = tseq(kind, caml_call1(remove_matches, y), z, 0);
          return caml_call3(Re_Cset[20], s, _I_, _H_);
         }
         if(332064784 <= kind){
          var
           match$0 = split_at_match(y),
           y$0 = match$0[2],
           y$1 = match$0[1],
           _J_ = tseq(kind, y$0, z, 0),
           _K_ = caml_call3(Re_Cset[20], s, _J_, rem),
           _L_ = caml_call2(prepend_deriv, restrict(s, z$1), _K_),
           _M_ = tseq(kind, y$1, z, 0);
          return caml_call3(Re_Cset[20], s, _M_, _L_);
         }
         var
          _N_ = tseq(kind, caml_call1(remove_matches, y), z, 0),
          _O_ = caml_call3(Re_Cset[20], s, _N_, rem);
         return caml_call2(prepend_deriv, restrict(s, z$1), _O_);
        };
     return caml_call3(Stdlib_List[26], _D_, y, rem);
    }
    function _E_(param, rem){
     var xl = param[2], s = param[1], _F_ = tseq(kind, xl, z, 0);
     return caml_call3(Re_Cset[20], s, _F_, rem);
    }
    return caml_call3(Stdlib_List[26], _E_, y, rem);
   }
   function deriv_4(all_chars, categories, cat, l, rem){
    if(! l) return rem;
    var
     r = l[2],
     y$1 = l[1],
     rem$0 = deriv_4(all_chars, categories, cat, r, rem);
    switch(y$1[0]){
      case 0:
       var
        kind = y$1[3],
        z = y$1[2],
        y = y$1[1],
        y$0 =
          deriv_4(all_chars, categories, cat, y, [0, [0, all_chars, 0], 0]);
       return deriv_seq(all_chars, categories, cat, kind, y$0, z, rem$0);
      case 1:
       var e = y$1[2], marks = y$1[1];
       return deriv_1(all_chars, categories, marks, cat, e, rem$0);
      default: return caml_call3(Re_Cset[20], all_chars, [0, y$1, 0], rem$0);
    }
   }
   function deriv(tbl_ref, all_chars, categories, st){
    var
     der =
       deriv_4(all_chars, categories, st[2], st[3], [0, [0, all_chars, 0], 0]),
     _x_ = 0;
    function _y_(param, rem){
     var
      expr = param[2],
      s = param[1],
      expr$0 = remove_duplicates(0, expr, eps_expr)[1],
      idx = free_index(tbl_ref, expr$0),
      expr$1 = set_idx(idx, expr$0);
     function _B_(param, rem){
      var
       s$0 = param[2],
       cat = param[1],
       s$1 = caml_call2(Re_Cset[3], s, s$0);
      return caml_call1(Re_Cset[19], s$1)
              ? rem
              : [0, [0, s$1, mk(idx, cat, expr$1)], rem];
     }
     return caml_call3(Stdlib_List[26], _B_, categories, rem);
    }
    var l = caml_call3(Stdlib_List[26], _y_, der, _x_);
    function _u_(param, _A_){
     var
      st2 = _A_[2],
      st1 = param[2],
      c = runtime.caml_int_compare(st1[5], st2[5]);
     if(0 !== c) return c;
     var c$0 = caml_call2(Re_Category[12], st1[2], st2[2]);
     return 0 === c$0 ? caml_compare(st1[3], st2[3]) : c$0;
    }
    var _v_ = red_tr(caml_call2(Stdlib_List[56], _u_, l));
    function _w_(param, _z_){
     var s2 = _z_[1], s1 = param[1];
     return caml_compare(s1, s2);
    }
    return caml_call2(Stdlib_List[56], _w_, _v_);
   }
   function status(s){
    var match = s[4];
    if(match){var st = match[1]; return st;}
    var _s_ = s[3];
    if(_s_){
     var match$0 = _s_[1];
     if(2 === match$0[0]){
      var
       m = match$0[1],
       m$0 = m[1],
       _t_ = m[2],
       _p_ = -1,
       _q_ =
         function(ma, param){
          var i = param[1];
          return caml_call2(Stdlib[17], ma, i);
         },
       ma = caml_call3(Stdlib_List[25], _q_, _p_, m$0),
       res = caml_make_vect(ma + 1 | 0, -1),
       _r_ =
         function(param){
          var v = param[2], i = param[1];
          caml_check_bound(res, i)[1 + i] = v;
          return 0;
         };
      caml_call2(Stdlib_List[17], _r_, m$0);
      var st$0 = [0, res, _t_];
     }
     else
      var st$0 = 1;
    }
    else
     var st$0 = 0;
    s[4] = [0, st$0];
    return st$0;
   }
   var
    Re_Automata =
      [0,
       pp_sem,
       pp_rep_kind,
       is_eps,
       pp,
       create_ids,
       cst,
       empty$0,
       alt,
       seq,
       eps,
       rep,
       mark,
       pmark,
       erase,
       before,
       after,
       rename,
       [0],
       [0, pp$0],
       [0, dummy, create, Table],
       create_working_area,
       index_count,
       delta,
       deriv,
       status];
   runtime.caml_register_global(38, Re_Automata, "Re__Automata");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Color_map
//# unitInfo: Requires: Re__Cset, Stdlib__Bytes, Stdlib__Char
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_set = runtime.caml_bytes_set,
    caml_create_bytes = runtime.caml_create_bytes;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Cset = global_data.Re__Cset,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_Bytes = global_data.Stdlib__Bytes;
   function make(param){return caml_call2(Stdlib_Bytes[1], 257, 0);}
   function flatten(cm){
    var
     c = caml_create_bytes(256),
     color_repr = caml_create_bytes(256),
     v = [0, 0];
    caml_bytes_set(c, 0, 0);
    caml_bytes_set(color_repr, 0, 0);
    var i = 1;
    for(;;){
     if(0 !== runtime.caml_bytes_get(cm, i)) v[1]++;
     caml_bytes_set(c, i, caml_call1(Stdlib_Char[1], v[1]));
     var _d_ = caml_call1(Stdlib_Char[1], i);
     caml_bytes_set(color_repr, v[1], _d_);
     var _e_ = i + 1 | 0;
     if(255 === i){
      var
       _b_ = v[1] + 1 | 0,
       _c_ = caml_call3(Stdlib_Bytes[8], color_repr, 0, v[1] + 1 | 0);
      return [0, caml_call1(Stdlib_Bytes[48], c), _c_, _b_];
     }
     var i = _e_;
    }
   }
   function split(s, cm){
    function _a_(i, j){
     caml_bytes_set(cm, i, 1);
     return caml_bytes_set(cm, j + 1 | 0, 1);
    }
    return caml_call2(Re_Cset[1], s, _a_);
   }
   var Re_Color_map = [0, make, flatten, split];
   runtime.caml_register_global(3, Re_Color_map, "Re__Color_map");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Group
//# unitInfo: Requires: Re__Fmt, Stdlib, Stdlib__Array, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    caml_check_bound = runtime.caml_check_bound,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    dummy_offset = [0, -1, -1],
    Re_Fmt = global_data.Re__Fmt,
    Stdlib_Array = global_data.Stdlib__Array,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    _a_ =
      [0,
       [18,
        [1, [0, 0, cst]],
        [12,
         40,
         [2,
          0,
          [11,
           " (",
           [4, 0, 0, 0, [12, 32, [4, 0, 0, 0, [11, "))", [17, 0, 0]]]]]]]]],
       "@[(%s (%d %d))@]"],
    cst_Group = "Group";
   function offset(t, i){
    if(t[2].length - 1 <= ((2 * i | 0) + 1 | 0))
     throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var _t_ = 2 * i | 0, m1 = caml_check_bound(t[2], _t_)[1 + _t_];
    if(-1 === m1) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var
     p1 = caml_check_bound(t[4], m1)[1 + m1],
     _u_ = (2 * i | 0) + 1 | 0,
     _v_ = caml_check_bound(t[2], _u_)[1 + _u_],
     p2 = caml_check_bound(t[4], _v_)[1 + _v_];
    return [0, p1, p2];
   }
   function get(t, i){
    var match = offset(t, i), p2 = match[2], p1 = match[1];
    return caml_call3(Stdlib_String[15], t[1], p1, p2 - p1 | 0);
   }
   function start(subs, i){return offset(subs, i)[1];}
   function stop(subs, i){return offset(subs, i)[2];}
   function test(t, i){
    if(t[2].length - 1 <= (2 * i | 0)) return 0;
    var _s_ = 2 * i | 0, idx = caml_check_bound(t[2], _s_)[1 + _s_];
    return -1 !== idx ? 1 : 0;
   }
   function get_opt(t, i){return test(t, i) ? [0, get(t, i)] : 0;}
   function all_offset(t){
    var
     res = caml_make_vect(t[5], dummy_offset),
     _n_ = ((t[2].length - 1) / 2 | 0) - 1 | 0,
     _m_ = 0;
    if(_n_ >= 0){
     var i = _m_;
     for(;;){
      var _o_ = 2 * i | 0, m1 = caml_check_bound(t[2], _o_)[1 + _o_];
      if(-1 !== m1){
       var
        p1 = caml_check_bound(t[4], m1)[1 + m1],
        _p_ = (2 * i | 0) + 1 | 0,
        _q_ = caml_check_bound(t[2], _p_)[1 + _p_],
        p2 = caml_check_bound(t[4], _q_)[1 + _q_];
       caml_check_bound(res, i)[1 + i] = [0, p1, p2];
      }
      var _r_ = i + 1 | 0;
      if(_n_ === i) break;
      var i = _r_;
     }
    }
    return res;
   }
   function all(t){
    var
     res = caml_make_vect(t[5], cst),
     _g_ = ((t[2].length - 1) / 2 | 0) - 1 | 0,
     _f_ = 0;
    if(_g_ >= 0){
     var i = _f_;
     for(;;){
      var _h_ = 2 * i | 0, m1 = caml_check_bound(t[2], _h_)[1 + _h_];
      if(-1 !== m1){
       var
        p1 = caml_check_bound(t[4], m1)[1 + m1],
        _i_ = (2 * i | 0) + 1 | 0,
        _j_ = caml_check_bound(t[2], _i_)[1 + _i_],
        p2 = caml_check_bound(t[4], _j_)[1 + _j_],
        _k_ = caml_call3(Stdlib_String[15], t[1], p1, p2 - p1 | 0);
       caml_check_bound(res, i)[1 + i] = _k_;
      }
      var _l_ = i + 1 | 0;
      if(_g_ === i) break;
      var i = _l_;
     }
    }
    return res;
   }
   function pp(fmt, t){
    var offsets = all_offset(t), strs = all(t);
    function _b_(i){
     var _e_ = caml_check_bound(offsets, i)[1 + i];
     return [0, caml_check_bound(strs, i)[1 + i], _e_];
    }
    var
     _c_ = caml_call2(Stdlib_Array[2], strs.length - 1, _b_),
     matches = caml_call1(Stdlib_Array[11], _c_);
    function pp_match(fmt, param){
     var match = param[2], stop = match[2], start = match[1], str = param[1];
     return caml_call5(Re_Fmt[129], fmt, _a_, str, start, stop);
    }
    var _d_ = caml_call2(Re_Fmt[155], 0, pp_match);
    return caml_call4(Re_Fmt[157], fmt, cst_Group, _d_, matches);
   }
   function nb_groups(t){return t[5];}
   var
    Re_Group =
      [0,
       get,
       get_opt,
       offset,
       start,
       stop,
       all,
       all_offset,
       test,
       nb_groups,
       pp];
   runtime.caml_register_global(8, Re_Group, "Re__Group");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Core
//# unitInfo: Requires: Assert_failure, Re__Automata, Re__Category, Re__Color_map, Re__Cset, Re__Fmt, Re__Group, Re__Pmark, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Char, Stdlib__List, Stdlib__Seq, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$2 = "",
    cst_Re_all$1 = "Re.all",
    cst_Re_replace$1 = "Re.replace",
    cst_Re_repn$1 = "Re.repn",
    cst_Re_split$1 = "Re.split",
    cst_lib_core_ml = "lib/core.ml",
    caml_check_bound = runtime.caml_check_bound,
    caml_equal = runtime.caml_equal,
    caml_make_vect = runtime.caml_make_vect,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   function caml_call7(f, a0, a1, a2, a3, a4, a5, a6){
    return (f.l >= 0 ? f.l : f.l = f.length) == 7
            ? f(a0, a1, a2, a3, a4, a5, a6)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4, a5, a6]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$2,
    cst$1 = cst$2,
    cst = "\t ",
    Re_Fmt = global_data.Re__Fmt,
    Re_Cset = global_data.Re__Cset,
    Re_Automata = global_data.Re__Automata,
    Re_Pmark = global_data.Re__Pmark,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib = global_data.Stdlib,
    Assert_failure = global_data.Assert_failure,
    Re_Category = global_data.Re__Category,
    Stdlib_Char = global_data.Stdlib__Char,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Re_Group = global_data.Re__Group,
    Stdlib_Seq = global_data.Stdlib__Seq,
    Re_Color_map = global_data.Re__Color_map,
    Stdlib_Array = global_data.Stdlib__Array,
    _b_ = [0, [15, [17, [0, "@ ", 1, 0], [4, 0, 0, 0, [15, 0]]]], "%a@ %d%a"],
    cst_Beg_of_line = "Beg_of_line",
    cst_End_of_line = "End_of_line",
    cst_Beg_of_word = "Beg_of_word",
    cst_End_of_word = "End_of_word",
    cst_Not_bound = "Not_bound",
    cst_Beg_of_str = "Beg_of_str",
    cst_End_of_str = "End_of_str",
    cst_Last_end_of_line = "Last_end_of_line",
    cst_Start = "Start",
    cst_Stop = "Stop",
    cst_Set = "Set",
    cst_Sequence = "Sequence",
    cst_Alternative = "Alternative",
    cst_Repeat = "Repeat",
    cst_Sem = "Sem",
    cst_Sem_greedy = "Sem_greedy",
    cst_Named_group = "Named_group",
    cst_Group = "Group",
    cst_No_group = "No_group",
    cst_Nest = "Nest",
    cst_Case = "Case",
    cst_No_case = "No_case",
    cst_Intersection = "Intersection",
    cst_Complement = "Complement",
    cst_Difference = "Difference",
    cst_Pmark = "Pmark",
    _j_ = [0, cst_lib_core_ml, 695, 4],
    _H_ = [0, cst_lib_core_ml, 1162, 24],
    _I_ = [0, cst_lib_core_ml, 1173, 27],
    cst_Re_replace = cst_Re_replace$1,
    cst_Re_replace$0 = cst_Re_replace$1,
    cst_Re_split = cst_Re_split$1,
    cst_Re_split$0 = cst_Re_split$1,
    cst_Re_all = cst_Re_all$1,
    cst_Re_all$0 = cst_Re_all$1,
    cst_Re_exec_partial_detailed = "Re.exec_partial_detailed",
    cst_Re_exec_partial = "Re.exec_partial",
    cst_Re_execp = "Re.execp",
    cst_Re_exec_opt = "Re.exec_opt",
    cst_Re_exec = "Re.exec",
    cst_Re_diff = "Re.diff",
    cst_Re_compl = "Re.compl",
    cst_Re_inter = "Re.inter",
    _l_ = [0, 1],
    cst_Re_repn = cst_Re_repn$1,
    cst_Re_repn$0 = cst_Re_repn$1,
    _k_ = [0, cst_lib_core_ml, 728, 13],
    _i_ = [0, cst_lib_core_ml, 493, 35],
    _a_ = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
    _h_ = [0, 170, [0, 181, [0, 186, [0, 223, [0, 255, 0]]]]];
   function iter(n, f, v){
    var n$0 = n, v$0 = v;
    for(;;){
     if(0 === n$0) return v$0;
     var v$1 = caml_call1(f, v$0), n$1 = n$0 - 1 | 0, n$0 = n$1, v$0 = v$1;
    }
   }
   var unknown = -2, break$0 = -3;
   function pp_re(ch, re){return caml_call2(Re_Automata[4], ch, re[1]);}
   function group_count(re){return re[10];}
   function group_names(re){return re[9];}
   function category(re, color){
    if(-1 === color) return Re_Category[4];
    if(color === re[6]){
     var
      _cp_ = Re_Category[6],
      _cq_ = caml_call2(Re_Category[1], Re_Category[8], Re_Category[7]);
     return caml_call2(Re_Category[1], _cq_, _cp_);
    }
    var _cr_ = caml_string_get(re[4], color);
    return caml_call1(Re_Category[2], _cr_);
   }
   var
    dummy_next = [0],
    unknown_state = [0, unknown, 0, dummy_next, 0, Re_Automata[20][1]];
   function find_state(re, desc){
    try{
     var _cn_ = caml_call2(Re_Automata[20][3][7], re[8], desc);
     return _cn_;
    }
    catch(_co_){
     var _cm_ = caml_wrap_exception(_co_);
     if(_cm_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_cm_, 0);
     var ncol = re[5], match = caml_call1(Re_Automata[25], desc);
     a:
     {
      if(typeof match === "number" && match){var break_state = 0; break a;}
      var break_state = 1;
     }
     var
      _ci_ = 0,
      _cj_ = break_state ? dummy_next : caml_make_vect(ncol, unknown_state),
      _ck_ = desc[1],
      _cl_ = break_state ? break$0 : desc[1],
      st = [0, _cl_, _ck_, _cj_, _ci_, desc];
     caml_call3(Re_Automata[20][3][5], re[8], desc, st);
     return st;
    }
   }
   function delta(info, cat, color, st){
    var
     desc = caml_call4(Re_Automata[23], info[1][7], cat, color, st[5]),
     len = info[3].length - 1,
     _cg_ = desc[1] === len ? 1 : 0,
     _ch_ = _cg_ ? 0 < len ? 1 : 0 : _cg_;
    if(_ch_){
     var pos = info[3];
     info[3] = caml_make_vect(2 * len | 0, 0);
     caml_call5(Stdlib_Array[10], pos, 0, info[3], 0, len);
    }
    return desc;
   }
   function validate(info, s, pos, st){
    var
     _cf_ = caml_string_get(s, pos),
     color = caml_string_get(info[2], _cf_),
     cat = category(info[1], color),
     desc = delta(info, cat, color, st),
     st$0 = find_state(info[1], desc);
    caml_check_bound(st[3], color)[1 + color] = st$0;
    return;
   }
   function get_color(re, s, pos){
    if(0 > pos) return -1;
    var slen = caml_ml_string_length(s);
    if(slen <= pos) return -1;
    if
     (pos === (slen - 1 | 0) && -1 !== re[6] && 10 === caml_string_get(s, pos))
     return re[6];
    var _ce_ = caml_string_get(s, pos);
    return caml_string_get(re[3], _ce_);
   }
   function scan_str(info, s, initial_state, groups){
    var pos$3 = info[4], last = info[5];
    if
     (last === caml_ml_string_length(s)
      &&
       -1 !== info[1][6]
       && pos$3 < last && 10 === caml_string_get(s, last - 1 | 0)){
     var
      info$0 = [0, info[1], info[2], info[3], info[4], last - 1 | 0],
      st$5 = scan_str(info$0, s, initial_state, groups);
     if(st$5[1] === -3) return st$5;
     var pos$4 = last - 1 | 0;
     for(;;){
      var
       _cb_ = info$0[1][6],
       st$3 = caml_check_bound(st$5[3], _cb_)[1 + _cb_];
      if(0 <= st$3[1]){
       if(groups){
        var _cc_ = st$3[1];
        caml_check_bound(info$0[3], _cc_)[1 + _cc_] = pos$4;
       }
       return st$3;
      }
      if(st$3[1] === -3){
       if(groups){
        var _cd_ = st$3[2];
        caml_check_bound(info$0[3], _cd_)[1 + _cd_] = pos$4;
       }
       return st$3;
      }
      var
       color = info$0[1][6],
       real_c = caml_string_get(info$0[2], 10),
       cat = category(info$0[1], color),
       desc = delta(info$0, cat, real_c, st$5),
       st$4 = find_state(info$0[1], desc);
      caml_check_bound(st$5[3], color)[1 + color] = st$4;
     }
    }
    if(groups){
     var pos = pos$3, st = initial_state;
     for(;;){
      if(pos >= info[5]) return st;
      var
       _b8_ = caml_string_get(s, pos),
       _b9_ = caml_string_get(info[2], _b8_),
       st$0 = caml_check_bound(st[3], _b9_)[1 + _b9_],
       idx = st$0[1];
      if(0 <= idx){
       caml_check_bound(info[3], idx)[1 + idx] = pos;
       var pos$0 = pos + 1 | 0, pos = pos$0, st = st$0;
      }
      else{
       if(idx === -3){
        var _b__ = st$0[2];
        caml_check_bound(info[3], _b__)[1 + _b__] = pos;
        return st$0;
       }
       validate(info, s, pos, st);
      }
     }
    }
    else{
     var pos$1 = pos$3, st$1 = initial_state;
     for(;;){
      if(pos$1 >= last) return st$1;
      var
       _b$_ = caml_string_get(s, pos$1),
       _ca_ = caml_string_get(info[2], _b$_),
       st$2 = caml_check_bound(st$1[3], _ca_)[1 + _ca_];
      if(0 <= st$2[1])
       var pos$2 = pos$1 + 1 | 0, pos$1 = pos$2, st$1 = st$2;
      else{if(st$2[1] === -3) return st$2; validate(info, s, pos$1, st$1);}
     }
    }
   }
   function final_boundary_check(last, slen, re, s, info, st$0, groups){
    if(last === slen)
     var
      final_cat = caml_call2(Re_Category[1], Re_Category[9], Re_Category[4]);
    else
     var
      _b6_ = category(re, get_color(re, s, last)),
      final_cat = caml_call2(Re_Category[1], Re_Category[9], _b6_);
    try{
     var _b5_ = caml_call2(Stdlib_List[48], final_cat, st$0[4]), match = _b5_;
    }
    catch(_b7_){
     var _b3_ = caml_wrap_exception(_b7_);
     if(_b3_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_b3_, 0);
     var
      st = delta(info, final_cat, -1, st$0),
      _b4_ = caml_call1(Re_Automata[25], st),
      res = [0, st[1], _b4_];
     st$0[4] = [0, [0, final_cat, res], st$0[4]];
     var match = res;
    }
    var res$0 = match[2], idx = match[1];
    a:
    if(groups && typeof res$0 !== "number"){
     caml_check_bound(info[3], idx)[1 + idx] = last;
     break a;
    }
    return res$0;
   }
   function match_str(groups, partial, re, s, pos, len){
    var
     slen = caml_ml_string_length(s),
     last = -1 === len ? slen : pos + len | 0;
    if(groups)
     var
      n = caml_call1(Re_Automata[22], re[7]) + 1 | 0,
      _bX_ = 10 < n ? caml_make_vect(n, 0) : _a_.slice(),
      _bY_ = _bX_;
    else
     var _bY_ = [0];
    var info = [0, re, re[3], _bY_, pos, last];
    if(0 === pos)
     var
      initial_cat = caml_call2(Re_Category[1], Re_Category[9], Re_Category[4]);
    else
     var
      _b1_ = category(re, get_color(re, s, pos - 1 | 0)),
      initial_cat = caml_call2(Re_Category[1], Re_Category[9], _b1_);
    try{
     var
      _bW_ = caml_call2(Stdlib_List[48], initial_cat, re[2]),
      initial_state = _bW_;
    }
    catch(_b2_){
     var _bV_ = caml_wrap_exception(_b2_);
     if(_bV_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_bV_, 0);
     var
      st = find_state(re, caml_call2(Re_Automata[20][2], initial_cat, re[1]));
     re[2] = [0, [0, initial_cat, st], re[2]];
     var initial_state = st;
    }
    var st$0 = scan_str(info, s, initial_state, groups);
    a:
    {
     b:
     if(st$0[1] !== -3){
      if(partial && ! groups) break b;
      if(partial && groups){
       var status = caml_call1(Re_Automata[25], st$0[5]);
       c:
       {
        if(typeof status === "number" && status){
         var
          status$0 =
            final_boundary_check(last, slen, re, s, info, st$0, groups),
          _bZ_ = typeof status$0 === "number" ? 1 : status$0,
          _b0_ = _bZ_;
         break c;
        }
        var _b0_ = status;
       }
       var res = _b0_;
       break a;
      }
      var res = final_boundary_check(last, slen, re, s, info, st$0, groups);
      break a;
     }
     var res = caml_call1(Re_Automata[25], st$0[5]);
    }
    if(typeof res !== "number"){
     var pmarks = res[2], marks = res[1];
     return [0, [0, s, marks, pmarks, info[3], re[10]]];
    }
    if(! res) return 0;
    var no_match_starts_before = groups ? caml_check_bound(info[3], 0)[1] : 0;
    return [1, no_match_starts_before];
   }
   function cseq(c$0, c){return caml_call2(Re_Cset[8], c$0, c);}
   function cadd(c, s){return caml_call2(Re_Cset[9], c, s);}
   function view(t){return t;}
   var View = [0, view];
   function pp(fmt, t){
    function var$0(s, re){return caml_call4(Re_Fmt[157], fmt, s, pp, re);}
    function seq(s, rel){
     var _bU_ = caml_call2(Re_Fmt[155], 0, pp);
     return caml_call4(Re_Fmt[157], fmt, s, _bU_, rel);
    }
    if(typeof t === "number")
     switch(t){
       case 0:
        return caml_call2(Re_Fmt[156], fmt, cst_Beg_of_line);
       case 1:
        return caml_call2(Re_Fmt[156], fmt, cst_End_of_line);
       case 2:
        return caml_call2(Re_Fmt[156], fmt, cst_Beg_of_word);
       case 3:
        return caml_call2(Re_Fmt[156], fmt, cst_End_of_word);
       case 4:
        return caml_call2(Re_Fmt[156], fmt, cst_Not_bound);
       case 5:
        return caml_call2(Re_Fmt[156], fmt, cst_Beg_of_str);
       case 6:
        return caml_call2(Re_Fmt[156], fmt, cst_End_of_str);
       case 7:
        return caml_call2(Re_Fmt[156], fmt, cst_Last_end_of_line);
       case 8:
        return caml_call2(Re_Fmt[156], fmt, cst_Start);
       default: return caml_call2(Re_Fmt[156], fmt, cst_Stop);
     }
    switch(t[0]){
      case 0:
       var s = t[1];
       return caml_call4(Re_Fmt[157], fmt, cst_Set, Re_Cset[12], s);
      case 1:
       var sq = t[1]; return seq(cst_Sequence, sq);
      case 2:
       var alt = t[1]; return seq(cst_Alternative, alt);
      case 3:
       var
        stop = t[3],
        start = t[2],
        re = t[1],
        pp$0 =
          function(fmt, param){
           return caml_call7
                   (Re_Fmt[129], fmt, _b_, pp, re, start, Re_Fmt[161], stop);
          };
       return caml_call4(Re_Fmt[157], fmt, cst_Repeat, pp$0, 0);
      case 4:
       var
        re$0 = t[2],
        sem = t[1],
        _bP_ = caml_call2(Re_Fmt[158], Re_Automata[1], pp);
       return caml_call4(Re_Fmt[157], fmt, cst_Sem, _bP_, [0, sem, re$0]);
      case 5:
       var
        re$1 = t[2],
        k = t[1],
        _bQ_ = caml_call2(Re_Fmt[158], Re_Automata[2], pp);
       return caml_call4(Re_Fmt[157], fmt, cst_Sem_greedy, _bQ_, [0, k, re$1]);
      case 6:
       var match = t[1];
       if(match){
        var
         c = t[2],
         n = match[1],
         _bR_ = caml_call2(Re_Fmt[158], Re_Fmt[156], pp);
        return caml_call4(Re_Fmt[157], fmt, cst_Named_group, _bR_, [0, n, c]);
       }
       var c$0 = t[2];
       return var$0(cst_Group, c$0);
      case 7:
       var c$1 = t[1]; return var$0(cst_No_group, c$1);
      case 8:
       var c$2 = t[1]; return var$0(cst_Nest, c$2);
      case 9:
       var c$3 = t[1]; return var$0(cst_Case, c$3);
      case 10:
       var c$4 = t[1]; return var$0(cst_No_case, c$4);
      case 11:
       var c$5 = t[1]; return seq(cst_Intersection, c$5);
      case 12:
       var c$6 = t[1]; return seq(cst_Complement, c$6);
      case 13:
       var b = t[2], a = t[1], _bS_ = caml_call2(Re_Fmt[158], pp, pp);
       return caml_call4(Re_Fmt[157], fmt, cst_Difference, _bS_, [0, a, b]);
      default:
       var
        r = t[2],
        m = t[1],
        _bT_ = caml_call2(Re_Fmt[158], Re_Pmark[4], pp);
       return caml_call4(Re_Fmt[157], fmt, cst_Pmark, _bT_, [0, m, r]);
    }
   }
   function is_charset(param){
    var param$0 = param;
    for(;;){
     a:
     if(typeof param$0 !== "number"){
      switch(param$0[0]){
        case 0:
         return 1;
        case 13:
         var r$0 = param$0[2], r$1 = param$0[1], _bO_ = is_charset(r$1);
         if(! _bO_) return _bO_;
         var param$0 = r$0;
         continue;
        case 4:
        case 5:
         var r = param$0[2]; break;
        case 2:
        case 11:
        case 12:
         var l = param$0[1];
         return caml_call2(Stdlib_List[32], is_charset, l);
        case 7:
        case 9:
        case 10:
         var r = param$0[1]; break;
        default: break a;
      }
      var param$0 = r;
      continue;
     }
     return 0;
    }
   }
   var
    _c_ = cseq(216, 222),
    _d_ = cseq(192, 214),
    _e_ = caml_call2(Re_Cset[2], _d_, _c_),
    _f_ = cseq(65, 90),
    cupper = caml_call2(Re_Cset[2], _f_, _e_),
    clower = caml_call2(Re_Cset[5], 32, cupper),
    _g_ = caml_call2(Re_Cset[2], clower, cupper),
    calpha = caml_call3(Stdlib_List[26], cadd, _h_, _g_),
    cdigit = cseq(48, 57),
    calnum = caml_call2(Re_Cset[2], calpha, cdigit),
    cword = cadd(95, calnum);
   function equal(x1, x2){
    var x1$0 = x1, x2$0 = x2;
    for(;;){
     a:
     {
      if(typeof x1$0 === "number"){
       switch(x1$0){
         case 0:
          if(typeof x2$0 !== "number" || x2$0) break a; break;
         case 1:
          if(typeof x2$0 !== "number" || 1 !== x2$0) break a; break;
         case 2:
          if(typeof x2$0 !== "number" || 2 !== x2$0) break a; break;
         case 3:
          if(typeof x2$0 !== "number" || 3 !== x2$0) break a; break;
         case 4:
          if(typeof x2$0 !== "number" || 4 !== x2$0) break a; break;
         case 5:
          if(typeof x2$0 !== "number" || 5 !== x2$0) break a; break;
         case 6:
          if(typeof x2$0 !== "number" || 6 !== x2$0) break a; break;
         case 7:
          if(typeof x2$0 !== "number" || 7 !== x2$0) break a; break;
         case 8:
          if(typeof x2$0 !== "number" || 8 !== x2$0) break a; break;
         default: if(typeof x2$0 !== "number" || 9 > x2$0) break a;
       }
       return 1;
      }
      switch(x1$0[0]){
        case 0:
         if(typeof x2$0 !== "number" && 0 === x2$0[0]){
          var s2 = x2$0[1], s1 = x1$0[1];
          return caml_equal(s1, s2);
         }
         break;
        case 1:
         if(typeof x2$0 !== "number" && 1 === x2$0[0]){
          var l2 = x2$0[1], l1 = x1$0[1];
          return eq_list(l1, l2);
         }
         break;
        case 2:
         if(typeof x2$0 !== "number" && 2 === x2$0[0]){
          var l2$0 = x2$0[1], l1$0 = x1$0[1];
          return eq_list(l1$0, l2$0);
         }
         break;
        case 3:
         if(typeof x2$0 !== "number" && 3 === x2$0[0]){
          var
           j2 = x2$0[3],
           i2 = x2$0[2],
           x2$1 = x2$0[1],
           j1 = x1$0[3],
           i1 = x1$0[2],
           x1$1 = x1$0[1],
           _bH_ = i1 === i2 ? 1 : 0;
          if(_bH_){
           var _bI_ = caml_equal(j1, j2);
           if(_bI_){var x1$0 = x1$1, x2$0 = x2$1; continue;}
           var _bJ_ = _bI_;
          }
          else
           var _bJ_ = _bH_;
          return _bJ_;
         }
         break;
        case 4:
         if(typeof x2$0 !== "number" && 4 === x2$0[0]){
          var
           x2$2 = x2$0[2],
           sem2 = x2$0[1],
           x1$2 = x1$0[2],
           sem1 = x1$0[1],
           _bK_ = sem1 === sem2 ? 1 : 0;
          if(! _bK_) return _bK_;
          var x1$0 = x1$2, x2$0 = x2$2;
          continue;
         }
         break;
        case 5:
         if(typeof x2$0 !== "number" && 5 === x2$0[0]){
          var
           x2$3 = x2$0[2],
           k2 = x2$0[1],
           x1$3 = x1$0[2],
           k1 = x1$0[1],
           _bL_ = k1 === k2 ? 1 : 0;
          if(! _bL_) return _bL_;
          var x1$0 = x1$3, x2$0 = x2$3;
          continue;
         }
         break;
        case 6:
         if(typeof x2$0 !== "number" && 6 === x2$0[0]) return 0; break;
        case 7:
         if(typeof x2$0 !== "number" && 7 === x2$0[0]){
          var x2$4 = x2$0[1], x1$4 = x1$0[1], x1$0 = x1$4, x2$0 = x2$4;
          continue;
         }
         break;
        case 8:
         if(typeof x2$0 !== "number" && 8 === x2$0[0]){
          var x2$5 = x2$0[1], x1$5 = x1$0[1], x1$0 = x1$5, x2$0 = x2$5;
          continue;
         }
         break;
        case 9:
         if(typeof x2$0 !== "number" && 9 === x2$0[0]){
          var x2$6 = x2$0[1], x1$6 = x1$0[1], x1$0 = x1$6, x2$0 = x2$6;
          continue;
         }
         break;
        case 10:
         if(typeof x2$0 !== "number" && 10 === x2$0[0]){
          var x2$7 = x2$0[1], x1$7 = x1$0[1], x1$0 = x1$7, x2$0 = x2$7;
          continue;
         }
         break;
        case 11:
         if(typeof x2$0 !== "number" && 11 === x2$0[0]){
          var l2$1 = x2$0[1], l1$1 = x1$0[1];
          return eq_list(l1$1, l2$1);
         }
         break;
        case 12:
         if(typeof x2$0 !== "number" && 12 === x2$0[0]){
          var l2$2 = x2$0[1], l1$2 = x1$0[1];
          return eq_list(l1$2, l2$2);
         }
         break;
        case 13:
         if(typeof x2$0 !== "number" && 13 === x2$0[0]){
          var
           x2$8 = x2$0[2],
           x2$9 = x2$0[1],
           x1$8 = x1$0[2],
           x1$9 = x1$0[1],
           _bM_ = equal(x1$9, x2$9);
          if(! _bM_) return _bM_;
          var x1$0 = x1$8, x2$0 = x2$8;
          continue;
         }
         break;
        default:
         if(typeof x2$0 !== "number" && 14 === x2$0[0]){
          var
           r2 = x2$0[2],
           m2 = x2$0[1],
           r1 = x1$0[2],
           m1 = x1$0[1],
           _bN_ = caml_call2(Re_Pmark[1], m1, m2);
          if(! _bN_) return _bN_;
          var x1$0 = r1, x2$0 = r2;
          continue;
         }
      }
     }
     return 0;
    }
   }
   function eq_list(l1, l2){
    var l1$0 = l1, l2$0 = l2;
    for(;;){
     if(l1$0){
      if(l2$0){
       var
        r2 = l2$0[2],
        x2 = l2$0[1],
        r1 = l1$0[2],
        x1 = l1$0[1],
        _bG_ = equal(x1, x2);
       if(! _bG_) return _bG_;
       var l1$0 = r1, l2$0 = r2;
       continue;
      }
     }
     else if(! l2$0) return 1;
     return 0;
    }
   }
   function sequence(l){
    if(l && ! l[2]){var x = l[1]; return x;}
    return [1, l];
   }
   function merge_sequences(param){
    var param$0 = param;
    for(;;){
     if(! param$0) return 0;
     var x = param$0[1];
     if(typeof x !== "number")
      switch(x[0]){
        case 1:
         var match = x[1];
         if(match){
          var
           r$0 = param$0[2],
           y = match[2],
           x$0 = match[1],
           r$1 = merge_sequences(r$0);
          a:
          if(r$1){
           var _bE_ = r$1[1];
           if(typeof _bE_ !== "number" && 1 === _bE_[0]){
            var match$0 = _bE_[1];
            if(! match$0) break a;
            var r$2 = r$1[2], y$0 = match$0[2], x$1 = match$0[1];
            if(! equal(x$0, x$1)) break a;
            var _bF_ = [0, sequence(y$0), 0];
            return [0,
                    [1, [0, x$0, [0, [2, [0, sequence(y), _bF_]], 0]]],
                    r$2];
           }
          }
          return [0, [1, [0, x$0, y]], r$1];
         }
         break;
        case 2:
         var
          r$3 = param$0[2],
          l = x[1],
          param$0 = caml_call2(Stdlib[37], l, r$3);
         continue;
      }
     var r = param$0[2];
     return [0, x, merge_sequences(r)];
    }
   }
   function enforce_kind(ids, kind$0, kind, cr){
    if(332064784 !== kind$0) return cr;
    if(332064784 === kind) return cr;
    var _bD_ = caml_call1(Re_Automata[10], ids);
    return caml_call4(Re_Automata[9], ids, kind, cr, _bD_);
   }
   function translate
   (ids, kind, ign_group, ign_case, greedy, pos, names, cache, cm, param){
    var ign_group$0 = ign_group, greedy$0 = greedy, param$0 = param;
    for(;;){
     if(typeof param$0 === "number")
      switch(param$0){
        case 0:
         var
          _a6_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[7]);
         return [0, caml_call2(Re_Automata[16], ids, _a6_), kind];
        case 1:
         var
          _a7_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[7]);
         return [0, caml_call2(Re_Automata[15], ids, _a7_), kind];
        case 2:
         var
          _a8_ = caml_call2(Re_Automata[15], ids, Re_Category[5]),
          _a9_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[6]),
          _a__ = caml_call2(Re_Automata[16], ids, _a9_);
         return [0,
                 caml_call4(Re_Automata[9], ids, 332064784, _a__, _a8_),
                 kind];
        case 3:
         var
          _a$_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[6]),
          _ba_ = caml_call2(Re_Automata[15], ids, _a$_),
          _bb_ = caml_call2(Re_Automata[16], ids, Re_Category[5]);
         return [0,
                 caml_call4(Re_Automata[9], ids, 332064784, _bb_, _ba_),
                 kind];
        case 4:
         var
          _bc_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[6]),
          _bd_ = caml_call2(Re_Automata[15], ids, _bc_),
          _be_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[6]),
          _bf_ = caml_call2(Re_Automata[16], ids, _be_),
          _bg_ =
            [0, caml_call4(Re_Automata[9], ids, 332064784, _bf_, _bd_), 0],
          _bh_ = caml_call2(Re_Automata[15], ids, Re_Category[5]),
          _bi_ = caml_call2(Re_Automata[16], ids, Re_Category[5]),
          _bj_ =
            [0, caml_call4(Re_Automata[9], ids, 332064784, _bi_, _bh_), _bg_];
         return [0, caml_call2(Re_Automata[8], ids, _bj_), kind];
        case 5:
         return [0, caml_call2(Re_Automata[16], ids, Re_Category[4]), kind];
        case 6:
         return [0, caml_call2(Re_Automata[15], ids, Re_Category[4]), kind];
        case 7:
         var
          _bk_ = caml_call2(Re_Category[1], Re_Category[4], Re_Category[8]);
         return [0, caml_call2(Re_Automata[15], ids, _bk_), kind];
        case 8:
         return [0, caml_call2(Re_Automata[16], ids, Re_Category[9]), kind];
        default:
         return [0, caml_call2(Re_Automata[15], ids, Re_Category[9]), kind];
      }
     switch(param$0[0]){
       case 0:
        var s = param$0[1], match = caml_call1(Re_Cset[13], s);
        if(match)
         var
          i = match[1],
          _a2_ = caml_string_get(cm, i),
          _bl_ = caml_call1(Re_Cset[18], _a2_);
        else{
         var v = [0, caml_call1(Re_Cset[15], s), s];
         try{var _a5_ = caml_call2(Re_Cset[16][28], v, cache[1]), _bl_ = _a5_;
         }
         catch(_bA_){
          var _a3_ = caml_wrap_exception(_bA_);
          if(_a3_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_a3_, 0);
          var
           _a4_ =
             function(param, l){
              var
               j = param[2],
               i = param[1],
               _bB_ = caml_string_get(cm, j),
               _bC_ = cseq(caml_string_get(cm, i), _bB_);
              return caml_call2(Re_Cset[2], _bC_, l);
             },
           l = caml_call3(Re_Cset[14], s, Re_Cset[6], _a4_);
          cache[1] = caml_call3(Re_Cset[16][4], v, l, cache[1]);
          var _bl_ = l;
         }
        }
        return [0, caml_call2(Re_Automata[6], ids, _bl_), kind];
       case 1:
        var l$0 = param$0[1];
        return [0,
                trans_seq
                 (ids,
                  kind,
                  ign_group$0,
                  ign_case,
                  greedy$0,
                  pos,
                  names,
                  cache,
                  cm,
                  l$0),
                kind];
       case 2:
        var l$1 = param$0[1], merged_sequences = merge_sequences(l$1);
        if(merged_sequences && ! merged_sequences[2]){
         var
          r = merged_sequences[1],
          match$0 =
            translate
             (ids,
              kind,
              ign_group$0,
              ign_case,
              greedy$0,
              pos,
              names,
              cache,
              cm,
              r),
          kind$0 = match$0[2],
          cr = match$0[1];
         return [0, enforce_kind(ids, kind, kind$0, cr), kind];
        }
        var
         _bm_ =
           function(r){
            var
             match =
               translate
                (ids,
                 kind,
                 ign_group$0,
                 ign_case,
                 greedy$0,
                 pos,
                 names,
                 cache,
                 cm,
                 r),
             kind$0 = match[2],
             cr = match[1];
            return enforce_kind(ids, kind, kind$0, cr);
           },
         _bn_ = caml_call2(Stdlib_List[19], _bm_, merged_sequences);
        return [0, caml_call2(Re_Automata[8], ids, _bn_), kind];
       case 3:
        var
         j = param$0[3],
         i$0 = param$0[2],
         r$0 = param$0[1],
         match$1 =
           translate
            (ids,
             kind,
             ign_group$0,
             ign_case,
             greedy$0,
             pos,
             names,
             cache,
             cm,
             r$0),
         kind$1 = match$1[2],
         cr$0 = match$1[1];
        if(j)
         var
          j$0 = j[1],
          f =
            620821490 <= greedy$0
             ? function
              (rem){
               var
                _bu_ = caml_call2(Re_Automata[17], ids, cr$0),
                _bv_ =
                  [0, caml_call4(Re_Automata[9], ids, kind$1, _bu_, rem), 0],
                _bw_ = [0, caml_call1(Re_Automata[10], ids), _bv_];
               return caml_call2(Re_Automata[8], ids, _bw_);
              }
             : function
              (rem){
               var
                _bx_ = [0, caml_call1(Re_Automata[10], ids), 0],
                _by_ = caml_call2(Re_Automata[17], ids, cr$0),
                _bz_ =
                  [0,
                   caml_call4(Re_Automata[9], ids, kind$1, _by_, rem),
                   _bx_];
               return caml_call2(Re_Automata[8], ids, _bz_);
              },
          rem = iter(j$0 - i$0 | 0, f, caml_call1(Re_Automata[10], ids));
        else
         var rem = caml_call4(Re_Automata[11], ids, greedy$0, kind$1, cr$0);
        return [0,
                iter
                 (i$0,
                  function(rem){
                   var _bt_ = caml_call2(Re_Automata[17], ids, cr$0);
                   return caml_call4(Re_Automata[9], ids, kind$1, _bt_, rem);
                  },
                  rem),
                kind];
       case 4:
        var
         r$1 = param$0[2],
         kind$2 = param$0[1],
         match$2 =
           translate
            (ids,
             kind$2,
             ign_group$0,
             ign_case,
             greedy$0,
             pos,
             names,
             cache,
             cm,
             r$1),
         kind$3 = match$2[2],
         cr$1 = match$2[1];
        return [0, enforce_kind(ids, kind$2, kind$3, cr$1), kind$2];
       case 5:
        var
         r$2 = param$0[2],
         greedy$1 = param$0[1],
         greedy$0 = greedy$1,
         param$0 = r$2;
        break;
       case 6:
        var r$3 = param$0[2], n = param$0[1];
        if(! ign_group$0){
         var p = pos[1];
         if(n){
          var name = n[1];
          names[1] = [0, [0, name, p / 2 | 0], names[1]];
         }
         pos[1] = pos[1] + 2 | 0;
         var
          match$3 =
            translate
             (ids,
              kind,
              ign_group$0,
              ign_case,
              greedy$0,
              pos,
              names,
              cache,
              cm,
              r$3),
          kind$4 = match$3[2],
          cr$2 = match$3[1],
          _bo_ = caml_call2(Re_Automata[12], ids, p + 1 | 0),
          _bp_ = caml_call4(Re_Automata[9], ids, 332064784, cr$2, _bo_),
          _bq_ = caml_call2(Re_Automata[12], ids, p);
         return [0,
                 caml_call4(Re_Automata[9], ids, 332064784, _bq_, _bp_),
                 kind$4];
        }
        var param$0 = r$3;
        break;
       case 7:
        var r$4 = param$0[1], ign_group$0 = 1, param$0 = r$4; break;
       case 8:
        var
         r$5 = param$0[1],
         b = pos[1],
         match$4 =
           translate
            (ids,
             kind,
             ign_group$0,
             ign_case,
             greedy$0,
             pos,
             names,
             cache,
             cm,
             r$5),
         kind$5 = match$4[2],
         cr$3 = match$4[1],
         e = pos[1] - 1 | 0;
        if(e < b) return [0, cr$3, kind$5];
        var _br_ = caml_call3(Re_Automata[14], ids, b, e);
        return [0,
                caml_call4(Re_Automata[9], ids, 332064784, _br_, cr$3),
                kind$5];
       case 14:
        var
         r$6 = param$0[2],
         i$1 = param$0[1],
         match$5 =
           translate
            (ids,
             kind,
             ign_group$0,
             ign_case,
             greedy$0,
             pos,
             names,
             cache,
             cm,
             r$6),
         kind$6 = match$5[2],
         cr$4 = match$5[1],
         _bs_ = caml_call2(Re_Automata[13], ids, i$1);
        return [0,
                caml_call4(Re_Automata[9], ids, 332064784, _bs_, cr$4),
                kind$6];
       default:
        throw caml_maybe_attach_backtrace([0, Assert_failure, _j_], 1);
     }
    }
   }
   function trans_seq
   (ids, kind, ign_group, ign_case, greedy, pos, names, cache, c, param){
    if(! param) return caml_call1(Re_Automata[10], ids);
    var r = param[1];
    if(param[2]){
     var
      rem = param[2],
      match =
        translate
         (ids, kind, ign_group, ign_case, greedy, pos, names, cache, c, r),
      kind$0 = match[2],
      cr = match[1],
      cr$0 =
        trans_seq
         (ids, kind, ign_group, ign_case, greedy, pos, names, cache, c, rem);
     return caml_call1(Re_Automata[3], cr$0)
             ? cr
             : caml_call1
                (Re_Automata[3], cr)
               ? cr$0
               : caml_call4(Re_Automata[9], ids, kind$0, cr, cr$0);
    }
    var
     match$0 =
       translate
        (ids, kind, ign_group, ign_case, greedy, pos, names, cache, c, r),
     kind$1 = match$0[2],
     cr$1 = match$0[1];
    return enforce_kind(ids, kind, kind$1, cr$1);
   }
   function as_set(param){
    if(typeof param !== "number" && 0 === param[0]){var s = param[1]; return s;}
    throw caml_maybe_attach_backtrace([0, Assert_failure, _k_], 1);
   }
   function handle_case(ign_case, r){
    var ign_case$0 = ign_case, r$0 = r;
    for(;;){
     if(typeof r$0 === "number") return r$0;
     switch(r$0[0]){
       case 0:
        var s = r$0[1];
        if(ign_case$0)
         var
          _aD_ = caml_call2(Re_Cset[3], s, clower),
          _aE_ = caml_call2(Re_Cset[5], -32, _aD_),
          _aF_ = caml_call2(Re_Cset[3], s, cupper),
          _aG_ = caml_call2(Re_Cset[5], 32, _aF_),
          _aH_ = caml_call2(Re_Cset[2], _aG_, _aE_),
          _aI_ = caml_call2(Re_Cset[2], s, _aH_);
        else
         var _aI_ = s;
        return [0, _aI_];
       case 1:
        var
         l = r$0[1],
         _aJ_ = function(_a1_){return handle_case(ign_case$0, _a1_);};
        return [1, caml_call2(Stdlib_List[19], _aJ_, l)];
       case 2:
        var
         l$0 = r$0[1],
         _aK_ = function(_a0_){return handle_case(ign_case$0, _a0_);},
         l$1 = caml_call2(Stdlib_List[19], _aK_, l$0);
        if(! is_charset([2, l$1])) return [2, l$1];
        var
         _aL_ = Re_Cset[6],
         _aM_ =
           function(s, r){
            var _aZ_ = as_set(r);
            return caml_call2(Re_Cset[2], s, _aZ_);
           };
        return [0, caml_call3(Stdlib_List[25], _aM_, _aL_, l$1)];
       case 3:
        var j = r$0[3], i = r$0[2], r$1 = r$0[1];
        return [3, handle_case(ign_case$0, r$1), i, j];
       case 4:
        var r$2 = r$0[2], k = r$0[1], r$3 = handle_case(ign_case$0, r$2);
        return is_charset(r$3) ? r$3 : [4, k, r$3];
       case 5:
        var r$4 = r$0[2], k$0 = r$0[1], r$5 = handle_case(ign_case$0, r$4);
        return is_charset(r$5) ? r$5 : [5, k$0, r$5];
       case 6:
        var r$6 = r$0[2], n = r$0[1];
        return [6, n, handle_case(ign_case$0, r$6)];
       case 7:
        var r$7 = r$0[1], r$8 = handle_case(ign_case$0, r$7);
        return is_charset(r$8) ? r$8 : [7, r$8];
       case 8:
        var r$9 = r$0[1], r$10 = handle_case(ign_case$0, r$9);
        return is_charset(r$10) ? r$10 : [8, r$10];
       case 9:
        var r$11 = r$0[1], ign_case$0 = 0, r$0 = r$11; break;
       case 10:
        var r$12 = r$0[1], ign_case$0 = 1, r$0 = r$12; break;
       case 11:
        var
         l$2 = r$0[1],
         _aN_ = function(r){return handle_case(ign_case$0, r);},
         l$3 = caml_call2(Stdlib_List[19], _aN_, l$2),
         _aO_ = Re_Cset[17],
         _aP_ =
           function(s, r){
            var _aY_ = as_set(r);
            return caml_call2(Re_Cset[3], s, _aY_);
           };
        return [0, caml_call3(Stdlib_List[25], _aP_, _aO_, l$3)];
       case 12:
        var
         l$4 = r$0[1],
         _aQ_ = function(r){return handle_case(ign_case$0, r);},
         l$5 = caml_call2(Stdlib_List[19], _aQ_, l$4),
         _aR_ = Re_Cset[6],
         _aS_ =
           function(s, r){
            var _aX_ = as_set(r);
            return caml_call2(Re_Cset[2], s, _aX_);
           },
         _aT_ = caml_call3(Stdlib_List[25], _aS_, _aR_, l$5);
        return [0, caml_call2(Re_Cset[4], Re_Cset[17], _aT_)];
       case 13:
        var
         r$13 = r$0[2],
         r$14 = r$0[1],
         _aU_ = as_set(handle_case(ign_case$0, r$13)),
         _aV_ = caml_call2(Re_Cset[4], Re_Cset[17], _aU_),
         _aW_ = as_set(handle_case(ign_case$0, r$14));
        return [0, caml_call2(Re_Cset[3], _aW_, _aV_)];
       default:
        var r$15 = r$0[2], i$0 = r$0[1];
        return [14, i$0, handle_case(ign_case$0, r$15)];
     }
    }
   }
   function anchored(param){
    var param$0 = param;
    for(;;){
     a:
     {
      if(typeof param$0 !== "number"){
       switch(param$0[0]){
         case 1:
          var l = param$0[1]; return caml_call2(Stdlib_List[33], anchored, l);
         case 2:
          var l$0 = param$0[1];
          return caml_call2(Stdlib_List[32], anchored, l$0);
         case 3:
          var i = param$0[2], r = param$0[1], _aC_ = 0 < i ? 1 : 0;
          if(! _aC_) return _aC_;
          var param$0 = r;
          continue;
         case 4:
         case 5:
         case 6:
         case 14:
          var r$0 = param$0[2]; break;
         case 7:
         case 8:
         case 9:
         case 10:
          var r$0 = param$0[1]; break;
         default: break a;
       }
       var param$0 = r$0;
       continue;
      }
      switch(param$0){case 5:case 8: return 1;
      }
     }
     return 0;
    }
   }
   function str(s){
    var l = [0, 0], _ay_ = caml_ml_string_length(s) - 1 | 0;
    if(_ay_ >= 0){
     var i = _ay_;
     for(;;){
      var _az_ = l[1], _aA_ = caml_string_get(s, i);
      l[1] = [0, [0, caml_call1(Re_Cset[18], _aA_)], _az_];
      var _aB_ = i - 1 | 0;
      if(0 === i) break;
      var i = _aB_;
     }
    }
    return [1, l[1]];
   }
   function char$0(c){return [0, caml_call1(Re_Cset[18], c)];}
   function alt(l){if(l && ! l[2]){var r = l[1]; return r;} return [2, l];}
   function seq(l){if(l && ! l[2]){var r = l[1]; return r;} return [1, l];}
   var empty = alt(0), epsilon = seq(0);
   function repn(r, i, j){
    if(i < 0) caml_call1(Stdlib[1], cst_Re_repn);
    a:
    if(j){
     var j$0 = j[1];
     if(j$0 < i){caml_call1(Stdlib[1], cst_Re_repn$0); break a;}
    }
    return [3, r, i, j];
   }
   function rep(r){return repn(r, 0, 0);}
   function rep1(r){return repn(r, 1, 0);}
   function opt(r){return repn(r, 0, _l_);}
   var bol = 0, eol = 1, bow = 2, eow = 3;
   function word(r){return seq([0, bow, [0, r, [0, eow, 0]]]);}
   var not_boundary = 4, bos = 5, eos = 6;
   function whole_string(r){return seq([0, bos, [0, r, [0, eos, 0]]]);}
   var leol = 7, start = 8, stop = 9;
   function longest(r){return [4, -730718166, r];}
   function shortest(r){return [4, -1034406550, r];}
   function first(r){return [4, 332064784, r];}
   function greedy(r){return [5, -904640576, r];}
   function non_greedy(r){return [5, 620821490, r];}
   function group(name, r){return [6, name, r];}
   function no_group(r){return [7, r];}
   function nest(r){return [8, r];}
   function mark(r){
    var i = caml_call1(Re_Pmark[3], 0);
    return [0, i, [14, i, r]];
   }
   function set(str){
    var
     s = [0, Re_Cset[6]],
     _at_ = caml_ml_string_length(str) - 1 | 0,
     _as_ = 0;
    if(_at_ >= 0){
     var i = _as_;
     for(;;){
      var
       _au_ = s[1],
       _av_ = caml_string_get(str, i),
       _aw_ = caml_call1(Re_Cset[18], _av_);
      s[1] = caml_call2(Re_Cset[2], _aw_, _au_);
      var _ax_ = i + 1 | 0;
      if(_at_ === i) break;
      var i = _ax_;
     }
    }
    return [0, s[1]];
   }
   function rg(c$0, c){return [0, cseq(c$0, c)];}
   function inter(l){
    var r = [11, l];
    return is_charset(r) ? r : caml_call1(Stdlib[1], cst_Re_inter);
   }
   function compl(l){
    var r = [12, l];
    return is_charset(r) ? r : caml_call1(Stdlib[1], cst_Re_compl);
   }
   function diff(r$0, r){
    var r$1 = [13, r$0, r];
    return is_charset(r$1) ? r$1 : caml_call1(Stdlib[1], cst_Re_diff);
   }
   var
    any = [0, Re_Cset[17]],
    _m_ = caml_call1(Re_Cset[18], 10),
    notnl = [0, caml_call2(Re_Cset[4], Re_Cset[17], _m_)],
    _n_ = [0, rg(248, 255), 0],
    _o_ = [0, rg(223, 246), _n_],
    _p_ = [0, char$0(181), _o_],
    lower = alt([0, rg(97, 122), _p_]),
    _q_ = [0, rg(216, 222), 0],
    _r_ = [0, rg(192, 214), _q_],
    upper = alt([0, rg(65, 90), _r_]),
    _s_ = [0, char$0(186), 0],
    alpha = alt([0, lower, [0, upper, [0, char$0(170), _s_]]]),
    digit = rg(48, 57),
    alnum = alt([0, alpha, [0, digit, 0]]),
    wordc = alt([0, alnum, [0, char$0(95), 0]]),
    ascii = rg(0, 127),
    blank = set(cst),
    _t_ = [0, rg(127, 159), 0],
    cntrl = alt([0, rg(0, 31), _t_]),
    _u_ = [0, rg(160, 255), 0],
    graph = alt([0, rg(33, 126), _u_]),
    _v_ = [0, rg(160, 255), 0],
    print = alt([0, rg(32, 126), _v_]),
    _w_ = [0, char$0(247), 0],
    _x_ = [0, char$0(215), _w_],
    _y_ = [0, rg(187, 191), _x_],
    _z_ = [0, rg(182, 185), _y_],
    _A_ = [0, rg(171, 180), _z_],
    _B_ = [0, rg(160, 169), _A_],
    _C_ = [0, rg(123, 126), _B_],
    _D_ = [0, rg(91, 96), _C_],
    _E_ = [0, rg(58, 64), _D_],
    punct = alt([0, rg(33, 47), _E_]),
    _F_ = [0, rg(9, 13), 0],
    space = alt([0, char$0(32), _F_]),
    _G_ = [0, rg(65, 70), 0],
    xdigit = alt([0, digit, [0, rg(97, 102), _G_]]);
   function case$0(r){return [9, r];}
   function no_case(r){return [10, r];}
   function compile(r$0){
    var
     regexp$0 =
       anchored(r$0)
        ? [6, 0, r$0]
        : seq([0, shortest(rep(any)), [0, [6, 0, r$0], 0]]),
     regexp = handle_case(0, regexp$0),
     c = caml_call1(Re_Color_map[1], 0),
     lnl = [0, 0];
    function colorize(regexp){
     var regexp$0 = regexp;
     for(;;){
      if(typeof regexp$0 === "number")
       switch(regexp$0){
         case 7:
          lnl[1] = 1; return 0;
         case 0:
         case 1:
          var _ar_ = caml_call1(Re_Cset[18], 10);
          return caml_call2(Re_Color_map[3], _ar_, c);
         case 2:
         case 3:
         case 4:
          return caml_call2(Re_Color_map[3], cword, c);
         default: return 0;
       }
      switch(regexp$0[0]){
        case 0:
         var s = regexp$0[1]; return caml_call2(Re_Color_map[3], s, c);
        case 1:
         var l = regexp$0[1]; return caml_call2(Stdlib_List[17], colorize, l);
        case 2:
         var l$0 = regexp$0[1];
         return caml_call2(Stdlib_List[17], colorize, l$0);
        case 3:
         var regexp$1 = regexp$0[1], regexp$0 = regexp$1; continue;
        case 7:
        case 8:
         var regexp$2 = regexp$0[1]; break;
        case 4:
        case 5:
        case 6:
        case 14:
         var regexp$2 = regexp$0[2]; break;
        default:
         throw caml_maybe_attach_backtrace([0, Assert_failure, _i_], 1);
      }
      var regexp$0 = regexp$2;
     }
    }
    colorize(regexp);
    var
     need_lnl = lnl[1],
     match = caml_call1(Re_Color_map[2], c),
     ncolor = match[3],
     color_repr = match[2],
     colors = match[1],
     lnl$0 = need_lnl ? ncolor : -1,
     ncolor$0 = need_lnl ? ncolor + 1 | 0 : ncolor,
     ids = caml_call1(Re_Automata[5], 0),
     pos = [0, 0],
     names = [0, 0],
     match$0 =
       translate
        (ids,
         332064784,
         0,
         0,
         -904640576,
         pos,
         names,
         [0, Re_Cset[16][1]],
         colors,
         regexp),
     kind = match$0[2],
     r = match$0[1],
     initial = enforce_kind(ids, 332064784, kind, r),
     group_count = pos[1] / 2 | 0,
     group_names = caml_call1(Stdlib_List[9], names[1]),
     _aq_ = caml_call1(Re_Automata[20][3][1], 97);
    return [0,
            initial,
            0,
            colors,
            color_repr,
            ncolor$0,
            lnl$0,
            caml_call1(Re_Automata[21], 0),
            _aq_,
            group_names,
            group_count];
   }
   function exec_internal(name, opt, _am_, partial, groups, re, s){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(_am_) var sth$0 = _am_[1], len = sth$0; else var len = -1;
    var _an_ = pos < 0 ? 1 : 0;
    if(_an_)
     var _ao_ = _an_;
    else
     var
      _ap_ = len < -1 ? 1 : 0,
      _ao_ = _ap_ || (caml_ml_string_length(s) < (pos + len | 0) ? 1 : 0);
    if(_ao_) caml_call1(Stdlib[1], name);
    return match_str(groups, partial, re, s, pos, len);
   }
   function exec(pos, len, re, s){
    var match = exec_internal(cst_Re_exec, pos, len, 0, 1, re, s);
    if(typeof match !== "number" && 0 === match[0]){var substr = match[1]; return substr;}
    throw caml_maybe_attach_backtrace(Stdlib[8], 1);
   }
   function exec_opt(pos, len, re, s){
    var match = exec_internal(cst_Re_exec_opt, pos, len, 0, 1, re, s);
    if(typeof match !== "number" && 0 === match[0]){var substr = match[1]; return [0, substr];}
    return 0;
   }
   function execp(pos, len, re, s){
    var match = exec_internal(cst_Re_execp, pos, len, 0, 0, re, s);
    if(typeof match !== "number" && 0 === match[0]) return 1;
    return 0;
   }
   function exec_partial(pos, len, re, s){
    var match = exec_internal(cst_Re_exec_partial, pos, len, 1, 0, re, s);
    return typeof match === "number"
            ? -1062743954
            : 0 === match[0] ? 782112175 : 939392865;
   }
   function exec_partial_detailed(pos, len, re, s){
    var
     match =
       exec_internal(cst_Re_exec_partial_detailed, pos, len, 1, 1, re, s);
    if(typeof match === "number") return -1062743954;
    if(0 === match[0]){var group = match[1]; return [0, 782112175, group];}
    var no_match_starts_before = match[1];
    return [0, 939392865, no_match_starts_before];
   }
   function marked(g, p){return caml_call2(Re_Pmark[5][3], p, g[3]);}
   function mark_set(g){return g[3];}
   var equal$0 = Re_Pmark[1], compare = Re_Pmark[2];
   function all_seq(opt, len, re, s){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(pos < 0) caml_call1(Stdlib[1], cst_Re_all);
    if(len){
     var
      l = len[1],
      _ai_ = l < 0 ? 1 : 0,
      _aj_ = _ai_ || (caml_ml_string_length(s) < (pos + l | 0) ? 1 : 0);
     if(_aj_) caml_call1(Stdlib[1], cst_Re_all$0);
     var limit = pos + l | 0;
    }
    else
     var limit = caml_ml_string_length(s);
    function aux(pos, param){
     if(limit <= pos) return 0;
     var match = match_str(1, 0, re, s, pos, limit - pos | 0);
     if(typeof match !== "number" && 0 === match[0]){
      var
       substr = match[1],
       match$0 = caml_call2(Re_Group[3], substr, 0),
       p2 = match$0[2],
       p1 = match$0[1],
       pos$0 = p1 === p2 ? p2 + 1 | 0 : p2;
      return [0, substr, function(_al_){return aux(pos$0, _al_);}];
     }
     return 0;
    }
    return function(_ak_){return aux(pos, _ak_);};
   }
   function matches_seq(pos, len, re, s){
    var _ag_ = all_seq(pos, len, re, s);
    function _ah_(sub){return caml_call2(Re_Group[1], sub, 0);}
    return caml_call1(caml_call1(Stdlib_Seq[27], _ah_), _ag_);
   }
   function split_full_seq(opt, len, re, s){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(pos < 0) caml_call1(Stdlib[1], cst_Re_split);
    if(len){
     var
      l = len[1],
      _X_ = l < 0 ? 1 : 0,
      _Y_ = _X_ || (caml_ml_string_length(s) < (pos + l | 0) ? 1 : 0);
     if(_Y_) caml_call1(Stdlib[1], cst_Re_split$0);
     var limit = pos + l | 0;
    }
    else
     var limit = caml_ml_string_length(s);
    function aux(state, old_i, pos$0, param){
     if(typeof state !== "number"){
      var x = state[2], _aa_ = 814535476;
      return [0, x, function(_af_){return aux(_aa_, old_i, pos$0, _af_);}];
     }
     if(limit <= pos$0){
      if(old_i >= limit) return 0;
      var
       sub = caml_call3(Stdlib_String[15], s, old_i, limit - old_i | 0),
       _$_ = old_i + 1 | 0;
      return [0,
              [0, 936573133, sub],
              function(_ae_){return aux(state, _$_, pos$0, _ae_);}];
     }
     var match = match_str(1, 0, re, s, pos$0, limit - pos$0 | 0);
     if(typeof match === "number"){
      if(old_i >= limit) return 0;
      var text = caml_call3(Stdlib_String[15], s, old_i, limit - old_i | 0);
      return [0,
              [0, 936573133, text],
              function(_ad_){return aux(state, limit, pos$0, _ad_);}];
     }
     if(0 !== match[0]) return 0;
     var
      substr = match[1],
      match$0 = caml_call2(Re_Group[3], substr, 0),
      p2 = match$0[2],
      p1 = match$0[1],
      pos$1 = p1 === p2 ? p2 + 1 | 0 : p2;
     if(pos >= p1)
      return [0,
              [0, -363573681, substr],
              function(_ac_){return aux(state, p2, pos$1, _ac_);}];
     var
      text$0 = caml_call3(Stdlib_String[15], s, old_i, p1 - old_i | 0),
      state$0 = [0, 73271853, [0, -363573681, substr]];
     return [0,
             [0, 936573133, text$0],
             function(_ab_){return aux(state$0, p2, pos$1, _ab_);}];
    }
    var _Z_ = 814535476;
    return function(___){return aux(_Z_, pos, pos, ___);};
   }
   function split_seq(pos, len, re, s){
    var seq = split_full_seq(pos, len, re, s);
    function filter(seq, param){
     var seq$0 = seq;
     for(;;){
      var match = caml_call1(seq$0, 0);
      if(! match) return 0;
      var match$0 = match[1];
      if(936573133 <= match$0[1]){
       var tl = match[2], s = match$0[2];
       return [0, s, function(_W_){return filter(tl, _W_);}];
      }
      var seq$1 = match[2], seq$0 = seq$1;
     }
    }
    return function(_V_){return filter(seq, _V_);};
   }
   function list_of_seq(s){
    var _S_ = 0;
    function _T_(l, x){return [0, x, l];}
    var _U_ = caml_call3(Stdlib_Seq[5], _T_, _S_, s);
    return caml_call1(Stdlib_List[9], _U_);
   }
   function all(pos, len, re, s){
    return list_of_seq(all_seq(pos, len, re, s));
   }
   function matches(pos, len, re, s){
    return list_of_seq(matches_seq(pos, len, re, s));
   }
   function split_full(pos, len, re, s){
    return list_of_seq(split_full_seq(pos, len, re, s));
   }
   function split(pos, len, re, s){
    return list_of_seq(split_seq(pos, len, re, s));
   }
   function gen_of_seq(s){
    var r = [0, s];
    return function(param){
     var match = caml_call1(r[1], 0);
     if(! match) return 0;
     var tl = match[2], x = match[1];
     r[1] = tl;
     return [0, x];};
   }
   function split_gen(pos, len, re, s){
    return gen_of_seq(split_seq(pos, len, re, s));
   }
   function split_full_gen(pos, len, re, s){
    return gen_of_seq(split_full_seq(pos, len, re, s));
   }
   function all_gen(pos, len, re, s){
    return gen_of_seq(all_seq(pos, len, re, s));
   }
   function matches_gen(pos, len, re, s){
    return gen_of_seq(matches_seq(pos, len, re, s));
   }
   function replace(opt, len, _O_, re, f, s){
    if(opt) var sth = opt[1], pos = sth; else var pos = 0;
    if(_O_) var sth$0 = _O_[1], all = sth$0; else var all = 1;
    if(pos < 0) caml_call1(Stdlib[1], cst_Re_replace);
    if(len){
     var
      l = len[1],
      _P_ = l < 0 ? 1 : 0,
      _Q_ = _P_ || (caml_ml_string_length(s) < (pos + l | 0) ? 1 : 0);
     if(_Q_) caml_call1(Stdlib[1], cst_Re_replace$0);
     var limit = pos + l | 0;
    }
    else
     var limit = caml_ml_string_length(s);
    var
     buf = caml_call1(Stdlib_Buffer[1], caml_ml_string_length(s)),
     pos$0 = pos;
    for(;;){
     if(pos$0 < limit){
      var match = match_str(1, 0, re, s, pos$0, limit - pos$0 | 0);
      if(typeof match === "number")
       caml_call4(Stdlib_Buffer[18], buf, s, pos$0, limit - pos$0 | 0);
      else if(0 === match[0]){
       var
        substr = match[1],
        match$0 = caml_call2(Re_Group[3], substr, 0),
        p2 = match$0[2],
        p1 = match$0[1];
       caml_call4(Stdlib_Buffer[18], buf, s, pos$0, p1 - pos$0 | 0);
       var replacing = caml_call1(f, substr);
       caml_call2(Stdlib_Buffer[16], buf, replacing);
       if(all){
        if(p1 === p2){
         if(p2 < limit){
          var _R_ = caml_string_get(s, p2);
          caml_call2(Stdlib_Buffer[12], buf, _R_);
         }
         var pos$1 = p2 + 1 | 0;
        }
        else
         var pos$1 = p2;
        var pos$0 = pos$1;
        continue;
       }
       caml_call4(Stdlib_Buffer[18], buf, s, p2, limit - p2 | 0);
      }
     }
     return caml_call1(Stdlib_Buffer[2], buf);
    }
   }
   function replace_string(pos, len, all, re, by, s){
    return replace(pos, len, all, re, function(param){return by;}, s);
   }
   function witness(t){
    function witness(param){
     var param$0 = param;
     for(;;){
      if(typeof param$0 === "number") return cst$0;
      switch(param$0[0]){
        case 0:
         var
          c = param$0[1],
          _J_ = caml_call1(Re_Cset[21], c),
          _K_ = caml_call1(Stdlib_Char[1], _J_);
         return caml_call2(Stdlib_String[1], 1, _K_);
        case 1:
         var xs = param$0[1], _L_ = caml_call2(Stdlib_List[19], witness, xs);
         return caml_call2(Stdlib_String[6], cst$1, _L_);
        case 2:
         var match = param$0[1];
         if(! match)
          throw caml_maybe_attach_backtrace([0, Assert_failure, _H_], 1);
         var x = match[1], param$0 = x;
         continue;
        case 3:
         var
          from = param$0[2],
          r = param$0[1],
          w = witness(r),
          b =
            caml_call1
             (Stdlib_Buffer[1],
              runtime.caml_mul(caml_ml_string_length(w), from)),
          _M_ = 1;
         if(from >= 1){
          var i = _M_;
          for(;;){
           caml_call2(Stdlib_Buffer[16], b, w);
           var _N_ = i + 1 | 0;
           if(from === i) break;
           var i = _N_;
          }
         }
         return caml_call1(Stdlib_Buffer[2], b);
        case 10:
         var r$1 = param$0[1], param$0 = r$1; continue;
        case 7:
        case 8:
        case 9:
         var r$0 = param$0[1]; break;
        case 11:
        case 12:
        case 13:
         throw caml_maybe_attach_backtrace([0, Assert_failure, _I_], 1);
        default: var r$0 = param$0[2];
      }
      var param$0 = r$0;
     }
    }
    return witness(handle_case(0, t));
   }
   var
    get = Re_Group[1],
    get_ofs = Re_Group[3],
    get_all = Re_Group[6],
    get_all_ofs = Re_Group[7],
    test = Re_Group[8],
    Re_Core =
      [0,
       Re_Group,
       compile,
       group_count,
       group_names,
       exec,
       exec_opt,
       execp,
       exec_partial,
       exec_partial_detailed,
       [0, marked, Re_Pmark[5], mark_set, equal$0, compare],
       all,
       all_gen,
       all_seq,
       matches,
       matches_gen,
       matches_seq,
       split,
       split_gen,
       split_seq,
       split_full,
       split_full_gen,
       split_full_seq,
       [0, all_seq, matches_seq, split_seq, split_full_seq],
       replace,
       replace_string,
       str,
       char$0,
       alt,
       seq,
       empty,
       epsilon,
       rep,
       rep1,
       repn,
       opt,
       bol,
       eol,
       bow,
       eow,
       bos,
       eos,
       leol,
       start,
       stop,
       word,
       not_boundary,
       whole_string,
       longest,
       shortest,
       first,
       greedy,
       non_greedy,
       group,
       no_group,
       nest,
       mark,
       set,
       rg,
       inter,
       diff,
       compl,
       any,
       notnl,
       alnum,
       wordc,
       alpha,
       ascii,
       blank,
       cntrl,
       digit,
       graph,
       lower,
       print,
       punct,
       space,
       upper,
       xdigit,
       case$0,
       no_case,
       pp,
       pp_re,
       pp_re,
       View,
       witness,
       get,
       get_ofs,
       get_all,
       get_all_ofs,
       test,
       marked,
       mark_set];
   runtime.caml_register_global(69, Re_Core, "Re__Core");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Emacs
//# unitInfo: Requires: Re__Core, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Parse_error = [248, "Re__Emacs.Parse_error", caml_fresh_oo_id(0)],
    Not_supported = [248, "Re__Emacs.Not_supported", caml_fresh_oo_id(0)];
   function re(opt, s){
    if(opt) var sth = opt[1], case$0 = sth; else var case$0 = 1;
    var i = [0, 0], l = runtime.caml_ml_string_length(s);
    function eos(param){return i[1] === l ? 1 : 0;}
    function test2(c$0, c){
     var _j_ = (i[1] + 1 | 0) < l ? 1 : 0;
     if(_j_)
      var
       _k_ = caml_string_get(s, i[1]) === c$0 ? 1 : 0,
       _l_ = _k_ ? caml_string_get(s, i[1] + 1 | 0) === c ? 1 : 0 : _k_;
     else
      var _l_ = _j_;
     return _l_;
    }
    function accept(c){
     var
      _i_ = 1 - eos(0),
      r = _i_ ? caml_string_get(s, i[1]) === c ? 1 : 0 : _i_;
     if(r) i[1]++;
     return r;
    }
    function accept2(c$0, c){
     var r = test2(c$0, c);
     if(r) i[1] = i[1] + 2 | 0;
     return r;
    }
    function get(param){var r = caml_string_get(s, i[1]); i[1]++; return r;}
    function regexp(param){
     var left = branch(0), left$0 = left;
     for(;;){
      if(! accept2(92, 124)) return left$0;
      var
       _h_ = [0, left$0, [0, branch(0), 0]],
       left$1 = caml_call1(Re_Core[28], _h_),
       left$0 = left$1;
     }
    }
    function branch(param){
     var left = 0;
     for(;;){
      if(! eos(0) && ! test2(92, 124) && ! test2(92, 41)){
       a:
       if(accept(46))
        var r = Re_Core[63];
       else if(accept(94))
        var r = Re_Core[36];
       else if(accept(36))
        var r = Re_Core[37];
       else if(accept(91))
        if(accept(94))
         var _d_ = bracket(0), r = caml_call1(Re_Core[61], _d_);
        else
         var _e_ = bracket(0), r = caml_call1(Re_Core[28], _e_);
       else{
        if(! accept(92)){
         if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
         var c$0 = get(0);
         b:
         {
          if(44 <= c$0){if(63 === c$0) break b;} else if(42 <= c$0) break b;
          var r = caml_call1(Re_Core[27], c$0);
          break a;
         }
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        }
        if(accept(40)){
         var r$0 = regexp(0);
         if(1 - accept2(92, 41))
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         var r = caml_call2(Re_Core[53], 0, r$0);
        }
        else if(accept(96))
         var r = Re_Core[40];
        else if(accept(39))
         var r = Re_Core[41];
        else if(accept(61))
         var r = Re_Core[43];
        else if(accept(98))
         var
          r = caml_call1(Re_Core[28], [0, Re_Core[38], [0, Re_Core[39], 0]]);
        else if(accept(66))
         var r = Re_Core[46];
        else if(accept(60))
         var r = Re_Core[38];
        else if(accept(62))
         var r = Re_Core[39];
        else if(accept(119))
         var
          _f_ = [0, caml_call1(Re_Core[27], 95), 0],
          r = caml_call1(Re_Core[28], [0, Re_Core[64], _f_]);
        else if(accept(87))
         var
          _g_ = [0, caml_call1(Re_Core[27], 95), 0],
          r = caml_call1(Re_Core[61], [0, Re_Core[64], _g_]);
        else{
         if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
         var c = get(0);
         b:
         {
          if(63 <= c){
           if(91 <= c){if(95 > c) break b;} else if(64 > c) break b;
          }
          else
           if(48 <= c){
            if(58 > c) throw caml_maybe_attach_backtrace(Not_supported, 1);
           }
           else if(36 <= c)
            switch(c - 36 | 0){case 0:case 6:case 7:case 10: break b;}
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         var r = caml_call1(Re_Core[27], c);
        }
       }
       var
        _c_ =
          accept(42)
           ? caml_call1(Re_Core[32], r)
           : accept
              (43)
             ? caml_call1(Re_Core[33], r)
             : accept(63) ? caml_call1(Re_Core[35], r) : r,
        left$0 = [0, _c_, left],
        left = left$0;
       continue;
      }
      var _b_ = caml_call1(Stdlib_List[9], left);
      return caml_call1(Re_Core[29], _b_);
     }
    }
    function bracket(s){
     var s$0 = s;
     for(;;){
      if(0 !== s$0 && accept(93)) return s$0;
      var c = char$0(0);
      if(accept(45)){
       if(accept(93)){
        var _a_ = [0, caml_call1(Re_Core[27], 45), s$0];
        return [0, caml_call1(Re_Core[27], c), _a_];
       }
       var
        c$0 = char$0(0),
        s$1 = [0, caml_call2(Re_Core[58], c, c$0), s$0],
        s$0 = s$1;
      }
      else
       var s$2 = [0, caml_call1(Re_Core[27], c), s$0], s$0 = s$2;
     }
    }
    function char$0(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     return get(0);
    }
    var res = regexp(0);
    if(1 - eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
    return case$0 ? res : caml_call1(Re_Core[79], res);
   }
   var compile = Re_Core[2];
   function compile_pat(opt, s){
    if(opt) var sth = opt[1], case$0 = sth; else var case$0 = 1;
    return caml_call1(compile, re([0, case$0], s));
   }
   var Re_Emacs = [0, Parse_error, Not_supported, re, compile, compile_pat];
   runtime.caml_register_global(4, Re_Emacs, "Re__Emacs");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Str
//# unitInfo: Requires: CamlinternalLazy, Re__Core, Re__Emacs, Stdlib, Stdlib__Buffer, Stdlib__Bytes, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst$1 = "",
    caml_bytes_set = runtime.caml_bytes_set,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_obj_tag = runtime.caml_obj_tag,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   function caml_call5(f, a0, a1, a2, a3, a4){
    return (f.l >= 0 ? f.l : f.l = f.length) == 5
            ? f(a0, a1, a2, a3, a4)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3, a4]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    cst$0 = cst$1,
    cst = cst$1,
    CamlinternalLazy = global_data.CamlinternalLazy,
    Re_Core = global_data.Re__Core,
    Stdlib = global_data.Stdlib,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Re_Emacs = global_data.Re__Emacs,
    cst_Str_replace_illegal_backsl = "Str.replace: illegal backslash sequence",
    cst_Str_group_end = "Str.group_end",
    cst_Str_group_beginning = "Str.group_beginning";
   function compile_regexp(s, c){
    var
     re = caml_call2(Re_Emacs[3], [0, 1 - c], s),
     _ah_ = [246, function(_aj_){return caml_call1(Re_Core[2], re);}];
    return [0,
            re,
            [246,
             function(param){
              var
               _ai_ = caml_call1(Re_Core[29], [0, Re_Core[43], [0, re, 0]]);
              return caml_call1(Re_Core[2], _ai_);
             }],
            _ah_];
   }
   var state = [0, 0];
   function string_match(re, s, p){
    try{
     var
      _ac_ = re[2],
      _ad_ = caml_obj_tag(_ac_),
      _ae_ =
        250 === _ad_
         ? _ac_[1]
         : 246 === _ad_ ? caml_call1(CamlinternalLazy[2], _ac_) : _ac_;
     state[1] = [0, caml_call4(Re_Core[5], [0, p], 0, _ae_, s)];
     var _af_ = 1;
     return _af_;
    }
    catch(_ag_){
     var _ab_ = caml_wrap_exception(_ag_);
     if(_ab_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_ab_, 0);
     state[1] = 0;
     return 0;
    }
   }
   function string_partial_match(re, s, p){
    var
     ___ = re[2],
     _$_ = caml_obj_tag(___),
     _aa_ =
       250 === _$_
        ? ___[1]
        : 246 === _$_ ? caml_call1(CamlinternalLazy[2], ___) : ___,
     match = caml_call4(Re_Core[8], [0, p], 0, _aa_, s);
    return 782112175 === match
            ? string_match(re, s, p)
            : 939392865 <= match ? 1 : 0;
   }
   function search_forward(re, s, p){
    try{
     var
      _V_ = re[3],
      _W_ = caml_obj_tag(_V_),
      _X_ =
        250 === _W_
         ? _V_[1]
         : 246 === _W_ ? caml_call1(CamlinternalLazy[2], _V_) : _V_,
      res = caml_call4(Re_Core[5], [0, p], 0, _X_, s);
     state[1] = [0, res];
     var _Y_ = caml_call2(Re_Core[1][3], res, 0)[1];
     return _Y_;
    }
    catch(_Z_){
     var _U_ = caml_wrap_exception(_Z_);
     if(_U_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_U_, 0);
     state[1] = 0;
     throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    }
   }
   function search_backward(re, s, p){
    var p$0 = p;
    for(;;)
     try{
      var
       _Q_ = re[2],
       _R_ = caml_obj_tag(_Q_),
       _S_ =
         250 === _R_
          ? _Q_[1]
          : 246 === _R_ ? caml_call1(CamlinternalLazy[2], _Q_) : _Q_,
       res = caml_call4(Re_Core[5], [0, p$0], 0, _S_, s);
      state[1] = [0, res];
      return p$0;
     }
     catch(_T_){
      var _P_ = caml_wrap_exception(_T_);
      if(_P_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_P_, 0);
      state[1] = 0;
      if(0 === p$0) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
      var p$1 = p$0 - 1 | 0, p$0 = p$1;
     }
   }
   function valid_group(n){
    var _M_ = 0 <= n ? 1 : 0;
    if(_M_){
     var _N_ = n < 10 ? 1 : 0;
     if(_N_){
      var match = state[1];
      if(match){
       var m = match[1];
       return n < caml_call1(Re_Core[1][9], m) ? 1 : 0;
      }
      var _O_ = 0;
     }
     else
      var _O_ = _N_;
    }
    else
     var _O_ = _M_;
    return _O_;
   }
   function offset_group(i){
    var match = state[1];
    if(! match) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    var m = match[1];
    return caml_call2(Re_Core[1][3], m, i);
   }
   function replacement_text(repl, orig){
    var len = caml_ml_string_length(repl), p = 0, q = 0;
    for(;;){
     if(p >= len) break;
     if(92 === caml_string_get(repl, p)){
      var p$0 = p + 1 | 0;
      if(p$0 === len) caml_call1(Stdlib[2], cst_Str_replace_illegal_backsl);
      var c = caml_string_get(repl, p$0);
      a:
      {
       if(58 <= c){
        if(92 === c){var q$0 = q + 1 | 0; break a;}
       }
       else if(48 <= c){
        var i = c - 48 | 0;
        try{
         var
          match = offset_group(i),
          e = match[2],
          b = match[1],
          _H_ = e - b | 0,
          _I_ = _H_;
        }
        catch(_L_){
         var _G_ = caml_wrap_exception(_L_);
         if(_G_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_G_, 0);
         var _I_ = 0;
        }
        var q$0 = q + _I_ | 0;
        break a;
       }
       var q$0 = q + 2 | 0;
      }
      var p$1 = p$0 + 1 | 0, p = p$1, q = q$0;
     }
     else
      var q$1 = q + 1 | 0, p$2 = p + 1 | 0, p = p$2, q = q$1;
    }
    var
     res = runtime.caml_create_bytes(q),
     len$0 = caml_ml_string_length(repl),
     p$3 = 0,
     q$2 = 0;
    for(;;){
     if(p$3 >= len$0) return caml_call1(Stdlib_Bytes[48], res);
     var c$0 = caml_string_get(repl, p$3);
     if(92 === c$0){
      var c$1 = caml_string_get(repl, p$3 + 1 | 0);
      if(58 <= c$1){
       if(92 === c$1){
        caml_bytes_set(res, q$2, 92);
        var q$3 = q$2 + 1 | 0, p$4 = p$3 + 2 | 0, p$3 = p$4, q$2 = q$3;
        continue;
       }
      }
      else if(48 <= c$1){
       try{
        var
         match$0 = offset_group(c$1 - 48 | 0),
         e$0 = match$0[2],
         b$0 = match$0[1],
         d$0 = e$0 - b$0 | 0;
        if(0 < d$0) caml_call5(Stdlib_String[48], orig, b$0, res, q$2, d$0);
        var d = d$0;
       }
       catch(_K_){
        var _J_ = caml_wrap_exception(_K_);
        if(_J_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_J_, 0);
        var d = 0;
       }
       var q$5 = q$2 + d | 0, p$6 = p$3 + 2 | 0, p$3 = p$6, q$2 = q$5;
       continue;
      }
      caml_bytes_set(res, q$2, 92);
      caml_bytes_set(res, q$2 + 1 | 0, c$1);
      var q$4 = q$2 + 2 | 0, p$5 = p$3 + 2 | 0, p$3 = p$5, q$2 = q$4;
     }
     else{
      caml_bytes_set(res, q$2, c$0);
      var q$6 = q$2 + 1 | 0, p$7 = p$3 + 1 | 0, p$3 = p$7, q$2 = q$6;
     }
    }
   }
   function quote(s){
    var
     len = caml_ml_string_length(s),
     buf = caml_call1(Stdlib_Buffer[1], 2 * len | 0),
     _C_ = len - 1 | 0,
     _B_ = 0;
    if(_C_ >= 0){
     var i = _B_;
     for(;;){
      var c = caml_string_get(s, i), _D_ = c - 63 | 0;
      a:
      {
       b:
       {
        if(31 < _D_ >>> 0){
         var _E_ = _D_ + 27 | 0;
         if(10 < _E_ >>> 0) break b;
         switch(_E_){case 0:case 6:case 7:case 10: break;default: break b;
         }
        }
        else if(26 >= _D_ - 1 >>> 0) break b;
        caml_call2(Stdlib_Buffer[12], buf, 92);
        caml_call2(Stdlib_Buffer[12], buf, c);
        break a;
       }
       caml_call2(Stdlib_Buffer[12], buf, c);
      }
      var _F_ = i + 1 | 0;
      if(_C_ === i) break;
      var i = _F_;
     }
    }
    return caml_call1(Stdlib_Buffer[2], buf);
   }
   function string_before(s, n){
    return caml_call3(Stdlib_String[15], s, 0, n);
   }
   function string_after(s, n){
    return caml_call3
            (Stdlib_String[15], s, n, caml_ml_string_length(s) - n | 0);
   }
   function first_chars(s, n){return caml_call3(Stdlib_String[15], s, 0, n);}
   function last_chars(s, n){
    return caml_call3
            (Stdlib_String[15], s, caml_ml_string_length(s) - n | 0, n);
   }
   function regexp(e){return compile_regexp(e, 0);}
   function regexp_case_fold(e){return compile_regexp(e, 1);}
   function regexp_string(s){return compile_regexp(quote(s), 0);}
   function regexp_string_case_fold(s){return compile_regexp(quote(s), 1);}
   function group_beginning(n){
    if(1 - valid_group(n)) caml_call1(Stdlib[1], cst_Str_group_beginning);
    var pos = offset_group(n)[1];
    if(-1 === pos) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    return pos;
   }
   function group_end(n){
    if(1 - valid_group(n)) caml_call1(Stdlib[1], cst_Str_group_end);
    var pos = offset_group(n)[2];
    if(-1 === pos) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
    return pos;
   }
   function matched_group(n, txt){
    var match = offset_group(n), e = match[2], b = match[1];
    return caml_call3(Stdlib_String[15], txt, b, e - b | 0);
   }
   function replace_matched(repl, matched){
    return replacement_text(repl, matched);
   }
   function match_beginning(param){return group_beginning(0);}
   function match_end(param){return group_end(0);}
   function matched_string(txt){return matched_group(0, txt);}
   function substitute_first(expr, repl_fun, text){
    try{
     var
      pos = search_forward(expr, text, 0),
      _w_ = [0, string_after(text, match_end(0)), 0],
      _x_ = [0, caml_call1(repl_fun, text), _w_],
      _y_ = [0, string_before(text, pos), _x_],
      _z_ = caml_call2(Stdlib_String[6], cst, _y_);
     return _z_;
    }
    catch(_A_){
     var _v_ = caml_wrap_exception(_A_);
     if(_v_ === Stdlib[8]) return text;
     throw caml_maybe_attach_backtrace(_v_, 0);
    }
   }
   function global_substitute(expr, repl_fun, text){
    var accu = 0, start = 0, last_was_empty = 0;
    for(;;){
     var startpos = last_was_empty ? start + 1 | 0 : start;
     a:
     {
      if(caml_ml_string_length(text) >= startpos){
       try{var pos = search_forward(expr, text, startpos);}
       catch(_u_){
        var _r_ = caml_wrap_exception(_u_);
        if(_r_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_r_, 0);
        var _s_ = [0, string_after(text, start), accu];
        break a;
       }
       var
        end_pos = match_end(0),
        repl_text = caml_call1(repl_fun, text),
        last_was_empty$0 = end_pos === pos ? 1 : 0,
        accu$0 =
          [0,
           repl_text,
           [0,
            caml_call3(Stdlib_String[15], text, start, pos - start | 0),
            accu]],
        accu = accu$0,
        start = end_pos,
        last_was_empty = last_was_empty$0;
       continue;
      }
      var _s_ = [0, string_after(text, start), accu];
     }
     var _t_ = caml_call1(Stdlib_List[9], _s_);
     return caml_call2(Stdlib_String[6], cst$0, _t_);
    }
   }
   function global_replace(expr, repl, text){
    return global_substitute
            (expr, function(_q_){return replacement_text(repl, _q_);}, text);
   }
   function replace_first(expr, repl, text){
    return substitute_first
            (expr, function(_p_){return replacement_text(repl, _p_);}, text);
   }
   function search_forward_progress(re, s, p){
    var pos = search_forward(re, s, p);
    if(p < match_end(0)) return pos;
    if(p < caml_ml_string_length(s)) return search_forward(re, s, p + 1 | 0);
    throw caml_maybe_attach_backtrace(Stdlib[8], 1);
   }
   function bounded_split(expr, text, num){
    var start = string_match(expr, text, 0) ? match_end(0) : 0;
    function split(accu, start, n){
     if(caml_ml_string_length(text) <= start) return accu;
     if(1 === n) return [0, string_after(text, start), accu];
     try{
      var
       pos = search_forward_progress(expr, text, start),
       _m_ = match_end(0),
       _n_ =
         split
          ([0,
            caml_call3(Stdlib_String[15], text, start, pos - start | 0),
            accu],
           _m_,
           n - 1 | 0);
      return _n_;
     }
     catch(_o_){
      var _l_ = caml_wrap_exception(_o_);
      if(_l_ === Stdlib[8]) return [0, string_after(text, start), accu];
      throw caml_maybe_attach_backtrace(_l_, 0);
     }
    }
    var _k_ = split(0, start, num);
    return caml_call1(Stdlib_List[9], _k_);
   }
   function split(expr, text){return bounded_split(expr, text, 0);}
   function bounded_split_delim(expr, text, num){
    function split(accu, start, n){
     if(caml_ml_string_length(text) < start) return accu;
     if(1 === n) return [0, string_after(text, start), accu];
     try{
      var
       pos = search_forward_progress(expr, text, start),
       _h_ = match_end(0),
       _i_ =
         split
          ([0,
            caml_call3(Stdlib_String[15], text, start, pos - start | 0),
            accu],
           _h_,
           n - 1 | 0);
      return _i_;
     }
     catch(_j_){
      var _g_ = caml_wrap_exception(_j_);
      if(_g_ === Stdlib[8]) return [0, string_after(text, start), accu];
      throw caml_maybe_attach_backtrace(_g_, 0);
     }
    }
    if(runtime.caml_string_equal(text, cst$1)) return 0;
    var _f_ = split(0, 0, num);
    return caml_call1(Stdlib_List[9], _f_);
   }
   function split_delim(expr, text){
    return bounded_split_delim(expr, text, 0);
   }
   function bounded_full_split(expr, text, num){
    function split(accu, start, n){
     if(caml_ml_string_length(text) <= start) return accu;
     if(1 === n) return [0, [0, string_after(text, start)], accu];
     try{
      var
       pos = search_forward_progress(expr, text, start),
       s = matched_string(text);
      if(start < pos)
       var
        _c_ = match_end(0),
        _d_ =
          split
           ([0,
             [1, s],
             [0,
              [0, caml_call3(Stdlib_String[15], text, start, pos - start | 0)],
              accu]],
            _c_,
            n - 1 | 0);
      else
       var _d_ = split([0, [1, s], accu], match_end(0), n - 1 | 0);
      return _d_;
     }
     catch(_e_){
      var _b_ = caml_wrap_exception(_e_);
      if(_b_ === Stdlib[8]) return [0, [0, string_after(text, start)], accu];
      throw caml_maybe_attach_backtrace(_b_, 0);
     }
    }
    var _a_ = split(0, 0, num);
    return caml_call1(Stdlib_List[9], _a_);
   }
   function full_split(expr, text){return bounded_full_split(expr, text, 0);}
   var
    Re_Str =
      [0,
       regexp,
       regexp_case_fold,
       quote,
       regexp_string,
       regexp_string_case_fold,
       string_match,
       search_forward,
       search_backward,
       string_partial_match,
       matched_string,
       match_beginning,
       match_end,
       matched_group,
       group_beginning,
       group_end,
       global_replace,
       replace_first,
       global_substitute,
       substitute_first,
       replace_matched,
       split,
       bounded_split,
       split_delim,
       bounded_split_delim,
       full_split,
       bounded_full_split,
       string_before,
       string_after,
       first_chars,
       last_chars];
   runtime.caml_register_global(14, Re_Str, "Re__Str");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Glob
//# unitInfo: Requires: Re__Core, Stdlib, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst = "",
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    beg = [0, cst, 0],
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib = global_data.Stdlib,
    Parse_error = [248, "Re__Glob.Parse_error", runtime.caml_fresh_oo_id(0)],
    _g_ = [0, 1],
    _f_ = [0, 1],
    _d_ = [0, 47, [0, 92, 0]],
    _e_ = [0, 47, 0],
    _b_ = [0, cst, 0],
    _c_ = [0, cst, 0],
    _a_ = [0, 45];
   function mul(l$0, l){
    function _ak_(s){
     function _am_(s$0){return caml_call2(Stdlib[28], s, s$0);}
     return caml_call2(Stdlib_List[19], _am_, l);
    }
    var _al_ = caml_call2(Stdlib_List[19], _ak_, l$0);
    return caml_call1(Stdlib_List[14], _al_);
   }
   function explicit_period(t){
    var _ag_ = t[7];
    if(_ag_){
     var _ah_ = t[3];
     if(_ah_)
      var _ai_ = _ah_;
     else
      var _aj_ = t[4], _ai_ = _aj_ ? t[5] : _aj_;
    }
    else
     var _ai_ = _ag_;
    return _ai_;
   }
   function slashes(t){return t[6] ? _d_ : _e_;}
   function append(opt, t, piece){
    if(opt)
     var sth = opt[1], am_at_start_of_component = sth;
    else
     var am_at_start_of_component = 0;
    return [0,
            [0, piece, t[1]],
            t[2],
            0,
            am_at_start_of_component,
            t[5],
            t[6],
            t[7]];
   }
   function next(t){
    var match = t[2];
    if(! match) return 0;
    var remaining = match[2], piece = match[1];
    return [0, [0, piece, [0, t[1], remaining, t[3], t[4], t[5], t[6], t[7]]]];
   }
   function one(explicit_slash, slashes, explicit_period){
    var
     _ab_ = 0,
     _ac_ = explicit_period ? [0, caml_call1(Re_Core[27], 46), 0] : 0,
     _ad_ = [0, _ac_, _ab_],
     _ae_ =
       explicit_slash ? caml_call2(Stdlib_List[19], Re_Core[27], slashes) : 0,
     _af_ = caml_call1(Stdlib_List[13], [0, _ae_, _ad_]);
    return caml_call1(Re_Core[61], _af_);
   }
   function enclosed(enclosed){
    if(0 === enclosed[0]){
     var c = enclosed[1];
     return caml_call1(Re_Core[27], c);
    }
    var high = enclosed[2], low = enclosed[1];
    return caml_call2(Re_Core[58], low, high);
   }
   function enclosed_set(explicit_slash, slashes, explicit_period, kind, set){
    var
     set$0 = caml_call2(Stdlib_List[19], enclosed, set),
     enclosure =
       596216810 <= kind
        ? caml_call1(Re_Core[28], set$0)
        : caml_call1(Re_Core[61], set$0),
     _aa_ =
       [0, enclosure, [0, one(explicit_slash, slashes, explicit_period), 0]];
    return caml_call1(Re_Core[59], _aa_);
   }
   function exactly(state, c){
    var
     slashes$0 = slashes(state),
     am_at_start_of_component = caml_call2(Stdlib_List[36], c, slashes$0),
     chars = am_at_start_of_component ? slashes$0 : [0, c, 0],
     _$_ = caml_call2(Stdlib_List[19], Re_Core[27], chars);
    return append
            ([0, am_at_start_of_component],
             state,
             caml_call1(Re_Core[28], _$_));
   }
   function many_many(state){
    var
     _P_ = state[7],
     explicit_period$0 = _P_ ? state[5] : _P_,
     first_explicit_period = explicit_period(state),
     slashes$0 = slashes(state);
    function match_component(explicit_period){
     var
      _Y_ = one(1, slashes$0, 0),
      _Z_ = [0, caml_call1(Re_Core[32], _Y_), 0],
      ___ = [0, one(1, slashes$0, explicit_period), _Z_];
     return caml_call1(Re_Core[29], ___);
    }
    var
     _Q_ = match_component(explicit_period$0),
     _R_ = [0, caml_call1(Re_Core[35], _Q_), 0],
     _S_ = caml_call2(Stdlib_List[19], Re_Core[27], slashes$0),
     _T_ = [0, caml_call1(Re_Core[28], _S_), _R_],
     _U_ = caml_call1(Re_Core[29], _T_),
     _V_ = [0, caml_call1(Re_Core[32], _U_), 0],
     _W_ = match_component(first_explicit_period),
     _X_ = [0, caml_call1(Re_Core[35], _W_), _V_];
    return append(0, state, caml_call1(Re_Core[29], _X_));
   }
   function glob(opt, _n_, _m_, _l_, _k_, _j_, str){
    if(opt) var sth = opt[1], anchored = sth; else var anchored = 0;
    if(_n_) var sth$0 = _n_[1], pathname = sth$0; else var pathname = 1;
    if(_m_)
     var sth$1 = _m_[1], match_backslashes = sth$1;
    else
     var match_backslashes = 0;
    if(_l_) var sth$2 = _l_[1], period = sth$2; else var period = 1;
    if(_k_)
     var sth$3 = _k_[1], expand_braces = sth$3;
    else
     var expand_braces = 0;
    if(_j_)
     var sth$4 = _j_[1], double_asterisk = sth$4;
    else
     var double_asterisk = 1;
    function to_re(s){
     var i = [0, 0], l = caml_ml_string_length(s);
     function eos(param){return i[1] === l ? 1 : 0;}
     function read(c){
      var
       _O_ = 1 - eos(0),
       r = _O_ ? caml_string_get(s, i[1]) === c ? 1 : 0 : _O_;
      if(r) i[1]++;
      return r;
     }
     function char$0(param){
      read(92);
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var r = caml_string_get(s, i[1]);
      i[1]++;
      return r;
     }
     function enclosed(param){
      var s = 0;
      for(;;){
       if(0 !== s && read(93)) return s;
       var c = char$0(0);
       if(read(45)){
        if(read(93)) return [0, [0, c], [0, _a_, s]];
        var c$0 = char$0(0), s$0 = [0, [1, c, c$0], s], s = s$0;
       }
       else
        var s$1 = [0, [0, c], s], s = s$1;
      }
     }
     var pieces = 0;
     for(;;){
      if(eos(0)) break;
      a:
      {
       if(double_asterisk){
        if(l <= (i[1] + 3 | 0))
         var _w_ = 0;
        else
         try{
          var j = 0;
          for(;;){
           var _t_ = 1 - eos(0);
           if(_t_)
            var
             _u_ = caml_string_get("/**", j),
             found = caml_string_get(s, i[1] + j | 0) === _u_ ? 1 : 0;
           else
            var found = _t_;
           if(1 - found) throw Stdlib[3];
           var _v_ = j + 1 | 0;
           if(2 === j) break;
           var j = _v_;
          }
          i[1] = i[1] + 3 | 0;
          var _s_ = 1, _w_ = _s_;
         }
         catch(_N_){
          var _r_ = caml_wrap_exception(_N_);
          if(_r_ !== Stdlib[3]) throw caml_maybe_attach_backtrace(_r_, 0);
          var _w_ = 0;
         }
        if(_w_ && ! eos(0)){var _x_ = 2; break a;}
       }
       if(read(42)){
        if(double_asterisk && read(42)){var _x_ = 2; break a;}
        var _x_ = 1;
       }
       else if(read(63))
        var _x_ = 0;
       else if(read(91)){
        if(! read(94) && ! read(33)){var _x_ = [1, enclosed(0)]; break a;}
        var _x_ = [2, enclosed(0)];
       }
       else
        var _x_ = [0, char$0(0)];
      }
      var pieces$0 = [0, _x_, pieces], pieces = pieces$0;
     }
     var
      remaining = caml_call1(Stdlib_List[9], pieces),
      state = [0, 0, remaining, 1, 1, pathname, match_backslashes, period],
      state$8 = state;
     for(;;){
      var match$1 = next(state$8);
      if(! match$1){
       var
        _y_ = caml_call1(Stdlib_List[9], state$8[1]),
        re = caml_call1(Re_Core[29], _y_);
       return anchored ? caml_call1(Re_Core[47], re) : re;
      }
      var
       match$2 = match$1[1],
       state$9 = match$2[2],
       piece = match$2[1],
       explicit_slash$0 = state$9[5],
       explicit_period$1 = explicit_period(state$9),
       slashes$1 = slashes(state$9);
      if(typeof piece === "number")
       switch(piece){
         case 0:
          var
           state$10 =
             append
              (0,
               state$9,
               one(explicit_slash$0, slashes$1, explicit_period$1));
          break;
         case 1:
          var
           explicit_slash = state$9[5],
           explicit_period$0 = explicit_period(state$9),
           slashes$0 = slashes(state$9);
          if(explicit_period$0)
           if(explicit_slash){
            var
             _z_ = one(1, slashes$0, 0),
             _A_ = [0, caml_call1(Re_Core[32], _z_), 0],
             _B_ = [0, one(1, slashes$0, 1), _A_],
             not_empty = caml_call1(Re_Core[29], _B_),
             maybe_empty = caml_call1(Re_Core[35], not_empty),
             enclosed_set$1 =
               function(slashes, not_empty){
                function enclosed_set$0(state, kind, set){
                 var
                  _K_ =
                    [0,
                     not_empty,
                     [0, enclosed_set(1, slashes, 0, kind, set), 0]],
                  _L_ = [0, caml_call1(Re_Core[29], _K_), 0],
                  _M_ = [0, enclosed_set(1, slashes, 1, kind, set), _L_];
                 return append(0, state, caml_call1(Re_Core[28], _M_));
                }
                return enclosed_set$0;
               },
             enclosed_set$0 = enclosed_set$1(slashes$0, not_empty);
            a:
            {
             b:
             {
              c:
              {
               d:
               {
                var state$0 = state$9;
                for(;;){
                 var match = next(state$0);
                 if(! match) break;
                 var _C_ = match[1], match$0 = _C_[1];
                 if(typeof match$0 !== "number") break d;
                 switch(match$0){
                   case 0:
                    break b;
                   case 1:
                    var state$2 = _C_[2], state$0 = state$2; break;
                   default: break c;
                 }
                }
                var _D_ = append(0, state$0, maybe_empty);
                break a;
               }
               switch(match$0[0]){
                 case 0:
                  var
                   state$4 = _C_[2],
                   c = match$0[1],
                   not_empty$0 = 46 === c ? not_empty : maybe_empty,
                   state$5 = append(0, state$4, not_empty$0),
                   _D_ = exactly(state$5, c);
                  break a;
                 case 1:
                  var
                   state$6 = _C_[2],
                   enclosed$0 = match$0[1],
                   _D_ = enclosed_set$0(state$6, 596216810, enclosed$0);
                  break a;
                 default:
                  var
                   state$7 = _C_[2],
                   enclosed$1 = match$0[1],
                   _D_ = enclosed_set$0(state$7, -188280562, enclosed$1);
                  break a;
               }
              }
              var state$3 = _C_[2], _D_ = many_many(state$3);
              break a;
             }
             var state$1 = _C_[2], _D_ = append(0, state$1, not_empty);
            }
            var _J_ = _D_;
           }
           else
            var
             _E_ = one(0, slashes$0, 0),
             _F_ = [0, caml_call1(Re_Core[32], _E_), 0],
             _G_ = [0, one(0, slashes$0, explicit_period$0), _F_],
             _H_ = caml_call1(Re_Core[29], _G_),
             _J_ = append(0, state$9, caml_call1(Re_Core[35], _H_));
          else
           var
            _I_ = one(explicit_slash, slashes$0, explicit_period$0),
            _J_ = append(0, state$9, caml_call1(Re_Core[32], _I_));
          var state$10 = _J_;
          break;
         default: var state$10 = many_many(state$9);
       }
      else
       switch(piece[0]){
         case 0:
          var c$0 = piece[1], state$10 = exactly(state$9, c$0); break;
         case 1:
          var
           enclosed$2 = piece[1],
           state$10 =
             append
              (0,
               state$9,
               enclosed_set
                (explicit_slash$0,
                 slashes$1,
                 explicit_period$1,
                 596216810,
                 enclosed$2));
          break;
         default:
          var
           enclosed$3 = piece[1],
           state$10 =
             append
              (0,
               state$9,
               enclosed_set
                (explicit_slash$0,
                 slashes$1,
                 explicit_period$1,
                 -188280562,
                 enclosed$3));
       }
      var state$8 = state$10;
     }
    }
    if(! expand_braces) return to_re(str);
    var l = caml_ml_string_length(str);
    function expl(inner, s, i, acc, beg$0){
     var s$0 = s, i$0 = i, acc$0 = acc, beg$1 = beg$0;
     for(;;){
      if(l <= i$0){
       if(inner) throw caml_maybe_attach_backtrace(Parse_error, 1);
       return [0,
               mul
                (beg$1,
                 [0,
                  caml_call3(Stdlib_String[15], str, s$0, i$0 - s$0 | 0),
                  0]),
               i$0];
      }
      var match = caml_string_get(str, i$0);
      if(44 === match){
       if(inner){
        var
         _p_ =
           mul
            (beg$1,
             [0, caml_call3(Stdlib_String[15], str, s$0, i$0 - s$0 | 0), 0]),
         acc$1 = caml_call2(Stdlib[37], _p_, acc$0),
         i$1 = i$0 + 1 | 0,
         s$1 = i$0 + 1 | 0,
         s$0 = s$1,
         i$0 = i$1,
         acc$0 = acc$1,
         beg$1 = beg;
        continue;
       }
      }
      else
       if(123 <= match){
        if(126 > match)
         switch(match - 123 | 0){
           case 0:
            var
             match$0 = expl(1, i$0 + 1 | 0, i$0 + 1 | 0, 0, _b_),
             i$3 = match$0[2],
             t = match$0[1],
             beg$2 =
               mul
                (beg$1,
                 mul
                  ([0,
                    caml_call3(Stdlib_String[15], str, s$0, i$0 - s$0 | 0),
                    0],
                   t)),
             s$0 = i$3,
             i$0 = i$3,
             beg$1 = beg$2;
            continue;
           case 1: break;
           default:
            if(inner){
             var
              _q_ =
                mul
                 (beg$1,
                  [0,
                   caml_call3(Stdlib_String[15], str, s$0, i$0 - s$0 | 0),
                   0]);
             return [0, caml_call2(Stdlib[37], _q_, acc$0), i$0 + 1 | 0];
            }
         }
       }
       else if(92 === match){var i$4 = i$0 + 2 | 0, i$0 = i$4; continue;}
      var i$2 = i$0 + 1 | 0, i$0 = i$2;
     }
    }
    var
     _h_ = expl(0, 0, 0, 0, _c_)[1],
     _i_ = caml_call1(Stdlib_List[9], _h_),
     _o_ = caml_call2(Stdlib_List[19], to_re, _i_);
    return caml_call1(Re_Core[28], _o_);
   }
   function glob$0(anchored, period, s){
    return glob(anchored, 0, 0, [0, period], 0, 0, s);
   }
   function globx(anchored, s){return glob(anchored, 0, 0, 0, _f_, 0, s);}
   function globx$0(anchored, period, s){
    return glob(anchored, 0, 0, [0, period], _g_, 0, s);
   }
   var Re_Glob = [0, Parse_error, glob, glob$0, globx, globx$0];
   runtime.caml_register_global(14, Re_Glob, "Re__Glob");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Perl
//# unitInfo: Requires: Re__Core, Stdlib, Stdlib__Buffer, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    cst_alnum = "alnum",
    cst_alpha = "alpha",
    cst_ascii = "ascii",
    cst_blank = "blank",
    cst_cntrl = "cntrl",
    cst_digit = "digit",
    cst_graph = "graph",
    cst_lower = "lower",
    cst_print = "print",
    cst_punct = "punct",
    cst_space = "space",
    cst_upper = "upper",
    cst_word = "word",
    cst_xdigit = "xdigit",
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_list_of_js_array = runtime.caml_list_of_js_array,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_string_get = runtime.caml_string_get,
    caml_string_notequal = runtime.caml_string_notequal,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    cst = ":]",
    posix_class_strings =
      caml_list_of_js_array
       ([cst_alpha,
         cst_alnum,
         cst_ascii,
         cst_blank,
         cst_cntrl,
         cst_digit,
         cst_lower,
         cst_print,
         cst_space,
         cst_upper,
         cst_word,
         cst_punct,
         cst_graph,
         cst_xdigit]),
    Stdlib_List = global_data.Stdlib__List,
    Re_Core = global_data.Re__Core,
    Stdlib = global_data.Stdlib,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Parse_error = [248, "Re__Perl.Parse_error", caml_fresh_oo_id(0)],
    Not_supported = [248, "Re__Perl.Not_supported", caml_fresh_oo_id(0)],
    _a_ = [0, 748194550, 8],
    _b_ = [0, 748194550, 10],
    _c_ = [0, 748194550, 13],
    _d_ = [0, 748194550, 9],
    cst_Invalid_pcre_class = "Invalid pcre class: ";
   function re(opt, s){
    if(opt) var sth = opt[1], opts = sth; else var opts = 0;
    var
     ungreedy = caml_call2(Stdlib_List[37], -243745063, opts),
     dotall = caml_call2(Stdlib_List[37], -424303016, opts),
     dollar_endonly = caml_call2(Stdlib_List[37], -712595228, opts),
     multiline = caml_call2(Stdlib_List[37], 1071952589, opts),
     i = [0, 0],
     l = caml_ml_string_length(s);
    function eos(param){return i[1] === l ? 1 : 0;}
    function test(c){
     var
      _D_ = 1 - eos(0),
      _E_ = _D_ ? caml_string_get(s, i[1]) === c ? 1 : 0 : _D_;
     return _E_;
    }
    function accept(c){var r = test(c); if(r) i[1]++; return r;}
    function accept_s(s$0){
     var len = caml_ml_string_length(s$0);
     try{
      var _x_ = len - 1 | 0, _w_ = 0;
      if(_x_ >= 0){
       var j = _w_;
       for(;;){
        try{
         var _z_ = caml_string_get(s, i[1] + j | 0);
         if(caml_string_get(s$0, j) !== _z_)
          throw caml_maybe_attach_backtrace(Stdlib[3], 1);
        }
        catch(_C_){throw caml_maybe_attach_backtrace(Stdlib[3], 1);}
        var _A_ = j + 1 | 0;
        if(_x_ === j) break;
        var j = _A_;
       }
      }
      i[1] = i[1] + len | 0;
      var _y_ = 1;
      return _y_;
     }
     catch(_B_){
      var _v_ = caml_wrap_exception(_B_);
      if(_v_ === Stdlib[3]) return 0;
      throw caml_maybe_attach_backtrace(_v_, 0);
     }
    }
    function get(param){var r = caml_string_get(s, i[1]); i[1]++; return r;}
    function unget(param){i[1] += -1; return;}
    function greedy_mod(r){
     var gr = accept(63), gr$0 = ungreedy ? 1 - gr : gr;
     return gr$0 ? caml_call1(Re_Core[52], r) : caml_call1(Re_Core[51], r);
    }
    function regexp(param){
     var left = branch(0), left$0 = left;
     for(;;){
      if(! accept(124)) return left$0;
      var
       _u_ = [0, left$0, [0, branch(0), 0]],
       left$1 = caml_call1(Re_Core[28], _u_),
       left$0 = left$1;
     }
    }
    function branch(param){
     var left = 0;
     for(;;){
      if(! eos(0) && ! test(124) && ! test(41)){
       var r = atom(0);
       if(accept(42))
        var _t_ = greedy_mod(caml_call1(Re_Core[32], r));
       else if(accept(43))
        var _t_ = greedy_mod(caml_call1(Re_Core[33], r));
       else if(accept(63))
        var _t_ = greedy_mod(caml_call1(Re_Core[35], r));
       else if(accept(123)){
        var match = integer(0);
        if(match){
         var i = match[1], j = accept(44) ? integer(0) : [0, i];
         if(1 - accept(125))
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         if(j){
          var j$0 = j[1];
          if(j$0 < i) throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         var _t_ = greedy_mod(caml_call3(Re_Core[34], r, i, j));
        }
        else{unget(0); var _t_ = r;}
       }
       else
        var _t_ = r;
       var left$0 = [0, _t_, left], left = left$0;
       continue;
      }
      var _s_ = caml_call1(Stdlib_List[9], left);
      return caml_call1(Re_Core[29], _s_);
     }
    }
    function atom(param){
     if(accept(46)) return dotall ? Re_Core[62] : Re_Core[63];
     if(! accept(40)){
      if(accept(94)) return multiline ? Re_Core[36] : Re_Core[40];
      if(accept(36))
       return multiline
               ? Re_Core[37]
               : dollar_endonly ? Re_Core[42] : Re_Core[41];
      if(accept(91)){
       if(accept(94)){
        var _l_ = bracket(0);
        return caml_call1(Re_Core[61], _l_);
       }
       var _m_ = bracket(0);
       return caml_call1(Re_Core[28], _m_);
      }
      if(accept(92)){
       if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
       var c = get(0), switcher = c - 48 | 0;
       if(74 >= switcher >>> 0)
        switch(switcher){
          case 17:
           return Re_Core[40];
          case 18:
           return Re_Core[46];
          case 20:
           return caml_call1(Re_Core[61], [0, Re_Core[70], 0]);
          case 23:
           return Re_Core[43];
          case 35:
           return caml_call1(Re_Core[61], [0, Re_Core[75], 0]);
          case 39:
           var _n_ = [0, caml_call1(Re_Core[27], 95), 0];
           return caml_call1(Re_Core[61], [0, Re_Core[64], _n_]);
          case 42:
           return Re_Core[42];
          case 50:
           return caml_call1
                   (Re_Core[28], [0, Re_Core[38], [0, Re_Core[39], 0]]);
          case 52:
           return Re_Core[70];
          case 53:
           return caml_call1(Re_Core[27], 27);
          case 54:
           return caml_call1(Re_Core[27], 12);
          case 62:
           return caml_call1(Re_Core[27], 10);
          case 66:
           return caml_call1(Re_Core[27], 13);
          case 67:
           return Re_Core[75];
          case 68:
           return caml_call1(Re_Core[27], 9);
          case 71:
           var _o_ = [0, caml_call1(Re_Core[27], 95), 0];
           return caml_call1(Re_Core[28], [0, Re_Core[64], _o_]);
          case 72:
           var
            c1 = hexdigit(0),
            c2 = hexdigit(0),
            code = (c1 * 16 | 0) + c2 | 0,
            _p_ = caml_call1(Stdlib[29], code);
           return caml_call1(Re_Core[27], _p_);
          case 74:
           return Re_Core[41];
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 7:
          case 8:
          case 9:
           throw caml_maybe_attach_backtrace(Not_supported, 1);
          case 10:
          case 11:
          case 12:
          case 13:
          case 14:
          case 15:
          case 16:
          case 43:
          case 44:
          case 45:
          case 46:
          case 47:
          case 48: break;
          default: throw caml_maybe_attach_backtrace(Parse_error, 1);
        }
       return caml_call1(Re_Core[27], c);
      }
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var c$0 = get(0);
      a:
      {
       if(64 <= c$0){
        if(92 === c$0 || 123 === c$0) break a;
       }
       else
        if(44 <= c$0){if(63 <= c$0) break a;} else if(42 <= c$0) break a;
       return caml_call1(Re_Core[27], c$0);
      }
      throw caml_maybe_attach_backtrace(Parse_error, 1);
     }
     if(! accept(63)){
      var r$1 = regexp(0);
      if(1 - accept(41)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      return caml_call2(Re_Core[53], 0, r$1);
     }
     if(accept(58)){
      var r = regexp(0);
      if(1 - accept(41)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      return r;
     }
     if(! accept(35)){
      if(! accept(60)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var c$1 = get(0), _q_ = c$1 - 91 | 0;
      a:
      {
       if(5 < _q_ >>> 0){
        if(57 < _q_ + 26 >>> 0) break a;
       }
       else if(4 !== _q_) break a;
       var b = caml_call1(Stdlib_Buffer[1], 32);
       caml_call2(Stdlib_Buffer[12], b, c$1);
       for(;;){
        if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
        var c$2 = get(0);
        b:
        {
         if(65 <= c$2){
          var _r_ = c$2 - 91 | 0;
          if(5 < _r_ >>> 0){
           if(32 <= _r_) break b;
          }
          else if(4 !== _r_) break b;
         }
         else{
          if(58 <= c$2){
           if(62 !== c$2) break b;
           var name = caml_call1(Stdlib_Buffer[2], b), r$0 = regexp(0);
           if(1 - accept(41))
            throw caml_maybe_attach_backtrace(Parse_error, 1);
           return caml_call2(Re_Core[53], [0, name], r$0);
          }
          if(48 > c$2) break b;
         }
         caml_call2(Stdlib_Buffer[12], b, c$2);
         continue;
        }
        throw caml_maybe_attach_backtrace(Parse_error, 1);
       }
      }
      throw caml_maybe_attach_backtrace(Parse_error, 1);
     }
     for(;;){
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      if(accept(41)) return Re_Core[31];
      i[1]++;
     }
    }
    function hexdigit(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var d = get(0);
     if(65 <= d){
      if(97 <= d){
       if(103 > d) return (d - 97 | 0) + 10 | 0;
      }
      else if(71 > d) return (d - 65 | 0) + 10 | 0;
     }
     else if(9 >= d - 48 >>> 0) return d - 48 | 0;
     throw caml_maybe_attach_backtrace(Parse_error, 1);
    }
    function integer(param){
     if(eos(0)) return 0;
     var d = get(0);
     if(9 < d - 48 >>> 0){unget(0); return 0;}
     var i = d - 48 | 0, i$0 = i;
     for(;;){
      if(eos(0)) return [0, i$0];
      var d$0 = get(0);
      if(9 < d$0 - 48 >>> 0){unget(0); return [0, i$0];}
      var i$1 = (10 * i$0 | 0) + (d$0 - 48 | 0) | 0;
      if(i$1 < i$0) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var i$0 = i$1;
     }
    }
    function bracket(s){
     var s$0 = s;
     for(;;){
      if(0 !== s$0 && accept(93)) return s$0;
      var match = char$0(0);
      if(748194550 <= match[1]){
       var c = match[2];
       if(accept(45)){
        if(accept(93)){
         var _j_ = [0, caml_call1(Re_Core[27], 45), s$0];
         return [0, caml_call1(Re_Core[27], c), _j_];
        }
        var match$0 = char$0(0);
        if(748194550 <= match$0[1])
         var
          c$0 = match$0[2],
          s$1 = [0, caml_call2(Re_Core[58], c, c$0), s$0],
          s$0 = s$1;
        else
         var
          st = match$0[2],
          _k_ = [0, caml_call1(Re_Core[27], 45), [0, st, s$0]],
          s$2 = [0, caml_call1(Re_Core[27], c), _k_],
          s$0 = s$2;
       }
       else
        var s$3 = [0, caml_call1(Re_Core[27], c), s$0], s$0 = s$3;
      }
      else
       var st$0 = match[2], s$4 = [0, st$0, s$0], s$0 = s$4;
     }
    }
    function char$0(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c = get(0);
     if(91 !== c){
      if(92 !== c) return [0, 748194550, c];
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var c$1 = get(0);
      if(58 <= c$1){
       if(123 > c$1)
        switch(c$1 - 58 | 0){
          case 10:
           return [0, 4150146, caml_call1(Re_Core[61], [0, Re_Core[70], 0])];
          case 25:
           return [0, 4150146, caml_call1(Re_Core[61], [0, Re_Core[75], 0])];
          case 29:
           var _g_ = [0, caml_call1(Re_Core[27], 95), 0];
           return [0, 4150146, caml_call1(Re_Core[61], [0, Re_Core[64], _g_])];
          case 40:
           return _a_;
          case 42:
           return [0, 4150146, Re_Core[70]];
          case 52:
           return _b_;
          case 56:
           return _c_;
          case 57:
           return [0, 4150146, Re_Core[75]];
          case 58:
           return _d_;
          case 61:
           var _h_ = [0, caml_call1(Re_Core[27], 95), 0];
           return [0, 4150146, caml_call1(Re_Core[28], [0, Re_Core[64], _h_])];
          case 0:
          case 1:
          case 2:
          case 3:
          case 4:
          case 5:
          case 6:
          case 33:
          case 34:
          case 35:
          case 36:
          case 37:
          case 38: break;
          default: throw caml_maybe_attach_backtrace(Parse_error, 1);
        }
      }
      else if(48 <= c$1) throw caml_maybe_attach_backtrace(Not_supported, 1);
      return [0, 748194550, c$1];
     }
     if(accept(61)) throw caml_maybe_attach_backtrace(Not_supported, 1);
     if(! accept(58)){
      if(! accept(46)) return [0, 748194550, c];
      if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var c$0 = get(0);
      if(1 - accept(46)) throw caml_maybe_attach_backtrace(Not_supported, 1);
      if(1 - accept(93)) throw caml_maybe_attach_backtrace(Parse_error, 1);
      return [0, 748194550, c$0];
     }
     var compl = accept(94);
     try{
      var
       class$0 = caml_call2(Stdlib_List[38], accept_s, posix_class_strings);
     }
     catch(_i_){
      var _f_ = caml_wrap_exception(_i_);
      if(_f_ === Stdlib[8]) throw caml_maybe_attach_backtrace(Parse_error, 1);
      throw caml_maybe_attach_backtrace(_f_, 0);
     }
     if(1 - accept_s(cst)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var switch$0 = runtime.caml_string_compare(class$0, cst_lower);
     a:
     {
      if(0 <= switch$0){
       if(0 >= switch$0){var posix_class = Re_Core[72]; break a;}
       if(! caml_string_notequal(class$0, cst_print)){var posix_class = Re_Core[73]; break a;}
       if(! caml_string_notequal(class$0, cst_punct)){var posix_class = Re_Core[74]; break a;}
       if(! caml_string_notequal(class$0, cst_space)){var posix_class = Re_Core[75]; break a;}
       if(! caml_string_notequal(class$0, cst_upper)){var posix_class = Re_Core[76]; break a;}
       if(! caml_string_notequal(class$0, cst_word)){var posix_class = Re_Core[65]; break a;}
       if(! caml_string_notequal(class$0, cst_xdigit)){var posix_class = Re_Core[77]; break a;}
      }
      else{
       if(! caml_string_notequal(class$0, cst_alnum)){var posix_class = Re_Core[64]; break a;}
       if(! caml_string_notequal(class$0, cst_alpha)){var posix_class = Re_Core[66]; break a;}
       if(! caml_string_notequal(class$0, cst_ascii)){var posix_class = Re_Core[67]; break a;}
       if(! caml_string_notequal(class$0, cst_blank)){var posix_class = Re_Core[68]; break a;}
       if(! caml_string_notequal(class$0, cst_cntrl)){var posix_class = Re_Core[69]; break a;}
       if(! caml_string_notequal(class$0, cst_digit)){var posix_class = Re_Core[70]; break a;}
       if(! caml_string_notequal(class$0, cst_graph)){var posix_class = Re_Core[71]; break a;}
      }
      var
       _e_ = caml_call2(Stdlib[28], cst_Invalid_pcre_class, class$0),
       posix_class = caml_call1(Stdlib[1], _e_);
     }
     var
      re = compl ? caml_call1(Re_Core[61], [0, posix_class, 0]) : posix_class;
     return [0, 4150146, re];
    }
    var res = regexp(0);
    if(1 - eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
    var
     r =
       caml_call2(Stdlib_List[37], 616470068, opts)
        ? caml_call1(Re_Core[29], [0, Re_Core[43], [0, res, 0]])
        : res,
     r$0 =
       caml_call2(Stdlib_List[37], 604571177, opts)
        ? caml_call1(Re_Core[79], r)
        : r;
    return r$0;
   }
   var compile = Re_Core[2];
   function compile_pat(opt, s){
    if(opt) var sth = opt[1], opts = sth; else var opts = 0;
    return caml_call1(compile, re([0, opts], s));
   }
   var Re_Perl = [0, Parse_error, Not_supported, re, compile, compile_pat];
   runtime.caml_register_global(27, Re_Perl, "Re__Perl");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Pcre
//# unitInfo: Requires: Re__Core, Re__Perl, Stdlib, Stdlib__Array, Stdlib__Buffer, Stdlib__Bytes, Stdlib__List, Stdlib__String
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_bytes_unsafe_set = runtime.caml_bytes_unsafe_set,
    caml_create_bytes = runtime.caml_create_bytes,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_ml_string_length = runtime.caml_ml_string_length,
    caml_wrap_exception = runtime.caml_wrap_exception;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   function caml_call4(f, a0, a1, a2, a3){
    return (f.l >= 0 ? f.l : f.l = f.length) == 4
            ? f(a0, a1, a2, a3)
            : runtime.caml_call_gen(f, [a0, a1, a2, a3]);
   }
   var
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Stdlib_Bytes = global_data.Stdlib__Bytes,
    Stdlib_String = global_data.Stdlib__String,
    Stdlib_Buffer = global_data.Stdlib__Buffer,
    Stdlib = global_data.Stdlib,
    Stdlib_Array = global_data.Stdlib__Array,
    Re_Perl = global_data.Re__Perl,
    Parse_error = Re_Perl[1],
    Not_supported = Re_Perl[2],
    _a_ = [0, -1, -1];
   function re(opt, pat){
    if(opt) var sth = opt[1], flags = sth; else var flags = 0;
    function _v_(param){
     return 601676297 <= param
             ? 613575188 <= param ? 616470068 : 604571177
             : 426394317 <= param ? 1071952589 : -424303016;
    }
    var opts = caml_call2(Stdlib_List[19], _v_, flags);
    return caml_call2(Re_Perl[3], [0, opts], pat);
   }
   function regexp(flags, pat){
    var _u_ = re(flags, pat);
    return caml_call1(Re_Core[2], _u_);
   }
   function extract(rex, s){
    var _t_ = caml_call4(Re_Core[5], 0, 0, rex, s);
    return caml_call1(Re_Core[1][6], _t_);
   }
   function exec(rex, pos, s){return caml_call4(Re_Core[5], pos, 0, rex, s);}
   function get_substring(s, i){return caml_call2(Re_Core[1][1], s, i);}
   function names(rex){
    var _p_ = caml_call1(Re_Core[4], rex);
    function _q_(_s_){return _s_[1];}
    var _r_ = caml_call1(caml_call1(Stdlib_List[19], _q_), _p_);
    return caml_call1(Stdlib_Array[12], _r_);
   }
   function get_named_substring(rex, name, s){
    var param = caml_call1(Re_Core[4], rex);
    for(;;){
     if(! param) throw caml_maybe_attach_backtrace(Stdlib[8], 1);
     var match = param[1], rem = param[2], i = match[2], n = match[1];
     if(runtime.caml_string_equal(n, name))
      try{var _n_ = get_substring(s, i); return _n_;}
      catch(_o_){
       var _m_ = caml_wrap_exception(_o_);
       if(_m_ !== Stdlib[8]) throw caml_maybe_attach_backtrace(_m_, 0);
       var param = rem;
      }
     else
      var rem$0 = param[2], param = rem$0;
    }
   }
   function get_substring_ofs(s, i){return caml_call2(Re_Core[1][3], s, i);}
   function pmatch(rex, s){return caml_call4(Re_Core[7], 0, 0, rex, s);}
   function substitute(rex, subst, str){
    var b = caml_call1(Stdlib_Buffer[1], 1024), pos = 0;
    for(;;){
     if(caml_ml_string_length(str) <= pos)
      return caml_call1(Stdlib_Buffer[2], b);
     if(caml_call4(Re_Core[7], [0, pos], 0, rex, str)){
      var
       ss = caml_call4(Re_Core[5], [0, pos], 0, rex, str),
       match = caml_call2(Re_Core[1][3], ss, 0),
       fin = match[2],
       start = match[1],
       pat = caml_call2(Re_Core[1][1], ss, 0);
      caml_call4(Stdlib_Buffer[18], b, str, pos, start - pos | 0);
      var _l_ = caml_call1(subst, pat);
      caml_call2(Stdlib_Buffer[16], b, _l_);
      var pos = fin;
     }
     else{
      caml_call4
       (Stdlib_Buffer[18], b, str, pos, caml_ml_string_length(str) - pos | 0);
      var pos$0 = caml_ml_string_length(str), pos = pos$0;
     }
    }
   }
   function split(rex, str){
    var accu = 0, pos = 0;
    for(;;){
     if(caml_ml_string_length(str) <= pos)
      return caml_call1(Stdlib_List[9], accu);
     if(caml_call4(Re_Core[7], [0, pos], 0, rex, str))
      var
       ss = caml_call4(Re_Core[5], [0, pos], 0, rex, str),
       match = caml_call2(Re_Core[1][3], ss, 0),
       fin = match[2],
       start = match[1],
       s = caml_call3(Stdlib_String[15], str, pos, start - pos | 0),
       accu$0 = [0, s, accu],
       accu = accu$0,
       pos = fin;
     else
      var
       s$0 =
         caml_call3
          (Stdlib_String[15], str, pos, caml_ml_string_length(str) - pos | 0),
       pos$0 = caml_ml_string_length(str),
       accu$1 = [0, s$0, accu],
       accu = accu$1,
       pos = pos$0;
    }
   }
   function quote(s){
    var
     len = caml_ml_string_length(s),
     buf = caml_create_bytes(len << 1),
     pos = [0, 0],
     _i_ = len - 1 | 0,
     _h_ = 0;
    if(_i_ >= 0){
     var i = _h_;
     for(;;){
      var c = runtime.caml_string_unsafe_get(s, i);
      a:
      {
       b:
       {
        if(91 <= c){
         var _j_ = c - 93 | 0;
         if(29 < _j_ >>> 0){
          if(32 <= _j_) break b;
         }
         else if(1 !== _j_) break b;
        }
        else
         if(47 <= c){
          if(63 !== c) break b;
         }
         else{
          if(36 > c) break b;
          switch(c - 36 | 0){case 1:case 2:case 3:case 8:case 9: break b;
          }
         }
        caml_bytes_unsafe_set(buf, pos[1], 92);
        pos[1]++;
        caml_bytes_unsafe_set(buf, pos[1], c);
        pos[1]++;
        break a;
       }
       caml_bytes_unsafe_set(buf, pos[1], c);
       pos[1]++;
      }
      var _k_ = i + 1 | 0;
      if(_i_ === i) break;
      var i = _k_;
     }
    }
    var len$0 = pos[1], r = caml_create_bytes(len$0);
    runtime.caml_blit_bytes(buf, 0, r, 0, len$0);
    return caml_call1(Stdlib_Bytes[48], r);
   }
   function full_split(opt, rex, s){
    if(opt) var sth = opt[1], max = sth; else var max = 0;
    if(0 === caml_ml_string_length(s)) return 0;
    if(1 === max) return [0, [0, s], 0];
    var results = caml_call4(Re_Core[20], 0, 0, rex, s);
    function _b_(param){
     if(936573133 <= param[1]){var s = param[2]; return [0, [0, s], 0];}
     var
      d = param[2],
      matches = caml_call1(Re_Core[1][7], d),
      delim = caml_call2(Re_Core[1][1], d, 0),
      l = [0, 0],
      _d_ = matches.length - 1 - 1 | 0,
      _c_ = 1;
     if(_d_ >= 1){
      var i = _c_;
      for(;;){
       var
        _e_ = l[1],
        _f_ =
          runtime.caml_equal(runtime.caml_check_bound(matches, i)[1 + i], _a_)
           ? 0
           : [2, i, caml_call2(Re_Core[1][1], d, i)];
       l[1] = [0, _f_, _e_];
       var _g_ = i + 1 | 0;
       if(_d_ === i) break;
       var i = _g_;
      }
     }
     return [0, [1, delim], caml_call1(Stdlib_List[9], l[1])];
    }
    var matches = caml_call2(Stdlib_List[19], _b_, results);
    return caml_call1(Stdlib_List[13], matches);
   }
   var
    Re_Pcre =
      [0,
       Parse_error,
       Not_supported,
       re,
       regexp,
       extract,
       exec,
       get_substring,
       names,
       get_named_substring,
       get_substring_ofs,
       pmatch,
       substitute,
       full_split,
       split,
       quote];
   runtime.caml_register_global(9, Re_Pcre, "Re__Pcre");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re__Posix
//# unitInfo: Requires: Re__Core, Stdlib__List
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    caml_fresh_oo_id = runtime.caml_fresh_oo_id,
    caml_maybe_attach_backtrace = runtime.caml_maybe_attach_backtrace,
    caml_string_get = runtime.caml_string_get;
   function caml_call1(f, a0){
    return (f.l >= 0 ? f.l : f.l = f.length) == 1
            ? f(a0)
            : runtime.caml_call_gen(f, [a0]);
   }
   function caml_call2(f, a0, a1){
    return (f.l >= 0 ? f.l : f.l = f.length) == 2
            ? f(a0, a1)
            : runtime.caml_call_gen(f, [a0, a1]);
   }
   function caml_call3(f, a0, a1, a2){
    return (f.l >= 0 ? f.l : f.l = f.length) == 3
            ? f(a0, a1, a2)
            : runtime.caml_call_gen(f, [a0, a1, a2]);
   }
   var
    undef = undefined,
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Stdlib_List = global_data.Stdlib__List,
    Parse_error = [248, "Re__Posix.Parse_error", caml_fresh_oo_id(0)],
    Not_supported = [248, "Re__Posix.Not_supported", caml_fresh_oo_id(0)];
   function re(opt, s){
    if(opt) var sth = opt[1], opts = sth; else var opts = 0;
    var
     newline = caml_call2(Stdlib_List[37], -638074828, opts),
     i = [0, 0],
     l = runtime.caml_ml_string_length(s);
    function eos(param){return i[1] === l ? 1 : 0;}
    function test(c){
     var
      _n_ = 1 - eos(0),
      _o_ = _n_ ? caml_string_get(s, i[1]) === c ? 1 : 0 : _n_;
     return _o_;
    }
    function accept(c){var r = test(c); if(r) i[1]++; return r;}
    function get(param){var r = caml_string_get(s, i[1]); i[1]++; return r;}
    function unget(param){i[1] += -1; return;}
    function regexp(param){
     var left = branch(0), left$0 = left;
     for(;;){
      if(! accept(124)) return left$0;
      var
       _m_ = [0, left$0, [0, branch(0), 0]],
       left$1 = caml_call1(Re_Core[28], _m_),
       left$0 = left$1;
     }
    }
    function branch(param){
     var left = 0;
     for(;;){
      if(! eos(0) && ! test(124) && ! test(41)){
       a:
       if(accept(46))
        var r = newline ? Re_Core[63] : Re_Core[62];
       else if(accept(40)){
        var r$0 = regexp(0);
        if(1 - accept(41)) throw caml_maybe_attach_backtrace(Parse_error, 1);
        var r = caml_call2(Re_Core[53], 0, r$0);
       }
       else if(accept(94))
        var r = newline ? Re_Core[36] : Re_Core[40];
       else if(accept(36))
        var r = newline ? Re_Core[37] : Re_Core[41];
       else{
        if(! accept(91)){
         if(! accept(92)){
          if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
          var c$0 = get(0);
          b:
          {
           if(64 <= c$0){
            if(92 === c$0 || 123 === c$0) break b;
           }
           else
            if(44 <= c$0){if(63 <= c$0) break b;} else if(42 <= c$0) break b;
           var r = caml_call1(Re_Core[27], c$0);
           break a;
          }
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
         var c = get(0);
         b:
         {
          if(91 <= c){
           var _l_ = c - 93 | 0;
           if(29 < _l_ >>> 0){
            if(32 <= _l_) break b;
           }
           else if(1 !== _l_) break b;
          }
          else
           if(47 <= c){
            if(63 !== c) break b;
           }
           else{
            if(36 > c) break b;
            switch(c - 36 | 0){case 1:case 2:case 3:case 8:case 9: break b;
            }
           }
          var r = caml_call1(Re_Core[27], c);
          break a;
         }
         throw caml_maybe_attach_backtrace(Parse_error, 1);
        }
        if(accept(94))
         var
          _h_ = caml_call1(Re_Core[27], 10),
          _i_ = bracket(0),
          _j_ = caml_call1(Re_Core[61], _i_),
          r = caml_call2(Re_Core[60], _j_, _h_);
        else
         var _k_ = bracket(0), r = caml_call1(Re_Core[28], _k_);
       }
       if(accept(42))
        var
         _e_ = caml_call1(Re_Core[55], r),
         _d_ = caml_call1(Re_Core[32], _e_);
       else if(accept(43))
        var
         _f_ = caml_call1(Re_Core[55], r),
         _d_ = caml_call1(Re_Core[33], _f_);
       else if(accept(63))
        var _d_ = caml_call1(Re_Core[35], r);
       else if(accept(123)){
        var match = integer(0);
        if(match){
         var i = match[1], j = accept(44) ? integer(0) : [0, i];
         if(1 - accept(125))
          throw caml_maybe_attach_backtrace(Parse_error, 1);
         if(j){
          var j$0 = j[1];
          if(j$0 < i) throw caml_maybe_attach_backtrace(Parse_error, 1);
         }
         var
          _g_ = caml_call1(Re_Core[55], r),
          _d_ = caml_call3(Re_Core[34], _g_, i, j);
        }
        else{unget(0); var _d_ = r;}
       }
       else
        var _d_ = r;
       var left$0 = [0, _d_, left], left = left$0;
       continue;
      }
      var _c_ = caml_call1(Stdlib_List[9], left);
      return caml_call1(Re_Core[29], _c_);
     }
    }
    function integer(param){
     if(eos(0)) return 0;
     var d = get(0);
     if(9 < d - 48 >>> 0){unget(0); return 0;}
     var i = d - 48 | 0, i$0 = i;
     for(;;){
      if(eos(0)) return [0, i$0];
      var d$0 = get(0);
      if(9 < d$0 - 48 >>> 0){unget(0); return [0, i$0];}
      var i$1 = (10 * i$0 | 0) + (d$0 - 48 | 0) | 0;
      if(i$1 < i$0) throw caml_maybe_attach_backtrace(Parse_error, 1);
      var i$0 = i$1;
     }
    }
    function bracket(s){
     var s$0 = s;
     for(;;){
      if(0 !== s$0 && accept(93)) return s$0;
      var c = char$0(0);
      if(accept(45)){
       if(accept(93)){
        var _b_ = [0, caml_call1(Re_Core[27], 45), s$0];
        return [0, caml_call1(Re_Core[27], c), _b_];
       }
       var
        c$0 = char$0(0),
        s$1 = [0, caml_call2(Re_Core[58], c, c$0), s$0],
        s$0 = s$1;
      }
      else
       var s$2 = [0, caml_call1(Re_Core[27], c), s$0], s$0 = s$2;
     }
    }
    function char$0(param){
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c = get(0);
     if(91 !== c) return c;
     if(accept(61)) throw caml_maybe_attach_backtrace(Not_supported, 1);
     if(accept(58)) throw caml_maybe_attach_backtrace(Not_supported, 1);
     if(! accept(46)) return c;
     if(eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     var c$0 = get(0);
     if(1 - accept(46)) throw caml_maybe_attach_backtrace(Not_supported, 1);
     if(1 - accept(93)) throw caml_maybe_attach_backtrace(Parse_error, 1);
     return c$0;
    }
    var res = regexp(0);
    if(1 - eos(0)) throw caml_maybe_attach_backtrace(Parse_error, 1);
    var
     r =
       caml_call2(Stdlib_List[37], 886285209, opts)
        ? caml_call1(Re_Core[79], res)
        : res,
     r$0 =
       caml_call2(Stdlib_List[37], 853495711, opts)
        ? caml_call1(Re_Core[54], r)
        : r;
    return r$0;
   }
   function compile(re){
    var _a_ = caml_call1(Re_Core[48], re);
    return caml_call1(Re_Core[2], _a_);
   }
   function compile_pat(opt, s){
    if(opt) var sth = opt[1], opts = sth; else var opts = 0;
    return compile(re([0, opts], s));
   }
   var Re_Posix = [0, Parse_error, Not_supported, re, compile, compile_pat];
   runtime.caml_register_global(4, Re_Posix, "Re__Posix");
   return;
  }
  (globalThis));

//# unitInfo: Provides: Re
//# unitInfo: Requires: Re__Core
(function
  (globalThis){
   "use strict";
   var
    runtime = globalThis.jsoo_runtime,
    global_data = runtime.caml_get_global_data(),
    Re_Core = global_data.Re__Core,
    Group = Re_Core[1],
    compile = Re_Core[2],
    group_count = Re_Core[3],
    group_names = Re_Core[4],
    exec = Re_Core[5],
    exec_opt = Re_Core[6],
    execp = Re_Core[7],
    exec_partial = Re_Core[8],
    exec_partial_detailed = Re_Core[9],
    Mark = Re_Core[10],
    all = Re_Core[11],
    all_gen = Re_Core[12],
    all_seq = Re_Core[13],
    matches = Re_Core[14],
    matches_gen = Re_Core[15],
    matches_seq = Re_Core[16],
    split = Re_Core[17],
    split_gen = Re_Core[18],
    split_seq = Re_Core[19],
    split_full = Re_Core[20],
    split_full_gen = Re_Core[21],
    split_full_seq = Re_Core[22],
    Seq = Re_Core[23],
    replace = Re_Core[24],
    replace_string = Re_Core[25],
    str = Re_Core[26],
    char$0 = Re_Core[27],
    alt = Re_Core[28],
    seq = Re_Core[29],
    empty = Re_Core[30],
    epsilon = Re_Core[31],
    rep = Re_Core[32],
    rep1 = Re_Core[33],
    repn = Re_Core[34],
    opt = Re_Core[35],
    bol = Re_Core[36],
    eol = Re_Core[37],
    bow = Re_Core[38],
    eow = Re_Core[39],
    bos = Re_Core[40],
    eos = Re_Core[41],
    leol = Re_Core[42],
    start = Re_Core[43],
    stop = Re_Core[44],
    word = Re_Core[45],
    not_boundary = Re_Core[46],
    whole_string = Re_Core[47],
    longest = Re_Core[48],
    shortest = Re_Core[49],
    first = Re_Core[50],
    greedy = Re_Core[51],
    non_greedy = Re_Core[52],
    group = Re_Core[53],
    no_group = Re_Core[54],
    nest = Re_Core[55],
    mark = Re_Core[56],
    set = Re_Core[57],
    rg = Re_Core[58],
    inter = Re_Core[59],
    diff = Re_Core[60],
    compl = Re_Core[61],
    any = Re_Core[62],
    notnl = Re_Core[63],
    alnum = Re_Core[64],
    wordc = Re_Core[65],
    alpha = Re_Core[66],
    ascii = Re_Core[67],
    blank = Re_Core[68],
    cntrl = Re_Core[69],
    digit = Re_Core[70],
    graph = Re_Core[71],
    lower = Re_Core[72],
    print = Re_Core[73],
    punct = Re_Core[74],
    space = Re_Core[75],
    upper = Re_Core[76],
    xdigit = Re_Core[77],
    case$0 = Re_Core[78],
    no_case = Re_Core[79],
    pp = Re_Core[80],
    pp_re = Re_Core[81],
    print_re = Re_Core[82],
    View = Re_Core[83],
    witness = Re_Core[84],
    get = Re_Core[85],
    get_ofs = Re_Core[86],
    get_all = Re_Core[87],
    get_all_ofs = Re_Core[88],
    test = Re_Core[89],
    marked = Re_Core[90],
    mark_set = Re_Core[91],
    Re =
      [0,
       Group,
       compile,
       group_count,
       group_names,
       exec,
       exec_opt,
       execp,
       exec_partial,
       exec_partial_detailed,
       Mark,
       all,
       all_gen,
       all_seq,
       matches,
       matches_gen,
       matches_seq,
       split,
       split_gen,
       split_seq,
       split_full,
       split_full_gen,
       split_full_seq,
       Seq,
       replace,
       replace_string,
       str,
       char$0,
       alt,
       seq,
       empty,
       epsilon,
       rep,
       rep1,
       repn,
       opt,
       bol,
       eol,
       bow,
       eow,
       bos,
       eos,
       leol,
       start,
       stop,
       word,
       not_boundary,
       whole_string,
       longest,
       shortest,
       first,
       greedy,
       non_greedy,
       group,
       no_group,
       nest,
       mark,
       set,
       rg,
       inter,
       diff,
       compl,
       any,
       notnl,
       alnum,
       wordc,
       alpha,
       ascii,
       blank,
       cntrl,
       digit,
       graph,
       lower,
       print,
       punct,
       space,
       upper,
       xdigit,
       case$0,
       no_case,
       pp,
       pp_re,
       print_re,
       View,
       witness,
       get,
       get_ofs,
       get_all,
       get_all_ofs,
       test,
       marked,
       mark_set];
   runtime.caml_register_global(1, Re, "Re");
   return;
  }
  (globalThis));

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLjAsImZpbGUiOiJyZS5jbWEuanMiLCJzb3VyY2VSb290IjoiIiwibmFtZXMiOlsiZXF1YWwiLCJ4IiwieSIsImNvbXBhcmUiLCJ0b19pbnQiLCJwcCIsImludGVyc2VjdCIsInN5bWJvbCIsImR1bW15IiwiaW5leGlzdGFudCIsImxldHRlciIsIm5vdF9sZXR0ZXIiLCJuZXdsaW5lIiwibGFzdG5ld2xpbmUiLCJzZWFyY2hfYm91bmRhcnkiLCJmcm9tX2NoYXIiLCJzZXhwIiwiZm10IiwicyIsInBhaXIiLCJwcDEiLCJwcDIiLCJ2MiIsInYxIiwidHJpcGxlIiwicHAzIiwidjMiLCJvcHRpbnQiLCJpIiwicXVvdGUiLCJwcF9vbGlzdCIsInBwX2VsZW0iLCJwcF9zdHJfbGlzdCIsInRvX3RvX3N0cmluZyIsImIiLCJjYW55IiwidW5pb24iLCJsJDAiLCJsIiwibCQyIiwibCQxIiwiciIsImMyIiwiYzEiLCJyJDAiLCJjMiQwIiwiYzEkMCIsImwkMyIsImwkNCIsImludGVyIiwiZGlmZiIsInIkMSIsInNpbmdsZSIsImMiLCJhZGQiLCJzZXEiLCJjJDAiLCJvZmZzZXQiLCJvIiwiZW1wdHkiLCJtZW0iLCJzJDAiLCJyZW0iLCJoYXNoX3JlYyIsImoiLCJoYXNoIiwicHJpbnRfb25lIiwiY2giLCJpdGVyIiwidCIsImYiLCJ0JDAiLCJ4cyIsIm9uZV9jaGFyIiwidiIsInUiLCJmb2xkX3JpZ2h0IiwiaW5pdCIsImNzaW5nbGUiLCJpc19lbXB0eSIsInByZXBlbmQiLCJ4JDAiLCJkIiwiZCQwIiwicGljayIsImdlbiIsImVwc19leHByIiwiaGFzaF9jb21iaW5lIiwiaCIsImFjY3UiLCJtZXJnZV9tYXJrc19vZmZzZXQiLCJvbGQiLCJudyIsIm1lcmdlIiwibSIsImFjY3UkMSIsImFjY3UkMiIsImEiLCJhY2N1JDAiLCJpZHgiLCJtYXJrcyIsIm1hcmtzX3NldF9pZHgiLCJwcF9tYXJrcyIsInBwX3NlbSIsImsiLCJwcF9yZXBfa2luZCIsImUiLCJlJDAiLCJlJDEiLCJlJDIiLCJrJDAiLCJlJDMiLCJpJDAiLCJmaXJzdCIsInJlcyIsImNyZWF0ZV9pZHMiLCJta19leHByIiwiaWRzIiwiZGVmIiwiZW1wdHkkMCIsImNzdCIsImFsdCIsImtpbmQiLCJpc19lcHMiLCJleHByIiwiZXBzIiwicmVwIiwic2VtIiwibWFyayIsInBtYXJrIiwiZXJhc2UiLCJtJDAiLCJiZWZvcmUiLCJhZnRlciIsInJlbmFtZSIsInoiLCJ5JDAiLCJnIiwibDEiLCJsMiIsImwxJDAiLCJsMiQwIiwicjEiLCJlMSIsImwxJDEiLCJyMiIsImUyIiwibDIkMSIsInIxJDAiLCJlMSQwIiwibWFya3MxIiwicjIkMCIsImUyJDAiLCJtYXJrczIiLCJyMSQxIiwibWFya3MxJDAiLCJyMiQxIiwibWFya3MyJDAiLCJoYXNoJDAiLCJtYXJrcyQwIiwiYWNjdSQzIiwidHNlcSIsInByaW50X3N0YXRlX3JlYyIsInByaW50X3N0YXRlX2xzdCIsInBwJDAiLCJtayIsImNhdCIsImRlc2MiLCJjcmVhdGUiLCJlcXVhbCQwIiwiaGFzaCQxIiwiY3JlYXRlX3dvcmtpbmdfYXJlYSIsImluZGV4X2NvdW50IiwidyIsIm1hcmtfdXNlZF9pbmRpY2VzIiwidGJsIiwiZnJlZV9pbmRleCIsInRibF9yZWYiLCJsZW4iLCJpZHgkMCIsInJlbW92ZV9tYXRjaGVzIiwic3BsaXRfYXRfbWF0Y2giLCJyZW1vdmVfZHVwbGljYXRlcyIsInByZXYiLCJwcmV2JDAiLCJwcmV2JDEiLCJwcmV2JDIiLCJyJDIiLCJyJDMiLCJ4JDEiLCJwcmV2JDMiLCJyJDQiLCJzZXRfaWR4IiwiZmlsdGVyX21hcmtzIiwiZGVsdGFfMSQwIiwibmV4dF9jYXQiLCJwcmV2X2NhdCIsImRlbHRhXzIkMCIsImRlbHRhXzEiLCJkZWx0YV9zZXEkMCIsInkkMSIsImtpbmQkMCIsInJlcF9raW5kIiwieSQyIiwibWFya3MkMSIsInkkMyIsIm1hcmtzJDIiLCJjYXQkMCIsIm1hcmtzJDMiLCJkZWx0YV8yIiwiZGVsdGFfc2VxIiwiZGVsdGFfNCIsInJlbSQwIiwiZGVsdGEiLCJjaGFyJDAiLCJzdCIsImV4cHIkMCIsInJlZF90ciIsInRyMiIsInN0MiIsInMyIiwidHIxIiwic3QxIiwiczEiLCJwcmVwZW5kX2Rlcml2IiwicmVzdHJpY3QiLCJzJDEiLCJwcmVwZW5kX21hcmtzX2V4cHJfbHN0IiwibSQxIiwiZGVyaXZfMSQwIiwiYWxsX2NoYXJzIiwiY2F0ZWdvcmllcyIsInJlbSQxIiwiZGVyaXZfMiQwIiwiZGVyaXZfMSIsImRlcml2X3NlcSIsInokMCIsInJlbSQyIiwiY2F0JDEiLCJkZXJpdl8yIiwieGwiLCJ6JDEiLCJkZXJpdl80IiwiZGVyaXYiLCJkZXIiLCJleHByJDEiLCJzdGF0dXMiLCJtYSIsInN0JDAiLCJtYWtlIiwiZmxhdHRlbiIsImNtIiwiY29sb3JfcmVwciIsInNwbGl0IiwiZHVtbXlfb2Zmc2V0IiwibTEiLCJwMSIsInAyIiwiZ2V0Iiwic3RhcnQiLCJzdWJzIiwic3RvcCIsInRlc3QiLCJnZXRfb3B0IiwiYWxsX29mZnNldCIsImFsbCIsIm9mZnNldHMiLCJzdHJzIiwibWF0Y2hlcyIsInBwX21hdGNoIiwic3RyIiwibmJfZ3JvdXBzIiwibiIsIm4kMCIsInYkMCIsInYkMSIsIm4kMSIsInVua25vd24iLCJicmVhayQwIiwicHBfcmUiLCJyZSIsImdyb3VwX2NvdW50IiwiZ3JvdXBfbmFtZXMiLCJjYXRlZ29yeSIsImNvbG9yIiwiZHVtbXlfbmV4dCIsInVua25vd25fc3RhdGUiLCJmaW5kX3N0YXRlIiwibmNvbCIsImJyZWFrX3N0YXRlIiwiaW5mbyIsInBvcyIsInZhbGlkYXRlIiwiZ2V0X2NvbG9yIiwic2xlbiIsInNjYW5fc3RyIiwiaW5pdGlhbF9zdGF0ZSIsImdyb3VwcyIsInBvcyQzIiwibGFzdCIsImluZm8kMCIsInN0JDUiLCJwb3MkNCIsInN0JDMiLCJyZWFsX2MiLCJzdCQ0IiwicG9zJDAiLCJwb3MkMSIsInN0JDEiLCJzdCQyIiwicG9zJDIiLCJmaW5hbF9ib3VuZGFyeV9jaGVjayIsImZpbmFsX2NhdCIsInJlcyQwIiwibWF0Y2hfc3RyIiwicGFydGlhbCIsImluaXRpYWxfY2F0Iiwic3RhdHVzJDAiLCJwbWFya3MiLCJub19tYXRjaF9zdGFydHNfYmVmb3JlIiwiY3NlcSIsImNhZGQiLCJ2aWV3IiwidmFyJDAiLCJyZWwiLCJzcSIsInJlJDAiLCJyZSQxIiwiYyQxIiwiYyQyIiwiYyQzIiwiYyQ0IiwiYyQ1IiwiYyQ2IiwiaXNfY2hhcnNldCIsImN1cHBlciIsImNsb3dlciIsImNhbHBoYSIsImNkaWdpdCIsImNhbG51bSIsImN3b3JkIiwieDEiLCJ4MiIsIngxJDAiLCJ4MiQwIiwiZXFfbGlzdCIsImoyIiwiaTIiLCJ4MiQxIiwiajEiLCJpMSIsIngxJDEiLCJ4MiQyIiwic2VtMiIsIngxJDIiLCJzZW0xIiwieDIkMyIsImsyIiwieDEkMyIsImsxIiwieDIkNCIsIngxJDQiLCJ4MiQ1IiwieDEkNSIsIngyJDYiLCJ4MSQ2IiwieDIkNyIsIngxJDciLCJsMiQyIiwibDEkMiIsIngyJDgiLCJ4MiQ5IiwieDEkOCIsIngxJDkiLCJtMiIsInNlcXVlbmNlIiwibWVyZ2Vfc2VxdWVuY2VzIiwiZW5mb3JjZV9raW5kIiwiY3IiLCJ0cmFuc2xhdGUiLCJpZ25fY2FzZSIsIm5hbWVzIiwiY2FjaGUiLCJpZ25fZ3JvdXAkMCIsImdyZWVkeSQwIiwidHJhbnNfc2VxIiwibWVyZ2VkX3NlcXVlbmNlcyIsImtpbmQkMSIsImNyJDAiLCJqJDAiLCJraW5kJDIiLCJraW5kJDMiLCJjciQxIiwiZ3JlZWR5JDEiLCJwIiwibmFtZSIsImtpbmQkNCIsImNyJDIiLCJyJDUiLCJraW5kJDUiLCJjciQzIiwiciQ2IiwiaSQxIiwia2luZCQ2IiwiY3IkNCIsImlnbl9ncm91cCIsImdyZWVkeSIsImFzX3NldCIsImhhbmRsZV9jYXNlIiwiaWduX2Nhc2UkMCIsInIkNyIsInIkOCIsInIkOSIsInIkMTAiLCJyJDExIiwiciQxMiIsImwkNSIsInIkMTMiLCJyJDE0IiwiciQxNSIsImFuY2hvcmVkIiwiZXBzaWxvbiIsInJlcG4iLCJyZXAxIiwib3B0IiwiYm9sIiwiZW9sIiwiYm93IiwiZW93Iiwid29yZCIsIm5vdF9ib3VuZGFyeSIsImJvcyIsImVvcyIsIndob2xlX3N0cmluZyIsImxlb2wiLCJsb25nZXN0Iiwic2hvcnRlc3QiLCJub25fZ3JlZWR5IiwiZ3JvdXAiLCJub19ncm91cCIsIm5lc3QiLCJzZXQiLCJyZyIsImNvbXBsIiwiYW55Iiwibm90bmwiLCJsb3dlciIsInVwcGVyIiwiYWxwaGEiLCJkaWdpdCIsImFsbnVtIiwid29yZGMiLCJhc2NpaSIsImJsYW5rIiwiY250cmwiLCJncmFwaCIsInByaW50IiwicHVuY3QiLCJzcGFjZSIsInhkaWdpdCIsImNhc2UkMCIsIm5vX2Nhc2UiLCJjb21waWxlIiwicmVnZXhwJDAiLCJyZWdleHAiLCJsbmwiLCJjb2xvcml6ZSIsInJlZ2V4cCQxIiwicmVnZXhwJDIiLCJuZWVkX2xubCIsIm5jb2xvciIsImNvbG9ycyIsImxubCQwIiwibmNvbG9yJDAiLCJpbml0aWFsIiwiZXhlY19pbnRlcm5hbCIsInN0aCIsInN0aCQwIiwiZXhlYyIsInN1YnN0ciIsImV4ZWNfb3B0IiwiZXhlY3AiLCJleGVjX3BhcnRpYWwiLCJleGVjX3BhcnRpYWxfZGV0YWlsZWQiLCJtYXJrZWQiLCJtYXJrX3NldCIsImFsbF9zZXEiLCJsaW1pdCIsImF1eCIsIm1hdGNoZXNfc2VxIiwic3ViIiwic3BsaXRfZnVsbF9zZXEiLCJzdGF0ZSIsIm9sZF9pIiwidGV4dCIsInRleHQkMCIsInN0YXRlJDAiLCJzcGxpdF9zZXEiLCJmaWx0ZXIiLCJzZXEkMCIsInRsIiwic2VxJDEiLCJsaXN0X29mX3NlcSIsInNwbGl0X2Z1bGwiLCJnZW5fb2Zfc2VxIiwic3BsaXRfZ2VuIiwic3BsaXRfZnVsbF9nZW4iLCJhbGxfZ2VuIiwibWF0Y2hlc19nZW4iLCJyZXBsYWNlIiwiYnVmIiwicmVwbGFjaW5nIiwicmVwbGFjZV9zdHJpbmciLCJieSIsIndpdG5lc3MiLCJmcm9tIiwiZ2V0X29mcyIsImdldF9hbGwiLCJnZXRfYWxsX29mcyIsInRlc3QyIiwiYWNjZXB0IiwiYWNjZXB0MiIsImxlZnQiLCJicmFuY2giLCJsZWZ0JDAiLCJsZWZ0JDEiLCJicmFja2V0IiwicyQyIiwiY29tcGlsZV9wYXQiLCJjb21waWxlX3JlZ2V4cCIsInN0cmluZ19tYXRjaCIsInN0cmluZ19wYXJ0aWFsX21hdGNoIiwic2VhcmNoX2ZvcndhcmQiLCJzZWFyY2hfYmFja3dhcmQiLCJwJDAiLCJwJDEiLCJ2YWxpZF9ncm91cCIsIm9mZnNldF9ncm91cCIsInJlcGxhY2VtZW50X3RleHQiLCJyZXBsIiwib3JpZyIsInEiLCJxJDAiLCJxJDEiLCJwJDIiLCJsZW4kMCIsInAkMyIsInEkMiIsInEkMyIsInAkNCIsImIkMCIsInEkNSIsInAkNiIsInEkNCIsInAkNSIsInEkNiIsInAkNyIsInN0cmluZ19iZWZvcmUiLCJzdHJpbmdfYWZ0ZXIiLCJmaXJzdF9jaGFycyIsImxhc3RfY2hhcnMiLCJyZWdleHBfY2FzZV9mb2xkIiwicmVnZXhwX3N0cmluZyIsInJlZ2V4cF9zdHJpbmdfY2FzZV9mb2xkIiwiZ3JvdXBfYmVnaW5uaW5nIiwiZ3JvdXBfZW5kIiwibWF0Y2hlZF9ncm91cCIsInR4dCIsInJlcGxhY2VfbWF0Y2hlZCIsIm1hdGNoZWQiLCJtYXRjaF9iZWdpbm5pbmciLCJtYXRjaF9lbmQiLCJtYXRjaGVkX3N0cmluZyIsInN1YnN0aXR1dGVfZmlyc3QiLCJyZXBsX2Z1biIsImdsb2JhbF9zdWJzdGl0dXRlIiwibGFzdF93YXNfZW1wdHkiLCJzdGFydHBvcyIsImVuZF9wb3MiLCJyZXBsX3RleHQiLCJsYXN0X3dhc19lbXB0eSQwIiwiZ2xvYmFsX3JlcGxhY2UiLCJyZXBsYWNlX2ZpcnN0Iiwic2VhcmNoX2ZvcndhcmRfcHJvZ3Jlc3MiLCJib3VuZGVkX3NwbGl0IiwibnVtIiwiYm91bmRlZF9zcGxpdF9kZWxpbSIsInNwbGl0X2RlbGltIiwiYm91bmRlZF9mdWxsX3NwbGl0IiwiZnVsbF9zcGxpdCIsImJlZyIsIm11bCIsImV4cGxpY2l0X3BlcmlvZCIsInNsYXNoZXMiLCJhcHBlbmQiLCJwaWVjZSIsImFtX2F0X3N0YXJ0X29mX2NvbXBvbmVudCIsIm5leHQiLCJyZW1haW5pbmciLCJvbmUiLCJleHBsaWNpdF9zbGFzaCIsImVuY2xvc2VkIiwiaGlnaCIsImxvdyIsImVuY2xvc2VkX3NldCIsInNldCQwIiwiZW5jbG9zdXJlIiwiZXhhY3RseSIsInNsYXNoZXMkMCIsImNoYXJzIiwibWFueV9tYW55IiwiZXhwbGljaXRfcGVyaW9kJDAiLCJmaXJzdF9leHBsaWNpdF9wZXJpb2QiLCJtYXRjaF9jb21wb25lbnQiLCJnbG9iIiwicGF0aG5hbWUiLCJzdGgkMSIsIm1hdGNoX2JhY2tzbGFzaGVzIiwic3RoJDIiLCJwZXJpb2QiLCJzdGgkMyIsImV4cGFuZF9icmFjZXMiLCJzdGgkNCIsImRvdWJsZV9hc3RlcmlzayIsInRvX3JlIiwicmVhZCIsInBpZWNlcyIsImZvdW5kIiwicGllY2VzJDAiLCJzdGF0ZSQ4Iiwic3RhdGUkOSIsImV4cGxpY2l0X3NsYXNoJDAiLCJleHBsaWNpdF9wZXJpb2QkMSIsInNsYXNoZXMkMSIsInN0YXRlJDEwIiwibm90X2VtcHR5IiwibWF5YmVfZW1wdHkiLCJlbmNsb3NlZF9zZXQkMSIsImVuY2xvc2VkX3NldCQwIiwic3RhdGUkMiIsInN0YXRlJDQiLCJub3RfZW1wdHkkMCIsInN0YXRlJDUiLCJzdGF0ZSQ2IiwiZW5jbG9zZWQkMCIsInN0YXRlJDciLCJlbmNsb3NlZCQxIiwic3RhdGUkMyIsInN0YXRlJDEiLCJlbmNsb3NlZCQyIiwiZW5jbG9zZWQkMyIsImV4cGwiLCJpbm5lciIsImFjYyIsImJlZyQwIiwiYWNjJDAiLCJiZWckMSIsImFjYyQxIiwiaSQzIiwiYmVnJDIiLCJpJDQiLCJpJDIiLCJnbG9iJDAiLCJnbG9ieCIsImdsb2J4JDAiLCJwb3NpeF9jbGFzc19zdHJpbmdzIiwib3B0cyIsInVuZ3JlZWR5IiwiZG90YWxsIiwiZG9sbGFyX2VuZG9ubHkiLCJtdWx0aWxpbmUiLCJhY2NlcHRfcyIsInVuZ2V0IiwiZ3JlZWR5X21vZCIsImdyIiwiZ3IkMCIsImF0b20iLCJpbnRlZ2VyIiwiaGV4ZGlnaXQiLCJjb2RlIiwicyQzIiwicyQ0IiwiY2xhc3MkMCIsInBvc2l4X2NsYXNzIiwicGF0IiwiZmxhZ3MiLCJleHRyYWN0IiwicmV4IiwiZ2V0X3N1YnN0cmluZyIsImdldF9uYW1lZF9zdWJzdHJpbmciLCJnZXRfc3Vic3RyaW5nX29mcyIsInBtYXRjaCIsInN1YnN0aXR1dGUiLCJzdWJzdCIsInNzIiwiZmluIiwibWF4IiwicmVzdWx0cyIsImRlbGltIl0sInNvdXJjZXMiOlsiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9yZS9jYXRlZ29yeS5tbCIsIi9Vc2Vycy9yb3N2YWxpLy5vcGFtLzQuMTQuMS9saWIvcmUvZm10Lm1sIiwiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9yZS9jc2V0Lm1sIiwiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9yZS9wbWFyay5tbCIsIi9Vc2Vycy9yb3N2YWxpLy5vcGFtLzQuMTQuMS9saWIvcmUvYXV0b21hdGEubWwiLCIvVXNlcnMvcm9zdmFsaS8ub3BhbS80LjE0LjEvbGliL3JlL2NvbG9yX21hcC5tbCIsIi9Vc2Vycy9yb3N2YWxpLy5vcGFtLzQuMTQuMS9saWIvcmUvZ3JvdXAubWwiLCIvVXNlcnMvcm9zdmFsaS8ub3BhbS80LjE0LjEvbGliL3JlL2NvcmUubWwiLCIvVXNlcnMvcm9zdmFsaS8ub3BhbS80LjE0LjEvbGliL3JlL2VtYWNzLm1sIiwiL1VzZXJzL3Jvc3ZhbGkvLm9wYW0vNC4xNC4xL2xpYi9yZS9zdHIubWwiLCIvVXNlcnMvcm9zdmFsaS8ub3BhbS80LjE0LjEvbGliL3JlL2dsb2IubWwiLCIvVXNlcnMvcm9zdmFsaS8ub3BhbS80LjE0LjEvbGliL3JlL3BlcmwubWwiLCIvVXNlcnMvcm9zdmFsaS8ub3BhbS80LjE0LjEvbGliL3JlL3BjcmUubWwiLCIvVXNlcnMvcm9zdmFsaS8ub3BhbS80LjE0LjEvbGliL3JlL3Bvc2l4Lm1sIl0sIm1hcHBp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ZTtZQUN2Q3dQLFlBQWN4RyxLQUFXdFo7SUFBSSxHQUFmc1osU0FBT29ELE1BQVBwRCxRQUFBa1AsT0FBTzlMLGNBQVA4TDtJQUF1QixPQURyQzVNLFFBTkF0TCxPQU9ja1ksT0FBV3hvQjtHQUF3QjtrREFQakRzUSxJQU1Bc0wsU0FDQWtFOzs7RTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0UiLCJzb3VyY2VzQ29udGVudCI6WyJcbnR5cGUgdCA9IGludFxubGV0IGVxdWFsICh4IDogaW50KSAoeSA6IGludCkgPSB4ID0geVxubGV0IGNvbXBhcmUgKHggOiBpbnQpICh5IDogaW50KSA9IGNvbXBhcmUgeCB5XG5sZXQgdG9faW50IHggPSB4XG5sZXQgcHAgPSBGb3JtYXQucHBfcHJpbnRfaW50XG5cbmxldCBpbnRlcnNlY3QgeCB5ID0geCBsYW5kIHkgPD4gMFxubGV0ICgrKykgeCB5ID0geCBsb3IgeVxuXG5sZXQgZHVtbXkgPSAtMVxubGV0IGluZXhpc3RhbnQgPSAxXG5sZXQgbGV0dGVyID0gMlxubGV0IG5vdF9sZXR0ZXIgPSA0XG5sZXQgbmV3bGluZSA9IDhcbmxldCBsYXN0bmV3bGluZSA9IDE2XG5sZXQgc2VhcmNoX2JvdW5kYXJ5ID0gMzJcblxubGV0IGZyb21fY2hhciA9IGZ1bmN0aW9uXG4gICgqIFNob3VsZCBtYXRjaCBbY3dvcmRdIGRlZmluaXRpb24gKilcbiAgfCAnYScuLid6JyB8ICdBJy4uJ1onIHwgJzAnLi4nOScgfCAnXycgfCAnXFwxNzAnIHwgJ1xcMTgxJyB8ICdcXDE4NidcbiAgfCAnXFwxOTInLi4nXFwyMTQnIHwgJ1xcMjE2Jy4uJ1xcMjQ2JyB8ICdcXDI0OCcuLidcXDI1NScgLT5cbiAgICBsZXR0ZXJcbiAgfCAnXFxuJyAtPlxuICAgIG5vdF9sZXR0ZXIgKysgbmV3bGluZVxuICB8IF8gLT5cbiAgICBub3RfbGV0dGVyXG4iLCIoKiogVmVyeSBzbWFsbCB0b29saW5nIGZvciBmb3JtYXQgcHJpbnRlcnMuICopXG5cbmluY2x1ZGUgRm9ybWF0XG5cbnR5cGUgJ2EgdCA9IEZvcm1hdC5mb3JtYXR0ZXIgLT4gJ2EgLT4gdW5pdFxuXG5sZXQgbGlzdCA9IHBwX3ByaW50X2xpc3RcbmxldCBzdHIgPSBwcF9wcmludF9zdHJpbmdcbmxldCBzZXhwIGZtdCBzIHBwIHggPSBmcHJpbnRmIGZtdCBcIkBbPDM+KCVzQCAlYSlAXVwiIHMgcHAgeFxubGV0IHBhaXIgcHAxIHBwMiBmbXQgKHYxLHYyKSA9XG4gIHBwMSBmbXQgdjE7IHBwX3ByaW50X3NwYWNlIGZtdCAoKSA7IHBwMiBmbXQgdjJcbmxldCB0cmlwbGUgcHAxIHBwMiBwcDMgZm10ICh2MSwgdjIsIHYzKSA9XG4gIHBwMSBmbXQgdjE7IHBwX3ByaW50X3NwYWNlIGZtdCAoKSA7XG4gIHBwMiBmbXQgdjI7IHBwX3ByaW50X3NwYWNlIGZtdCAoKSA7XG4gIHBwMyBmbXQgdjNcbmxldCBpbnQgPSBwcF9wcmludF9pbnRcbmxldCBvcHRpbnQgZm10ID0gZnVuY3Rpb25cbiAgfCBOb25lIC0+ICgpXG4gIHwgU29tZSBpIC0+IGZwcmludGYgZm10IFwiQCAlZFwiIGlcblxubGV0IHF1b3RlIGZtdCBzID0gRm9ybWF0LmZwcmludGYgZm10IFwiXFxcIiVzXFxcIlwiIHNcblxubGV0IHBwX29saXN0IHBwX2VsZW0gZm10ID1cbiAgRm9ybWF0LmZwcmludGYgZm10IFwiQFs8Mz5bQCAlYUAgXUBdXCJcbiAgICAocHBfcHJpbnRfbGlzdFxuICAgICAgIH5wcF9zZXA6KGZ1biBmbXQgKCkgLT4gZnByaW50ZiBmbXQgXCI7QCBcIilcbiAgICAgICBwcF9lbGVtKVxuXG5sZXQgcHBfc3RyX2xpc3QgPSBwcF9vbGlzdCBxdW90ZVxuXG5sZXQgdG9fdG9fc3RyaW5nIHBwIHggPVxuICBsZXQgYiA9IEJ1ZmZlci5jcmVhdGUgMTYgaW5cbiAgbGV0IGZtdCA9IEZvcm1hdC5mb3JtYXR0ZXJfb2ZfYnVmZmVyIGIgaW5cbiAgcHAgZm10IHg7XG4gIEJ1ZmZlci5jb250ZW50cyBiXG4iLCIoKlxuICAgUkUgLSBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaWJyYXJ5XG5cbiAgIENvcHlyaWdodCAoQykgMjAwMSBKZXJvbWUgVm91aWxsb25cbiAgIGVtYWlsOiBKZXJvbWUuVm91aWxsb25AcHBzLmp1c3NpZXUuZnJcblxuICAgVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aFxuICAgbGlua2luZyBleGNlcHRpb247IGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0XG4gICB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gICBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gICBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBXG4qKVxuXG50eXBlIGMgPSBpbnRcbnR5cGUgdCA9IChjICogYykgbGlzdFxuXG5sZXQgcmVjIHVuaW9uIGwgbCcgPVxuICBtYXRjaCBsLCBsJyB3aXRoXG4gICAgXywgW10gLT4gbFxuICB8IFtdLCBfIC0+IGwnXG4gIHwgKGMxLCBjMik6OnIsIChjMScsIGMyJyk6OnInIC0+XG4gICAgaWYgYzIgKyAxIDwgYzEnIHRoZW5cbiAgICAgIChjMSwgYzIpOjp1bmlvbiByIGwnXG4gICAgZWxzZSBpZiBjMicgKyAxIDwgYzEgdGhlblxuICAgICAgKGMxJywgYzInKTo6dW5pb24gbCByJ1xuICAgIGVsc2UgaWYgYzIgPCBjMicgdGhlblxuICAgICAgdW5pb24gciAoKG1pbiBjMSBjMScsIGMyJyk6OnInKVxuICAgIGVsc2VcbiAgICAgIHVuaW9uICgobWluIGMxIGMxJywgYzIpOjpyKSByJ1xuXG5sZXQgcmVjIGludGVyIGwgbCcgPVxuICBtYXRjaCBsLCBsJyB3aXRoXG4gICAgXywgW10gLT4gW11cbiAgfCBbXSwgXyAtPiBbXVxuICB8IChjMSwgYzIpOjpyLCAoYzEnLCBjMicpOjpyJyAtPlxuICAgIGlmIGMyIDwgYzEnIHRoZW5cbiAgICAgIGludGVyIHIgbCdcbiAgICBlbHNlIGlmIGMyJyA8IGMxIHRoZW5cbiAgICAgIGludGVyIGwgcidcbiAgICBlbHNlIGlmIGMyIDwgYzInIHRoZW5cbiAgICAgIChtYXggYzEgYzEnLCBjMik6OmludGVyIHIgbCdcbiAgICBlbHNlXG4gICAgICAobWF4IGMxIGMxJywgYzInKTo6aW50ZXIgbCByJ1xuXG5sZXQgcmVjIGRpZmYgbCBsJyA9XG4gIG1hdGNoIGwsIGwnIHdpdGhcbiAgICBfLCBbXSAtPiBsXG4gIHwgW10sIF8gLT4gW11cbiAgfCAoYzEsIGMyKTo6ciwgKGMxJywgYzInKTo6cicgLT5cbiAgICBpZiBjMiA8IGMxJyB0aGVuXG4gICAgICAoYzEsIGMyKTo6ZGlmZiByIGwnXG4gICAgZWxzZSBpZiBjMicgPCBjMSB0aGVuXG4gICAgICBkaWZmIGwgcidcbiAgICBlbHNlXG4gICAgICBsZXQgcicnID0gaWYgYzInIDwgYzIgdGhlbiAoYzInICsgMSwgYzIpIDo6IHIgZWxzZSByIGluXG4gICAgICBpZiBjMSA8IGMxJyB0aGVuXG4gICAgICAgIChjMSwgYzEnIC0gMSk6OmRpZmYgcicnIHInXG4gICAgICBlbHNlXG4gICAgICAgIGRpZmYgcicnIHInXG5cbmxldCBzaW5nbGUgYyA9IFtjLCBjXVxuXG5sZXQgYWRkIGMgbCA9IHVuaW9uIChzaW5nbGUgYykgbFxuXG5sZXQgc2VxIGMgYycgPSBpZiBjIDw9IGMnIHRoZW4gW2MsIGMnXSBlbHNlIFtjJywgY11cblxubGV0IHJlYyBvZmZzZXQgbyBsID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gICAgICAgICAgICAtPiBbXVxuICB8IChjMSwgYzIpIDo6IHIgLT4gKGMxICsgbywgYzIgKyBvKSA6OiBvZmZzZXQgbyByXG5cbmxldCBlbXB0eSA9IFtdXG5cbmxldCByZWMgbWVtIChjIDogaW50KSBzID1cbiAgbWF0Y2ggcyB3aXRoXG4gICAgW10gICAgICAgICAgICAgIC0+IGZhbHNlXG4gIHwgKGMxLCBjMikgOjogcmVtIC0+IGlmIGMgPD0gYzIgdGhlbiBjID49IGMxIGVsc2UgbWVtIGMgcmVtXG5cbigqKioqKVxuXG50eXBlIGhhc2ggPSBpbnRcblxubGV0IHJlYyBoYXNoX3JlYyA9IGZ1bmN0aW9uXG4gIHwgW10gICAgICAgIC0+IDBcbiAgfCAoaSwgaik6OnIgLT4gaSArIDEzICogaiArIDI1NyAqIGhhc2hfcmVjIHJcbmxldCBoYXNoIGwgPSAoaGFzaF9yZWMgbCkgbGFuZCAweDNGRkZGRkZGXG5cbigqKioqKVxuXG5sZXQgcHJpbnRfb25lIGNoIChjMSwgYzIpID1cbiAgaWYgYzEgPSBjMiB0aGVuXG4gICAgRm9ybWF0LmZwcmludGYgY2ggXCIlZFwiIGMxXG4gIGVsc2VcbiAgICBGb3JtYXQuZnByaW50ZiBjaCBcIiVkLSVkXCIgYzEgYzJcblxubGV0IHBwID0gRm10Lmxpc3QgcHJpbnRfb25lXG5cbmxldCByZWMgaXRlciB0IH5mID1cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgW10gLT4gKClcbiAgfCAoeCwgeSk6OnhzIC0+XG4gICAgZiB4IHk7XG4gICAgaXRlciB4cyAgfmZcblxubGV0IG9uZV9jaGFyID0gZnVuY3Rpb25cbiAgfCBbaSwgal0gd2hlbiBpID0gaiAtPiBTb21lIGlcbiAgfCBfIC0+IE5vbmVcblxuXG5tb2R1bGUgQ1NldE1hcCA9IE1hcC5NYWtlIChzdHJ1Y3RcbiAgICB0eXBlIHQgPSBpbnQgKiAoaW50ICogaW50KSBsaXN0XG4gICAgbGV0IGNvbXBhcmUgKGksIHUpIChqLCB2KSA9XG4gICAgICBsZXQgYyA9IGNvbXBhcmUgaSBqIGluXG4gICAgICBpZiBjIDw+IDBcbiAgICAgIHRoZW4gY1xuICAgICAgZWxzZSBjb21wYXJlIHUgdlxuICBlbmQpXG5cbmxldCBmb2xkX3JpZ2h0IHQgfmluaXQgfmYgPSBMaXN0LmZvbGRfcmlnaHQgZiB0IGluaXRcblxubGV0IGNzaW5nbGUgYyA9IHNpbmdsZSAoQ2hhci5jb2RlIGMpXG5cbmxldCBjYW55ID0gWzAsIDI1NV1cblxubGV0IGlzX2VtcHR5ID0gZnVuY3Rpb25cbiAgfCBbXSAtPiB0cnVlXG4gIHwgXyAtPiBmYWxzZVxuXG5sZXQgcmVjIHByZXBlbmQgcyB4IGwgPVxuICBtYXRjaCBzLCBsIHdpdGhcbiAgfCBbXSwgXyAtPiBsXG4gIHwgX3IsIFtdIC0+IFtdXG4gIHwgKF9jLCBjJykgOjogciwgKFtkLCBfZCddLCBfeCcpIDo6IF9yJyB3aGVuIGMnIDwgZCAtPiBwcmVwZW5kIHIgeCBsXG4gIHwgKGMsIGMnKSA6OiByLCAoW2QsIGQnXSwgeCcpIDo6IHInIC0+XG4gICAgaWYgYyA8PSBkIHRoZW4gYmVnaW5cbiAgICAgIGlmIGMnIDwgZCdcbiAgICAgIHRoZW4gKFtkLCBjJ10sIHggQCB4JykgOjogcHJlcGVuZCByIHggKChbYycgKyAxLCBkJ10sIHgnKSA6OiByJylcbiAgICAgIGVsc2UgKFtkLCBkJ10sIHggQCB4JykgOjogcHJlcGVuZCBzIHggcidcbiAgICBlbmQgZWxzZSBiZWdpblxuICAgICAgaWYgYyA+IGQnXG4gICAgICB0aGVuIChbZCwgZCddLCB4JykgOjogcHJlcGVuZCBzIHggcidcbiAgICAgIGVsc2UgKFtkLCBjIC0gMV0sIHgnKSA6OiBwcmVwZW5kIHMgeCAoKFtjLCBkJ10sIHgnKSA6OiByJylcbiAgICBlbmRcbiAgfCBfIC0+IGFzc2VydCBmYWxzZVxuXG5sZXQgcGljayA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gaW52YWxpZF9hcmcgXCJSZV9jc2V0LnBpY2tcIlxuICB8ICh4LCBfKTo6XyAtPiB4XG4iLCJcbm1vZHVsZSBQbWFyayA9IHN0cnVjdFxuICB0eXBlIHQgPSBpbnRcbiAgbGV0IGVxdWFsICh4IDogaW50KSAoeSA6IGludCkgPSB4ID0geVxuICBsZXQgY29tcGFyZSAoeCA6IGludCkgKHkgOiBpbnQpID0gY29tcGFyZSB4IHlcbiAgbGV0IHIgPSByZWYgMFxuICBsZXQgZ2VuICgpID0gaW5jciByIDsgIXJcblxuICBsZXQgcHAgPSBGb3JtYXQucHBfcHJpbnRfaW50XG5lbmRcblxuaW5jbHVkZSBQbWFya1xubW9kdWxlIFNldCA9IFNldC5NYWtlKFBtYXJrKVxuIiwiKCpcbiAgIFJFIC0gQSByZWd1bGFyIGV4cHJlc3Npb24gbGlicmFyeVxuXG4gICBDb3B5cmlnaHQgKEMpIDIwMDEgSmVyb21lIFZvdWlsbG9uXG4gICBlbWFpbDogSmVyb21lLlZvdWlsbG9uQHBwcy5qdXNzaWV1LmZyXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGhcbiAgIGxpbmtpbmcgZXhjZXB0aW9uOyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdFxuICAgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuICAgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICAgRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQVxuKilcblxudHlwZSBzZW0gPSBbIGBMb25nZXN0IHwgYFNob3J0ZXN0IHwgYEZpcnN0IF1cblxudHlwZSByZXBfa2luZCA9IFsgYEdyZWVkeSB8IGBOb25fZ3JlZWR5IF1cblxudHlwZSBtYXJrID0gaW50XG50eXBlIGlkeCA9IGludFxuXG50eXBlIGV4cHIgPSB7IGlkIDogaW50OyBkZWYgOiBkZWYgfVxuXG5hbmQgZGVmID1cbiAgICBDc3Qgb2YgQ3NldC50XG4gIHwgQWx0IG9mIGV4cHIgbGlzdFxuICB8IFNlcSBvZiBzZW0gKiBleHByICogZXhwclxuICB8IEVwc1xuICB8IFJlcCBvZiByZXBfa2luZCAqIHNlbSAqIGV4cHJcbiAgfCBNYXJrIG9mIGludFxuICB8IEVyYXNlIG9mIGludCAqIGludFxuICB8IEJlZm9yZSBvZiBDYXRlZ29yeS50XG4gIHwgQWZ0ZXIgb2YgQ2F0ZWdvcnkudFxuICB8IFBtYXJrIG9mIFBtYXJrLnRcblxubGV0IGhhc2hfY29tYmluZSBoIGFjY3UgPSBhY2N1ICogNjU1OTkgKyBoXG5cbm1vZHVsZSBNYXJrcyA9IHN0cnVjdFxuICB0eXBlIHQgPVxuICAgIHsgbWFya3MgOiAoaW50ICogaW50KSBsaXN0XG4gICAgOyBwbWFya3MgOiBQbWFyay5TZXQudCB9XG5cbiAgbGV0IGVtcHR5ID0geyBtYXJrcyA9IFtdIDsgcG1hcmtzID0gUG1hcmsuU2V0LmVtcHR5IH1cblxuICBsZXQgcmVjIG1lcmdlX21hcmtzX29mZnNldCBvbGQgPSBmdW5jdGlvblxuICAgIHwgW10gLT5cbiAgICAgIG9sZFxuICAgIHwgKGksIHYpIDo6IHJlbSAtPlxuICAgICAgbGV0IG53JyA9IG1lcmdlX21hcmtzX29mZnNldCAoTGlzdC5yZW1vdmVfYXNzcSBpIG9sZCkgcmVtIGluXG4gICAgICBpZiB2ID0gLTIgdGhlblxuICAgICAgICBudydcbiAgICAgIGVsc2VcbiAgICAgICAgKGksIHYpIDo6IG53J1xuXG4gIGxldCBtZXJnZSBvbGQgbncgPVxuICAgIHsgbWFya3MgPSBtZXJnZV9tYXJrc19vZmZzZXQgb2xkLm1hcmtzIG53Lm1hcmtzXG4gICAgOyBwbWFya3MgPSBQbWFyay5TZXQudW5pb24gb2xkLnBtYXJrcyBudy5wbWFya3MgfVxuXG4gIGxldCByZWMgaGFzaF9tYXJrc19vZmZzZXQgbCBhY2N1ID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICAgIFtdICAgICAgICAgIC0+IGFjY3VcbiAgICB8IChhLCBpKSA6OiByIC0+IGhhc2hfbWFya3Nfb2Zmc2V0IHIgKGhhc2hfY29tYmluZSBhIChoYXNoX2NvbWJpbmUgaSBhY2N1KSlcblxuICBsZXQgaGFzaCBtIGFjY3UgPVxuICAgIGhhc2hfbWFya3Nfb2Zmc2V0IG0ubWFya3MgKGhhc2hfY29tYmluZSAoSGFzaHRibC5oYXNoIG0ucG1hcmtzKSBhY2N1KVxuXG4gIGxldCByZWMgbWFya3Nfc2V0X2lkeCBpZHggPSBmdW5jdGlvblxuICAgIHwgKGEsIC0xKSA6OiByZW0gLT5cbiAgICAgIChhLCBpZHgpIDo6IG1hcmtzX3NldF9pZHggaWR4IHJlbVxuICAgIHwgbWFya3MgLT5cbiAgICAgIG1hcmtzXG5cbiAgbGV0IG1hcmtzX3NldF9pZHggbWFya3MgaWR4ID1cbiAgICB7IG1hcmtzIHdpdGggbWFya3MgPSBtYXJrc19zZXRfaWR4IGlkeCBtYXJrcy5tYXJrcyB9XG5cbiAgbGV0IHBwX21hcmtzIGNoIHQgPVxuICAgIG1hdGNoIHQubWFya3Mgd2l0aFxuICAgIHwgW10gLT5cbiAgICAgICgpXG4gICAgfCAoYSwgaSkgOjogciAtPlxuICAgICAgRm9ybWF0LmZwcmludGYgY2ggXCIlZC0lZFwiIGEgaTtcbiAgICAgIExpc3QuaXRlciAoZnVuIChhLCBpKSAtPiBGb3JtYXQuZnByaW50ZiBjaCBcIiAlZC0lZFwiIGEgaSkgclxuZW5kXG5cbigqKioqKVxuXG5sZXQgcHBfc2VtIGNoIGsgPVxuICBGb3JtYXQucHBfcHJpbnRfc3RyaW5nIGNoXG4gICAgKG1hdGNoIGsgd2l0aFxuICAgICAgIGBTaG9ydGVzdCAtPiBcInNob3J0XCJcbiAgICAgfCBgTG9uZ2VzdCAgLT4gXCJsb25nXCJcbiAgICAgfCBgRmlyc3QgICAgLT4gXCJmaXJzdFwiKVxuXG5cbmxldCBwcF9yZXBfa2luZCBmbXQgPSBmdW5jdGlvblxuICB8IGBHcmVlZHkgLT4gRm9ybWF0LnBwX3ByaW50X3N0cmluZyBmbXQgXCJHcmVlZHlcIlxuICB8IGBOb25fZ3JlZWR5IC0+IEZvcm1hdC5wcF9wcmludF9zdHJpbmcgZm10IFwiTm9uX2dyZWVkeVwiXG5cbmxldCByZWMgcHAgY2ggZSA9XG4gIGxldCBvcGVuIEZtdCBpblxuICBtYXRjaCBlLmRlZiB3aXRoXG4gICAgQ3N0IGwgLT5cbiAgICBzZXhwIGNoIFwiY3N0XCIgQ3NldC5wcCBsO1xuICB8IEFsdCBsIC0+XG4gICAgc2V4cCBjaCBcImFsdFwiIChsaXN0IHBwKSBsXG4gIHwgU2VxIChrLCBlLCBlJykgLT5cbiAgICBzZXhwIGNoIFwic2VxXCIgKHRyaXBsZSBwcF9zZW0gcHAgcHApIChrLCBlLCBlJylcbiAgfCBFcHMgLT5cbiAgICBzdHIgY2ggXCJlcHNcIlxuICB8IFJlcCAoX3JrLCBrLCBlKSAtPlxuICAgIHNleHAgY2ggXCJyZXBcIiAocGFpciBwcF9zZW0gcHApIChrLCBlKVxuICB8IE1hcmsgaSAtPlxuICAgIHNleHAgY2ggXCJtYXJrXCIgaW50IGlcbiAgfCBQbWFyayBpIC0+XG4gICAgc2V4cCBjaCBcInBtYXJrXCIgaW50IChpIDo+IGludClcbiAgfCBFcmFzZSAoYiwgZSkgLT5cbiAgICBzZXhwIGNoIFwiZXJhc2VcIiAocGFpciBpbnQgaW50KSAoYiwgZSlcbiAgfCBCZWZvcmUgYyAtPlxuICAgIHNleHAgY2ggXCJiZWZvcmVcIiBDYXRlZ29yeS5wcCBjXG4gIHwgQWZ0ZXIgYyAtPlxuICAgIHNleHAgY2ggXCJhZnRlclwiIENhdGVnb3J5LnBwIGNcblxuXG4oKioqKilcblxubGV0IHJlYyBmaXJzdCBmID0gZnVuY3Rpb25cbiAgfCBbXSAtPlxuICAgIE5vbmVcbiAgfCB4IDo6IHIgLT5cbiAgICBtYXRjaCBmIHggd2l0aFxuICAgICAgTm9uZSAgICAgICAgICAtPiBmaXJzdCBmIHJcbiAgICB8IFNvbWUgXyBhcyByZXMgLT4gcmVzXG5cbigqKioqKVxuXG50eXBlIGlkcyA9IGludCByZWZcbmxldCBjcmVhdGVfaWRzICgpID0gcmVmIDBcblxubGV0IGVwc19leHByID0geyBpZCA9IDA7IGRlZiA9IEVwcyB9XG5cbmxldCBta19leHByIGlkcyBkZWYgPVxuICBpbmNyIGlkcztcbiAgeyBpZCA9ICFpZHM7IGRlZiA9IGRlZiB9XG5cbmxldCBlbXB0eSBpZHMgPSBta19leHByIGlkcyAoQWx0IFtdKVxuXG5sZXQgY3N0IGlkcyBzID1cbiAgaWYgQ3NldC5pc19lbXB0eSBzXG4gIHRoZW4gZW1wdHkgaWRzXG4gIGVsc2UgbWtfZXhwciBpZHMgKENzdCBzKVxuXG5sZXQgYWx0IGlkcyA9IGZ1bmN0aW9uXG4gIHwgW10gIC0+IGVtcHR5IGlkc1xuICB8IFtjXSAtPiBjXG4gIHwgbCAgIC0+IG1rX2V4cHIgaWRzIChBbHQgbClcblxubGV0IHNlcSBpZHMga2luZCB4IHkgPVxuICBtYXRjaCB4LmRlZiwgeS5kZWYgd2l0aFxuICAgIEFsdCBbXSwgXyAgICAgICAgICAgICAgICAgLT4geFxuICB8IF8sIEFsdCBbXSAgICAgICAgICAgICAgICAgLT4geVxuICB8IEVwcywgXyAgICAgICAgICAgICAgICAgICAgLT4geVxuICB8IF8sIEVwcyB3aGVuIGtpbmQgPSBgRmlyc3QgLT4geFxuICB8IF8gICAgICAgICAgICAgICAgICAgICAgICAgLT4gbWtfZXhwciBpZHMgKFNlcSAoa2luZCwgeCwgeSkpXG5cbmxldCBpc19lcHMgZXhwciA9XG4gIG1hdGNoIGV4cHIuZGVmIHdpdGhcbiAgfCBFcHMgLT4gdHJ1ZVxuICB8IF8gLT4gZmFsc2VcblxubGV0IGVwcyBpZHMgPSBta19leHByIGlkcyBFcHNcblxubGV0IHJlcCBpZHMga2luZCBzZW0geCA9IG1rX2V4cHIgaWRzIChSZXAgKGtpbmQsIHNlbSwgeCkpXG5cbmxldCBtYXJrIGlkcyBtID0gbWtfZXhwciBpZHMgKE1hcmsgbSlcblxubGV0IHBtYXJrIGlkcyBpID0gbWtfZXhwciBpZHMgKFBtYXJrIGkpXG5cbmxldCBlcmFzZSBpZHMgbSBtJyA9IG1rX2V4cHIgaWRzIChFcmFzZSAobSwgbScpKVxuXG5sZXQgYmVmb3JlIGlkcyBjID0gbWtfZXhwciBpZHMgKEJlZm9yZSBjKVxuXG5sZXQgYWZ0ZXIgaWRzIGMgPSBta19leHByIGlkcyAoQWZ0ZXIgYylcblxuKCoqKiopXG5cbmxldCByZWMgcmVuYW1lIGlkcyB4ID1cbiAgbWF0Y2ggeC5kZWYgd2l0aFxuICAgIENzdCBfIHwgRXBzIHwgTWFyayBfIHwgUG1hcmsgXyB8IEVyYXNlIF8gfCBCZWZvcmUgXyB8IEFmdGVyIF8gLT5cbiAgICBta19leHByIGlkcyB4LmRlZlxuICB8IEFsdCBsIC0+XG4gICAgbWtfZXhwciBpZHMgKEFsdCAoTGlzdC5tYXAgKHJlbmFtZSBpZHMpIGwpKVxuICB8IFNlcSAoaywgeSwgeikgLT5cbiAgICBta19leHByIGlkcyAoU2VxIChrLCByZW5hbWUgaWRzIHksIHJlbmFtZSBpZHMgeikpXG4gIHwgUmVwIChnLCBrLCB5KSAtPlxuICAgIG1rX2V4cHIgaWRzIChSZXAgKGcsIGssIHJlbmFtZSBpZHMgeSkpXG5cbigqKioqKVxuXG50eXBlIGhhc2ggPSBpbnRcbnR5cGUgbWFya19pbmZvcyA9IGludCBhcnJheVxudHlwZSBzdGF0dXMgPSBGYWlsZWQgfCBNYXRjaCBvZiBtYXJrX2luZm9zICogUG1hcmsuU2V0LnQgfCBSdW5uaW5nXG5cbm1vZHVsZSBFID0gc3RydWN0XG4gIHR5cGUgdCA9XG4gICAgfCBUU2VxIG9mIHQgbGlzdCAqIGV4cHIgKiBzZW1cbiAgICB8IFRFeHAgb2YgTWFya3MudCAqIGV4cHJcbiAgICB8IFRNYXRjaCBvZiBNYXJrcy50XG5cbiAgbGV0IHJlYyBlcXVhbCBsMSBsMiA9XG4gICAgbWF0Y2ggbDEsIGwyIHdpdGhcbiAgICB8IFtdLCBbXSAtPlxuICAgICAgdHJ1ZVxuICAgIHwgVFNlcSAobDEnLCBlMSwgXykgOjogcjEsIFRTZXEgKGwyJywgZTIsIF8pIDo6IHIyIC0+XG4gICAgICBlMS5pZCA9IGUyLmlkICYmIGVxdWFsIGwxJyBsMicgJiYgZXF1YWwgcjEgcjJcbiAgICB8IFRFeHAgKG1hcmtzMSwgZTEpIDo6IHIxLCBURXhwIChtYXJrczIsIGUyKSA6OiByMiAtPlxuICAgICAgZTEuaWQgPSBlMi5pZCAmJiBtYXJrczEgPSBtYXJrczIgJiYgZXF1YWwgcjEgcjJcbiAgICB8IFRNYXRjaCBtYXJrczEgOjogcjEsIFRNYXRjaCBtYXJrczIgOjogcjIgLT5cbiAgICAgIG1hcmtzMSA9IG1hcmtzMiAmJiBlcXVhbCByMSByMlxuICAgIHwgXyAtPlxuICAgICAgZmFsc2VcblxuICBsZXQgcmVjIGhhc2ggbCBhY2N1ID1cbiAgICBtYXRjaCBsIHdpdGhcbiAgICB8IFtdIC0+XG4gICAgICBhY2N1XG4gICAgfCBUU2VxIChsJywgZSwgXykgOjogciAtPlxuICAgICAgaGFzaCByIChoYXNoX2NvbWJpbmUgMHgxNzJhMWJjZSAoaGFzaF9jb21iaW5lIGUuaWQgKGhhc2ggbCcgYWNjdSkpKVxuICAgIHwgVEV4cCAobWFya3MsIGUpIDo6IHIgLT5cbiAgICAgIGhhc2ggclxuICAgICAgICAoaGFzaF9jb21iaW5lIDB4MmI0YzBkNzcgKGhhc2hfY29tYmluZSBlLmlkIChNYXJrcy5oYXNoIG1hcmtzIGFjY3UpKSlcbiAgICB8IFRNYXRjaCBtYXJrcyA6OiByIC0+XG4gICAgICBoYXNoIHIgKGhhc2hfY29tYmluZSAweDFjMjA1YWQ1IChNYXJrcy5oYXNoIG1hcmtzIGFjY3UpKVxuXG4gIGxldCB0ZXhwIG1hcmtzIHggPSBURXhwIChtYXJrcywgeClcblxuICBsZXQgdHNlcSBraW5kIHggeSByZW0gPVxuICAgIG1hdGNoIHggd2l0aFxuICAgICAgW10gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiByZW1cbiAgICB8IFtURXhwIChtYXJrcywge2RlZiA9IEVwcyA7IF99KV0gLT4gVEV4cCAobWFya3MsIHkpIDo6IHJlbVxuICAgIHwgXyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAtPiBUU2VxICh4LCB5LCBraW5kKSA6OiByZW1cblxuICBsZXQgcmVjIHByaW50X3N0YXRlX3JlYyBjaCBlIHkgPVxuICAgIG1hdGNoIGUgd2l0aFxuICAgIHwgVE1hdGNoIG1hcmtzIC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBjaCBcIkBbPDI+KE1hdGNoQCAlYSlAXVwiIE1hcmtzLnBwX21hcmtzIG1hcmtzXG4gICAgfCBUU2VxIChsJywgeCwgX2tpbmQpIC0+XG4gICAgICBGb3JtYXQuZnByaW50ZiBjaCBcIkBbPDI+KFNlcUAgXCI7XG4gICAgICBwcmludF9zdGF0ZV9sc3QgY2ggbCcgeDtcbiAgICAgIEZvcm1hdC5mcHJpbnRmIGNoIFwiQCAlYSlAXVwiIHBwIHhcbiAgICB8IFRFeHAgKG1hcmtzLCB7ZGVmID0gRXBzOyBffSkgLT5cbiAgICAgIEZvcm1hdC5mcHJpbnRmIGNoIFwiQFs8Mj4oRXhwQCAlZEAgKCVhKUAgKGVwcykpQF1cIiB5LmlkIE1hcmtzLnBwX21hcmtzIG1hcmtzXG4gICAgfCBURXhwIChtYXJrcywgeCkgLT5cbiAgICAgIEZvcm1hdC5mcHJpbnRmIGNoIFwiQFs8Mj4oRXhwQCAlZEAgKCVhKUAgJWEpQF1cIiB4LmlkIE1hcmtzLnBwX21hcmtzIG1hcmtzIHBwIHhcblxuICBhbmQgcHJpbnRfc3RhdGVfbHN0IGNoIGwgeSA9XG4gICAgbWF0Y2ggbCB3aXRoXG4gICAgICBbXSAtPlxuICAgICAgRm9ybWF0LmZwcmludGYgY2ggXCIoKVwiXG4gICAgfCBlIDo6IHJlbSAtPlxuICAgICAgcHJpbnRfc3RhdGVfcmVjIGNoIGUgeTtcbiAgICAgIExpc3QuaXRlclxuICAgICAgICAoZnVuIGUgLT5cbiAgICAgICAgICAgRm9ybWF0LmZwcmludGYgY2ggXCJAIHwgXCI7XG4gICAgICAgICAgIHByaW50X3N0YXRlX3JlYyBjaCBlIHkpXG4gICAgICAgIHJlbVxuXG4gIGxldCBwcCBjaCB0ID0gcHJpbnRfc3RhdGVfbHN0IGNoIFt0XSB7IGlkID0gMDsgZGVmID0gRXBzIH1cbmVuZFxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID1cbiAgICB7IGlkeDogaWR4XG4gICAgOyBjYXRlZ29yeTogQ2F0ZWdvcnkudFxuICAgIDsgZGVzYzogRS50IGxpc3RcbiAgICA7IG11dGFibGUgc3RhdHVzOiBzdGF0dXMgb3B0aW9uXG4gICAgOyBoYXNoOiBoYXNoIH1cblxuICBsZXQgZHVtbXkgPVxuICAgIHsgaWR4ID0gLTFcbiAgICA7IGNhdGVnb3J5ID0gQ2F0ZWdvcnkuZHVtbXlcbiAgICA7IGRlc2MgPSBbXVxuICAgIDsgc3RhdHVzID0gTm9uZVxuICAgIDsgaGFzaCA9IC0xIH1cblxuICBsZXQgaGFzaCBpZHggY2F0IGRlc2MgPVxuICAgIEUuaGFzaCBkZXNjIChoYXNoX2NvbWJpbmUgaWR4IChoYXNoX2NvbWJpbmUgKENhdGVnb3J5LnRvX2ludCBjYXQpIDApKSBsYW5kIDB4M0ZGRkZGRkZcblxuICBsZXQgbWsgaWR4IGNhdCBkZXNjID1cbiAgICB7IGlkeFxuICAgIDsgY2F0ZWdvcnkgPSBjYXRcbiAgICA7IGRlc2NcbiAgICA7IHN0YXR1cyA9IE5vbmVcbiAgICA7IGhhc2ggPSBoYXNoIGlkeCBjYXQgZGVzY31cblxuICBsZXQgY3JlYXRlIGNhdCBlID0gbWsgMCBjYXQgW0UuVEV4cCAoTWFya3MuZW1wdHksIGUpXVxuXG4gIGxldCBlcXVhbCB4IHkgPVxuICAgICh4Lmhhc2ggOiBpbnQpID0geS5oYXNoICYmICh4LmlkeCA6IGludCkgPSB5LmlkeCAmJlxuICAgIENhdGVnb3J5LmVxdWFsIHguY2F0ZWdvcnkgeS5jYXRlZ29yeSAmJiBFLmVxdWFsIHguZGVzYyB5LmRlc2NcblxuICBsZXQgY29tcGFyZSB4IHkgPVxuICAgIGxldCBjID0gY29tcGFyZSAoeC5oYXNoIDogaW50KSB5Lmhhc2ggaW5cbiAgICBpZiBjIDw+IDAgdGhlbiBjIGVsc2VcbiAgICAgIGxldCBjID0gQ2F0ZWdvcnkuY29tcGFyZSB4LmNhdGVnb3J5IHkuY2F0ZWdvcnkgaW5cbiAgICAgIGlmIGMgPD4gMCB0aGVuIGMgZWxzZVxuICAgICAgICBjb21wYXJlIHguZGVzYyB5LmRlc2NcblxuICB0eXBlIHQnID0gdFxuICBtb2R1bGUgVGFibGUgPSBIYXNodGJsLk1ha2UoXG4gICAgc3RydWN0XG4gICAgICB0eXBlIHQgPSB0J1xuICAgICAgbGV0IGVxdWFsID0gZXF1YWxcbiAgICAgIGxldCBoYXNoIHQgPSB0Lmhhc2hcbiAgICBlbmQpXG5lbmRcblxuKCoqKiogRmluZCBhIGZyZWUgaW5kZXggKioqKilcblxudHlwZSB3b3JraW5nX2FyZWEgPSBib29sIGFycmF5IHJlZlxuXG5sZXQgY3JlYXRlX3dvcmtpbmdfYXJlYSAoKSA9IHJlZiBbfCBmYWxzZSB8XVxuXG5sZXQgaW5kZXhfY291bnQgdyA9IEFycmF5Lmxlbmd0aCAhd1xuXG5sZXQgcmVzZXRfdGFibGUgYSA9IEFycmF5LmZpbGwgYSAwIChBcnJheS5sZW5ndGggYSkgZmFsc2VcblxubGV0IHJlYyBtYXJrX3VzZWRfaW5kaWNlcyB0YmwgPVxuICBMaXN0Lml0ZXIgKGZ1bmN0aW9uXG4gICAgICB8IEUuVFNlcSAobCwgXywgXykgLT4gbWFya191c2VkX2luZGljZXMgdGJsIGxcbiAgICAgIHwgRS5URXhwIChtYXJrcywgXylcbiAgICAgIHwgRS5UTWF0Y2ggbWFya3MgLT5cbiAgICAgICAgTGlzdC5pdGVyIChmdW4gKF8sIGkpIC0+IGlmIGkgPj0gMCB0aGVuIHRibC4oaSkgPC0gdHJ1ZSlcbiAgICAgICAgICBtYXJrcy5NYXJrcy5tYXJrcylcblxubGV0IHJlYyBmaW5kX2ZyZWUgdGJsIGlkeCBsZW4gPVxuICBpZiBpZHggPSBsZW4gfHwgbm90IHRibC4oaWR4KSB0aGVuIGlkeCBlbHNlIGZpbmRfZnJlZSB0YmwgKGlkeCArIDEpIGxlblxuXG5sZXQgZnJlZV9pbmRleCB0YmxfcmVmIGwgPVxuICBsZXQgdGJsID0gIXRibF9yZWYgaW5cbiAgcmVzZXRfdGFibGUgdGJsO1xuICBtYXJrX3VzZWRfaW5kaWNlcyB0YmwgbDtcbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCB0YmwgaW5cbiAgbGV0IGlkeCA9IGZpbmRfZnJlZSB0YmwgMCBsZW4gaW5cbiAgaWYgaWR4ID0gbGVuIHRoZW4gdGJsX3JlZiA6PSBBcnJheS5tYWtlICgyICogbGVuKSBmYWxzZTtcbiAgaWR4XG5cbigqKioqIENvbXB1dGF0aW9uIG9mIHRoZSBuZXh0IHN0YXRlICoqKiopXG5cbmxldCByZW1vdmVfbWF0Y2hlcyA9IExpc3QuZmlsdGVyIChmdW5jdGlvbiBFLlRNYXRjaCBfIC0+IGZhbHNlIHwgXyAtPiB0cnVlKVxuXG5sZXQgcmVjIHNwbGl0X2F0X21hdGNoX3JlYyBsJyA9IGZ1bmN0aW9uXG4gIHwgW10gICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgfCBFLlRNYXRjaCBfIDo6IHIgLT4gKExpc3QucmV2IGwnLCByZW1vdmVfbWF0Y2hlcyByKVxuICB8IHggOjogciAgICAgICAgLT4gc3BsaXRfYXRfbWF0Y2hfcmVjICh4IDo6IGwnKSByXG5cbmxldCBzcGxpdF9hdF9tYXRjaCBsID0gc3BsaXRfYXRfbWF0Y2hfcmVjIFtdIGxcblxubGV0IHJlYyByZW1vdmVfZHVwbGljYXRlcyBwcmV2IGwgeSA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdIC0+XG4gICAgKFtdLCBwcmV2KVxuICB8IEUuVE1hdGNoIF8gYXMgeCA6OiBfIC0+ICgqIFRydW5jYXRlIGFmdGVyIGZpcnN0IG1hdGNoICopXG4gICAgKFt4XSwgcHJldilcbiAgfCBFLlRTZXEgKGwnLCB4LCBraW5kKSA6OiByIC0+XG4gICAgbGV0IChsJycsIHByZXYnKSA9IHJlbW92ZV9kdXBsaWNhdGVzIHByZXYgbCcgeCBpblxuICAgIGxldCAocicsIHByZXYnJykgPSByZW1vdmVfZHVwbGljYXRlcyBwcmV2JyByIHkgaW5cbiAgICAoRS50c2VxIGtpbmQgbCcnIHggcicsIHByZXYnJylcbiAgfCBFLlRFeHAgKF9tYXJrcywge2RlZiA9IEVwczsgX30pIGFzIGUgOjogciAtPlxuICAgIGlmIExpc3QubWVtcSB5LmlkIHByZXYgdGhlblxuICAgICAgcmVtb3ZlX2R1cGxpY2F0ZXMgcHJldiByIHlcbiAgICBlbHNlXG4gICAgICBsZXQgKHInLCBwcmV2JykgPSByZW1vdmVfZHVwbGljYXRlcyAoeS5pZCA6OiBwcmV2KSByIHkgaW5cbiAgICAgIChlIDo6IHInLCBwcmV2JylcbiAgfCBFLlRFeHAgKF9tYXJrcywgeCkgYXMgZSA6OiByIC0+XG4gICAgaWYgTGlzdC5tZW1xIHguaWQgcHJldiB0aGVuXG4gICAgICByZW1vdmVfZHVwbGljYXRlcyBwcmV2IHIgeVxuICAgIGVsc2VcbiAgICAgIGxldCAocicsIHByZXYnKSA9IHJlbW92ZV9kdXBsaWNhdGVzICh4LmlkIDo6IHByZXYpIHIgeSBpblxuICAgICAgKGUgOjogcicsIHByZXYnKVxuXG5sZXQgcmVjIHNldF9pZHggaWR4ID0gZnVuY3Rpb25cbiAgfCBbXSAtPlxuICAgIFtdXG4gIHwgRS5UTWF0Y2ggbWFya3MgOjogciAtPlxuICAgIEUuVE1hdGNoIChNYXJrcy5tYXJrc19zZXRfaWR4IG1hcmtzIGlkeCkgOjogc2V0X2lkeCBpZHggclxuICB8IEUuVFNlcSAobCcsIHgsIGtpbmQpIDo6IHIgLT5cbiAgICBFLlRTZXEgKHNldF9pZHggaWR4IGwnLCB4LCBraW5kKSA6OiBzZXRfaWR4IGlkeCByXG4gIHwgRS5URXhwIChtYXJrcywgeCkgOjogciAtPlxuICAgIEUuVEV4cCAoKE1hcmtzLm1hcmtzX3NldF9pZHggbWFya3MgaWR4KSwgeCkgOjogc2V0X2lkeCBpZHggclxuXG5sZXQgZmlsdGVyX21hcmtzIGIgZSBtYXJrcyA9XG4gIHttYXJrcyB3aXRoIE1hcmtzLm1hcmtzID0gTGlzdC5maWx0ZXIgKGZ1biAoaSwgXykgLT4gaSA8IGIgfHwgaSA+IGUpIG1hcmtzLk1hcmtzLm1hcmtzIH1cblxubGV0IHJlYyBkZWx0YV8xIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCB4IHJlbSA9XG4gICgqRm9ybWF0LmVwcmludGYgXCIlZEAuXCIgeC5pZDsqKVxuICBtYXRjaCB4LmRlZiB3aXRoXG4gICAgQ3N0IHMgLT5cbiAgICBpZiBDc2V0Lm1lbSBjIHMgdGhlbiBFLnRleHAgbWFya3MgZXBzX2V4cHIgOjogcmVtIGVsc2UgcmVtXG4gIHwgQWx0IGwgLT5cbiAgICBkZWx0YV8yIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCBsIHJlbVxuICB8IFNlcSAoa2luZCwgeSwgeikgLT5cbiAgICBsZXQgeScgPSBkZWx0YV8xIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCB5IFtdIGluXG4gICAgZGVsdGFfc2VxIGMgfm5leHRfY2F0IH5wcmV2X2NhdCBraW5kIHknIHogcmVtXG4gIHwgUmVwIChyZXBfa2luZCwga2luZCwgeSkgLT5cbiAgICBsZXQgeScgPSBkZWx0YV8xIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCB5IFtdIGluXG4gICAgbGV0ICh5JycsIG1hcmtzJykgPVxuICAgICAgbWF0Y2hcbiAgICAgICAgZmlyc3RcbiAgICAgICAgICAoZnVuY3Rpb24gRS5UTWF0Y2ggbWFya3MgLT4gU29tZSBtYXJrcyB8IF8gLT4gTm9uZSkgeSdcbiAgICAgIHdpdGhcbiAgICAgICAgTm9uZSAgICAgICAgLT4gKHknLCBtYXJrcylcbiAgICAgIHwgU29tZSBtYXJrcycgLT4gKHJlbW92ZV9tYXRjaGVzIHknLCBtYXJrcycpXG4gICAgaW5cbiAgICBiZWdpbiBtYXRjaCByZXBfa2luZCB3aXRoXG4gICAgICAgIGBHcmVlZHkgICAgIC0+IEUudHNlcSBraW5kIHknJyB4IChFLlRNYXRjaCBtYXJrcycgOjogcmVtKVxuICAgICAgfCBgTm9uX2dyZWVkeSAtPiBFLlRNYXRjaCBtYXJrcyA6OiBFLnRzZXEga2luZCB5JycgeCByZW1cbiAgICBlbmRcbiAgfCBFcHMgLT5cbiAgICBFLlRNYXRjaCBtYXJrcyA6OiByZW1cbiAgfCBNYXJrIGkgLT5cbiAgICBsZXQgbWFya3MgPSB7IG1hcmtzIHdpdGggTWFya3MubWFya3MgPSAoaSwgLTEpIDo6IExpc3QucmVtb3ZlX2Fzc3EgaSBtYXJrcy5NYXJrcy5tYXJrcyB9IGluXG4gICAgRS5UTWF0Y2ggbWFya3MgOjogcmVtXG4gIHwgUG1hcmsgaSAtPlxuICAgIGxldCBtYXJrcyA9IHsgbWFya3Mgd2l0aCBNYXJrcy5wbWFya3MgPSBQbWFyay5TZXQuYWRkIGkgbWFya3MuTWFya3MucG1hcmtzIH0gaW5cbiAgICBFLlRNYXRjaCBtYXJrcyA6OiByZW1cbiAgfCBFcmFzZSAoYiwgZSkgLT5cbiAgICBFLlRNYXRjaCAoZmlsdGVyX21hcmtzIGIgZSBtYXJrcykgOjogcmVtXG4gIHwgQmVmb3JlIGNhdCcnIC0+XG4gICAgaWYgQ2F0ZWdvcnkuaW50ZXJzZWN0IG5leHRfY2F0IGNhdCcnIHRoZW4gRS5UTWF0Y2ggbWFya3MgOjogcmVtIGVsc2UgcmVtXG4gIHwgQWZ0ZXIgY2F0JycgLT5cbiAgICBpZiBDYXRlZ29yeS5pbnRlcnNlY3QgcHJldl9jYXQgY2F0JycgdGhlbiBFLlRNYXRjaCBtYXJrcyA6OiByZW0gZWxzZSByZW1cblxuYW5kIGRlbHRhXzIgbWFya3MgYyB+bmV4dF9jYXQgfnByZXZfY2F0IGwgcmVtID1cbiAgbWF0Y2ggbCB3aXRoXG4gICAgW10gICAgIC0+IHJlbVxuICB8IHkgOjogciAtPlxuICAgIGRlbHRhXzEgbWFya3MgYyB+bmV4dF9jYXQgfnByZXZfY2F0IHlcbiAgICAgIChkZWx0YV8yIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCByIHJlbSlcblxuYW5kIGRlbHRhX3NlcSBjIH5uZXh0X2NhdCB+cHJldl9jYXQga2luZCB5IHogcmVtID1cbiAgbWF0Y2hcbiAgICBmaXJzdCAoZnVuY3Rpb24gRS5UTWF0Y2ggbWFya3MgLT4gU29tZSBtYXJrcyB8IF8gLT4gTm9uZSkgeVxuICB3aXRoXG4gICAgTm9uZSAtPlxuICAgIEUudHNlcSBraW5kIHkgeiByZW1cbiAgfCBTb21lIG1hcmtzIC0+XG4gICAgbWF0Y2gga2luZCB3aXRoXG4gICAgICBgTG9uZ2VzdCAtPlxuICAgICAgRS50c2VxIGtpbmQgKHJlbW92ZV9tYXRjaGVzIHkpIHpcbiAgICAgICAgKGRlbHRhXzEgbWFya3MgYyB+bmV4dF9jYXQgfnByZXZfY2F0IHogcmVtKVxuICAgIHwgYFNob3J0ZXN0IC0+XG4gICAgICBkZWx0YV8xIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCB6XG4gICAgICAgIChFLnRzZXEga2luZCAocmVtb3ZlX21hdGNoZXMgeSkgeiByZW0pXG4gICAgfCBgRmlyc3QgLT5cbiAgICAgIGxldCAoeScsIHknJykgPSBzcGxpdF9hdF9tYXRjaCB5IGluXG4gICAgICBFLnRzZXEga2luZCB5JyB6XG4gICAgICAgIChkZWx0YV8xIG1hcmtzIGMgfm5leHRfY2F0IH5wcmV2X2NhdCB6IChFLnRzZXEga2luZCB5JycgeiByZW0pKVxuXG5sZXQgcmVjIGRlbHRhXzMgYyB+bmV4dF9jYXQgfnByZXZfY2F0IHggcmVtID1cbiAgbWF0Y2ggeCB3aXRoXG4gICAgRS5UU2VxICh5LCB6LCBraW5kKSAtPlxuICAgIGxldCB5JyA9IGRlbHRhXzQgYyB+bmV4dF9jYXQgfnByZXZfY2F0IHkgW10gaW5cbiAgICBkZWx0YV9zZXEgYyB+bmV4dF9jYXQgfnByZXZfY2F0IGtpbmQgeScgeiByZW1cbiAgfCBFLlRFeHAgKG1hcmtzLCBlKSAtPlxuICAgIGRlbHRhXzEgbWFya3MgYyB+bmV4dF9jYXQgfnByZXZfY2F0IGUgcmVtXG4gIHwgRS5UTWF0Y2ggXyAtPlxuICAgIHggOjogcmVtXG5cbmFuZCBkZWx0YV80IGMgfm5leHRfY2F0IH5wcmV2X2NhdCBsIHJlbSA9XG4gIG1hdGNoIGwgd2l0aFxuICAgIFtdICAgICAtPiByZW1cbiAgfCB5IDo6IHIgLT5cbiAgICBkZWx0YV8zIGMgfm5leHRfY2F0IH5wcmV2X2NhdCB5XG4gICAgICAoZGVsdGFfNCBjIH5uZXh0X2NhdCB+cHJldl9jYXQgciByZW0pXG5cbmxldCBkZWx0YSB0YmxfcmVmIG5leHRfY2F0IGNoYXIgc3QgPVxuICBsZXQgcHJldl9jYXQgPSBzdC5TdGF0ZS5jYXRlZ29yeSBpblxuICBsZXQgKGV4cHInLCBfKSA9XG4gICAgcmVtb3ZlX2R1cGxpY2F0ZXMgW11cbiAgICAgIChkZWx0YV80IGNoYXIgfm5leHRfY2F0IH5wcmV2X2NhdCBzdC5TdGF0ZS5kZXNjIFtdKVxuICAgICAgZXBzX2V4cHIgaW5cbiAgbGV0IGlkeCA9IGZyZWVfaW5kZXggdGJsX3JlZiBleHByJyBpblxuICBsZXQgZXhwcicnID0gc2V0X2lkeCBpZHggZXhwcicgaW5cbiAgU3RhdGUubWsgaWR4IG5leHRfY2F0IGV4cHInJ1xuXG4oKioqKilcblxubGV0IHJlYyByZWRfdHIgPSBmdW5jdGlvblxuICB8IFtdIHwgW19dIGFzIGwgLT5cbiAgICBsXG4gIHwgKChzMSwgc3QxKSBhcyB0cjEpIDo6ICgoczIsIHN0MikgYXMgdHIyKSA6OiByZW0gLT5cbiAgICBpZiBTdGF0ZS5lcXVhbCBzdDEgc3QyIHRoZW5cbiAgICAgIHJlZF90ciAoKENzZXQudW5pb24gczEgczIsIHN0MSkgOjogcmVtKVxuICAgIGVsc2VcbiAgICAgIHRyMSA6OiByZWRfdHIgKHRyMiA6OiByZW0pXG5cbmxldCBzaW1wbF90ciBsID1cbiAgTGlzdC5zb3J0XG4gICAgKGZ1biAoczEsIF8pIChzMiwgXykgLT4gY29tcGFyZSBzMSBzMilcbiAgICAocmVkX3RyIChMaXN0LnNvcnQgKGZ1biAoXywgc3QxKSAoXywgc3QyKSAtPiBTdGF0ZS5jb21wYXJlIHN0MSBzdDIpIGwpKVxuXG4oKioqKilcblxubGV0IHByZXBlbmRfZGVyaXYgPSBMaXN0LmZvbGRfcmlnaHQgKGZ1biAocywgeCkgbCAtPiBDc2V0LnByZXBlbmQgcyB4IGwpXG5cbmxldCByZWMgcmVzdHJpY3QgcyA9IGZ1bmN0aW9uXG4gIHwgW10gLT4gW11cbiAgfCAocycsIHgnKSA6OiByZW0gLT5cbiAgICBsZXQgcycnID0gQ3NldC5pbnRlciBzIHMnIGluXG4gICAgaWYgQ3NldC5pc19lbXB0eSBzJydcbiAgICB0aGVuIHJlc3RyaWN0IHMgcmVtXG4gICAgZWxzZSAocycnLCB4JykgOjogcmVzdHJpY3QgcyByZW1cblxubGV0IHJlYyByZW1vdmVfbWFya3MgYiBlIHJlbSA9XG4gIGlmIGIgPiBlIHRoZW4gcmVtIGVsc2UgcmVtb3ZlX21hcmtzIGIgKGUgLSAxKSAoKGUsIC0yKSA6OiByZW0pXG5cbmxldCByZWMgcHJlcGVuZF9tYXJrc19leHByIG0gPSBmdW5jdGlvblxuICB8IEUuVFNlcSAobCwgZScsIHMpIC0+IEUuVFNlcSAocHJlcGVuZF9tYXJrc19leHByX2xzdCBtIGwsIGUnLCBzKVxuICB8IEUuVEV4cCAobScsIGUnKSAgIC0+IEUuVEV4cCAoTWFya3MubWVyZ2UgbSBtJywgZScpXG4gIHwgRS5UTWF0Y2ggbScgICAgICAgLT4gRS5UTWF0Y2ggKE1hcmtzLm1lcmdlIG0gbScpXG5cbmFuZCBwcmVwZW5kX21hcmtzX2V4cHJfbHN0IG0gbCA9XG4gIExpc3QubWFwIChwcmVwZW5kX21hcmtzX2V4cHIgbSkgbFxuXG5sZXQgcHJlcGVuZF9tYXJrcyBtID1cbiAgTGlzdC5tYXAgKGZ1biAocywgeCkgLT4gKHMsIHByZXBlbmRfbWFya3NfZXhwcl9sc3QgbSB4KSlcblxubGV0IHJlYyBkZXJpdl8xIGFsbF9jaGFycyBjYXRlZ29yaWVzIG1hcmtzIGNhdCB4IHJlbSA9XG4gIG1hdGNoIHguZGVmIHdpdGhcbiAgfCBDc3QgcyAtPlxuICAgIENzZXQucHJlcGVuZCBzIFtFLnRleHAgbWFya3MgZXBzX2V4cHJdIHJlbVxuICB8IEFsdCBsIC0+XG4gICAgZGVyaXZfMiBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgbCByZW1cbiAgfCBTZXEgKGtpbmQsIHksIHopIC0+XG4gICAgbGV0IHknID0gZGVyaXZfMSBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgeSBbKGFsbF9jaGFycywgW10pXSBpblxuICAgIGRlcml2X3NlcSBhbGxfY2hhcnMgY2F0ZWdvcmllcyBjYXQga2luZCB5JyB6IHJlbVxuICB8IFJlcCAocmVwX2tpbmQsIGtpbmQsIHkpIC0+XG4gICAgbGV0IHknID0gZGVyaXZfMSBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgeSBbKGFsbF9jaGFycywgW10pXSBpblxuICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgKGZ1biAocywgeikgcmVtIC0+XG4gICAgICAgICBsZXQgKHonLCBtYXJrcycpID1cbiAgICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgICBmaXJzdFxuICAgICAgICAgICAgICAgKGZ1bmN0aW9uIEUuVE1hdGNoIG1hcmtzIC0+IFNvbWUgbWFya3MgfCBfIC0+IE5vbmUpXG4gICAgICAgICAgICAgICB6XG4gICAgICAgICAgIHdpdGhcbiAgICAgICAgICAgICBOb25lICAgICAgICAtPiAoeiwgbWFya3MpXG4gICAgICAgICAgIHwgU29tZSBtYXJrcycgLT4gKHJlbW92ZV9tYXRjaGVzIHosIG1hcmtzJylcbiAgICAgICAgIGluXG4gICAgICAgICBDc2V0LnByZXBlbmQgc1xuICAgICAgICAgICAobWF0Y2ggcmVwX2tpbmQgd2l0aFxuICAgICAgICAgICAgICBgR3JlZWR5ICAgICAtPiBFLnRzZXEga2luZCB6JyB4IFtFLlRNYXRjaCBtYXJrcyddXG4gICAgICAgICAgICB8IGBOb25fZ3JlZWR5IC0+IEUuVE1hdGNoIG1hcmtzIDo6IEUudHNlcSBraW5kIHonIHggW10pXG4gICAgICAgICAgIHJlbSlcbiAgICAgIHknIHJlbVxuICB8IEVwcyAtPlxuICAgIENzZXQucHJlcGVuZCBhbGxfY2hhcnMgW0UuVE1hdGNoIG1hcmtzXSByZW1cbiAgfCBNYXJrIGkgLT5cbiAgICBDc2V0LnByZXBlbmQgYWxsX2NoYXJzIFtFLlRNYXRjaCB7bWFya3Mgd2l0aCBNYXJrcy5tYXJrcyA9ICgoaSwgLTEpIDo6IExpc3QucmVtb3ZlX2Fzc3EgaSBtYXJrcy5NYXJrcy5tYXJrcyl9XSByZW1cbiAgfCBQbWFyayBfIC0+XG4gICAgQ3NldC5wcmVwZW5kIGFsbF9jaGFycyBbRS5UTWF0Y2ggbWFya3NdIHJlbVxuICB8IEVyYXNlIChiLCBlKSAtPlxuICAgIENzZXQucHJlcGVuZCBhbGxfY2hhcnNcbiAgICAgIFtFLlRNYXRjaCB7bWFya3Mgd2l0aCBNYXJrcy5tYXJrcyA9IChyZW1vdmVfbWFya3MgYiBlIChmaWx0ZXJfbWFya3MgYiBlIG1hcmtzKS5NYXJrcy5tYXJrcyl9XSByZW1cbiAgfCBCZWZvcmUgY2F0JyAtPlxuICAgIENzZXQucHJlcGVuZCAoTGlzdC5hc3NxIGNhdCcgY2F0ZWdvcmllcykgW0UuVE1hdGNoIG1hcmtzXSByZW1cbiAgfCBBZnRlciBjYXQnIC0+XG4gICAgaWYgQ2F0ZWdvcnkuaW50ZXJzZWN0IGNhdCBjYXQnIHRoZW4gQ3NldC5wcmVwZW5kIGFsbF9jaGFycyBbRS5UTWF0Y2ggbWFya3NdIHJlbSBlbHNlIHJlbVxuXG5hbmQgZGVyaXZfMiBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgbCByZW0gPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAgICAgLT4gcmVtXG4gIHwgeSA6OiByIC0+IGRlcml2XzEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgbWFya3MgY2F0IHlcbiAgICAgICAgICAgICAgICAoZGVyaXZfMiBhbGxfY2hhcnMgY2F0ZWdvcmllcyBtYXJrcyBjYXQgciByZW0pXG5cbmFuZCBkZXJpdl9zZXEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgY2F0IGtpbmQgeSB6IHJlbSA9XG4gIGlmXG4gICAgTGlzdC5leGlzdHNcbiAgICAgIChmdW4gKF9zLCB4bCkgLT5cbiAgICAgICAgIExpc3QuZXhpc3RzIChmdW5jdGlvbiBFLlRNYXRjaCBfIC0+IHRydWUgfCBfIC0+IGZhbHNlKSB4bClcbiAgICAgIHlcbiAgdGhlblxuICAgIGxldCB6JyA9IGRlcml2XzEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgTWFya3MuZW1wdHkgY2F0IHogWyhhbGxfY2hhcnMsIFtdKV0gaW5cbiAgICBMaXN0LmZvbGRfcmlnaHRcbiAgICAgIChmdW4gKHMsIHkpIHJlbSAtPlxuICAgICAgICAgbWF0Y2hcbiAgICAgICAgICAgZmlyc3QgKGZ1bmN0aW9uIEUuVE1hdGNoIG1hcmtzIC0+IFNvbWUgbWFya3MgfCBfIC0+IE5vbmUpXG4gICAgICAgICAgICAgeVxuICAgICAgICAgd2l0aFxuICAgICAgICAgICBOb25lIC0+XG4gICAgICAgICAgIENzZXQucHJlcGVuZCBzIChFLnRzZXEga2luZCB5IHogW10pIHJlbVxuICAgICAgICAgfCBTb21lIG1hcmtzIC0+XG4gICAgICAgICAgIGxldCB6JycgPSBwcmVwZW5kX21hcmtzIG1hcmtzIHonIGluXG4gICAgICAgICAgIG1hdGNoIGtpbmQgd2l0aFxuICAgICAgICAgICAgIGBMb25nZXN0IC0+XG4gICAgICAgICAgICAgQ3NldC5wcmVwZW5kIHMgKEUudHNlcSBraW5kIChyZW1vdmVfbWF0Y2hlcyB5KSB6IFtdKSAoXG4gICAgICAgICAgICAgICBwcmVwZW5kX2Rlcml2IChyZXN0cmljdCBzIHonJykgcmVtKVxuICAgICAgICAgICB8IGBTaG9ydGVzdCAtPlxuICAgICAgICAgICAgIHByZXBlbmRfZGVyaXYgKHJlc3RyaWN0IHMgeicnKSAoXG4gICAgICAgICAgICAgICBDc2V0LnByZXBlbmQgcyAoRS50c2VxIGtpbmQgKHJlbW92ZV9tYXRjaGVzIHkpIHogW10pIHJlbSlcbiAgICAgICAgICAgfCBgRmlyc3QgLT5cbiAgICAgICAgICAgICBsZXQgKHknLCB5JycpID0gc3BsaXRfYXRfbWF0Y2ggeSBpblxuICAgICAgICAgICAgIENzZXQucHJlcGVuZCBzIChFLnRzZXEga2luZCB5JyB6IFtdKSAoXG4gICAgICAgICAgICAgICBwcmVwZW5kX2Rlcml2IChyZXN0cmljdCBzIHonJykgKFxuICAgICAgICAgICAgICAgICBDc2V0LnByZXBlbmQgcyAoRS50c2VxIGtpbmQgeScnIHogW10pIHJlbSkpKVxuICAgICAgeSByZW1cbiAgZWxzZVxuICAgIExpc3QuZm9sZF9yaWdodFxuICAgICAgKGZ1biAocywgeGwpIHJlbSAtPiBDc2V0LnByZXBlbmQgcyAoRS50c2VxIGtpbmQgeGwgeiBbXSkgcmVtKSB5IHJlbVxuXG5sZXQgcmVjIGRlcml2XzMgYWxsX2NoYXJzIGNhdGVnb3JpZXMgY2F0IHggcmVtID1cbiAgbWF0Y2ggeCB3aXRoXG4gICAgRS5UU2VxICh5LCB6LCBraW5kKSAtPlxuICAgIGxldCB5JyA9IGRlcml2XzQgYWxsX2NoYXJzIGNhdGVnb3JpZXMgY2F0IHkgWyhhbGxfY2hhcnMsIFtdKV0gaW5cbiAgICBkZXJpdl9zZXEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgY2F0IGtpbmQgeScgeiByZW1cbiAgfCBFLlRFeHAgKG1hcmtzLCBlKSAtPlxuICAgIGRlcml2XzEgYWxsX2NoYXJzIGNhdGVnb3JpZXMgbWFya3MgY2F0IGUgcmVtXG4gIHwgRS5UTWF0Y2ggXyAtPlxuICAgIENzZXQucHJlcGVuZCBhbGxfY2hhcnMgW3hdIHJlbVxuXG5hbmQgZGVyaXZfNCBhbGxfY2hhcnMgY2F0ZWdvcmllcyBjYXQgbCByZW0gPVxuICBtYXRjaCBsIHdpdGhcbiAgICBbXSAgICAgLT4gcmVtXG4gIHwgeSA6OiByIC0+IGRlcml2XzMgYWxsX2NoYXJzIGNhdGVnb3JpZXMgY2F0IHlcbiAgICAgICAgICAgICAgICAoZGVyaXZfNCBhbGxfY2hhcnMgY2F0ZWdvcmllcyBjYXQgciByZW0pXG5cbmxldCBkZXJpdiB0YmxfcmVmIGFsbF9jaGFycyBjYXRlZ29yaWVzIHN0ID1cbiAgbGV0IGRlciA9IGRlcml2XzQgYWxsX2NoYXJzIGNhdGVnb3JpZXMgc3QuU3RhdGUuY2F0ZWdvcnkgc3QuU3RhdGUuZGVzY1xuICAgICAgWyhhbGxfY2hhcnMsIFtdKV0gaW5cbiAgc2ltcGxfdHIgKFxuICAgIExpc3QuZm9sZF9yaWdodCAoZnVuIChzLCBleHByKSByZW0gLT5cbiAgICAgICAgbGV0IChleHByJywgXykgPSByZW1vdmVfZHVwbGljYXRlcyBbXSBleHByIGVwc19leHByIGluXG4oKlxuRm9ybWF0LmVwcmludGYgXCJAWzwzPkBbJWFAXTogJWEgLyAlYUBdQC5cIiBDc2V0LnByaW50IHMgcHJpbnRfc3RhdGUgZXhwciBwcmludF9zdGF0ZSBleHByJztcbiopXG4gICAgICAgIGxldCBpZHggPSBmcmVlX2luZGV4IHRibF9yZWYgZXhwcicgaW5cbiAgICAgICAgbGV0IGV4cHInJyA9IHNldF9pZHggaWR4IGV4cHInIGluXG4gICAgICAgIExpc3QuZm9sZF9yaWdodCAoZnVuIChjYXQnLCBzJykgcmVtIC0+XG4gICAgICAgICAgICBsZXQgcycnID0gQ3NldC5pbnRlciBzIHMnIGluXG4gICAgICAgICAgICBpZiBDc2V0LmlzX2VtcHR5IHMnJ1xuICAgICAgICAgICAgdGhlbiByZW1cbiAgICAgICAgICAgIGVsc2UgKHMnJywgU3RhdGUubWsgaWR4IGNhdCcgZXhwcicnKSA6OiByZW0pXG4gICAgICAgICAgY2F0ZWdvcmllcyByZW0pIGRlciBbXSlcblxuKCoqKiopXG5cbmxldCBmbGF0dGVuX21hdGNoIG0gPVxuICBsZXQgbWEgPSBMaXN0LmZvbGRfbGVmdCAoZnVuIG1hIChpLCBfKSAtPiBtYXggbWEgaSkgKC0xKSBtIGluXG4gIGxldCByZXMgPSBBcnJheS5tYWtlIChtYSArIDEpICgtMSkgaW5cbiAgTGlzdC5pdGVyIChmdW4gKGksIHYpIC0+IHJlcy4oaSkgPC0gdikgbTtcbiAgcmVzXG5cbmxldCBzdGF0dXMgcyA9XG4gIG1hdGNoIHMuU3RhdGUuc3RhdHVzIHdpdGhcbiAgICBTb21lIHN0IC0+XG4gICAgc3RcbiAgfCBOb25lIC0+XG4gICAgbGV0IHN0ID1cbiAgICAgIG1hdGNoIHMuU3RhdGUuZGVzYyB3aXRoXG4gICAgICAgIFtdICAgICAgICAgICAgICAtPiBGYWlsZWRcbiAgICAgIHwgRS5UTWF0Y2ggbSA6OiBfIC0+IE1hdGNoIChmbGF0dGVuX21hdGNoIG0uTWFya3MubWFya3MsIG0uTWFya3MucG1hcmtzKVxuICAgICAgfCBfICAgICAgICAgICAgICAgLT4gUnVubmluZ1xuICAgIGluXG4gICAgcy5TdGF0ZS5zdGF0dXMgPC0gU29tZSBzdDtcbiAgICBzdFxuIiwiKCogSW4gcmVhbGl0eSwgdGhpcyBjYW4gcmVhbGx5IGJlIHJlcHJlc2VudGVkIGFzIGEgYm9vbCBhcnJheS5cblxuICAgVGhlIHJlcHJlc2VudGF0aW9uIGlzIGJlc3QgdGhvdWdodCBvZiBhcyBhIGxpc3Qgb2YgYWxsIGNoYXJzIGFsb25nIHdpdGggYVxuICAgZmxhZzpcblxuICAgKGEsIDApLCAoYiwgMSksIChjLCAwKSwgKGQsIDApLCAuLi5cblxuICAgY2hhcmFjdGVycyBiZWxvbmdpbmcgdG8gdGhlIHNhbWUgY29sb3IgYXJlIHJlcHJlc2VudGVkIGJ5IHNlcXVuY2VzIG9mXG4gICBjaGFyYWN0ZXJzIHdpdGggdGhlIGZsYWcgc2V0IHRvIDAuXG4qKVxuXG50eXBlIHQgPSBCeXRlcy50XG5cbmxldCBtYWtlICgpID0gQnl0ZXMubWFrZSAyNTcgJ1xcMDAwJ1xuXG5sZXQgZmxhdHRlbiBjbSA9XG4gIGxldCBjID0gQnl0ZXMuY3JlYXRlIDI1NiBpblxuICBsZXQgY29sb3JfcmVwciA9IEJ5dGVzLmNyZWF0ZSAyNTYgaW5cbiAgbGV0IHYgPSByZWYgMCBpblxuICBCeXRlcy5zZXQgYyAwICdcXDAwMCc7XG4gIEJ5dGVzLnNldCBjb2xvcl9yZXByIDAgJ1xcMDAwJztcbiAgZm9yIGkgPSAxIHRvIDI1NSBkb1xuICAgIGlmIEJ5dGVzLmdldCBjbSBpIDw+ICdcXDAwMCcgdGhlbiBpbmNyIHY7XG4gICAgQnl0ZXMuc2V0IGMgaSAoQ2hhci5jaHIgIXYpO1xuICAgIEJ5dGVzLnNldCBjb2xvcl9yZXByICF2IChDaGFyLmNociBpKVxuICBkb25lO1xuICAoQnl0ZXMudW5zYWZlX3RvX3N0cmluZyBjLCBCeXRlcy5zdWJfc3RyaW5nIGNvbG9yX3JlcHIgMCAoIXYgKyAxKSwgIXYgKyAxKVxuXG4oKiBtYXJrIGFsbCB0aGUgZW5kcG9pbnRzIG9mIHRoZSBpbnRlcnZhbHMgb2YgdGhlIGNoYXIgc2V0IHdpdGggdGhlIDEgYnl0ZSAqKVxubGV0IHNwbGl0IHMgY20gPVxuICBDc2V0Lml0ZXIgcyB+ZjooZnVuIGkgaiAtPlxuICAgICAgQnl0ZXMuc2V0IGNtIGkgJ1xcMDAxJztcbiAgICAgIEJ5dGVzLnNldCBjbSAoaiArIDEpICdcXDAwMSc7XG4gICAgKVxuIiwiKCogUmVzdWx0IG9mIGEgc3VjY2Vzc2Z1bCBtYXRjaC4gKilcbnR5cGUgdCA9XG4gIHsgcyA6IHN0cmluZ1xuICA7IG1hcmtzIDogQXV0b21hdGEubWFya19pbmZvc1xuICA7IHBtYXJrcyA6IFBtYXJrLlNldC50XG4gIDsgZ3BvcyA6IGludCBhcnJheVxuICA7IGdjb3VudCA6IGludFxuICB9XG5cbmxldCBvZmZzZXQgdCBpID1cbiAgaWYgMiAqIGkgKyAxID49IEFycmF5Lmxlbmd0aCB0Lm1hcmtzIHRoZW4gcmFpc2UgTm90X2ZvdW5kO1xuICBsZXQgbTEgPSB0Lm1hcmtzLigyICogaSkgaW5cbiAgaWYgbTEgPSAtMSB0aGVuIHJhaXNlIE5vdF9mb3VuZDtcbiAgbGV0IHAxID0gdC5ncG9zLihtMSkgaW5cbiAgbGV0IHAyID0gdC5ncG9zLih0Lm1hcmtzLigyICogaSArIDEpKSBpblxuICAocDEsIHAyKVxuXG5sZXQgZ2V0IHQgaSA9XG4gIGxldCAocDEsIHAyKSA9IG9mZnNldCB0IGkgaW5cbiAgU3RyaW5nLnN1YiB0LnMgcDEgKHAyIC0gcDEpXG5cbmxldCBzdGFydCBzdWJzIGkgPSBmc3QgKG9mZnNldCBzdWJzIGkpXG5cbmxldCBzdG9wIHN1YnMgaSA9IHNuZCAob2Zmc2V0IHN1YnMgaSlcblxubGV0IHRlc3QgdCBpID1cbiAgaWYgMiAqIGkgPj0gQXJyYXkubGVuZ3RoIHQubWFya3MgdGhlblxuICAgIGZhbHNlXG4gIGVsc2VcbiAgICBsZXQgaWR4ID0gdC5tYXJrcy4oMiAqIGkpIGluXG4gICAgaWR4IDw+IC0xXG5cbmxldCBnZXRfb3B0IHQgaSA9XG4gIGlmIHRlc3QgdCBpXG4gIHRoZW4gU29tZSAoZ2V0IHQgaSlcbiAgZWxzZSBOb25lXG5cbmxldCBkdW1teV9vZmZzZXQgPSAoLTEsIC0xKVxuXG5sZXQgYWxsX29mZnNldCB0ID1cbiAgbGV0IHJlcyA9IEFycmF5Lm1ha2UgdC5nY291bnQgZHVtbXlfb2Zmc2V0IGluXG4gIGZvciBpID0gMCB0byBBcnJheS5sZW5ndGggdC5tYXJrcyAvIDIgLSAxIGRvXG4gICAgbGV0IG0xID0gdC5tYXJrcy4oMiAqIGkpIGluXG4gICAgaWYgbTEgPD4gLTEgdGhlbiBiZWdpblxuICAgICAgbGV0IHAxID0gdC5ncG9zLihtMSkgaW5cbiAgICAgIGxldCBwMiA9IHQuZ3Bvcy4odC5tYXJrcy4oMiAqIGkgKyAxKSkgaW5cbiAgICAgIHJlcy4oaSkgPC0gKHAxLCBwMilcbiAgICBlbmRcbiAgZG9uZTtcbiAgcmVzXG5cbmxldCBkdW1teV9zdHJpbmcgPSBcIlwiXG5cbmxldCBhbGwgdCA9XG4gIGxldCByZXMgPSBBcnJheS5tYWtlIHQuZ2NvdW50IGR1bW15X3N0cmluZyBpblxuICBmb3IgaSA9IDAgdG8gQXJyYXkubGVuZ3RoIHQubWFya3MgLyAyIC0gMSBkb1xuICAgIGxldCBtMSA9IHQubWFya3MuKDIgKiBpKSBpblxuICAgIGlmIG0xIDw+IC0xIHRoZW4gYmVnaW5cbiAgICAgIGxldCBwMSA9IHQuZ3Bvcy4obTEpIGluXG4gICAgICBsZXQgcDIgPSB0Lmdwb3MuKHQubWFya3MuKDIgKiBpICsgMSkpIGluXG4gICAgICByZXMuKGkpIDwtIFN0cmluZy5zdWIgdC5zIHAxIChwMiAtIHAxKVxuICAgIGVuZFxuICBkb25lO1xuICByZXNcblxubGV0IHBwIGZtdCB0ID1cbiAgbGV0IG1hdGNoZXMgPVxuICAgIGxldCBvZmZzZXRzID0gYWxsX29mZnNldCB0IGluXG4gICAgbGV0IHN0cnMgPSBhbGwgdCBpblxuICAgIEFycmF5LnRvX2xpc3QgKFxuICAgICAgQXJyYXkuaW5pdCAoQXJyYXkubGVuZ3RoIHN0cnMpIChmdW4gaSAtPiBzdHJzLihpKSwgb2Zmc2V0cy4oaSkpXG4gICAgKSBpblxuICBsZXQgb3BlbiBGbXQgaW5cbiAgbGV0IHBwX21hdGNoIGZtdCAoc3RyLCAoc3RhcnQsIHN0b3ApKSA9XG4gICAgZnByaW50ZiBmbXQgXCJAWyglcyAoJWQgJWQpKUBdXCIgc3RyIHN0YXJ0IHN0b3AgaW5cbiAgc2V4cCBmbXQgXCJHcm91cFwiIChsaXN0IHBwX21hdGNoKSBtYXRjaGVzXG5cbmxldCBuYl9ncm91cHMgdCA9IHQuZ2NvdW50XG4iLCIoKlxuICAgUkUgLSBBIHJlZ3VsYXIgZXhwcmVzc2lvbiBsaWJyYXJ5XG5cbiAgIENvcHlyaWdodCAoQykgMjAwMSBKZXJvbWUgVm91aWxsb25cbiAgIGVtYWlsOiBKZXJvbWUuVm91aWxsb25AcHBzLmp1c3NpZXUuZnJcblxuICAgVGhpcyBsaWJyYXJ5IGlzIGZyZWUgc29mdHdhcmU7IHlvdSBjYW4gcmVkaXN0cmlidXRlIGl0IGFuZC9vclxuICAgbW9kaWZ5IGl0IHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhcyBwdWJsaXNoZWQgYnkgdGhlIEZyZWUgU29mdHdhcmUgRm91bmRhdGlvbiwgd2l0aFxuICAgbGlua2luZyBleGNlcHRpb247IGVpdGhlciB2ZXJzaW9uIDIuMSBvZiB0aGUgTGljZW5zZSwgb3IgKGF0XG4gICB5b3VyIG9wdGlvbikgYW55IGxhdGVyIHZlcnNpb24uXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICAgYnV0IFdJVEhPVVQgQU5ZIFdBUlJBTlRZOyB3aXRob3V0IGV2ZW4gdGhlIGltcGxpZWQgd2FycmFudHkgb2ZcbiAgIE1FUkNIQU5UQUJJTElUWSBvciBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRS4gIFNlZSB0aGUgR05VXG4gICBMZXNzZXIgR2VuZXJhbCBQdWJsaWMgTGljZW5zZSBmb3IgbW9yZSBkZXRhaWxzLlxuXG4gICBZb3Ugc2hvdWxkIGhhdmUgcmVjZWl2ZWQgYSBjb3B5IG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFsb25nIHdpdGggdGhpcyBsaWJyYXJ5OyBpZiBub3QsIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlXG4gICBGb3VuZGF0aW9uLCBJbmMuLCA1MSBGcmFua2xpbiBTdHJlZXQsIEZpZnRoIEZsb29yLCBCb3N0b24sIE1BIDAyMTEwLTEzMDEgVVNBXG4qKVxuXG5sZXQgcmVjIGl0ZXIgbiBmIHYgPSBpZiBuID0gMCB0aGVuIHYgZWxzZSBpdGVyIChuIC0gMSkgZiAoZiB2KVxuXG4oKioqKilcblxubGV0IHVua25vd24gPSAtMlxubGV0IGJyZWFrID0gLTNcblxudHlwZSBtYXRjaF9pbmZvID1cbiAgfCBNYXRjaCBvZiBHcm91cC50XG4gIHwgRmFpbGVkXG4gIHwgUnVubmluZyBvZiB7IG5vX21hdGNoX3N0YXJ0c19iZWZvcmUgOiBpbnQgfVxuXG50eXBlIHN0YXRlID1cbiAgeyBpZHggOiBpbnQ7XG4gICAgKCogSW5kZXggb2YgdGhlIGN1cnJlbnQgcG9zaXRpb24gaW4gdGhlIHBvc2l0aW9uIHRhYmxlLlxuICAgICAgIE5vdCB5ZXQgY29tcHV0ZWQgdHJhbnNpdGlvbnMgcG9pbnQgdG8gYSBkdW1teSBzdGF0ZSB3aGVyZVxuICAgICAgIFtpZHhdIGlzIHNldCB0byBbdW5rbm93bl07XG4gICAgICAgSWYgW2lkeF0gaXMgc2V0IHRvIFticmVha10gZm9yIHN0YXRlcyB0aGF0IGVpdGhlciBhbHdheXNcbiAgICAgICBzdWNjZWVkIG9yIGFsd2F5cyBmYWlsLiAqKVxuICAgIHJlYWxfaWR4IDogaW50O1xuICAgICgqIFRoZSByZWFsIGluZGV4LCBpbiBjYXNlIFtpZHhdIGlzIHNldCB0byBbYnJlYWtdICopXG4gICAgbmV4dCA6IHN0YXRlIGFycmF5O1xuICAgICgqIFRyYW5zaXRpb24gdGFibGUsIGluZGV4ZWQgYnkgY29sb3IgKilcbiAgICBtdXRhYmxlIGZpbmFsIDpcbiAgICAgIChDYXRlZ29yeS50ICpcbiAgICAgICAoQXV0b21hdGEuaWR4ICogQXV0b21hdGEuc3RhdHVzKSkgbGlzdDtcbiAgICAoKiBNYXBwaW5nIGZyb20gdGhlIGNhdGVnb3J5IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0b1xuICAgICAgIC0gdGhlIGluZGV4IHdoZXJlIHRoZSBuZXh0IHBvc2l0aW9uIHNob3VsZCBiZSBzYXZlZFxuICAgICAgIC0gcG9zc2libHksIHRoZSBsaXN0IG9mIG1hcmtzIChhbmQgdGhlIGNvcnJlc3BvbmRpbmcgaW5kaWNlcylcbiAgICAgICAgIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGJlc3QgbWF0Y2ggKilcbiAgICBkZXNjIDogQXV0b21hdGEuU3RhdGUudFxuICAgICgqIERlc2NyaXB0aW9uIG9mIHRoaXMgc3RhdGUgb2YgdGhlIGF1dG9tYXRhICopIH1cblxuKCogQXV0b21hdGEgKGNvbXBpbGVkIHJlZ3VsYXIgZXhwcmVzc2lvbikgKilcbnR5cGUgcmUgPVxuICB7IGluaXRpYWwgOiBBdXRvbWF0YS5leHByO1xuICAgICgqIFRoZSB3aG9sZSByZWd1bGFyIGV4cHJlc3Npb24gKilcbiAgICBtdXRhYmxlIGluaXRpYWxfc3RhdGVzIDogKENhdGVnb3J5LnQgKiBzdGF0ZSkgbGlzdDtcbiAgICAoKiBJbml0aWFsIHN0YXRlcywgaW5kZXhlZCBieSBpbml0aWFsIGNhdGVnb3J5ICopXG4gICAgY29sb3JzIDogc3RyaW5nO1xuICAgICgqIENvbG9yIHRhYmxlICopXG4gICAgY29sb3JfcmVwciA6IHN0cmluZztcbiAgICAoKiBUYWJsZSBmcm9tIGNvbG9ycyB0byBvbmUgY2hhcmFjdGVyIG9mIHRoaXMgY29sb3IgKilcbiAgICBuY29sb3IgOiBpbnQ7XG4gICAgKCogTnVtYmVyIG9mIGNvbG9ycy4gKilcbiAgICBsbmwgOiBpbnQ7XG4gICAgKCogQ29sb3Igb2YgdGhlIGxhc3QgbmV3bGluZS4gLTEgaWYgdW5uZWNlc3NhcnkgKilcbiAgICB0YmwgOiBBdXRvbWF0YS53b3JraW5nX2FyZWE7XG4gICAgKCogVGVtcG9yYXJ5IHRhYmxlIHVzZWQgdG8gY29tcHV0ZSB0aGUgZmlyc3QgYXZhaWxhYmxlIGluZGV4XG4gICAgICAgd2hlbiBjb21wdXRpbmcgYSBuZXcgc3RhdGUgKilcbiAgICBzdGF0ZXMgOiBzdGF0ZSBBdXRvbWF0YS5TdGF0ZS5UYWJsZS50O1xuICAgICgqIFN0YXRlcyBvZiB0aGUgZGV0ZXJtaW5pc3RpYyBhdXRvbWF0YSAqKVxuICAgIGdyb3VwX25hbWVzIDogKHN0cmluZyAqIGludCkgbGlzdDtcbiAgICAoKiBOYW1lZCBncm91cHMgaW4gdGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAqKVxuICAgIGdyb3VwX2NvdW50IDogaW50XG4gICAgKCogTnVtYmVyIG9mIGdyb3VwcyBpbiB0aGUgcmVndWxhciBleHByZXNzaW9uICopIH1cblxubGV0IHBwX3JlIGNoIHJlID0gQXV0b21hdGEucHAgY2ggcmUuaW5pdGlhbFxuXG5sZXQgcHJpbnRfcmUgPSBwcF9yZVxuXG5sZXQgZ3JvdXBfY291bnQgcmUgPSByZS5ncm91cF9jb3VudFxuXG5sZXQgZ3JvdXBfbmFtZXMgcmUgPSByZS5ncm91cF9uYW1lc1xuXG4oKiBJbmZvcm1hdGlvbiB1c2VkIGR1cmluZyBtYXRjaGluZyAqKVxudHlwZSBpbmZvID1cbiAgeyByZSA6IHJlO1xuICAgICgqIFRoZSBhdXRvbWF0YSAqKVxuICAgIGNvbG9ycyA6IHN0cmluZztcbiAgICAoKiBDb2xvciB0YWJsZSAoW3guY29sb3JzID0geC5yZS5jb2xvcnNdKVxuICAgICAgIFNob3J0Y3V0IHVzZWQgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnMgKilcbiAgICBtdXRhYmxlIHBvc2l0aW9ucyA6IGludCBhcnJheTtcbiAgICAoKiBBcnJheSBvZiBtYXJrIHBvc2l0aW9uc1xuICAgICAgIFRoZSBtYXJrIGFyZSBvZmYgYnkgb25lIGZvciBwZXJmb3JtYW5jZSByZWFzb25zICopXG4gICAgcG9zIDogaW50O1xuICAgICgqIFBvc2l0aW9uIHdoZXJlIHRoZSBtYXRjaCBpcyBzdGFydGVkICopXG4gICAgbGFzdCA6IGludFxuICAgICgqIFBvc2l0aW9uIHdoZXJlIHRoZSBtYXRjaCBzaG91bGQgc3RvcCAqKSB9XG5cblxuKCoqKiopXG5cbmxldCBjYXRlZ29yeSByZSB+Y29sb3IgPVxuICBpZiBjb2xvciA9IC0xIHRoZW5cbiAgICBDYXRlZ29yeS5pbmV4aXN0YW50XG4gICAgKCogU3BlY2lhbCBjYXRlZ29yeSBmb3IgdGhlIGxhc3QgbmV3bGluZSAqKVxuICBlbHNlIGlmIGNvbG9yID0gcmUubG5sIHRoZW5cbiAgICBDYXRlZ29yeS4obGFzdG5ld2xpbmUgKysgbmV3bGluZSArKyBub3RfbGV0dGVyKVxuICBlbHNlXG4gICAgQ2F0ZWdvcnkuZnJvbV9jaGFyIChyZS5jb2xvcl9yZXByLltjb2xvcl0pXG5cbigqKioqKVxuXG5sZXQgZHVtbXlfbmV4dCA9IFt8fF1cblxubGV0IHVua25vd25fc3RhdGUgPVxuICB7IGlkeCA9IHVua25vd247IHJlYWxfaWR4ID0gMDtcbiAgICBuZXh0ID0gZHVtbXlfbmV4dDsgZmluYWwgPSBbXTtcbiAgICBkZXNjID0gQXV0b21hdGEuU3RhdGUuZHVtbXkgfVxuXG5sZXQgbWtfc3RhdGUgbmNvbCBkZXNjID1cbiAgbGV0IGJyZWFrX3N0YXRlID1cbiAgICBtYXRjaCBBdXRvbWF0YS5zdGF0dXMgZGVzYyB3aXRoXG4gICAgfCBBdXRvbWF0YS5SdW5uaW5nIC0+IGZhbHNlXG4gICAgfCBBdXRvbWF0YS5GYWlsZWRcbiAgICB8IEF1dG9tYXRhLk1hdGNoIF8gLT4gdHJ1ZVxuICBpblxuICB7IGlkeCA9IGlmIGJyZWFrX3N0YXRlIHRoZW4gYnJlYWsgZWxzZSBkZXNjLkF1dG9tYXRhLlN0YXRlLmlkeDtcbiAgICByZWFsX2lkeCA9IGRlc2MuQXV0b21hdGEuU3RhdGUuaWR4O1xuICAgIG5leHQgPSBpZiBicmVha19zdGF0ZSB0aGVuIGR1bW15X25leHQgZWxzZSBBcnJheS5tYWtlIG5jb2wgdW5rbm93bl9zdGF0ZTtcbiAgICBmaW5hbCA9IFtdO1xuICAgIGRlc2MgfVxuXG5sZXQgZmluZF9zdGF0ZSByZSBkZXNjID1cbiAgdHJ5XG4gICAgQXV0b21hdGEuU3RhdGUuVGFibGUuZmluZCByZS5zdGF0ZXMgZGVzY1xuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIGxldCBzdCA9IG1rX3N0YXRlIHJlLm5jb2xvciBkZXNjIGluXG4gICAgQXV0b21hdGEuU3RhdGUuVGFibGUuYWRkIHJlLnN0YXRlcyBkZXNjIHN0O1xuICAgIHN0XG5cbigqKioqIE1hdGNoIHdpdGggbWFya3MgKioqKilcblxubGV0IGRlbHRhIGluZm8gY2F0IH5jb2xvciBzdCA9XG4gIGxldCBkZXNjID0gQXV0b21hdGEuZGVsdGEgaW5mby5yZS50YmwgY2F0IGNvbG9yIHN0LmRlc2MgaW5cbiAgbGV0IGxlbiA9IEFycmF5Lmxlbmd0aCBpbmZvLnBvc2l0aW9ucyBpblxuICBpZiBkZXNjLkF1dG9tYXRhLlN0YXRlLmlkeCA9IGxlbiAmJiBsZW4gPiAwIHRoZW4gYmVnaW5cbiAgICBsZXQgcG9zID0gaW5mby5wb3NpdGlvbnMgaW5cbiAgICBpbmZvLnBvc2l0aW9ucyA8LSBBcnJheS5tYWtlICgyICogbGVuKSAwO1xuICAgIEFycmF5LmJsaXQgcG9zIDAgaW5mby5wb3NpdGlvbnMgMCBsZW5cbiAgZW5kO1xuICBkZXNjXG5cbmxldCB2YWxpZGF0ZSBpbmZvIChzOnN0cmluZykgfnBvcyBzdCA9XG4gIGxldCBjb2xvciA9IENoYXIuY29kZSAoaW5mby5jb2xvcnMuW0NoYXIuY29kZSBzLltwb3NdXSkgaW5cbiAgbGV0IGNhdCA9IGNhdGVnb3J5IGluZm8ucmUgfmNvbG9yIGluXG4gIGxldCBkZXNjJyA9IGRlbHRhIGluZm8gY2F0IH5jb2xvciBzdCBpblxuICBsZXQgc3QnID0gZmluZF9zdGF0ZSBpbmZvLnJlIGRlc2MnIGluXG4gIHN0Lm5leHQuKGNvbG9yKSA8LSBzdCdcblxubGV0IHJlYyBsb29wIGluZm8gcyB+cG9zIHN0ID1cbiAgaWYgcG9zIDwgaW5mby5sYXN0IHRoZW5cbiAgICBsZXQgc3QnID0gc3QubmV4dC4oQ2hhci5jb2RlIGluZm8uY29sb3JzLltDaGFyLmNvZGUgcy5bcG9zXV0pIGluXG4gICAgbGV0IGlkeCA9IHN0Jy5pZHggaW5cbiAgICBpZiBpZHggPj0gMCB0aGVuIGJlZ2luXG4gICAgICBpbmZvLnBvc2l0aW9ucy4oaWR4KSA8LSBwb3M7XG4gICAgICBsb29wIGluZm8gcyB+cG9zOihwb3MgKyAxKSBzdCdcbiAgICBlbmQgZWxzZSBpZiBpZHggPSBicmVhayB0aGVuIGJlZ2luXG4gICAgICBpbmZvLnBvc2l0aW9ucy4oc3QnLnJlYWxfaWR4KSA8LSBwb3M7XG4gICAgICBzdCdcbiAgICBlbmQgZWxzZSBiZWdpbiAoKiBVbmtub3duICopXG4gICAgICB2YWxpZGF0ZSBpbmZvIHMgfnBvcyBzdDtcbiAgICAgIGxvb3AgaW5mbyBzIH5wb3Mgc3RcbiAgICBlbmRcbiAgZWxzZVxuICAgIHN0XG5cbmxldCByZWMgbG9vcF9ub19tYXJrIGluZm8gcyB+cG9zIH5sYXN0IHN0ID1cbiAgaWYgcG9zIDwgbGFzdCB0aGVuXG4gICAgbGV0IHN0JyA9IHN0Lm5leHQuKENoYXIuY29kZSBpbmZvLmNvbG9ycy5bQ2hhci5jb2RlIHMuW3Bvc11dKSBpblxuICAgIGlmIHN0Jy5pZHggPj0gMCB0aGVuXG4gICAgICBsb29wX25vX21hcmsgaW5mbyBzIH5wb3M6KHBvcyArIDEpIH5sYXN0IHN0J1xuICAgIGVsc2UgaWYgc3QnLmlkeCA9IGJyZWFrIHRoZW5cbiAgICAgIHN0J1xuICAgIGVsc2UgYmVnaW4gKCogVW5rbm93biAqKVxuICAgICAgdmFsaWRhdGUgaW5mbyBzIH5wb3Mgc3Q7XG4gICAgICBsb29wX25vX21hcmsgaW5mbyBzIH5wb3Mgfmxhc3Qgc3RcbiAgICBlbmRcbiAgZWxzZVxuICAgIHN0XG5cbmxldCBmaW5hbCBpbmZvIHN0IGNhdCA9XG4gIHRyeVxuICAgIExpc3QuYXNzcSBjYXQgc3QuZmluYWxcbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICBsZXQgc3QnID0gZGVsdGEgaW5mbyBjYXQgfmNvbG9yOigtMSkgc3QgaW5cbiAgICBsZXQgcmVzID0gKHN0Jy5BdXRvbWF0YS5TdGF0ZS5pZHgsIEF1dG9tYXRhLnN0YXR1cyBzdCcpIGluXG4gICAgc3QuZmluYWwgPC0gKGNhdCwgcmVzKSA6OiBzdC5maW5hbDtcbiAgICByZXNcblxubGV0IGZpbmRfaW5pdGlhbF9zdGF0ZSByZSBjYXQgPVxuICB0cnlcbiAgICBMaXN0LmFzc3EgY2F0IHJlLmluaXRpYWxfc3RhdGVzXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgbGV0IHN0ID0gZmluZF9zdGF0ZSByZSAoQXV0b21hdGEuU3RhdGUuY3JlYXRlIGNhdCByZS5pbml0aWFsKSBpblxuICAgIHJlLmluaXRpYWxfc3RhdGVzIDwtIChjYXQsIHN0KSA6OiByZS5pbml0aWFsX3N0YXRlcztcbiAgICBzdFxuXG5sZXQgZ2V0X2NvbG9yIHJlIChzOnN0cmluZykgcG9zID1cbiAgaWYgcG9zIDwgMCB0aGVuXG4gICAgLTFcbiAgZWxzZVxuICAgIGxldCBzbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gICAgaWYgcG9zID49IHNsZW4gdGhlblxuICAgICAgLTFcbiAgICBlbHNlIGlmIHBvcyA9IHNsZW4gLSAxICYmIHJlLmxubCA8PiAtMSAmJiBzLltwb3NdID0gJ1xcbicgdGhlblxuICAgICAgKCogU3BlY2lhbCBjYXNlIGZvciB0aGUgbGFzdCBuZXdsaW5lICopXG4gICAgICByZS5sbmxcbiAgICBlbHNlXG4gICAgICBDaGFyLmNvZGUgcmUuY29sb3JzLltDaGFyLmNvZGUgcy5bcG9zXV1cblxubGV0IHJlYyBoYW5kbGVfbGFzdF9uZXdsaW5lIGluZm8gfnBvcyBzdCB+Z3JvdXBzID1cbiAgbGV0IHN0JyA9IHN0Lm5leHQuKGluZm8ucmUubG5sKSBpblxuICBpZiBzdCcuaWR4ID49IDAgdGhlbiBiZWdpblxuICAgIGlmIGdyb3VwcyB0aGVuIGluZm8ucG9zaXRpb25zLihzdCcuaWR4KSA8LSBwb3M7XG4gICAgc3QnXG4gIGVuZCBlbHNlIGlmIHN0Jy5pZHggPSBicmVhayB0aGVuIGJlZ2luXG4gICAgaWYgZ3JvdXBzIHRoZW4gaW5mby5wb3NpdGlvbnMuKHN0Jy5yZWFsX2lkeCkgPC0gcG9zO1xuICAgIHN0J1xuICBlbmQgZWxzZSBiZWdpbiAoKiBVbmtub3duICopXG4gICAgbGV0IGNvbG9yID0gaW5mby5yZS5sbmwgaW5cbiAgICBsZXQgcmVhbF9jID0gQ2hhci5jb2RlIGluZm8uY29sb3JzLltDaGFyLmNvZGUgJ1xcbiddIGluXG4gICAgbGV0IGNhdCA9IGNhdGVnb3J5IGluZm8ucmUgfmNvbG9yIGluXG4gICAgbGV0IGRlc2MnID0gZGVsdGEgaW5mbyBjYXQgfmNvbG9yOnJlYWxfYyBzdCBpblxuICAgIGxldCBzdCcgPSBmaW5kX3N0YXRlIGluZm8ucmUgZGVzYycgaW5cbiAgICBzdC5uZXh0Lihjb2xvcikgPC0gc3QnO1xuICAgIGhhbmRsZV9sYXN0X25ld2xpbmUgaW5mbyB+cG9zIHN0IH5ncm91cHNcbiAgZW5kXG5cbmxldCByZWMgc2Nhbl9zdHIgaW5mbyAoczpzdHJpbmcpIGluaXRpYWxfc3RhdGUgfmdyb3VwcyA9XG4gIGxldCBwb3MgPSBpbmZvLnBvcyBpblxuICBsZXQgbGFzdCA9IGluZm8ubGFzdCBpblxuICBpZiAobGFzdCA9IFN0cmluZy5sZW5ndGggc1xuICAgICAgJiYgaW5mby5yZS5sbmwgPD4gLTFcbiAgICAgICYmIGxhc3QgPiBwb3NcbiAgICAgICYmIFN0cmluZy5nZXQgcyAobGFzdCAtIDEpID0gJ1xcbicpXG4gIHRoZW4gYmVnaW5cbiAgICBsZXQgaW5mbyA9IHsgaW5mbyB3aXRoIGxhc3QgPSBsYXN0IC0gMSB9IGluXG4gICAgbGV0IHN0ID0gc2Nhbl9zdHIgaW5mbyBzIGluaXRpYWxfc3RhdGUgfmdyb3VwcyBpblxuICAgIGlmIHN0LmlkeCA9IGJyZWFrIHRoZW5cbiAgICAgIHN0XG4gICAgZWxzZVxuICAgICAgaGFuZGxlX2xhc3RfbmV3bGluZSBpbmZvIH5wb3M6KGxhc3QgLSAxKSBzdCB+Z3JvdXBzXG4gIGVuZCBlbHNlIGlmIGdyb3VwcyB0aGVuXG4gICAgbG9vcCBpbmZvIHMgfnBvcyBpbml0aWFsX3N0YXRlXG4gIGVsc2VcbiAgICBsb29wX25vX21hcmsgaW5mbyBzIH5wb3Mgfmxhc3QgaW5pdGlhbF9zdGF0ZVxuXG4oKiBUaGlzIGZ1bmN0aW9uIGFkZHMgYSBmaW5hbCBib3VuZGFyeSBjaGVjayBvbiB0aGUgaW5wdXQuXG4gICBUaGlzIGlzIHVzZWZ1bCB0byBpbmRpY2F0ZSB0aGF0IHRoZSBvdXRwdXQgZmFpbGVkIGJlY2F1c2VcbiAgIG9mIGluc3VmZmljaWVudCBpbnB1dCwgb3IgdG8gdmVyaWZ5IHRoYXQgdGhlIG91dHB1dCBhY3R1YWxseVxuICAgbWF0Y2hlcyBmb3IgcmVnZXggdGhhdCBoYXZlIGJvdW5kYXJ5IGNvbmRpdGlvbnMgd2l0aCByZXNwZWN0XG4gICB0byB0aGUgaW5wdXQgc3RyaW5nLlxuICopXG5sZXQgZmluYWxfYm91bmRhcnlfY2hlY2sgfmxhc3QgfnNsZW4gcmUgcyB+aW5mbyB+c3Qgfmdyb3VwcyA9XG4gIGxldCBmaW5hbF9jYXQgPVxuICAgIGlmIGxhc3QgPSBzbGVuIHRoZW5cbiAgICAgIENhdGVnb3J5LihzZWFyY2hfYm91bmRhcnkgKysgaW5leGlzdGFudClcbiAgICBlbHNlXG4gICAgICBDYXRlZ29yeS4oc2VhcmNoX2JvdW5kYXJ5ICsrIGNhdGVnb3J5IHJlIH5jb2xvcjooZ2V0X2NvbG9yIHJlIHMgbGFzdCkpXG4gIGluXG4gIGxldCAoaWR4LCByZXMpID0gZmluYWwgaW5mbyBzdCBmaW5hbF9jYXQgaW5cbiAgKG1hdGNoIGdyb3VwcywgcmVzIHdpdGhcbiAgfCB0cnVlLCBNYXRjaCBfIC0+IGluZm8ucG9zaXRpb25zLihpZHgpIDwtIGxhc3RcbiAgfCBfIC0+ICgpKTtcbiAgcmVzXG5cbmxldCBtYXRjaF9zdHIgfmdyb3VwcyB+cGFydGlhbCByZSBzIH5wb3MgfmxlbiA9XG4gIGxldCBzbGVuID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBsYXN0ID0gaWYgbGVuID0gLTEgdGhlbiBzbGVuIGVsc2UgcG9zICsgbGVuIGluXG4gIGxldCBpbmZvID1cbiAgICB7IHJlIDsgY29sb3JzID0gcmUuY29sb3JzOyBwb3MgOyBsYXN0XG4gICAgOyBwb3NpdGlvbnMgPVxuICAgICAgICBpZiBncm91cHMgdGhlbiBiZWdpblxuICAgICAgICAgIGxldCBuID0gQXV0b21hdGEuaW5kZXhfY291bnQgcmUudGJsICsgMSBpblxuICAgICAgICAgIGlmIG4gPD0gMTAgdGhlblxuICAgICAgICAgICAgW3wwOzA7MDswOzA7MDswOzA7MDswfF1cbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBBcnJheS5tYWtlIG4gMFxuICAgICAgICBlbmQgZWxzZVxuICAgICAgICAgIFt8fF0gfVxuICBpblxuICBsZXQgaW5pdGlhbF9jYXQgPVxuICAgIGlmIHBvcyA9IDAgdGhlblxuICAgICAgQ2F0ZWdvcnkuKHNlYXJjaF9ib3VuZGFyeSArKyBpbmV4aXN0YW50KVxuICAgIGVsc2VcbiAgICAgIENhdGVnb3J5LihzZWFyY2hfYm91bmRhcnlcbiAgICAgICAgICAgICAgICArKyBjYXRlZ29yeSByZSB+Y29sb3I6KGdldF9jb2xvciByZSBzIChwb3MgLSAxKSkpXG4gIGluXG4gIGxldCBpbml0aWFsX3N0YXRlID0gZmluZF9pbml0aWFsX3N0YXRlIHJlIGluaXRpYWxfY2F0IGluXG4gIGxldCBzdCA9IHNjYW5fc3RyIGluZm8gcyBpbml0aWFsX3N0YXRlIH5ncm91cHMgaW5cbiAgbGV0IHJlcyA9XG4gICAgaWYgc3QuaWR4ID0gYnJlYWsgfHwgKHBhcnRpYWwgJiYgbm90IGdyb3VwcykgdGhlblxuICAgICAgQXV0b21hdGEuc3RhdHVzIHN0LmRlc2NcbiAgICBlbHNlIGlmIHBhcnRpYWwgJiYgZ3JvdXBzIHRoZW5cbiAgICAgIG1hdGNoIEF1dG9tYXRhLnN0YXR1cyBzdC5kZXNjIHdpdGhcbiAgICAgIHwgTWF0Y2ggXyB8IEZhaWxlZCBhcyBzdGF0dXMgLT4gc3RhdHVzXG4gICAgICB8IFJ1bm5pbmcgLT5cbiAgICAgICAgKCogVGhpcyBjb3VsZCBiZSBiZWNhdXNlIGl0J3Mgc3RpbGwgbm90IGZ1bGx5IG1hdGNoZWQsIG9yIGl0XG4gICAgICAgICAgIGNvdWxkIGJlIHRoYXQgYmVjYXVzZSB3ZSBuZWVkIHRvIHJ1biBzcGVjaWFsIGVuZCBvZiBpbnB1dFxuICAgICAgICAgICBjaGVja3MuICopXG4gICAgICAgIChtYXRjaCBmaW5hbF9ib3VuZGFyeV9jaGVjayB+bGFzdCB+c2xlbiByZSBzIH5pbmZvIH5zdCB+Z3JvdXBzIHdpdGhcbiAgICAgICAgIHwgTWF0Y2ggXyBhcyBzdGF0dXMgLT4gc3RhdHVzXG4gICAgICAgICB8IEZhaWxlZCB8IFJ1bm5pbmcgLT5cbiAgICAgICAgICAgKCogQSBmYWlsdXJlIGhlcmUganVzdCBtZWFucyB0aGF0IHdlIG5lZWQgbW9yZSBkYXRhLCBpLmUuXG4gICAgICAgICAgICAgIGl0J3MgYSBwYXJ0aWFsIG1hdGNoLiAqKVxuICAgICAgICAgICBSdW5uaW5nKVxuICAgIGVsc2UgZmluYWxfYm91bmRhcnlfY2hlY2sgfmxhc3QgfnNsZW4gcmUgcyB+aW5mbyB+c3Qgfmdyb3Vwc1xuICBpblxuICBtYXRjaCByZXMgd2l0aFxuICAgIEF1dG9tYXRhLk1hdGNoIChtYXJrcywgcG1hcmtzKSAtPlxuICAgIE1hdGNoIHsgcyA7IG1hcmtzOyBwbWFya3MgOyBncG9zID0gaW5mby5wb3NpdGlvbnM7IGdjb3VudCA9IHJlLmdyb3VwX2NvdW50fVxuICB8IEF1dG9tYXRhLkZhaWxlZCAtPiBGYWlsZWRcbiAgfCBBdXRvbWF0YS5SdW5uaW5nIC0+XG4gICAgbGV0IG5vX21hdGNoX3N0YXJ0c19iZWZvcmUgPSBpZiBncm91cHMgdGhlbiBpbmZvLnBvc2l0aW9ucy4oMCkgZWxzZSAwIGluXG4gICAgUnVubmluZyB7IG5vX21hdGNoX3N0YXJ0c19iZWZvcmUgfVxuXG5sZXQgbWtfcmUgfmluaXRpYWwgfmNvbG9ycyB+Y29sb3JfcmVwciB+bmNvbG9yIH5sbmwgfmdyb3VwX25hbWVzIH5ncm91cF9jb3VudCA9XG4gIHsgaW5pdGlhbCA7XG4gICAgaW5pdGlhbF9zdGF0ZXMgPSBbXTtcbiAgICBjb2xvcnM7XG4gICAgY29sb3JfcmVwcjtcbiAgICBuY29sb3I7XG4gICAgbG5sO1xuICAgIHRibCA9IEF1dG9tYXRhLmNyZWF0ZV93b3JraW5nX2FyZWEgKCk7XG4gICAgc3RhdGVzID0gQXV0b21hdGEuU3RhdGUuVGFibGUuY3JlYXRlIDk3O1xuICAgIGdyb3VwX25hbWVzO1xuICAgIGdyb3VwX2NvdW50IH1cblxuKCoqKiogQ2hhcmFjdGVyIHNldHMgKioqKilcblxubGV0IGNzZXEgYyBjJyA9IENzZXQuc2VxIChDaGFyLmNvZGUgYykgKENoYXIuY29kZSBjJylcbmxldCBjYWRkIGMgcyA9IENzZXQuYWRkIChDaGFyLmNvZGUgYykgc1xuXG5sZXQgdHJhbnNfc2V0IGNhY2hlIGNtIHMgPVxuICBtYXRjaCBDc2V0Lm9uZV9jaGFyIHMgd2l0aFxuICB8IFNvbWUgaSAtPiBDc2V0LmNzaW5nbGUgY20uW2ldXG4gIHwgTm9uZSAtPlxuICAgIGxldCB2ID0gKENzZXQuaGFzaF9yZWMgcywgcykgaW5cbiAgICB0cnlcbiAgICAgIENzZXQuQ1NldE1hcC5maW5kIHYgIWNhY2hlXG4gICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgIGxldCBsID1cbiAgICAgICAgQ3NldC5mb2xkX3JpZ2h0XG4gICAgICAgICAgc1xuICAgICAgICAgIH5mOihmdW4gKGksIGopIGwgLT4gQ3NldC51bmlvbiAoY3NlcSBjbS5baV0gY20uW2pdKSBsKVxuICAgICAgICAgIH5pbml0OkNzZXQuZW1wdHlcbiAgICAgIGluXG4gICAgICBjYWNoZSA6PSBDc2V0LkNTZXRNYXAuYWRkIHYgbCAhY2FjaGU7XG4gICAgICBsXG5cbigqKioqKVxuXG50eXBlIHJlZ2V4cCA9XG4gICAgU2V0IG9mIENzZXQudFxuICB8IFNlcXVlbmNlIG9mIHJlZ2V4cCBsaXN0XG4gIHwgQWx0ZXJuYXRpdmUgb2YgcmVnZXhwIGxpc3RcbiAgfCBSZXBlYXQgb2YgcmVnZXhwICogaW50ICogaW50IG9wdGlvblxuICB8IEJlZ19vZl9saW5lIHwgRW5kX29mX2xpbmVcbiAgfCBCZWdfb2Zfd29yZCB8IEVuZF9vZl93b3JkIHwgTm90X2JvdW5kXG4gIHwgQmVnX29mX3N0ciB8IEVuZF9vZl9zdHJcbiAgfCBMYXN0X2VuZF9vZl9saW5lIHwgU3RhcnQgfCBTdG9wXG4gIHwgU2VtIG9mIEF1dG9tYXRhLnNlbSAqIHJlZ2V4cFxuICB8IFNlbV9ncmVlZHkgb2YgQXV0b21hdGEucmVwX2tpbmQgKiByZWdleHBcbiAgfCBHcm91cCBvZiBzdHJpbmcgb3B0aW9uICogcmVnZXhwIHwgTm9fZ3JvdXAgb2YgcmVnZXhwIHwgTmVzdCBvZiByZWdleHBcbiAgfCBDYXNlIG9mIHJlZ2V4cCB8IE5vX2Nhc2Ugb2YgcmVnZXhwXG4gIHwgSW50ZXJzZWN0aW9uIG9mIHJlZ2V4cCBsaXN0XG4gIHwgQ29tcGxlbWVudCBvZiByZWdleHAgbGlzdFxuICB8IERpZmZlcmVuY2Ugb2YgcmVnZXhwICogcmVnZXhwXG4gIHwgUG1hcmsgb2YgUG1hcmsudCAqIHJlZ2V4cFxuXG5tb2R1bGUgVmlldyA9IHN0cnVjdFxuICB0eXBlIHQgPSByZWdleHAgPVxuICAgICAgU2V0IG9mIENzZXQudFxuICAgIHwgU2VxdWVuY2Ugb2YgcmVnZXhwIGxpc3RcbiAgICB8IEFsdGVybmF0aXZlIG9mIHJlZ2V4cCBsaXN0XG4gICAgfCBSZXBlYXQgb2YgcmVnZXhwICogaW50ICogaW50IG9wdGlvblxuICAgIHwgQmVnX29mX2xpbmUgfCBFbmRfb2ZfbGluZVxuICAgIHwgQmVnX29mX3dvcmQgfCBFbmRfb2Zfd29yZCB8IE5vdF9ib3VuZFxuICAgIHwgQmVnX29mX3N0ciB8IEVuZF9vZl9zdHJcbiAgICB8IExhc3RfZW5kX29mX2xpbmUgfCBTdGFydCB8IFN0b3BcbiAgICB8IFNlbSBvZiBBdXRvbWF0YS5zZW0gKiByZWdleHBcbiAgICB8IFNlbV9ncmVlZHkgb2YgQXV0b21hdGEucmVwX2tpbmQgKiByZWdleHBcbiAgICB8IEdyb3VwIG9mIHN0cmluZyBvcHRpb24gKiByZWdleHAgfCBOb19ncm91cCBvZiByZWdleHAgfCBOZXN0IG9mIHJlZ2V4cFxuICAgIHwgQ2FzZSBvZiByZWdleHAgfCBOb19jYXNlIG9mIHJlZ2V4cFxuICAgIHwgSW50ZXJzZWN0aW9uIG9mIHJlZ2V4cCBsaXN0XG4gICAgfCBDb21wbGVtZW50IG9mIHJlZ2V4cCBsaXN0XG4gICAgfCBEaWZmZXJlbmNlIG9mIHJlZ2V4cCAqIHJlZ2V4cFxuICAgIHwgUG1hcmsgb2YgUG1hcmsudCAqIHJlZ2V4cFxuXG4gIGxldCB2aWV3IHQgPSB0XG5lbmRcblxubGV0IHJlYyBwcCBmbXQgdCA9XG4gIGxldCBvcGVuIEZtdCBpblxuICBsZXQgdmFyIHMgcmUgPSBzZXhwIGZtdCBzIHBwIHJlIGluXG4gIGxldCBzZXEgcyByZWwgPSBzZXhwIGZtdCBzIChsaXN0IHBwKSByZWwgaW5cbiAgbWF0Y2ggdCB3aXRoXG4gIHwgU2V0IHMgLT4gIHNleHAgZm10IFwiU2V0XCIgQ3NldC5wcCBzXG4gIHwgU2VxdWVuY2Ugc3EgLT4gc2VxIFwiU2VxdWVuY2VcIiBzcVxuICB8IEFsdGVybmF0aXZlIGFsdCAtPiBzZXEgXCJBbHRlcm5hdGl2ZVwiIGFsdFxuICB8IFJlcGVhdCAocmUsIHN0YXJ0LCBzdG9wKSAtPlxuICAgIGxldCBwcCcgZm10ICgpID0gZnByaW50ZiBmbXQgXCIlYUAgJWQlYVwiIHBwIHJlICAgc3RhcnQgICBvcHRpbnQgc3RvcCBpblxuICAgIHNleHAgZm10IFwiUmVwZWF0XCIgcHAnICgpXG4gIHwgQmVnX29mX2xpbmUgICAgICAtPiBzdHIgZm10IFwiQmVnX29mX2xpbmVcIlxuICB8IEVuZF9vZl9saW5lICAgICAgLT4gc3RyIGZtdCBcIkVuZF9vZl9saW5lXCJcbiAgfCBCZWdfb2Zfd29yZCAgICAgIC0+IHN0ciBmbXQgXCJCZWdfb2Zfd29yZFwiXG4gIHwgRW5kX29mX3dvcmQgICAgICAtPiBzdHIgZm10IFwiRW5kX29mX3dvcmRcIlxuICB8IE5vdF9ib3VuZCAgICAgICAgLT4gc3RyIGZtdCBcIk5vdF9ib3VuZFwiXG4gIHwgQmVnX29mX3N0ciAgICAgICAtPiBzdHIgZm10IFwiQmVnX29mX3N0clwiXG4gIHwgRW5kX29mX3N0ciAgICAgICAtPiBzdHIgZm10IFwiRW5kX29mX3N0clwiXG4gIHwgTGFzdF9lbmRfb2ZfbGluZSAtPiBzdHIgZm10IFwiTGFzdF9lbmRfb2ZfbGluZVwiXG4gIHwgU3RhcnQgICAgICAgICAgICAtPiBzdHIgZm10IFwiU3RhcnRcIlxuICB8IFN0b3AgICAgICAgICAgICAgLT4gc3RyIGZtdCBcIlN0b3BcIlxuICB8IFNlbSAoc2VtLCByZSkgICAgLT5cbiAgICBzZXhwIGZtdCBcIlNlbVwiIChwYWlyIEF1dG9tYXRhLnBwX3NlbSBwcCkgKHNlbSwgcmUpXG4gIHwgU2VtX2dyZWVkeSAoaywgcmUpIC0+XG4gICAgc2V4cCBmbXQgXCJTZW1fZ3JlZWR5XCIgKHBhaXIgQXV0b21hdGEucHBfcmVwX2tpbmQgcHApIChrLCByZSlcbiAgfCBHcm91cCAoTm9uZSwgYykgICAtPiB2YXIgXCJHcm91cFwiIGNcbiAgfCBHcm91cCAoU29tZSBuLCBjKSAtPiBzZXhwIGZtdCBcIk5hbWVkX2dyb3VwXCIgKHBhaXIgc3RyIHBwKSAobiwgYylcbiAgfCBOb19ncm91cCBjICAgICAtPiB2YXIgXCJOb19ncm91cFwiIGNcbiAgfCBOZXN0IGMgICAgICAgICAtPiB2YXIgXCJOZXN0XCIgY1xuICB8IENhc2UgYyAgICAgICAgIC0+IHZhciBcIkNhc2VcIiBjXG4gIHwgTm9fY2FzZSBjICAgICAgLT4gdmFyIFwiTm9fY2FzZVwiIGNcbiAgfCBJbnRlcnNlY3Rpb24gYyAtPiBzZXEgXCJJbnRlcnNlY3Rpb25cIiBjXG4gIHwgQ29tcGxlbWVudCBjICAgLT4gc2VxIFwiQ29tcGxlbWVudFwiIGNcbiAgfCBEaWZmZXJlbmNlIChhLCBiKSAtPiBzZXhwIGZtdCBcIkRpZmZlcmVuY2VcIiAocGFpciBwcCBwcCkgKGEsIGIpXG4gIHwgUG1hcmsgKG0sIHIpICAgICAgLT4gc2V4cCBmbXQgXCJQbWFya1wiIChwYWlyIFBtYXJrLnBwIHBwKSAobSwgcilcblxubGV0IHJlYyBpc19jaGFyc2V0ID0gZnVuY3Rpb25cbiAgfCBTZXQgXyAtPlxuICAgIHRydWVcbiAgfCBBbHRlcm5hdGl2ZSBsIHwgSW50ZXJzZWN0aW9uIGwgfCBDb21wbGVtZW50IGwgLT5cbiAgICBMaXN0LmZvcl9hbGwgaXNfY2hhcnNldCBsXG4gIHwgRGlmZmVyZW5jZSAociwgcicpIC0+XG4gICAgaXNfY2hhcnNldCByICYmIGlzX2NoYXJzZXQgcidcbiAgfCBTZW0gKF8sIHIpIHwgU2VtX2dyZWVkeSAoXywgcilcbiAgfCBOb19ncm91cCByIHwgQ2FzZSByIHwgTm9fY2FzZSByIC0+XG4gICAgaXNfY2hhcnNldCByXG4gIHwgU2VxdWVuY2UgXyB8IFJlcGVhdCBfIHwgQmVnX29mX2xpbmUgfCBFbmRfb2ZfbGluZVxuICB8IEJlZ19vZl93b3JkIHwgRW5kX29mX3dvcmQgfCBCZWdfb2Zfc3RyIHwgRW5kX29mX3N0clxuICB8IE5vdF9ib3VuZCB8IExhc3RfZW5kX29mX2xpbmUgfCBTdGFydCB8IFN0b3BcbiAgfCBHcm91cCBfIHwgTmVzdCBfIHwgUG1hcmsgKF8sXyktPlxuICAgIGZhbHNlXG5cbigqWFhYIFVzZSBhIGJldHRlciBhbGdvcml0aG0gYWxsb3dpbmcgbm9uLWNvbnRpZ3VvdXMgcmVnaW9ucz8gKilcblxubGV0IGN1cHBlciA9XG4gIENzZXQudW5pb24gKGNzZXEgJ0EnICdaJylcbiAgICAoQ3NldC51bmlvbiAoY3NlcSAnXFwxOTInICdcXDIxNCcpIChjc2VxICdcXDIxNicgJ1xcMjIyJykpXG5sZXQgY2xvd2VyID0gQ3NldC5vZmZzZXQgMzIgY3VwcGVyXG5sZXQgY2FscGhhID1cbiAgTGlzdC5mb2xkX3JpZ2h0IGNhZGQgWydcXDE3MCc7ICdcXDE4MSc7ICdcXDE4Nic7ICdcXDIyMyc7ICdcXDI1NSddXG4gICAgKENzZXQudW5pb24gY2xvd2VyIGN1cHBlcilcbmxldCBjZGlnaXQgPSBjc2VxICcwJyAnOSdcbmxldCBjYWxudW0gPSBDc2V0LnVuaW9uIGNhbHBoYSBjZGlnaXRcbmxldCBjd29yZCA9IGNhZGQgJ18nIGNhbG51bVxuXG5sZXQgY29sb3JpemUgYyByZWdleHAgPVxuICBsZXQgbG5sID0gcmVmIGZhbHNlIGluXG4gIGxldCByZWMgY29sb3JpemUgcmVnZXhwID1cbiAgICBtYXRjaCByZWdleHAgd2l0aFxuICAgICAgU2V0IHMgICAgICAgICAgICAgICAgICAgICAtPiBDb2xvcl9tYXAuc3BsaXQgcyBjXG4gICAgfCBTZXF1ZW5jZSBsICAgICAgICAgICAgICAgIC0+IExpc3QuaXRlciBjb2xvcml6ZSBsXG4gICAgfCBBbHRlcm5hdGl2ZSBsICAgICAgICAgICAgIC0+IExpc3QuaXRlciBjb2xvcml6ZSBsXG4gICAgfCBSZXBlYXQgKHIsIF8sIF8pICAgICAgICAgIC0+IGNvbG9yaXplIHJcbiAgICB8IEJlZ19vZl9saW5lIHwgRW5kX29mX2xpbmUgLT4gQ29sb3JfbWFwLnNwbGl0IChDc2V0LmNzaW5nbGUgJ1xcbicpIGNcbiAgICB8IEJlZ19vZl93b3JkIHwgRW5kX29mX3dvcmRcbiAgICB8IE5vdF9ib3VuZCAgICAgICAgICAgICAgICAgLT4gQ29sb3JfbWFwLnNwbGl0IGN3b3JkIGNcbiAgICB8IEJlZ19vZl9zdHIgfCBFbmRfb2Zfc3RyXG4gICAgfCBTdGFydCB8IFN0b3AgICAgICAgICAgICAgIC0+ICgpXG4gICAgfCBMYXN0X2VuZF9vZl9saW5lICAgICAgICAgIC0+IGxubCA6PSB0cnVlXG4gICAgfCBTZW0gKF8sIHIpXG4gICAgfCBTZW1fZ3JlZWR5IChfLCByKVxuICAgIHwgR3JvdXAgKF8sIHIpIHwgTm9fZ3JvdXAgclxuICAgIHwgTmVzdCByIHwgUG1hcmsgKF8scikgICAgIC0+IGNvbG9yaXplIHJcbiAgICB8IENhc2UgXyB8IE5vX2Nhc2UgX1xuICAgIHwgSW50ZXJzZWN0aW9uIF9cbiAgICB8IENvbXBsZW1lbnQgX1xuICAgIHwgRGlmZmVyZW5jZSBfICAgICAgICAgICAgICAtPiBhc3NlcnQgZmFsc2VcbiAgaW5cbiAgY29sb3JpemUgcmVnZXhwO1xuICAhbG5sXG5cbigqKioqIENvbXBpbGF0aW9uICoqKiopXG5cbmxldCByZWMgZXF1YWwgeDEgeDIgPVxuICBtYXRjaCB4MSwgeDIgd2l0aFxuICAgIFNldCBzMSwgU2V0IHMyIC0+XG4gICAgczEgPSBzMlxuICB8IFNlcXVlbmNlIGwxLCBTZXF1ZW5jZSBsMiAtPlxuICAgIGVxX2xpc3QgbDEgbDJcbiAgfCBBbHRlcm5hdGl2ZSBsMSwgQWx0ZXJuYXRpdmUgbDIgLT5cbiAgICBlcV9saXN0IGwxIGwyXG4gIHwgUmVwZWF0ICh4MScsIGkxLCBqMSksIFJlcGVhdCAoeDInLCBpMiwgajIpIC0+XG4gICAgaTEgPSBpMiAmJiBqMSA9IGoyICYmIGVxdWFsIHgxJyB4MidcbiAgfCBCZWdfb2ZfbGluZSwgQmVnX29mX2xpbmVcbiAgfCBFbmRfb2ZfbGluZSwgRW5kX29mX2xpbmVcbiAgfCBCZWdfb2Zfd29yZCwgQmVnX29mX3dvcmRcbiAgfCBFbmRfb2Zfd29yZCwgRW5kX29mX3dvcmRcbiAgfCBOb3RfYm91bmQsIE5vdF9ib3VuZFxuICB8IEJlZ19vZl9zdHIsIEJlZ19vZl9zdHJcbiAgfCBFbmRfb2Zfc3RyLCBFbmRfb2Zfc3RyXG4gIHwgTGFzdF9lbmRfb2ZfbGluZSwgTGFzdF9lbmRfb2ZfbGluZVxuICB8IFN0YXJ0LCBTdGFydFxuICB8IFN0b3AsIFN0b3AgLT5cbiAgICB0cnVlXG4gIHwgU2VtIChzZW0xLCB4MScpLCBTZW0gKHNlbTIsIHgyJykgLT5cbiAgICBzZW0xID0gc2VtMiAmJiBlcXVhbCB4MScgeDInXG4gIHwgU2VtX2dyZWVkeSAoazEsIHgxJyksIFNlbV9ncmVlZHkgKGsyLCB4MicpIC0+XG4gICAgazEgPSBrMiAmJiBlcXVhbCB4MScgeDInXG4gIHwgR3JvdXAgXywgR3JvdXAgXyAtPiAoKiBEbyBub3QgbWVyZ2UgZ3JvdXBzISAqKVxuICAgIGZhbHNlXG4gIHwgTm9fZ3JvdXAgeDEnLCBOb19ncm91cCB4MicgLT5cbiAgICBlcXVhbCB4MScgeDInXG4gIHwgTmVzdCB4MScsIE5lc3QgeDInIC0+XG4gICAgZXF1YWwgeDEnIHgyJ1xuICB8IENhc2UgeDEnLCBDYXNlIHgyJyAtPlxuICAgIGVxdWFsIHgxJyB4MidcbiAgfCBOb19jYXNlIHgxJywgTm9fY2FzZSB4MicgLT5cbiAgICBlcXVhbCB4MScgeDInXG4gIHwgSW50ZXJzZWN0aW9uIGwxLCBJbnRlcnNlY3Rpb24gbDIgLT5cbiAgICBlcV9saXN0IGwxIGwyXG4gIHwgQ29tcGxlbWVudCBsMSwgQ29tcGxlbWVudCBsMiAtPlxuICAgIGVxX2xpc3QgbDEgbDJcbiAgfCBEaWZmZXJlbmNlICh4MScsIHgxJycpLCBEaWZmZXJlbmNlICh4MicsIHgyJycpIC0+XG4gICAgZXF1YWwgeDEnIHgyJyAmJiBlcXVhbCB4MScnIHgyJydcbiAgfCBQbWFyayAobTEsIHIxKSwgUG1hcmsgKG0yLCByMikgLT5cbiAgICBQbWFyay5lcXVhbCBtMSBtMiAmJiBlcXVhbCByMSByMlxuICB8IF8gLT5cbiAgICBmYWxzZVxuXG5hbmQgZXFfbGlzdCBsMSBsMiA9XG4gIG1hdGNoIGwxLCBsMiB3aXRoXG4gICAgW10sIFtdIC0+XG4gICAgdHJ1ZVxuICB8IHgxIDo6IHIxLCB4MiA6OiByMiAtPlxuICAgIGVxdWFsIHgxIHgyICYmIGVxX2xpc3QgcjEgcjJcbiAgfCBfIC0+XG4gICAgZmFsc2VcblxubGV0IHNlcXVlbmNlID0gZnVuY3Rpb25cbiAgfCBbeF0gLT4geFxuICB8IGwgICAtPiBTZXF1ZW5jZSBsXG5cbmxldCByZWMgbWVyZ2Vfc2VxdWVuY2VzID0gZnVuY3Rpb25cbiAgfCBbXSAtPlxuICAgIFtdXG4gIHwgQWx0ZXJuYXRpdmUgbCcgOjogciAtPlxuICAgIG1lcmdlX3NlcXVlbmNlcyAobCcgQCByKVxuICB8IFNlcXVlbmNlICh4IDo6IHkpIDo6IHIgLT5cbiAgICBiZWdpbiBtYXRjaCBtZXJnZV9zZXF1ZW5jZXMgciB3aXRoXG4gICAgICAgIFNlcXVlbmNlICh4JyA6OiB5JykgOjogcicgd2hlbiBlcXVhbCB4IHgnIC0+XG4gICAgICAgIFNlcXVlbmNlIFt4OyBBbHRlcm5hdGl2ZSBbc2VxdWVuY2UgeTsgc2VxdWVuY2UgeSddXSA6OiByJ1xuICAgICAgfCByJyAtPlxuICAgICAgICBTZXF1ZW5jZSAoeCA6OiB5KSA6OiByJ1xuICAgIGVuZFxuICB8IHggOjogciAtPlxuICAgIHggOjogbWVyZ2Vfc2VxdWVuY2VzIHJcblxubW9kdWxlIEEgPSBBdXRvbWF0YVxuXG5sZXQgZW5mb3JjZV9raW5kIGlkcyBraW5kIGtpbmQnIGNyID1cbiAgbWF0Y2gga2luZCwga2luZCcgd2l0aFxuICAgIGBGaXJzdCwgYEZpcnN0IC0+IGNyXG4gIHwgYEZpcnN0LCBrICAgICAgIC0+IEEuc2VxIGlkcyBrIGNyIChBLmVwcyBpZHMpXG4gIHwgIF8gICAgICAgICAgICAgICAtPiBjclxuXG4oKiBYWFggc2hvdWxkIHByb2JhYmx5IGNvbXB1dGUgYSBjYXRlZ29yeSBtYXNrICopXG5sZXQgcmVjIHRyYW5zbGF0ZSBpZHMga2luZCBpZ25fZ3JvdXAgaWduX2Nhc2UgZ3JlZWR5IHBvcyBuYW1lcyBjYWNoZSBjID0gZnVuY3Rpb25cbiAgfCBTZXQgcyAtPlxuICAgIChBLmNzdCBpZHMgKHRyYW5zX3NldCBjYWNoZSBjIHMpLCBraW5kKVxuICB8IFNlcXVlbmNlIGwgLT5cbiAgICAodHJhbnNfc2VxIGlkcyBraW5kIGlnbl9ncm91cCBpZ25fY2FzZSBncmVlZHkgcG9zIG5hbWVzIGNhY2hlIGMgbCwga2luZClcbiAgfCBBbHRlcm5hdGl2ZSBsIC0+XG4gICAgYmVnaW4gbWF0Y2ggbWVyZ2Vfc2VxdWVuY2VzIGwgd2l0aFxuICAgICAgICBbciddIC0+XG4gICAgICAgIGxldCAoY3IsIGtpbmQnKSA9XG4gICAgICAgICAgdHJhbnNsYXRlIGlkcyBraW5kIGlnbl9ncm91cCBpZ25fY2FzZSBncmVlZHkgcG9zIG5hbWVzIGNhY2hlIGMgcicgaW5cbiAgICAgICAgKGVuZm9yY2Vfa2luZCBpZHMga2luZCBraW5kJyBjciwga2luZClcbiAgICAgIHwgbWVyZ2VkX3NlcXVlbmNlcyAtPlxuICAgICAgICAoQS5hbHQgaWRzXG4gICAgICAgICAgIChMaXN0Lm1hcFxuICAgICAgICAgICAgICAoZnVuIHInIC0+XG4gICAgICAgICAgICAgICAgIGxldCAoY3IsIGtpbmQnKSA9XG4gICAgICAgICAgICAgICAgICAgdHJhbnNsYXRlIGlkcyBraW5kIGlnbl9ncm91cCBpZ25fY2FzZSBncmVlZHlcbiAgICAgICAgICAgICAgICAgICAgIHBvcyBuYW1lcyBjYWNoZSBjIHInIGluXG4gICAgICAgICAgICAgICAgIGVuZm9yY2Vfa2luZCBpZHMga2luZCBraW5kJyBjcilcbiAgICAgICAgICAgICAgbWVyZ2VkX3NlcXVlbmNlcyksXG4gICAgICAgICBraW5kKVxuICAgIGVuZFxuICB8IFJlcGVhdCAocicsIGksIGopIC0+XG4gICAgbGV0IChjciwga2luZCcpID1cbiAgICAgIHRyYW5zbGF0ZSBpZHMga2luZCBpZ25fZ3JvdXAgaWduX2Nhc2UgZ3JlZWR5IHBvcyBuYW1lcyBjYWNoZSBjIHInIGluXG4gICAgbGV0IHJlbSA9XG4gICAgICBtYXRjaCBqIHdpdGhcbiAgICAgICAgTm9uZSAtPlxuICAgICAgICBBLnJlcCBpZHMgZ3JlZWR5IGtpbmQnIGNyXG4gICAgICB8IFNvbWUgaiAtPlxuICAgICAgICBsZXQgZiA9XG4gICAgICAgICAgbWF0Y2ggZ3JlZWR5IHdpdGhcbiAgICAgICAgICAgIGBHcmVlZHkgLT5cbiAgICAgICAgICAgIGZ1biByZW0gLT5cbiAgICAgICAgICAgICAgQS5hbHQgaWRzXG4gICAgICAgICAgICAgICAgW0Euc2VxIGlkcyBraW5kJyAoQS5yZW5hbWUgaWRzIGNyKSByZW07IEEuZXBzIGlkc11cbiAgICAgICAgICB8IGBOb25fZ3JlZWR5IC0+XG4gICAgICAgICAgICBmdW4gcmVtIC0+XG4gICAgICAgICAgICAgIEEuYWx0IGlkc1xuICAgICAgICAgICAgICAgIFtBLmVwcyBpZHM7IEEuc2VxIGlkcyBraW5kJyAoQS5yZW5hbWUgaWRzIGNyKSByZW1dXG4gICAgICAgIGluXG4gICAgICAgIGl0ZXIgKGogLSBpKSBmIChBLmVwcyBpZHMpXG4gICAgaW5cbiAgICAoaXRlciBpIChmdW4gcmVtIC0+IEEuc2VxIGlkcyBraW5kJyAoQS5yZW5hbWUgaWRzIGNyKSByZW0pIHJlbSwga2luZClcbiAgfCBCZWdfb2ZfbGluZSAtPlxuICAgIChBLmFmdGVyIGlkcyBDYXRlZ29yeS4oaW5leGlzdGFudCArKyBuZXdsaW5lKSwga2luZClcbiAgfCBFbmRfb2ZfbGluZSAtPlxuICAgIChBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbmV3bGluZSksIGtpbmQpXG4gIHwgQmVnX29mX3dvcmQgLT5cbiAgICAoQS5zZXEgaWRzIGBGaXJzdFxuICAgICAgIChBLmFmdGVyIGlkcyBDYXRlZ29yeS4oaW5leGlzdGFudCArKyBub3RfbGV0dGVyKSlcbiAgICAgICAoQS5iZWZvcmUgaWRzIENhdGVnb3J5LmxldHRlciksXG4gICAgIGtpbmQpXG4gIHwgRW5kX29mX3dvcmQgLT5cbiAgICAoQS5zZXEgaWRzIGBGaXJzdFxuICAgICAgIChBLmFmdGVyIGlkcyBDYXRlZ29yeS5sZXR0ZXIpXG4gICAgICAgKEEuYmVmb3JlIGlkcyBDYXRlZ29yeS4oaW5leGlzdGFudCArKyBub3RfbGV0dGVyKSksXG4gICAgIGtpbmQpXG4gIHwgTm90X2JvdW5kIC0+XG4gICAgKEEuYWx0IGlkcyBbQS5zZXEgaWRzIGBGaXJzdFxuICAgICAgICAgICAgICAgICAgKEEuYWZ0ZXIgaWRzIENhdGVnb3J5LmxldHRlcilcbiAgICAgICAgICAgICAgICAgIChBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkubGV0dGVyKTtcbiAgICAgICAgICAgICAgICBBLnNlcSBpZHMgYEZpcnN0XG4gICAgICAgICAgICAgICAgICAoQS5hZnRlciBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbm90X2xldHRlcikpXG4gICAgICAgICAgICAgICAgICAoQS5iZWZvcmUgaWRzIENhdGVnb3J5LihpbmV4aXN0YW50ICsrIG5vdF9sZXR0ZXIpKV0sXG4gICAgIGtpbmQpXG4gIHwgQmVnX29mX3N0ciAtPlxuICAgIChBLmFmdGVyIGlkcyBDYXRlZ29yeS5pbmV4aXN0YW50LCBraW5kKVxuICB8IEVuZF9vZl9zdHIgLT5cbiAgICAoQS5iZWZvcmUgaWRzIENhdGVnb3J5LmluZXhpc3RhbnQsIGtpbmQpXG4gIHwgTGFzdF9lbmRfb2ZfbGluZSAtPlxuICAgIChBLmJlZm9yZSBpZHMgQ2F0ZWdvcnkuKGluZXhpc3RhbnQgKysgbGFzdG5ld2xpbmUpLCBraW5kKVxuICB8IFN0YXJ0IC0+XG4gICAgKEEuYWZ0ZXIgaWRzIENhdGVnb3J5LnNlYXJjaF9ib3VuZGFyeSwga2luZClcbiAgfCBTdG9wIC0+XG4gICAgKEEuYmVmb3JlIGlkcyBDYXRlZ29yeS5zZWFyY2hfYm91bmRhcnksIGtpbmQpXG4gIHwgU2VtIChraW5kJywgcicpIC0+XG4gICAgbGV0IChjciwga2luZCcnKSA9XG4gICAgICB0cmFuc2xhdGUgaWRzIGtpbmQnIGlnbl9ncm91cCBpZ25fY2FzZSBncmVlZHkgcG9zIG5hbWVzIGNhY2hlIGMgcicgaW5cbiAgICAoZW5mb3JjZV9raW5kIGlkcyBraW5kJyBraW5kJycgY3IsXG4gICAgIGtpbmQnKVxuICB8IFNlbV9ncmVlZHkgKGdyZWVkeScsIHInKSAtPlxuICAgIHRyYW5zbGF0ZSBpZHMga2luZCBpZ25fZ3JvdXAgaWduX2Nhc2UgZ3JlZWR5JyBwb3MgbmFtZXMgY2FjaGUgYyByJ1xuICB8IEdyb3VwIChuLCByJykgLT5cbiAgICBpZiBpZ25fZ3JvdXAgdGhlblxuICAgICAgdHJhbnNsYXRlIGlkcyBraW5kIGlnbl9ncm91cCBpZ25fY2FzZSBncmVlZHkgcG9zIG5hbWVzIGNhY2hlIGMgcidcbiAgICBlbHNlXG4gICAgICBsZXQgcCA9ICFwb3MgaW5cbiAgICAgIGxldCAoKSA9XG4gICAgICAgIG1hdGNoIG4gd2l0aFxuICAgICAgICB8IFNvbWUgbmFtZSAtPiBuYW1lcyA6PSAobmFtZSwgcCAvIDIpIDo6ICFuYW1lc1xuICAgICAgICB8IE5vbmUgLT4gKClcbiAgICAgIGluXG4gICAgICBwb3MgOj0gIXBvcyArIDI7XG4gICAgICBsZXQgKGNyLCBraW5kJykgPVxuICAgICAgICB0cmFuc2xhdGUgaWRzIGtpbmQgaWduX2dyb3VwIGlnbl9jYXNlIGdyZWVkeSBwb3MgbmFtZXMgY2FjaGUgYyByJyBpblxuICAgICAgKEEuc2VxIGlkcyBgRmlyc3QgKEEubWFyayBpZHMgcCkgKFxuICAgICAgICAgIEEuc2VxIGlkcyBgRmlyc3QgY3IgKEEubWFyayBpZHMgKHAgKyAxKSkpLFxuICAgICAgIGtpbmQnKVxuICB8IE5vX2dyb3VwIHInIC0+XG4gICAgdHJhbnNsYXRlIGlkcyBraW5kIHRydWUgaWduX2Nhc2UgZ3JlZWR5IHBvcyBuYW1lcyBjYWNoZSBjIHInXG4gIHwgTmVzdCByJyAtPlxuICAgIGxldCBiID0gIXBvcyBpblxuICAgIGxldCAoY3IsIGtpbmQnKSA9XG4gICAgICB0cmFuc2xhdGUgaWRzIGtpbmQgaWduX2dyb3VwIGlnbl9jYXNlIGdyZWVkeSBwb3MgbmFtZXMgY2FjaGUgYyByJ1xuICAgIGluXG4gICAgbGV0IGUgPSAhcG9zIC0gMSBpblxuICAgIGlmIGUgPCBiIHRoZW5cbiAgICAgIChjciwga2luZCcpXG4gICAgZWxzZVxuICAgICAgKEEuc2VxIGlkcyBgRmlyc3QgKEEuZXJhc2UgaWRzIGIgZSkgY3IsIGtpbmQnKVxuICB8IERpZmZlcmVuY2UgXyB8IENvbXBsZW1lbnQgXyB8IEludGVyc2VjdGlvbiBfIHwgTm9fY2FzZSBfIHwgQ2FzZSBfIC0+XG4gICAgYXNzZXJ0IGZhbHNlXG4gIHwgUG1hcmsgKGksIHInKSAtPlxuICAgIGxldCAoY3IsIGtpbmQnKSA9XG4gICAgICB0cmFuc2xhdGUgaWRzIGtpbmQgaWduX2dyb3VwIGlnbl9jYXNlIGdyZWVkeSBwb3MgbmFtZXMgY2FjaGUgYyByJyBpblxuICAgIChBLnNlcSBpZHMgYEZpcnN0IChBLnBtYXJrIGlkcyBpKSBjciwga2luZCcpXG5cbmFuZCB0cmFuc19zZXEgaWRzIGtpbmQgaWduX2dyb3VwIGlnbl9jYXNlIGdyZWVkeSBwb3MgbmFtZXMgY2FjaGUgYyA9IGZ1bmN0aW9uXG4gIHwgW10gLT5cbiAgICBBLmVwcyBpZHNcbiAgfCBbcl0gLT5cbiAgICBsZXQgKGNyJywga2luZCcpID1cbiAgICAgIHRyYW5zbGF0ZSBpZHMga2luZCBpZ25fZ3JvdXAgaWduX2Nhc2UgZ3JlZWR5IHBvcyBuYW1lcyBjYWNoZSBjIHIgaW5cbiAgICBlbmZvcmNlX2tpbmQgaWRzIGtpbmQga2luZCcgY3InXG4gIHwgciA6OiByZW0gLT5cbiAgICBsZXQgKGNyJywga2luZCcpID1cbiAgICAgIHRyYW5zbGF0ZSBpZHMga2luZCBpZ25fZ3JvdXAgaWduX2Nhc2UgZ3JlZWR5IHBvcyBuYW1lcyBjYWNoZSBjIHIgaW5cbiAgICBsZXQgY3InJyA9XG4gICAgICB0cmFuc19zZXEgaWRzIGtpbmQgaWduX2dyb3VwIGlnbl9jYXNlIGdyZWVkeSBwb3MgbmFtZXMgY2FjaGUgYyByZW0gaW5cbiAgICBpZiBBLmlzX2VwcyBjcicnIHRoZW5cbiAgICAgIGNyJ1xuICAgIGVsc2UgaWYgQS5pc19lcHMgY3InIHRoZW5cbiAgICAgIGNyJydcbiAgICBlbHNlXG4gICAgICBBLnNlcSBpZHMga2luZCcgY3InIGNyJydcblxuKCoqKiogQ2FzZSAqKioqKVxuXG5sZXQgY2FzZV9pbnNlbnMgcyA9XG4gIENzZXQudW5pb24gcyAoQ3NldC51bmlvbiAoQ3NldC5vZmZzZXQgMzIgKENzZXQuaW50ZXIgcyBjdXBwZXIpKVxuICAgICAgICAgICAgICAgICAgKENzZXQub2Zmc2V0ICgtMzIpIChDc2V0LmludGVyIHMgY2xvd2VyKSkpXG5cbmxldCBhc19zZXQgPSBmdW5jdGlvblxuICB8IFNldCBzIC0+IHNcbiAgfCBfICAgICAtPiBhc3NlcnQgZmFsc2VcblxuKCogWFhYIFNob3VsZCBzcGxpdCBhbHRlcm5hdGl2ZXMgaW50byAoMSkgY2hhcnNldHMgYW5kICgyKSBtb3JlXG4gICBjb21wbGV4IHJlZ3VsYXIgZXhwcmVzc2lvbnM7IGFsdGVybmF0aXZlIHNob3VsZCB0aGVyZWZvcmUgcHJvYmFibHlcbiAgIGJlIGZsYXR0ZW4gaGVyZSAqKVxubGV0IHJlYyBoYW5kbGVfY2FzZSBpZ25fY2FzZSA9IGZ1bmN0aW9uXG4gIHwgU2V0IHMgLT5cbiAgICBTZXQgKGlmIGlnbl9jYXNlIHRoZW4gY2FzZV9pbnNlbnMgcyBlbHNlIHMpXG4gIHwgU2VxdWVuY2UgbCAtPlxuICAgIFNlcXVlbmNlIChMaXN0Lm1hcCAoaGFuZGxlX2Nhc2UgaWduX2Nhc2UpIGwpXG4gIHwgQWx0ZXJuYXRpdmUgbCAtPlxuICAgIGxldCBsJyA9IExpc3QubWFwIChoYW5kbGVfY2FzZSBpZ25fY2FzZSkgbCBpblxuICAgIGlmIGlzX2NoYXJzZXQgKEFsdGVybmF0aXZlIGwnKSB0aGVuXG4gICAgICBTZXQgKExpc3QuZm9sZF9sZWZ0IChmdW4gcyByIC0+IENzZXQudW5pb24gcyAoYXNfc2V0IHIpKSBDc2V0LmVtcHR5IGwnKVxuICAgIGVsc2VcbiAgICAgIEFsdGVybmF0aXZlIGwnXG4gIHwgUmVwZWF0IChyLCBpLCBqKSAtPlxuICAgIFJlcGVhdCAoaGFuZGxlX2Nhc2UgaWduX2Nhc2UgciwgaSwgailcbiAgfCBCZWdfb2ZfbGluZSB8IEVuZF9vZl9saW5lIHwgQmVnX29mX3dvcmQgfCBFbmRfb2Zfd29yZCB8IE5vdF9ib3VuZFxuICB8IEJlZ19vZl9zdHIgfCBFbmRfb2Zfc3RyIHwgTGFzdF9lbmRfb2ZfbGluZSB8IFN0YXJ0IHwgU3RvcCBhcyByIC0+XG4gICAgclxuICB8IFNlbSAoaywgcikgLT5cbiAgICBsZXQgcicgPSBoYW5kbGVfY2FzZSBpZ25fY2FzZSByIGluXG4gICAgaWYgaXNfY2hhcnNldCByJyB0aGVuIHInIGVsc2UgU2VtIChrLCByJylcbiAgfCBTZW1fZ3JlZWR5IChrLCByKSAtPlxuICAgIGxldCByJyA9IGhhbmRsZV9jYXNlIGlnbl9jYXNlIHIgaW5cbiAgICBpZiBpc19jaGFyc2V0IHInIHRoZW4gcicgZWxzZSBTZW1fZ3JlZWR5IChrLCByJylcbiAgfCBHcm91cCAobiwgcikgLT5cbiAgICBHcm91cCAobiwgaGFuZGxlX2Nhc2UgaWduX2Nhc2UgcilcbiAgfCBOb19ncm91cCByIC0+XG4gICAgbGV0IHInID0gaGFuZGxlX2Nhc2UgaWduX2Nhc2UgciBpblxuICAgIGlmIGlzX2NoYXJzZXQgcicgdGhlbiByJyBlbHNlIE5vX2dyb3VwIHInXG4gIHwgTmVzdCByIC0+XG4gICAgbGV0IHInID0gaGFuZGxlX2Nhc2UgaWduX2Nhc2UgciBpblxuICAgIGlmIGlzX2NoYXJzZXQgcicgdGhlbiByJyBlbHNlIE5lc3QgcidcbiAgfCBDYXNlIHIgLT5cbiAgICBoYW5kbGVfY2FzZSBmYWxzZSByXG4gIHwgTm9fY2FzZSByIC0+XG4gICAgaGFuZGxlX2Nhc2UgdHJ1ZSByXG4gIHwgSW50ZXJzZWN0aW9uIGwgLT5cbiAgICBsZXQgbCcgPSBMaXN0Lm1hcCAoZnVuIHIgLT4gaGFuZGxlX2Nhc2UgaWduX2Nhc2UgcikgbCBpblxuICAgIFNldCAoTGlzdC5mb2xkX2xlZnQgKGZ1biBzIHIgLT4gQ3NldC5pbnRlciBzIChhc19zZXQgcikpIENzZXQuY2FueSBsJylcbiAgfCBDb21wbGVtZW50IGwgLT5cbiAgICBsZXQgbCcgPSBMaXN0Lm1hcCAoZnVuIHIgLT4gaGFuZGxlX2Nhc2UgaWduX2Nhc2UgcikgbCBpblxuICAgIFNldCAoQ3NldC5kaWZmIENzZXQuY2FueVxuICAgICAgICAgICAoTGlzdC5mb2xkX2xlZnQgKGZ1biBzIHIgLT4gQ3NldC51bmlvbiBzIChhc19zZXQgcikpXG4gICAgICAgICAgICAgIENzZXQuZW1wdHkgbCcpKVxuICB8IERpZmZlcmVuY2UgKHIsIHInKSAtPlxuICAgIFNldCAoQ3NldC5pbnRlciAoYXNfc2V0IChoYW5kbGVfY2FzZSBpZ25fY2FzZSByKSlcbiAgICAgICAgICAgKENzZXQuZGlmZiBDc2V0LmNhbnkgKGFzX3NldCAoaGFuZGxlX2Nhc2UgaWduX2Nhc2UgcicpKSkpXG4gIHwgUG1hcmsgKGkscikgLT4gUG1hcmsgKGksaGFuZGxlX2Nhc2UgaWduX2Nhc2UgcilcblxuKCoqKiopXG5cbmxldCBjb21waWxlXzEgcmVnZXhwID1cbiAgbGV0IHJlZ2V4cCA9IGhhbmRsZV9jYXNlIGZhbHNlIHJlZ2V4cCBpblxuICBsZXQgYyA9IENvbG9yX21hcC5tYWtlICgpIGluXG4gIGxldCBuZWVkX2xubCA9IGNvbG9yaXplIGMgcmVnZXhwIGluXG4gIGxldCAoY29sb3JzLCBjb2xvcl9yZXByLCBuY29sb3IpID0gQ29sb3JfbWFwLmZsYXR0ZW4gYyBpblxuICBsZXQgbG5sID0gaWYgbmVlZF9sbmwgdGhlbiBuY29sb3IgZWxzZSAtMSBpblxuICBsZXQgbmNvbG9yID0gaWYgbmVlZF9sbmwgdGhlbiBuY29sb3IgKyAxIGVsc2UgbmNvbG9yIGluXG4gIGxldCBpZHMgPSBBLmNyZWF0ZV9pZHMgKCkgaW5cbiAgbGV0IHBvcyA9IHJlZiAwIGluXG4gIGxldCBuYW1lcyA9IHJlZiBbXSBpblxuICBsZXQgKHIsIGtpbmQpID1cbiAgICB0cmFuc2xhdGUgaWRzXG4gICAgICBgRmlyc3QgZmFsc2UgZmFsc2UgYEdyZWVkeSBwb3MgbmFtZXMgKHJlZiBDc2V0LkNTZXRNYXAuZW1wdHkpIGNvbG9ycyByZWdleHAgaW5cbiAgbGV0IHIgPSBlbmZvcmNlX2tpbmQgaWRzIGBGaXJzdCBraW5kIHIgaW5cbiAgKCpGb3JtYXQuZXByaW50ZiBcIjwlZCAlZD5ALlwiICFpZHMgbmNvbDsqKVxuICBta19yZSB+aW5pdGlhbDpyIH5jb2xvcnMgfmNvbG9yX3JlcHIgfm5jb2xvciB+bG5sIH5ncm91cF9uYW1lczooTGlzdC5yZXYgIW5hbWVzKSB+Z3JvdXBfY291bnQ6KCFwb3MgLyAyKVxuXG4oKioqKilcblxubGV0IHJlYyBhbmNob3JlZCA9IGZ1bmN0aW9uXG4gIHwgU2VxdWVuY2UgbCAtPlxuICAgIExpc3QuZXhpc3RzIGFuY2hvcmVkIGxcbiAgfCBBbHRlcm5hdGl2ZSBsIC0+XG4gICAgTGlzdC5mb3JfYWxsIGFuY2hvcmVkIGxcbiAgfCBSZXBlYXQgKHIsIGksIF8pIC0+XG4gICAgaSA+IDAgJiYgYW5jaG9yZWQgclxuICB8IFNldCBfIHwgQmVnX29mX2xpbmUgfCBFbmRfb2ZfbGluZSB8IEJlZ19vZl93b3JkIHwgRW5kX29mX3dvcmRcbiAgfCBOb3RfYm91bmQgfCBFbmRfb2Zfc3RyIHwgTGFzdF9lbmRfb2ZfbGluZSB8IFN0b3BcbiAgfCBJbnRlcnNlY3Rpb24gXyB8IENvbXBsZW1lbnQgXyB8IERpZmZlcmVuY2UgXyAtPlxuICAgIGZhbHNlXG4gIHwgQmVnX29mX3N0ciB8IFN0YXJ0IC0+XG4gICAgdHJ1ZVxuICB8IFNlbSAoXywgcikgfCBTZW1fZ3JlZWR5IChfLCByKSB8IEdyb3VwIChfLCByKSB8IE5vX2dyb3VwIHIgfCBOZXN0IHJcbiAgfCBDYXNlIHIgfCBOb19jYXNlIHIgfCBQbWFyayAoXywgcikgLT5cbiAgICBhbmNob3JlZCByXG5cbigqKioqKVxuXG50eXBlIHQgPSByZWdleHBcblxubGV0IHN0ciBzID1cbiAgbGV0IGwgPSByZWYgW10gaW5cbiAgZm9yIGkgPSBTdHJpbmcubGVuZ3RoIHMgLSAxIGRvd250byAwIGRvXG4gICAgbCA6PSBTZXQgKENzZXQuY3NpbmdsZSBzLltpXSkgOjogIWxcbiAgZG9uZTtcbiAgU2VxdWVuY2UgIWxcbmxldCBjaGFyIGMgPSBTZXQgKENzZXQuY3NpbmdsZSBjKVxuXG5sZXQgYWx0ID0gZnVuY3Rpb25cbiAgfCBbcl0gLT4gclxuICB8IGwgICAtPiBBbHRlcm5hdGl2ZSBsXG5sZXQgc2VxID0gZnVuY3Rpb25cbiAgfCBbcl0gLT4gclxuICB8IGwgICAtPiBTZXF1ZW5jZSBsXG5cbmxldCBlbXB0eSA9IGFsdCBbXVxubGV0IGVwc2lsb24gPSBzZXEgW11cbmxldCByZXBuIHIgaSBqID1cbiAgaWYgaSA8IDAgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLnJlcG5cIjtcbiAgYmVnaW4gbWF0Y2ggaiB3aXRoXG4gICAgfCBTb21lIGogd2hlbiBqIDwgaSAtPiBpbnZhbGlkX2FyZyBcIlJlLnJlcG5cIlxuICAgIHwgXyAtPiAoKVxuICBlbmQ7XG4gIFJlcGVhdCAociwgaSwgailcbmxldCByZXAgciA9IHJlcG4gciAwIE5vbmVcbmxldCByZXAxIHIgPSByZXBuIHIgMSBOb25lXG5sZXQgb3B0IHIgPSByZXBuIHIgMCAoU29tZSAxKVxubGV0IGJvbCA9IEJlZ19vZl9saW5lXG5sZXQgZW9sID0gRW5kX29mX2xpbmVcbmxldCBib3cgPSBCZWdfb2Zfd29yZFxubGV0IGVvdyA9IEVuZF9vZl93b3JkXG5sZXQgd29yZCByID0gc2VxIFtib3c7IHI7IGVvd11cbmxldCBub3RfYm91bmRhcnkgPSBOb3RfYm91bmRcbmxldCBib3MgPSBCZWdfb2Zfc3RyXG5sZXQgZW9zID0gRW5kX29mX3N0clxubGV0IHdob2xlX3N0cmluZyByID0gc2VxIFtib3M7IHI7IGVvc11cbmxldCBsZW9sID0gTGFzdF9lbmRfb2ZfbGluZVxubGV0IHN0YXJ0ID0gU3RhcnRcbmxldCBzdG9wID0gU3RvcFxubGV0IGxvbmdlc3QgciA9IFNlbSAoYExvbmdlc3QsIHIpXG5sZXQgc2hvcnRlc3QgciA9IFNlbSAoYFNob3J0ZXN0LCByKVxubGV0IGZpcnN0IHIgPSBTZW0gKGBGaXJzdCwgcilcbmxldCBncmVlZHkgciA9IFNlbV9ncmVlZHkgKGBHcmVlZHksIHIpXG5sZXQgbm9uX2dyZWVkeSByID0gU2VtX2dyZWVkeSAoYE5vbl9ncmVlZHksIHIpXG5sZXQgZ3JvdXAgP25hbWUgciA9IEdyb3VwIChuYW1lLCByKVxubGV0IG5vX2dyb3VwIHIgPSBOb19ncm91cCByXG5sZXQgbmVzdCByID0gTmVzdCByXG5sZXQgbWFyayByID0gbGV0IGkgPSBQbWFyay5nZW4gKCkgaW4gKGksUG1hcmsgKGkscikpXG5cbmxldCBzZXQgc3RyID1cbiAgbGV0IHMgPSByZWYgQ3NldC5lbXB0eSBpblxuICBmb3IgaSA9IDAgdG8gU3RyaW5nLmxlbmd0aCBzdHIgLSAxIGRvXG4gICAgcyA6PSBDc2V0LnVuaW9uIChDc2V0LmNzaW5nbGUgc3RyLltpXSkgIXNcbiAgZG9uZTtcbiAgU2V0ICFzXG5cbmxldCByZyBjIGMnID0gU2V0IChjc2VxIGMgYycpXG5cbmxldCBpbnRlciBsID1cbiAgbGV0IHIgPSBJbnRlcnNlY3Rpb24gbCBpblxuICBpZiBpc19jaGFyc2V0IHIgdGhlblxuICAgIHJcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnIFwiUmUuaW50ZXJcIlxuXG5sZXQgY29tcGwgbCA9XG4gIGxldCByID0gQ29tcGxlbWVudCBsIGluXG4gIGlmIGlzX2NoYXJzZXQgciB0aGVuXG4gICAgclxuICBlbHNlXG4gICAgaW52YWxpZF9hcmcgXCJSZS5jb21wbFwiXG5cbmxldCBkaWZmIHIgcicgPVxuICBsZXQgcicnID0gRGlmZmVyZW5jZSAociwgcicpIGluXG4gIGlmIGlzX2NoYXJzZXQgcicnIHRoZW5cbiAgICByJydcbiAgZWxzZVxuICAgIGludmFsaWRfYXJnIFwiUmUuZGlmZlwiXG5cbmxldCBhbnkgPSBTZXQgQ3NldC5jYW55XG5sZXQgbm90bmwgPSBTZXQgKENzZXQuZGlmZiBDc2V0LmNhbnkgKENzZXQuY3NpbmdsZSAnXFxuJykpXG5cbmxldCBsb3dlciA9IGFsdCBbcmcgJ2EnICd6JzsgY2hhciAnXFwxODEnOyByZyAnXFwyMjMnICdcXDI0Nic7IHJnICdcXDI0OCcgJ1xcMjU1J11cbmxldCB1cHBlciA9IGFsdCBbcmcgJ0EnICdaJzsgcmcgJ1xcMTkyJyAnXFwyMTQnOyByZyAnXFwyMTYnICdcXDIyMiddXG5sZXQgYWxwaGEgPSBhbHQgW2xvd2VyOyB1cHBlcjsgY2hhciAnXFwxNzAnOyBjaGFyICdcXDE4NiddXG5sZXQgZGlnaXQgPSByZyAnMCcgJzknXG5sZXQgYWxudW0gPSBhbHQgW2FscGhhOyBkaWdpdF1cbmxldCB3b3JkYyA9IGFsdCBbYWxudW07IGNoYXIgJ18nXVxubGV0IGFzY2lpID0gcmcgJ1xcMDAwJyAnXFwxMjcnXG5sZXQgYmxhbmsgPSBzZXQgXCJcXHQgXCJcbmxldCBjbnRybCA9IGFsdCBbcmcgJ1xcMDAwJyAnXFwwMzEnOyByZyAnXFwxMjcnICdcXDE1OSddXG5sZXQgZ3JhcGggPSBhbHQgW3JnICdcXDAzMycgJ1xcMTI2JzsgcmcgJ1xcMTYwJyAnXFwyNTUnXVxubGV0IHByaW50ID0gYWx0IFtyZyAnXFwwMzInICdcXDEyNic7IHJnICdcXDE2MCcgJ1xcMjU1J11cbmxldCBwdW5jdCA9XG4gIGFsdCBbcmcgJ1xcMDMzJyAnXFwwNDcnOyByZyAnXFwwNTgnICdcXDA2NCc7IHJnICdcXDA5MScgJ1xcMDk2JztcbiAgICAgICByZyAnXFwxMjMnICdcXDEyNic7IHJnICdcXDE2MCcgJ1xcMTY5JzsgcmcgJ1xcMTcxJyAnXFwxODAnO1xuICAgICAgIHJnICdcXDE4MicgJ1xcMTg1JzsgcmcgJ1xcMTg3JyAnXFwxOTEnOyBjaGFyICdcXDIxNSc7IGNoYXIgJ1xcMjQ3J11cbmxldCBzcGFjZSA9IGFsdCBbY2hhciAnICc7IHJnICdcXDAwOScgJ1xcMDEzJ11cbmxldCB4ZGlnaXQgPSBhbHQgW2RpZ2l0OyByZyAnYScgJ2YnOyByZyAnQScgJ0YnXVxuXG5sZXQgY2FzZSByID0gQ2FzZSByXG5sZXQgbm9fY2FzZSByID0gTm9fY2FzZSByXG5cbigqKioqKVxuXG5sZXQgY29tcGlsZSByID1cbiAgY29tcGlsZV8xIChcbiAgICBpZiBhbmNob3JlZCByIHRoZW5cbiAgICAgIGdyb3VwIHJcbiAgICBlbHNlXG4gICAgICBzZXEgW3Nob3J0ZXN0IChyZXAgYW55KTsgZ3JvdXAgcl1cbiAgKVxuXG5sZXQgZXhlY19pbnRlcm5hbCBuYW1lID8ocG9zPTApID8obGVuID0gLTEpIH5wYXJ0aWFsIH5ncm91cHMgcmUgcyA9XG4gIGlmIHBvcyA8IDAgfHwgbGVuIDwgLTEgfHwgcG9zICsgbGVuID4gU3RyaW5nLmxlbmd0aCBzIHRoZW5cbiAgICBpbnZhbGlkX2FyZyBuYW1lO1xuICBtYXRjaF9zdHIgfmdyb3VwcyB+cGFydGlhbCByZSBzIH5wb3MgfmxlblxuXG5sZXQgZXhlYyA/cG9zID9sZW4gcmUgcyA9XG4gIG1hdGNoIGV4ZWNfaW50ZXJuYWwgXCJSZS5leGVjXCIgP3BvcyA/bGVuIH5ncm91cHM6dHJ1ZSB+cGFydGlhbDpmYWxzZSByZSBzIHdpdGhcbiAgICBNYXRjaCBzdWJzdHIgLT4gc3Vic3RyXG4gIHwgXyAgICAgICAgICAgIC0+IHJhaXNlIE5vdF9mb3VuZFxuXG5sZXQgZXhlY19vcHQgP3BvcyA/bGVuIHJlIHMgPVxuICBtYXRjaCBleGVjX2ludGVybmFsIFwiUmUuZXhlY19vcHRcIiA/cG9zID9sZW4gfmdyb3Vwczp0cnVlIH5wYXJ0aWFsOmZhbHNlXG4gICAgICAgICAgcmUgcyB3aXRoXG4gICAgTWF0Y2ggc3Vic3RyIC0+IFNvbWUgc3Vic3RyXG4gIHwgXyAgICAgICAgICAgIC0+IE5vbmVcblxubGV0IGV4ZWNwID9wb3MgP2xlbiByZSBzID1cbiAgbWF0Y2ggZXhlY19pbnRlcm5hbCB+Z3JvdXBzOmZhbHNlIH5wYXJ0aWFsOmZhbHNlIFwiUmUuZXhlY3BcIiA/cG9zID9sZW4gcmUgcyB3aXRoXG4gICAgTWF0Y2ggX3N1YnN0ciAtPiB0cnVlXG4gIHwgXyAgICAgICAgICAgICAtPiBmYWxzZVxuXG5sZXQgZXhlY19wYXJ0aWFsID9wb3MgP2xlbiByZSBzID1cbiAgbWF0Y2ggZXhlY19pbnRlcm5hbCB+Z3JvdXBzOmZhbHNlIH5wYXJ0aWFsOnRydWUgXCJSZS5leGVjX3BhcnRpYWxcIlxuICAgICAgICAgID9wb3MgP2xlbiByZSBzIHdpdGhcbiAgICBNYXRjaCBfIC0+IGBGdWxsXG4gIHwgUnVubmluZyBfIC0+IGBQYXJ0aWFsXG4gIHwgRmFpbGVkICAtPiBgTWlzbWF0Y2hcblxubGV0IGV4ZWNfcGFydGlhbF9kZXRhaWxlZCA/cG9zID9sZW4gcmUgcyA9XG4gIG1hdGNoIGV4ZWNfaW50ZXJuYWwgfmdyb3Vwczp0cnVlIH5wYXJ0aWFsOnRydWUgXCJSZS5leGVjX3BhcnRpYWxfZGV0YWlsZWRcIlxuICAgICAgICAgID9wb3MgP2xlbiByZSBzIHdpdGhcbiAgICBNYXRjaCBncm91cCAtPiBgRnVsbCBncm91cFxuICB8IFJ1bm5pbmcgeyBub19tYXRjaF9zdGFydHNfYmVmb3JlIH0gLT4gYFBhcnRpYWwgbm9fbWF0Y2hfc3RhcnRzX2JlZm9yZVxuICB8IEZhaWxlZCAgLT4gYE1pc21hdGNoXG5cbm1vZHVsZSBNYXJrID0gc3RydWN0XG5cbiAgdHlwZSB0ID0gUG1hcmsudFxuXG4gIGxldCB0ZXN0IChnIDogR3JvdXAudCkgcCA9XG4gICAgUG1hcmsuU2V0Lm1lbSBwIGcucG1hcmtzXG5cbiAgbGV0IGFsbCAoZyA6IEdyb3VwLnQpID0gZy5wbWFya3NcblxuICBtb2R1bGUgU2V0ID0gUG1hcmsuU2V0XG5cbiAgbGV0IGVxdWFsID0gUG1hcmsuZXF1YWxcblxuICBsZXQgY29tcGFyZSA9IFBtYXJrLmNvbXBhcmVcblxuZW5kXG5cbnR5cGUgc3BsaXRfdG9rZW4gPVxuICBbIGBUZXh0IG9mIHN0cmluZ1xuICB8IGBEZWxpbSBvZiBHcm91cC50XG4gIF1cblxubW9kdWxlIFJzZXEgPSBzdHJ1Y3RcbiAgbGV0IGFsbCA/KHBvcz0wKSA/bGVuIHJlIHMgOiBfIFNlcS50ID1cbiAgICBpZiBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJSZS5hbGxcIjtcbiAgICAoKiBpbmRleCBvZiB0aGUgZmlyc3QgcG9zaXRpb24gd2UgZG8gbm90IGNvbnNpZGVyLlxuICAgICAgICFwb3MgPCBsaW1pdCBpcyBhbiBpbnZhcmlhbnQgKilcbiAgICBsZXQgbGltaXQgPSBtYXRjaCBsZW4gd2l0aFxuICAgICAgfCBOb25lIC0+IFN0cmluZy5sZW5ndGggc1xuICAgICAgfCBTb21lIGwgLT5cbiAgICAgICAgaWYgbDwwIHx8IHBvcytsID4gU3RyaW5nLmxlbmd0aCBzIHRoZW4gaW52YWxpZF9hcmcgXCJSZS5hbGxcIjtcbiAgICAgICAgcG9zK2xcbiAgICBpblxuICAgICgqIGl0ZXJhdGUgb24gbWF0Y2hlcy4gV2hlbiBhIG1hdGNoIGlzIGZvdW5kLCBzZWFyY2ggZm9yIHRoZSBuZXh0XG4gICAgICAgb25lIGp1c3QgYWZ0ZXIgaXRzIGVuZCAqKVxuICAgIGxldCByZWMgYXV4IHBvcyAoKSA9XG4gICAgICBpZiBwb3MgPj0gbGltaXRcbiAgICAgIHRoZW4gU2VxLk5pbCAoKiBubyBtb3JlIG1hdGNoZXMgKilcbiAgICAgIGVsc2VcbiAgICAgICAgbWF0Y2ggbWF0Y2hfc3RyIH5ncm91cHM6dHJ1ZSB+cGFydGlhbDpmYWxzZSByZSBzXG4gICAgICAgICAgICAgICAgfnBvcyB+bGVuOihsaW1pdCAtIHBvcykgd2l0aFxuICAgICAgICB8IE1hdGNoIHN1YnN0ciAtPlxuICAgICAgICAgIGxldCBwMSwgcDIgPSBHcm91cC5vZmZzZXQgc3Vic3RyIDAgaW5cbiAgICAgICAgICBsZXQgcG9zID0gaWYgcDE9cDIgdGhlbiBwMisxIGVsc2UgcDIgaW5cbiAgICAgICAgICBTZXEuQ29ucyAoc3Vic3RyLCBhdXggcG9zKVxuICAgICAgICB8IFJ1bm5pbmcgX1xuICAgICAgICB8IEZhaWxlZCAtPiBTZXEuTmlsXG4gICAgaW5cbiAgICBhdXggcG9zXG5cbiAgbGV0IG1hdGNoZXMgP3BvcyA/bGVuIHJlIHMgOiBfIFNlcS50ID1cbiAgICBhbGwgP3BvcyA/bGVuIHJlIHNcbiAgICB8PiBTZXEubWFwIChmdW4gc3ViIC0+IEdyb3VwLmdldCBzdWIgMClcblxuICBsZXQgc3BsaXRfZnVsbCA/KHBvcz0wKSA/bGVuIHJlIHMgOiBfIFNlcS50ID1cbiAgICBpZiBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJSZS5zcGxpdFwiO1xuICAgIGxldCBsaW1pdCA9IG1hdGNoIGxlbiB3aXRoXG4gICAgICB8IE5vbmUgLT4gU3RyaW5nLmxlbmd0aCBzXG4gICAgICB8IFNvbWUgbCAtPlxuICAgICAgICBpZiBsPDAgfHwgcG9zK2wgPiBTdHJpbmcubGVuZ3RoIHMgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLnNwbGl0XCI7XG4gICAgICAgIHBvcytsXG4gICAgaW5cbiAgICAoKiBpOiBzdGFydCBvZiBkZWxpbWl0ZWQgc3RyaW5nXG4gICAgICAgcG9zOiBmaXJzdCBwb3NpdGlvbiBhZnRlciBsYXN0IG1hdGNoIG9mIFtyZV1cbiAgICAgICBsaW1pdDogZmlyc3QgaW5kZXggd2UgaWdub3JlICghcG9zIDwgbGltaXQgaXMgYW4gaW52YXJpYW50KSAqKVxuICAgIGxldCBwb3MwID0gcG9zIGluXG4gICAgbGV0IHJlYyBhdXggc3RhdGUgaSBwb3MgKCkgPSBtYXRjaCBzdGF0ZSB3aXRoXG4gICAgICB8IGBJZGxlIHdoZW4gcG9zID49IGxpbWl0IC0+XG4gICAgICAgIGlmIGkgPCBsaW1pdCB0aGVuIChcbiAgICAgICAgICBsZXQgc3ViID0gU3RyaW5nLnN1YiBzIGkgKGxpbWl0IC0gaSkgaW5cbiAgICAgICAgICBTZXEuQ29ucyAoYFRleHQgc3ViLCBhdXggc3RhdGUgKGkrMSkgcG9zKVxuICAgICAgICApIGVsc2UgU2VxLk5pbFxuICAgICAgfCBgSWRsZSAtPlxuICAgICAgICBiZWdpbiBtYXRjaCBtYXRjaF9zdHIgfmdyb3Vwczp0cnVlIH5wYXJ0aWFsOmZhbHNlIHJlIHMgfnBvc1xuICAgICAgICAgICAgICAgICAgICAgIH5sZW46KGxpbWl0IC0gcG9zKSB3aXRoXG4gICAgICAgIHwgTWF0Y2ggc3Vic3RyIC0+XG4gICAgICAgICAgbGV0IHAxLCBwMiA9IEdyb3VwLm9mZnNldCBzdWJzdHIgMCBpblxuICAgICAgICAgIGxldCBwb3MgPSBpZiBwMT1wMiB0aGVuIHAyKzEgZWxzZSBwMiBpblxuICAgICAgICAgIGxldCBvbGRfaSA9IGkgaW5cbiAgICAgICAgICBsZXQgaSA9IHAyIGluXG4gICAgICAgICAgaWYgcDEgPiBwb3MwIHRoZW4gKFxuICAgICAgICAgICAgKCogc3RyaW5nIGRvZXMgbm90IHN0YXJ0IGJ5IGEgZGVsaW1pdGVyICopXG4gICAgICAgICAgICBsZXQgdGV4dCA9IFN0cmluZy5zdWIgcyBvbGRfaSAocDEgLSBvbGRfaSkgaW5cbiAgICAgICAgICAgIGxldCBzdGF0ZSA9IGBZaWVsZCAoYERlbGltIHN1YnN0cikgaW5cbiAgICAgICAgICAgIFNlcS5Db25zIChgVGV4dCB0ZXh0LCBhdXggc3RhdGUgaSBwb3MpXG4gICAgICAgICAgKSBlbHNlIFNlcS5Db25zIChgRGVsaW0gc3Vic3RyLCBhdXggc3RhdGUgaSBwb3MpXG4gICAgICAgIHwgUnVubmluZyBfIC0+IFNlcS5OaWxcbiAgICAgICAgfCBGYWlsZWQgLT5cbiAgICAgICAgICBpZiBpIDwgbGltaXRcbiAgICAgICAgICB0aGVuIChcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gU3RyaW5nLnN1YiBzIGkgKGxpbWl0IC0gaSkgaW5cbiAgICAgICAgICAgICgqIHlpZWxkIGxhc3Qgc3RyaW5nICopXG4gICAgICAgICAgICBTZXEuQ29ucyAoYFRleHQgdGV4dCwgYXV4IHN0YXRlIGxpbWl0IHBvcylcbiAgICAgICAgICApIGVsc2VcbiAgICAgICAgICAgIFNlcS5OaWxcbiAgICAgICAgZW5kXG4gICAgICB8IGBZaWVsZCB4IC0+XG4gICAgICAgIFNlcS5Db25zICh4LCBhdXggYElkbGUgaSBwb3MpXG4gICAgaW5cbiAgICBhdXggYElkbGUgcG9zIHBvc1xuXG4gIGxldCBzcGxpdCA/cG9zID9sZW4gcmUgcyA6IF8gU2VxLnQgPVxuICAgIGxldCBzZXEgPSBzcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzIGluXG4gICAgbGV0IHJlYyBmaWx0ZXIgc2VxICgpID0gbWF0Y2ggc2VxICgpICB3aXRoXG4gICAgICB8IFNlcS5OaWwgLT4gU2VxLk5pbFxuICAgICAgfCBTZXEuQ29ucyAoYERlbGltIF8sIHRsKSAtPiBmaWx0ZXIgdGwgKClcbiAgICAgIHwgU2VxLkNvbnMgKGBUZXh0IHMsdGwpIC0+IFNlcS5Db25zIChzLCBmaWx0ZXIgdGwpXG4gICAgaW4gZmlsdGVyIHNlcVxuZW5kXG5cbm1vZHVsZSBSbGlzdCA9IHN0cnVjdFxuICBsZXQgbGlzdF9vZl9zZXEgKHM6J2EgU2VxLnQpIDogJ2EgbGlzdCA9XG4gICAgU2VxLmZvbGRfbGVmdCAoZnVuIGwgeCAtPiB4IDo6IGwpIFtdIHMgfD4gTGlzdC5yZXZcblxuICBsZXQgYWxsID9wb3MgP2xlbiByZSBzID0gUnNlcS5hbGwgP3BvcyA/bGVuIHJlIHMgfD4gbGlzdF9vZl9zZXFcblxuICBsZXQgbWF0Y2hlcyA/cG9zID9sZW4gcmUgcyA9IFJzZXEubWF0Y2hlcyA/cG9zID9sZW4gcmUgcyB8PiBsaXN0X29mX3NlcVxuXG4gIGxldCBzcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzID0gUnNlcS5zcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzIHw+IGxpc3Rfb2Zfc2VxXG5cbiAgbGV0IHNwbGl0ID9wb3MgP2xlbiByZSBzID0gUnNlcS5zcGxpdCA/cG9zID9sZW4gcmUgcyB8PiBsaXN0X29mX3NlcVxuZW5kXG5cbm1vZHVsZSBHZW4gPSBzdHJ1Y3RcbiAgdHlwZSAnYSBnZW4gPSB1bml0IC0+ICdhIG9wdGlvblxuICBsZXQgZ2VuX29mX3NlcSAoczonYSBTZXEudCkgOiAnYSBnZW4gPVxuICAgIGxldCByID0gcmVmIHMgaW5cbiAgICBmdW4gKCkgLT4gbWF0Y2ggIXIgKCkgd2l0aFxuICAgICAgfCBTZXEuTmlsIC0+IE5vbmVcbiAgICAgIHwgU2VxLkNvbnMgKHgsIHRsKSAtPlxuICAgICAgICByIDo9IHRsO1xuICAgICAgICBTb21lIHhcblxuICBsZXQgc3BsaXQgP3BvcyA/bGVuIHJlIHMgOiBfIGdlbiA9XG4gICAgUnNlcS5zcGxpdCA/cG9zID9sZW4gcmUgcyB8PiBnZW5fb2Zfc2VxXG5cbiAgbGV0IHNwbGl0X2Z1bGwgP3BvcyA/bGVuIHJlIHMgOiBfIGdlbiA9XG4gICAgUnNlcS5zcGxpdF9mdWxsID9wb3MgP2xlbiByZSBzIHw+IGdlbl9vZl9zZXFcblxuICBsZXQgYWxsID9wb3MgP2xlbiByZSBzID0gUnNlcS5hbGwgP3BvcyA/bGVuIHJlIHMgfD4gZ2VuX29mX3NlcVxuXG4gIGxldCBtYXRjaGVzID9wb3MgP2xlbiByZSBzID0gUnNlcS5tYXRjaGVzID9wb3MgP2xlbiByZSBzIHw+IGdlbl9vZl9zZXFcbmVuZFxuXG5sZXQgcmVwbGFjZSA/KHBvcz0wKSA/bGVuID8oYWxsPXRydWUpIHJlIH5mIHMgPVxuICBpZiBwb3MgPCAwIHRoZW4gaW52YWxpZF9hcmcgXCJSZS5yZXBsYWNlXCI7XG4gIGxldCBsaW1pdCA9IG1hdGNoIGxlbiB3aXRoXG4gICAgfCBOb25lIC0+IFN0cmluZy5sZW5ndGggc1xuICAgIHwgU29tZSBsIC0+XG4gICAgICBpZiBsPDAgfHwgcG9zK2wgPiBTdHJpbmcubGVuZ3RoIHMgdGhlbiBpbnZhbGlkX2FyZyBcIlJlLnJlcGxhY2VcIjtcbiAgICAgIHBvcytsXG4gIGluXG4gICgqIGJ1ZmZlciBpbnRvIHdoaWNoIHdlIHdyaXRlIHRoZSByZXN1bHQgKilcbiAgbGV0IGJ1ZiA9IEJ1ZmZlci5jcmVhdGUgKFN0cmluZy5sZW5ndGggcykgaW5cbiAgKCogaXRlcmF0ZSBvbiBtYXRjaGVkIHN1YnN0cmluZ3MuICopXG4gIGxldCByZWMgaXRlciBwb3MgPVxuICAgIGlmIHBvcyA8IGxpbWl0XG4gICAgdGhlblxuICAgICAgbWF0Y2ggbWF0Y2hfc3RyIH5ncm91cHM6dHJ1ZSB+cGFydGlhbDpmYWxzZSByZSBzIH5wb3MgfmxlbjoobGltaXQtcG9zKSB3aXRoXG4gICAgICB8IE1hdGNoIHN1YnN0ciAtPlxuICAgICAgICBsZXQgcDEsIHAyID0gR3JvdXAub2Zmc2V0IHN1YnN0ciAwIGluXG4gICAgICAgICgqIGFkZCBzdHJpbmcgYmV0d2VlbiBwcmV2aW91cyBtYXRjaCBhbmQgY3VycmVudCBtYXRjaCAqKVxuICAgICAgICBCdWZmZXIuYWRkX3N1YnN0cmluZyBidWYgcyBwb3MgKHAxLXBvcyk7XG4gICAgICAgICgqIHdoYXQgc2hvdWxkIHdlIHJlcGxhY2UgdGhlIG1hdGNoZWQgZ3JvdXAgd2l0aD8gKilcbiAgICAgICAgbGV0IHJlcGxhY2luZyA9IGYgc3Vic3RyIGluXG4gICAgICAgIEJ1ZmZlci5hZGRfc3RyaW5nIGJ1ZiByZXBsYWNpbmc7XG4gICAgICAgIGlmIGFsbCB0aGVuXG4gICAgICAgICAgKCogaWYgd2UgbWF0Y2hlZCBhIG5vbi1jaGFyIGUuZy4gXiB3ZSBtdXN0IG1hbnVhbGx5IGFkdmFuY2UgYnkgMSAqKVxuICAgICAgICAgIGl0ZXIgKFxuICAgICAgICAgICAgaWYgcDE9cDIgdGhlbiAoXG4gICAgICAgICAgICAgICgqIGEgbm9uIGNoYXIgY291bGQgYmUgcGFzdCB0aGUgZW5kIG9mIHN0cmluZy4gZS5nLiAkICopXG4gICAgICAgICAgICAgIGlmIHAyIDwgbGltaXQgdGhlbiBCdWZmZXIuYWRkX2NoYXIgYnVmIHMuW3AyXTtcbiAgICAgICAgICAgICAgcDIrMVxuICAgICAgICAgICAgKSBlbHNlXG4gICAgICAgICAgICAgIHAyKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYnVmIHMgcDIgKGxpbWl0LXAyKVxuICAgICAgfCBSdW5uaW5nIF8gLT4gKClcbiAgICAgIHwgRmFpbGVkIC0+XG4gICAgICAgIEJ1ZmZlci5hZGRfc3Vic3RyaW5nIGJ1ZiBzIHBvcyAobGltaXQtcG9zKVxuICBpblxuICBpdGVyIHBvcztcbiAgQnVmZmVyLmNvbnRlbnRzIGJ1ZlxuXG5sZXQgcmVwbGFjZV9zdHJpbmcgP3BvcyA/bGVuID9hbGwgcmUgfmJ5IHMgPVxuICByZXBsYWNlID9wb3MgP2xlbiA/YWxsIHJlIHMgfmY6KGZ1biBfIC0+IGJ5KVxuXG5sZXQgd2l0bmVzcyB0ID1cbiAgbGV0IHJlYyB3aXRuZXNzID0gZnVuY3Rpb25cbiAgICB8IFNldCBjIC0+IFN0cmluZy5tYWtlIDEgKENoYXIuY2hyIChDc2V0LnBpY2sgYykpXG4gICAgfCBTZXF1ZW5jZSB4cyAtPiBTdHJpbmcuY29uY2F0IFwiXCIgKExpc3QubWFwIHdpdG5lc3MgeHMpXG4gICAgfCBBbHRlcm5hdGl2ZSAoeCA6OiBfKSAtPiB3aXRuZXNzIHhcbiAgICB8IEFsdGVybmF0aXZlIFtdIC0+IGFzc2VydCBmYWxzZVxuICAgIHwgUmVwZWF0IChyLCBmcm9tLCBfdG8pIC0+XG4gICAgICBsZXQgdyA9IHdpdG5lc3MgciBpblxuICAgICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIChTdHJpbmcubGVuZ3RoIHcgKiBmcm9tKSBpblxuICAgICAgZm9yIF9pPTEgdG8gZnJvbSBkb1xuICAgICAgICBCdWZmZXIuYWRkX3N0cmluZyBiIHdcbiAgICAgIGRvbmU7XG4gICAgICBCdWZmZXIuY29udGVudHMgYlxuICAgIHwgTm9fY2FzZSByIC0+IHdpdG5lc3MgclxuICAgIHwgSW50ZXJzZWN0aW9uIF9cbiAgICB8IENvbXBsZW1lbnQgX1xuICAgIHwgRGlmZmVyZW5jZSAoXywgXykgLT4gYXNzZXJ0IGZhbHNlXG4gICAgfCBHcm91cCAoXywgcilcbiAgICB8IE5vX2dyb3VwIHJcbiAgICB8IE5lc3QgclxuICAgIHwgU2VtIChfLCByKVxuICAgIHwgUG1hcmsgKF8sIHIpXG4gICAgfCBDYXNlIHJcbiAgICB8IFNlbV9ncmVlZHkgKF8sIHIpIC0+IHdpdG5lc3MgclxuICAgIHwgQmVnX29mX2xpbmVcbiAgICB8IEVuZF9vZl9saW5lXG4gICAgfCBCZWdfb2Zfd29yZFxuICAgIHwgRW5kX29mX3dvcmRcbiAgICB8IE5vdF9ib3VuZFxuICAgIHwgQmVnX29mX3N0clxuICAgIHwgTGFzdF9lbmRfb2ZfbGluZVxuICAgIHwgU3RhcnRcbiAgICB8IFN0b3BcbiAgICB8IEVuZF9vZl9zdHIgLT4gXCJcIiBpblxuICB3aXRuZXNzIChoYW5kbGVfY2FzZSBmYWxzZSB0KVxuXG5tb2R1bGUgU2VxID0gUnNlcVxubW9kdWxlIExpc3QgPSBSbGlzdFxubW9kdWxlIEdyb3VwID0gR3JvdXBcblxuKCoqIHsyIERlcHJlY2F0ZWQgZnVuY3Rpb25zfSAqKVxuXG5sZXQgc3BsaXRfZnVsbF9zZXEgPSBTZXEuc3BsaXRfZnVsbFxubGV0IHNwbGl0X3NlcSA9IFNlcS5zcGxpdFxubGV0IG1hdGNoZXNfc2VxID0gU2VxLm1hdGNoZXNcbmxldCBhbGxfc2VxID0gU2VxLmFsbFxuXG50eXBlICdhIGdlbiAgICAgICAgPSAnYSBHZW4uZ2VuXG5sZXQgYWxsX2dlbiAgICAgICAgPSBHZW4uYWxsXG5sZXQgbWF0Y2hlc19nZW4gICAgPSBHZW4ubWF0Y2hlc1xubGV0IHNwbGl0X2dlbiAgICAgID0gR2VuLnNwbGl0XG5sZXQgc3BsaXRfZnVsbF9nZW4gPSBHZW4uc3BsaXRfZnVsbFxuXG5cbnR5cGUgc3Vic3RyaW5ncyA9IEdyb3VwLnRcblxubGV0IGdldCA9IEdyb3VwLmdldFxubGV0IGdldF9vZnMgPSBHcm91cC5vZmZzZXRcbmxldCBnZXRfYWxsID0gR3JvdXAuYWxsXG5sZXQgZ2V0X2FsbF9vZnMgPSBHcm91cC5hbGxfb2Zmc2V0XG5sZXQgdGVzdCA9IEdyb3VwLnRlc3RcblxudHlwZSBtYXJraWQgPSBNYXJrLnRcblxubGV0IG1hcmtlZCA9IE1hcmsudGVzdFxubGV0IG1hcmtfc2V0ID0gTWFyay5hbGxcblxuKCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiopXG5cbigqXG5JbmZvcm1hdGlvbiBhYm91dCB0aGUgcHJldmlvdXMgY2hhcmFjdGVyOlxuLSBkb2VzIG5vdCBleGlzdHNcbi0gaXMgYSBsZXR0ZXJcbi0gaXMgbm90IGEgbGV0dGVyXG4tIGlzIGEgbmV3bGluZVxuLSBpcyBsYXN0IG5ld2xpbmVcblxuQmVnaW5uaW5nIG9mIHdvcmQ6XG4tIHByZXZpb3VzIGlzIG5vdCBhIGxldHRlciBvciBkb2VzIG5vdCBleGlzdFxuLSBjdXJyZW50IGlzIGEgbGV0dGVyIG9yIGRvZXMgbm90IGV4aXN0XG5cbkVuZCBvZiB3b3JkOlxuLSBwcmV2aW91cyBpcyBhIGxldHRlciBvciBkb2VzIG5vdCBleGlzdFxuLSBjdXJyZW50IGlzIG5vdCBhIGxldHRlciBvciBkb2VzIG5vdCBleGlzdFxuXG5CZWdpbm5pbmcgb2YgbGluZTpcbi0gcHJldmlvdXMgaXMgYSBuZXdsaW5lIG9yIGRvZXMgbm90IGV4aXN0XG5cbkJlZ2lubmluZyBvZiBidWZmZXI6XG4tIHByZXZpb3VzIGRvZXMgbm90IGV4aXN0XG5cbkVuZCBvZiBidWZmZXJcbi0gY3VycmVudCBkb2VzIG5vdCBleGlzdFxuXG5FbmQgb2YgbGluZVxuLSBjdXJyZW50IGlzIGEgbmV3bGluZSBvciBkb2VzIG5vdCBleGlzdFxuKilcblxuKCpcblJlcDogZSA9IFQsZSB8ICgpXG4gIC0gc2VtYW50aWNzIG9mIHRoZSBjb21tYSAoc2hvcnRlc3QvbG9uZ2VzdC9maXJzdClcbiAgLSBzZW1hbnRpY3Mgb2YgdGhlIHVuaW9uIChncmVlZHkvbm9uLWdyZWVkeSlcblxuQm91bmRlZCByZXBldGl0aW9uXG4gIGF7MCwzfSA9IChhLChhLGE/KT8pP1xuKilcblxudHlwZSBncm91cHMgPSBHcm91cC50XG5cbmluY2x1ZGUgUmxpc3RcbiIsIigqXG4gICBSRSAtIEEgcmVndWxhciBleHByZXNzaW9uIGxpYnJhcnlcblxuICAgQ29weXJpZ2h0IChDKSAyMDAxIEplcm9tZSBWb3VpbGxvblxuICAgZW1haWw6IEplcm9tZS5Wb3VpbGxvbkBwcHMuanVzc2lldS5mclxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoXG4gICBsaW5raW5nIGV4Y2VwdGlvbjsgZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXRcbiAgIHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAgIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAgIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0FcbiopXG5cbm1vZHVsZSBSZSA9IENvcmVcblxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yXG5leGNlcHRpb24gTm90X3N1cHBvcnRlZFxuXG5sZXQgcGFyc2UgcyA9XG4gIGxldCBpID0gcmVmIDAgaW5cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGVvcyAoKSA9ICFpID0gbCBpblxuICBsZXQgdGVzdCBjID0gbm90IChlb3MgKCkpICYmIHMuWyFpXSA9IGMgaW5cbiAgbGV0IHRlc3QyIGMgYycgPSAhaSArIDEgPCBsICYmIHMuWyFpXSA9IGMgJiYgcy5bIWkgKyAxXSA9IGMnIGluXG4gIGxldCBhY2NlcHQgYyA9IGxldCByID0gdGVzdCBjIGluIGlmIHIgdGhlbiBpbmNyIGk7IHIgaW5cbiAgbGV0IGFjY2VwdDIgYyBjJyA9IGxldCByID0gdGVzdDIgYyBjJyBpbiBpZiByIHRoZW4gaSA6PSAhaSArIDI7IHIgaW5cbiAgbGV0IGdldCAoKSA9IGxldCByID0gcy5bIWldIGluIGluY3IgaTsgciBpblxuXG4gIGxldCByZWMgcmVnZXhwICgpID0gcmVnZXhwJyAoYnJhbmNoICgpKVxuICBhbmQgcmVnZXhwJyBsZWZ0ID1cbiAgICBpZiBhY2NlcHQyICdcXFxcJyAnfCcgdGhlbiByZWdleHAnIChSZS5hbHQgW2xlZnQ7IGJyYW5jaCAoKV0pIGVsc2UgbGVmdFxuICBhbmQgYnJhbmNoICgpID0gYnJhbmNoJyBbXVxuICBhbmQgYnJhbmNoJyBsZWZ0ID1cbiAgICBpZiBlb3MgKCkgfHwgdGVzdDIgJ1xcXFwnICd8JyB8fCB0ZXN0MiAnXFxcXCcgJyknIHRoZW4gUmUuc2VxIChMaXN0LnJldiBsZWZ0KVxuICAgIGVsc2UgYnJhbmNoJyAocGllY2UgKCkgOjogbGVmdClcbiAgYW5kIHBpZWNlICgpID1cbiAgICBsZXQgciA9IGF0b20gKCkgaW5cbiAgICBpZiBhY2NlcHQgJyonIHRoZW4gUmUucmVwIHIgZWxzZVxuICAgIGlmIGFjY2VwdCAnKycgdGhlbiBSZS5yZXAxIHIgZWxzZVxuICAgIGlmIGFjY2VwdCAnPycgdGhlbiBSZS5vcHQgciBlbHNlXG4gICAgclxuICBhbmQgYXRvbSAoKSA9XG4gICAgaWYgYWNjZXB0ICcuJyB0aGVuIGJlZ2luXG4gICAgICBSZS5ub3RubFxuICAgIGVuZCBlbHNlIGlmIGFjY2VwdCAnXicgdGhlbiBiZWdpblxuICAgICAgUmUuYm9sXG4gICAgZW5kIGVsc2UgaWYgYWNjZXB0ICckJyB0aGVuIGJlZ2luXG4gICAgICBSZS5lb2xcbiAgICBlbmQgZWxzZSBpZiBhY2NlcHQgJ1snIHRoZW4gYmVnaW5cbiAgICAgIGlmIGFjY2VwdCAnXicgdGhlblxuICAgICAgICBSZS5jb21wbCAoYnJhY2tldCBbXSlcbiAgICAgIGVsc2VcbiAgICAgICAgUmUuYWx0IChicmFja2V0IFtdKVxuICAgIGVuZCBlbHNlIGlmIGFjY2VwdCAnXFxcXCcgdGhlbiBiZWdpblxuICAgICAgaWYgYWNjZXB0ICcoJyB0aGVuIGJlZ2luXG4gICAgICAgIGxldCByID0gcmVnZXhwICgpIGluXG4gICAgICAgIGlmIG5vdCAoYWNjZXB0MiAnXFxcXCcgJyknKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICBSZS5ncm91cCByXG4gICAgICBlbmQgZWxzZSBpZiBhY2NlcHQgJ2AnIHRoZW5cbiAgICAgICAgUmUuYm9zXG4gICAgICBlbHNlIGlmIGFjY2VwdCAnXFwnJyB0aGVuXG4gICAgICAgIFJlLmVvc1xuICAgICAgZWxzZSBpZiBhY2NlcHQgJz0nIHRoZW5cbiAgICAgICAgUmUuc3RhcnRcbiAgICAgIGVsc2UgaWYgYWNjZXB0ICdiJyB0aGVuXG4gICAgICAgIFJlLmFsdCBbUmUuYm93OyBSZS5lb3ddXG4gICAgICBlbHNlIGlmIGFjY2VwdCAnQicgdGhlblxuICAgICAgICBSZS5ub3RfYm91bmRhcnlcbiAgICAgIGVsc2UgaWYgYWNjZXB0ICc8JyB0aGVuXG4gICAgICAgIFJlLmJvd1xuICAgICAgZWxzZSBpZiBhY2NlcHQgJz4nIHRoZW5cbiAgICAgICAgUmUuZW93XG4gICAgICBlbHNlIGlmIGFjY2VwdCAndycgdGhlblxuICAgICAgICBSZS5hbHQgW1JlLmFsbnVtOyBSZS5jaGFyICdfJ11cbiAgICAgIGVsc2UgaWYgYWNjZXB0ICdXJyB0aGVuXG4gICAgICAgIFJlLmNvbXBsIFtSZS5hbG51bTsgUmUuY2hhciAnXyddXG4gICAgICBlbHNlIGJlZ2luXG4gICAgICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgICAgICcqJyB8ICcrJyB8ICc/JyB8ICdbJyB8ICddJyB8ICcuJyB8ICdeJyB8ICckJyB8ICdcXFxcJyBhcyBjIC0+XG4gICAgICAgICAgICBSZS5jaGFyIGNcbiAgICAgICAgfCAnMCcgLi4gJzknIC0+XG4gICAgICAgICAgICByYWlzZSBOb3Rfc3VwcG9ydGVkXG4gICAgICAgIHwgXyAtPlxuICAgICAgICAgICAgcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgIGVuZFxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICAgICcqJyB8ICcrJyB8ICc/JyAtPiByYWlzZSBQYXJzZV9lcnJvclxuICAgICAgfCAgICAgICAgYyAgICAgICAgLT4gUmUuY2hhciBjXG4gICAgZW5kXG4gIGFuZCBicmFja2V0IHMgPVxuICAgIGlmIHMgPD4gW10gJiYgYWNjZXB0ICddJyB0aGVuIHMgZWxzZSBiZWdpblxuICAgICAgbGV0IGMgPSBjaGFyICgpIGluXG4gICAgICBpZiBhY2NlcHQgJy0nIHRoZW4gYmVnaW5cbiAgICAgICAgaWYgYWNjZXB0ICddJyB0aGVuIFJlLmNoYXIgYyA6OiBSZS5jaGFyICctJyA6OiBzIGVsc2UgYmVnaW5cbiAgICAgICAgICBsZXQgYycgPSBjaGFyICgpIGluXG4gICAgICAgICAgYnJhY2tldCAoUmUucmcgYyBjJyA6OiBzKVxuICAgICAgICBlbmRcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIGJyYWNrZXQgKFJlLmNoYXIgYyA6OiBzKVxuICAgIGVuZFxuICBhbmQgY2hhciAoKSA9XG4gICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgZ2V0ICgpXG4gIGluXG4gIGxldCByZXMgPSByZWdleHAgKCkgaW5cbiAgaWYgbm90IChlb3MgKCkpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gIHJlc1xuXG5sZXQgcmUgPyhjYXNlID0gdHJ1ZSkgcyA9IGxldCByID0gcGFyc2UgcyBpbiBpZiBjYXNlIHRoZW4gciBlbHNlIFJlLm5vX2Nhc2UgclxuXG5sZXQgY29tcGlsZSA9IFJlLmNvbXBpbGVcbmxldCBjb21waWxlX3BhdCA/KGNhc2UgPSB0cnVlKSBzID0gY29tcGlsZSAocmUgfmNhc2UgcylcbiIsIigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0aXZlIENhbWwgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgWGF2aWVyIExlcm95LCBwcm9qZXQgQ3Jpc3RhbCwgSU5SSUEgUm9jcXVlbmNvdXJ0ICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICBDb3B5cmlnaHQgMTk5NiBJbnN0aXR1dCBOYXRpb25hbCBkZSBSZWNoZXJjaGUgZW4gSW5mb3JtYXRpcXVlIGV0ICAgKilcbigqICBlbiBBdXRvbWF0aXF1ZS4gIEFsbCByaWdodHMgcmVzZXJ2ZWQuICBUaGlzIGZpbGUgaXMgZGlzdHJpYnV0ZWQgICAgKilcbigqICB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMaWJyYXJ5IEdlbmVyYWwgUHVibGljIExpY2Vuc2UsIHdpdGggICAgKilcbigqICBsaW5raW5nIGV4Y2VwdGlvbi4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKilcbigqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKilcblxuKCogTW9kaWZpZWQgYnkgSmVyb21lLlZvdWlsbG9uQHBwcy5qdXNzaWV1LmZyIGZvciBpbnRlZ3JhdGlvbiBpbiBSRSAqKVxuXG4oKiAkSWQ6IHJlX3N0ci5tbCx2IDEuMyAyMDAyLzA3LzAzIDE1OjQ3OjU0IHZvdWlsbG9uIEV4cCAkICopXG5cbm1vZHVsZSBSZSA9IENvcmVcblxudHlwZSByZWdleHAgPVxuICB7IHJlOiBSZS50XG4gIDsgbXRjaDogUmUucmUgTGF6eS50XG4gIDsgc3JjaDogUmUucmUgTGF6eS50IH1cblxubGV0IGNvbXBpbGVfcmVnZXhwIHMgYyA9XG4gIGxldCByZSA9IEVtYWNzLnJlIH5jYXNlOihub3QgYykgcyBpblxuICB7IHJlXG4gIDsgbXRjaCA9IGxhenkgKFJlLmNvbXBpbGUgKFJlLnNlcSBbUmUuc3RhcnQ7IHJlXSkpXG4gIDsgc3JjaCA9IGxhenkgKFJlLmNvbXBpbGUgcmUpIH1cblxubGV0IHN0YXRlID0gcmVmIE5vbmVcblxubGV0IHN0cmluZ19tYXRjaCByZSBzIHAgPVxuICB0cnlcbiAgICBzdGF0ZSA6PSBTb21lIChSZS5leGVjIH5wb3M6cCAoTGF6eS5mb3JjZSByZS5tdGNoKSBzKTtcbiAgICB0cnVlXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgc3RhdGUgOj0gTm9uZTtcbiAgICBmYWxzZVxuXG5sZXQgc3RyaW5nX3BhcnRpYWxfbWF0Y2ggcmUgcyBwID1cbiAgbWF0Y2hcbiAgICBSZS5leGVjX3BhcnRpYWwgfnBvczpwIChMYXp5LmZvcmNlIHJlLm10Y2gpIHNcbiAgd2l0aFxuICAgIGBGdWxsICAgICAtPiBzdHJpbmdfbWF0Y2ggcmUgcyBwXG4gIHwgYFBhcnRpYWwgIC0+IHRydWVcbiAgfCBgTWlzbWF0Y2ggLT4gZmFsc2VcblxubGV0IHNlYXJjaF9mb3J3YXJkIHJlIHMgcCA9XG4gIHRyeVxuICAgIGxldCByZXMgPSBSZS5leGVjIH5wb3M6cCAoTGF6eS5mb3JjZSByZS5zcmNoKSBzIGluXG4gICAgc3RhdGUgOj0gU29tZSByZXM7XG4gICAgZnN0IChSZS5Hcm91cC5vZmZzZXQgcmVzIDApXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgc3RhdGUgOj0gTm9uZTtcbiAgICByYWlzZSBOb3RfZm91bmRcblxubGV0IHJlYyBzZWFyY2hfYmFja3dhcmQgcmUgcyBwID1cbiAgdHJ5XG4gICAgbGV0IHJlcyA9IFJlLmV4ZWMgfnBvczpwIChMYXp5LmZvcmNlIHJlLm10Y2gpIHMgaW5cbiAgICBzdGF0ZSA6PSBTb21lIHJlcztcbiAgICBwXG4gIHdpdGggTm90X2ZvdW5kIC0+XG4gICAgc3RhdGUgOj0gTm9uZTtcbiAgICBpZiBwID0gMCB0aGVuXG4gICAgICByYWlzZSBOb3RfZm91bmRcbiAgICBlbHNlXG4gICAgICBzZWFyY2hfYmFja3dhcmQgcmUgcyAocCAtIDEpXG5cbmxldCB2YWxpZF9ncm91cCBuID1cbiAgbiA+PSAwICYmIG4gPCAxMCAmJiAoXG4gICAgbWF0Y2ggIXN0YXRlIHdpdGhcbiAgICB8IE5vbmUgLT4gZmFsc2VcbiAgICB8IFNvbWUgbSAtPiBuIDwgUmUuR3JvdXAubmJfZ3JvdXBzIG1cbiAgKVxuXG5sZXQgb2Zmc2V0X2dyb3VwIGkgPVxuICBtYXRjaCAhc3RhdGUgd2l0aFxuICB8IFNvbWUgbSAtPiBSZS5Hcm91cC5vZmZzZXQgbSBpXG4gIHwgTm9uZSAgIC0+IHJhaXNlIE5vdF9mb3VuZFxuXG5sZXQgZ3JvdXBfbGVuIGkgPVxuICB0cnlcbiAgICBsZXQgKGIsIGUpID0gb2Zmc2V0X2dyb3VwIGkgaW5cbiAgICBlIC0gYlxuICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgIDBcblxubGV0IHJlYyByZXBsX2xlbmd0aCByZXBsIHAgcSBsZW4gPVxuICBpZiBwIDwgbGVuIHRoZW4gYmVnaW5cbiAgICBpZiByZXBsLltwXSA8PiAnXFxcXCcgdGhlblxuICAgICAgcmVwbF9sZW5ndGggcmVwbCAocCArIDEpIChxICsgMSkgbGVuXG4gICAgZWxzZSBiZWdpblxuICAgICAgbGV0IHAgPSBwICsgMSBpblxuICAgICAgaWYgcCA9IGxlbiB0aGVuIGZhaWx3aXRoIFwiU3RyLnJlcGxhY2U6IGlsbGVnYWwgYmFja3NsYXNoIHNlcXVlbmNlXCI7XG4gICAgICBsZXQgcSA9XG4gICAgICAgIG1hdGNoIHJlcGwuW3BdIHdpdGhcbiAgICAgICAgfCAnXFxcXCcgLT4gcSArIDFcbiAgICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT4gcSArIGdyb3VwX2xlbiAoQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnKVxuICAgICAgICB8IF8gLT4gcSArIDIgaW5cbiAgICAgIHJlcGxfbGVuZ3RoIHJlcGwgKHAgKyAxKSBxIGxlblxuICAgIGVuZFxuICBlbmQgZWxzZVxuICAgIHFcblxubGV0IHJlYyByZXBsYWNlIG9yaWcgcmVwbCBwIHJlcyBxIGxlbiA9XG4gIGlmIHAgPCBsZW4gdGhlbiBiZWdpblxuICAgIGxldCBjID0gcmVwbC5bcF0gaW5cbiAgICBpZiBjIDw+ICdcXFxcJyB0aGVuIGJlZ2luXG4gICAgICBCeXRlcy5zZXQgcmVzIHEgYztcbiAgICAgIHJlcGxhY2Ugb3JpZyByZXBsIChwICsgMSkgcmVzIChxICsgMSkgbGVuXG4gICAgZW5kIGVsc2UgYmVnaW5cbiAgICAgIG1hdGNoIHJlcGwuW3AgKyAxXSB3aXRoXG4gICAgICAgICdcXFxcJyAtPlxuICAgICAgICBCeXRlcy5zZXQgcmVzIHEgJ1xcXFwnO1xuICAgICAgICByZXBsYWNlIG9yaWcgcmVwbCAocCArIDIpIHJlcyAocSArIDEpIGxlblxuICAgICAgfCAnMCcgLi4gJzknIGFzIGMgLT5cbiAgICAgICAgbGV0IGQgPVxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbGV0IChiLCBlKSA9IG9mZnNldF9ncm91cCAoQ2hhci5jb2RlIGMgLSBDaGFyLmNvZGUgJzAnKSBpblxuICAgICAgICAgICAgbGV0IGQgPSBlIC0gYiBpblxuICAgICAgICAgICAgaWYgZCA+IDAgdGhlbiBTdHJpbmcuYmxpdCBvcmlnIGIgcmVzIHEgZDtcbiAgICAgICAgICAgIGRcbiAgICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAgICAgMFxuICAgICAgICBpblxuICAgICAgICByZXBsYWNlIG9yaWcgcmVwbCAocCArIDIpIHJlcyAocSArIGQpIGxlblxuICAgICAgfCBjIC0+XG4gICAgICAgIEJ5dGVzLnNldCByZXMgcSAnXFxcXCc7XG4gICAgICAgIEJ5dGVzLnNldCByZXMgKHEgKyAxKSBjO1xuICAgICAgICByZXBsYWNlIG9yaWcgcmVwbCAocCArIDIpIHJlcyAocSArIDIpIGxlblxuICAgIGVuZFxuICBlbmRcblxubGV0IHJlcGxhY2VtZW50X3RleHQgcmVwbCBvcmlnID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcmVwbCBpblxuICBsZXQgcmVzID0gQnl0ZXMuY3JlYXRlIChyZXBsX2xlbmd0aCByZXBsIDAgMCBsZW4pIGluXG4gIHJlcGxhY2Ugb3JpZyByZXBsIDAgcmVzIDAgKFN0cmluZy5sZW5ndGggcmVwbCk7XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgcmVzXG5cbmxldCBxdW90ZSBzID1cbiAgbGV0IGxlbiA9IFN0cmluZy5sZW5ndGggcyBpblxuICBsZXQgYnVmID0gQnVmZmVyLmNyZWF0ZSAoMiAqIGxlbikgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBtYXRjaCBzLltpXSB3aXRoXG4gICAgICAnWycgfCAnXScgfCAnKicgfCAnLicgfCAnXFxcXCcgfCAnPycgfCAnKycgfCAnXicgfCAnJCcgYXMgYyAtPlxuICAgICAgQnVmZmVyLmFkZF9jaGFyIGJ1ZiAnXFxcXCc7XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYnVmIGNcbiAgICB8IGMgLT4gQnVmZmVyLmFkZF9jaGFyIGJ1ZiBjXG4gIGRvbmU7XG4gIEJ1ZmZlci5jb250ZW50cyBidWZcblxubGV0IHN0cmluZ19iZWZvcmUgcyBuID0gU3RyaW5nLnN1YiBzIDAgblxuXG5sZXQgc3RyaW5nX2FmdGVyIHMgbiA9IFN0cmluZy5zdWIgcyBuIChTdHJpbmcubGVuZ3RoIHMgLSBuKVxuXG5sZXQgZmlyc3RfY2hhcnMgcyBuID0gU3RyaW5nLnN1YiBzIDAgblxuXG5sZXQgbGFzdF9jaGFycyBzIG4gPSBTdHJpbmcuc3ViIHMgKFN0cmluZy5sZW5ndGggcyAtIG4pIG5cblxubGV0IHJlZ2V4cCBlID0gY29tcGlsZV9yZWdleHAgZSBmYWxzZVxuXG5sZXQgcmVnZXhwX2Nhc2VfZm9sZCBlID0gY29tcGlsZV9yZWdleHAgZSB0cnVlXG5cbmxldCByZWdleHBfc3RyaW5nIHMgPSBjb21waWxlX3JlZ2V4cCAocXVvdGUgcykgZmFsc2VcblxubGV0IHJlZ2V4cF9zdHJpbmdfY2FzZV9mb2xkIHMgPSBjb21waWxlX3JlZ2V4cCAocXVvdGUgcykgdHJ1ZVxuXG5sZXQgZ3JvdXBfYmVnaW5uaW5nIG4gPVxuICBpZiBub3QgKHZhbGlkX2dyb3VwIG4pIHRoZW4gaW52YWxpZF9hcmcgXCJTdHIuZ3JvdXBfYmVnaW5uaW5nXCI7XG4gIGxldCBwb3MgPSBmc3QgKG9mZnNldF9ncm91cCBuKSBpblxuICBpZiBwb3MgPSAtMSB0aGVuXG4gICAgcmFpc2UgTm90X2ZvdW5kXG4gIGVsc2VcbiAgICBwb3NcblxubGV0IGdyb3VwX2VuZCBuID1cbiAgaWYgbm90ICh2YWxpZF9ncm91cCBuKSB0aGVuIGludmFsaWRfYXJnIFwiU3RyLmdyb3VwX2VuZFwiO1xuICBsZXQgcG9zID0gc25kIChvZmZzZXRfZ3JvdXAgbikgaW5cbiAgaWYgcG9zID0gLTEgdGhlblxuICAgIHJhaXNlIE5vdF9mb3VuZFxuICBlbHNlXG4gICAgcG9zXG5cbmxldCBtYXRjaGVkX2dyb3VwIG4gdHh0ID1cbiAgbGV0IChiLCBlKSA9IG9mZnNldF9ncm91cCBuIGluXG4gIFN0cmluZy5zdWIgdHh0IGIgKGUgLSBiKVxuXG5sZXQgcmVwbGFjZV9tYXRjaGVkIHJlcGwgbWF0Y2hlZCA9IHJlcGxhY2VtZW50X3RleHQgcmVwbCBtYXRjaGVkXG5cbmxldCBtYXRjaF9iZWdpbm5pbmcgKCkgPSBncm91cF9iZWdpbm5pbmcgMFxuYW5kIG1hdGNoX2VuZCAoKSA9IGdyb3VwX2VuZCAwXG5hbmQgbWF0Y2hlZF9zdHJpbmcgdHh0ID0gbWF0Y2hlZF9ncm91cCAwIHR4dFxuXG5sZXQgc3Vic3RpdHV0ZV9maXJzdCBleHByIHJlcGxfZnVuIHRleHQgPVxuICB0cnlcbiAgICBsZXQgcG9zID0gc2VhcmNoX2ZvcndhcmQgZXhwciB0ZXh0IDAgaW5cbiAgICBTdHJpbmcuY29uY2F0IFwiXCIgW3N0cmluZ19iZWZvcmUgdGV4dCBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgcmVwbF9mdW4gdGV4dDtcbiAgICAgICAgICAgICAgICAgICAgICBzdHJpbmdfYWZ0ZXIgdGV4dCAobWF0Y2hfZW5kICgpKV1cbiAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICB0ZXh0XG5cbmxldCBnbG9iYWxfc3Vic3RpdHV0ZSBleHByIHJlcGxfZnVuIHRleHQgPVxuICBsZXQgcmVjIHJlcGxhY2UgYWNjdSBzdGFydCBsYXN0X3dhc19lbXB0eSA9XG4gICAgbGV0IHN0YXJ0cG9zID0gaWYgbGFzdF93YXNfZW1wdHkgdGhlbiBzdGFydCArIDEgZWxzZSBzdGFydCBpblxuICAgIGlmIHN0YXJ0cG9zID4gU3RyaW5nLmxlbmd0aCB0ZXh0IHRoZW5cbiAgICAgIChzdHJpbmdfYWZ0ZXIgdGV4dCBzdGFydCkgOjogYWNjdVxuICAgIGVsc2VcbiAgICAgIG1hdGNoIHNlYXJjaF9mb3J3YXJkIGV4cHIgdGV4dCBzdGFydHBvcyB3aXRoXG4gICAgICB8IHBvcyAtPlxuICAgICAgICBsZXQgZW5kX3BvcyA9IG1hdGNoX2VuZCAoKSBpblxuICAgICAgICBsZXQgcmVwbF90ZXh0ID0gcmVwbF9mdW4gdGV4dCBpblxuICAgICAgICByZXBsYWNlIChyZXBsX3RleHQgOjogU3RyaW5nLnN1YiB0ZXh0IHN0YXJ0IChwb3Mtc3RhcnQpIDo6IGFjY3UpXG4gICAgICAgICAgZW5kX3BvcyAoZW5kX3BvcyA9IHBvcylcbiAgICAgIHwgZXhjZXB0aW9uIE5vdF9mb3VuZCAtPiAoc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQpIDo6IGFjY3VcbiAgaW5cbiAgU3RyaW5nLmNvbmNhdCBcIlwiIChMaXN0LnJldiAocmVwbGFjZSBbXSAwIGZhbHNlKSlcblxubGV0IGdsb2JhbF9yZXBsYWNlIGV4cHIgcmVwbCB0ZXh0ID1cbiAgZ2xvYmFsX3N1YnN0aXR1dGUgZXhwciAocmVwbGFjZW1lbnRfdGV4dCByZXBsKSB0ZXh0XG5hbmQgcmVwbGFjZV9maXJzdCBleHByIHJlcGwgdGV4dCA9XG4gIHN1YnN0aXR1dGVfZmlyc3QgZXhwciAocmVwbGFjZW1lbnRfdGV4dCByZXBsKSB0ZXh0XG5cbmxldCBzZWFyY2hfZm9yd2FyZF9wcm9ncmVzcyByZSBzIHAgPVxuICBsZXQgcG9zID0gc2VhcmNoX2ZvcndhcmQgcmUgcyBwIGluXG4gIGlmIG1hdGNoX2VuZCAoKSA+IHAgdGhlblxuICAgIHBvc1xuICBlbHNlIGlmIHAgPCBTdHJpbmcubGVuZ3RoIHMgdGhlblxuICAgIHNlYXJjaF9mb3J3YXJkIHJlIHMgKHAgKyAxKVxuICBlbHNlXG4gICAgcmFpc2UgTm90X2ZvdW5kXG5cbmxldCBib3VuZGVkX3NwbGl0IGV4cHIgdGV4dCBudW0gPVxuICBsZXQgc3RhcnQgPVxuICAgIGlmIHN0cmluZ19tYXRjaCBleHByIHRleHQgMCB0aGVuIG1hdGNoX2VuZCAoKSBlbHNlIDAgaW5cbiAgbGV0IHJlYyBzcGxpdCBhY2N1IHN0YXJ0IG4gPVxuICAgIGlmIHN0YXJ0ID49IFN0cmluZy5sZW5ndGggdGV4dCB0aGVuXG4gICAgICBhY2N1XG4gICAgZWxzZSBpZiBuID0gMSB0aGVuXG4gICAgICAoc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQpIDo6IGFjY3VcbiAgICBlbHNlXG4gICAgICB0cnlcbiAgICAgICAgbGV0IHBvcyA9IHNlYXJjaF9mb3J3YXJkX3Byb2dyZXNzIGV4cHIgdGV4dCBzdGFydCBpblxuICAgICAgICBzcGxpdCAoKFN0cmluZy5zdWIgdGV4dCBzdGFydCAocG9zLXN0YXJ0KSkgOjogYWNjdSlcbiAgICAgICAgICAobWF0Y2hfZW5kICgpKSAobiAtIDEpXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICAoc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQpIDo6IGFjY3UgaW5cbiAgTGlzdC5yZXYgKHNwbGl0IFtdIHN0YXJ0IG51bSlcblxubGV0IHNwbGl0IGV4cHIgdGV4dCA9IGJvdW5kZWRfc3BsaXQgZXhwciB0ZXh0IDBcblxubGV0IGJvdW5kZWRfc3BsaXRfZGVsaW0gZXhwciB0ZXh0IG51bSA9XG4gIGxldCByZWMgc3BsaXQgYWNjdSBzdGFydCBuID1cbiAgICBpZiBzdGFydCA+IFN0cmluZy5sZW5ndGggdGV4dCB0aGVuXG4gICAgICBhY2N1XG4gICAgZWxzZSBpZiBuID0gMSB0aGVuXG4gICAgICAoc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQpIDo6IGFjY3VcbiAgICBlbHNlXG4gICAgICB0cnlcbiAgICAgICAgbGV0IHBvcyA9IHNlYXJjaF9mb3J3YXJkX3Byb2dyZXNzIGV4cHIgdGV4dCBzdGFydCBpblxuICAgICAgICBzcGxpdCAoU3RyaW5nLnN1YiB0ZXh0IHN0YXJ0IChwb3Mtc3RhcnQpIDo6IGFjY3UpXG4gICAgICAgICAgKG1hdGNoX2VuZCAoKSkgKG4gLSAxKVxuICAgICAgd2l0aCBOb3RfZm91bmQgLT5cbiAgICAgICAgKHN0cmluZ19hZnRlciB0ZXh0IHN0YXJ0KSA6OiBhY2N1IGluXG4gIGlmIHRleHQgPSBcIlwiIHRoZW5cbiAgICBbXVxuICBlbHNlXG4gICAgTGlzdC5yZXYgKHNwbGl0IFtdIDAgbnVtKVxuXG5sZXQgc3BsaXRfZGVsaW0gZXhwciB0ZXh0ID0gYm91bmRlZF9zcGxpdF9kZWxpbSBleHByIHRleHQgMFxuXG50eXBlIHNwbGl0X3Jlc3VsdCA9IFRleHQgb2Ygc3RyaW5nIHwgRGVsaW0gb2Ygc3RyaW5nXG5cbmxldCBib3VuZGVkX2Z1bGxfc3BsaXQgZXhwciB0ZXh0IG51bSA9XG4gIGxldCByZWMgc3BsaXQgYWNjdSBzdGFydCBuID1cbiAgICBpZiBzdGFydCA+PSBTdHJpbmcubGVuZ3RoIHRleHQgdGhlblxuICAgICAgYWNjdVxuICAgIGVsc2UgaWYgbiA9IDEgdGhlblxuICAgICAgVGV4dCAoc3RyaW5nX2FmdGVyIHRleHQgc3RhcnQpIDo6IGFjY3VcbiAgICBlbHNlXG4gICAgICB0cnlcbiAgICAgICAgbGV0IHBvcyA9IHNlYXJjaF9mb3J3YXJkX3Byb2dyZXNzIGV4cHIgdGV4dCBzdGFydCBpblxuICAgICAgICBsZXQgcyA9IG1hdGNoZWRfc3RyaW5nIHRleHQgaW5cbiAgICAgICAgaWYgcG9zID4gc3RhcnQgdGhlblxuICAgICAgICAgIHNwbGl0IChEZWxpbSAocykgOjpcbiAgICAgICAgICAgICAgICAgVGV4dCAoU3RyaW5nLnN1YiB0ZXh0IHN0YXJ0IChwb3MgLSBzdGFydCkpIDo6XG4gICAgICAgICAgICAgICAgIGFjY3UpXG4gICAgICAgICAgICAobWF0Y2hfZW5kICgpKSAobiAtIDEpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBzcGxpdCAoRGVsaW0gKHMpIDo6IGFjY3UpXG4gICAgICAgICAgICAobWF0Y2hfZW5kICgpKSAobiAtIDEpXG4gICAgICB3aXRoIE5vdF9mb3VuZCAtPlxuICAgICAgICBUZXh0IChzdHJpbmdfYWZ0ZXIgdGV4dCBzdGFydCkgOjogYWNjdSBpblxuICBMaXN0LnJldiAoc3BsaXQgW10gMCBudW0pXG5cbmxldCBmdWxsX3NwbGl0IGV4cHIgdGV4dCA9IGJvdW5kZWRfZnVsbF9zcGxpdCBleHByIHRleHQgMFxuIiwiKCpcbiAgIFJFIC0gQSByZWd1bGFyIGV4cHJlc3Npb24gbGlicmFyeVxuXG4gICBDb3B5cmlnaHQgKEMpIDIwMDEgSmVyb21lIFZvdWlsbG9uXG4gICBlbWFpbDogSmVyb21lLlZvdWlsbG9uQHBwcy5qdXNzaWV1LmZyXG5cbiAgIFRoaXMgbGlicmFyeSBpcyBmcmVlIHNvZnR3YXJlOyB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3JcbiAgIG1vZGlmeSBpdCB1bmRlciB0aGUgdGVybXMgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYXMgcHVibGlzaGVkIGJ5IHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIHdpdGhcbiAgIGxpbmtpbmcgZXhjZXB0aW9uOyBlaXRoZXIgdmVyc2lvbiAyLjEgb2YgdGhlIExpY2Vuc2UsIG9yIChhdFxuICAgeW91ciBvcHRpb24pIGFueSBsYXRlciB2ZXJzaW9uLlxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZGlzdHJpYnV0ZWQgaW4gdGhlIGhvcGUgdGhhdCBpdCB3aWxsIGJlIHVzZWZ1bCxcbiAgIGJ1dCBXSVRIT1VUIEFOWSBXQVJSQU5UWTsgd2l0aG91dCBldmVuIHRoZSBpbXBsaWVkIHdhcnJhbnR5IG9mXG4gICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuICBTZWUgdGhlIEdOVVxuICAgTGVzc2VyIEdlbmVyYWwgUHVibGljIExpY2Vuc2UgZm9yIG1vcmUgZGV0YWlscy5cblxuICAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIExlc3NlciBHZW5lcmFsIFB1YmxpY1xuICAgTGljZW5zZSBhbG9uZyB3aXRoIHRoaXMgbGlicmFyeTsgaWYgbm90LCB3cml0ZSB0byB0aGUgRnJlZSBTb2Z0d2FyZVxuICAgRm91bmRhdGlvbiwgSW5jLiwgNTEgRnJhbmtsaW4gU3RyZWV0LCBGaWZ0aCBGbG9vciwgQm9zdG9uLCBNQSAwMjExMC0xMzAxIFVTQVxuKilcblxubW9kdWxlIFJlID0gQ29yZVxuXG5leGNlcHRpb24gUGFyc2VfZXJyb3JcblxudHlwZSBlbmNsb3NlZCA9XG4gIHwgQ2hhciBvZiBjaGFyXG4gIHwgUmFuZ2Ugb2YgY2hhciAqIGNoYXJcblxudHlwZSBwaWVjZSA9XG4gIHwgRXhhY3RseSBvZiBjaGFyXG4gIHwgQW55X29mIG9mIGVuY2xvc2VkIGxpc3RcbiAgfCBBbnlfYnV0IG9mIGVuY2xvc2VkIGxpc3RcbiAgfCBPbmVcbiAgfCBNYW55XG4gIHwgTWFueU1hbnlcblxudHlwZSB0ID0gcGllY2UgbGlzdFxuXG5sZXQgb2Zfc3RyaW5nIH5kb3VibGVfYXN0ZXJpc2sgcyA6IHQgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBlb3MgKCkgPSAhaSA9IGwgaW5cbiAgbGV0IHJlYWQgYyA9XG4gICAgbGV0IHIgPSBub3QgKGVvcyAoKSkgJiYgcy5bIWldID0gYyBpblxuICAgIGlmIHIgdGhlbiBpbmNyIGk7XG4gICAgclxuICBpblxuXG4gICgqKlxuICAgW3JlYWRfYWhlYWQgcGF0dGVybl0gd2lsbCBhdHRlbXB0IHRvIHJlYWQgW3BhdHRlcm5dIGFuZCB3aWxsIHJldHVybiBbdHJ1ZV0gaWYgaXQgd2FzIHN1Y2Nlc3NmdWwuXG4gICBJZiBpdCBmYWlscywgaXQgd2lsbCByZXR1cm4gW2ZhbHNlXSBhbmQgbm90IGluY3JlbWVudCB0aGUgcmVhZCBpbmRleC5cbiAgKilcbiAgbGV0IHJlYWRfYWhlYWQgcGF0dGVybiA9XG4gICAgbGV0IHBhdHRlcm5fbGVuID0gU3RyaW5nLmxlbmd0aCBwYXR0ZXJuIGluXG4gICAgKCogaWYgdGhlIHBhdHRlcm4gd2UgYXJlIGxvb2tpbmcgZm9yIGV4ZWVkcyB0aGUgcmVtYWluaW5nIGxlbmd0aCBvZiBzLCByZXR1cm4gZmFsc2UgaW1tZWRpYXRlbHkgKilcbiAgICBpZiAhaSArIHBhdHRlcm5fbGVuID49IGwgdGhlblxuICAgICAgZmFsc2VcbiAgICBlbHNlXG4gICAgICB0cnlcbiAgICAgICAgZm9yIGogPSAwIHRvIHBhdHRlcm5fbGVuIC0gMSBkb1xuICAgICAgICAgIGxldCBmb3VuZCA9IG5vdCAoZW9zICgpKSAmJiBzLlshaSArIGpdID0gcGF0dGVybi5bal0gaW5cbiAgICAgICAgICBpZiBub3QgZm91bmQgdGhlbiByYWlzZV9ub3RyYWNlIEV4aXQ7XG4gICAgICAgIGRvbmU7XG4gICAgICAgIGkgOj0gIWkgKyBwYXR0ZXJuX2xlbjtcbiAgICAgICAgdHJ1ZVxuICAgICAgd2l0aCB8IEV4aXQgIC0+IGZhbHNlXG4gIGluXG5cbiAgbGV0IGNoYXIgKCkgPVxuICAgIGlnbm9yZSAocmVhZCAnXFxcXCcgOiBib29sKTtcbiAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICBsZXQgciA9IHMuWyFpXSBpblxuICAgIGluY3IgaTtcbiAgICByXG4gIGluXG5cbiAgbGV0IGVuY2xvc2VkICgpIDogZW5jbG9zZWQgbGlzdCA9XG4gICAgbGV0IHJlYyBsb29wIHMgPVxuICAgICAgKCogVGhpcyByZXR1cm5zIHRoZSBsaXN0IGluIHJldmVyc2Ugb3JkZXIsIGJ1dCBvcmRlciBpc24ndCBpbXBvcnRhbnQgYW55d2F5ICopXG4gICAgICBpZiBzIDw+IFtdICYmIHJlYWQgJ10nXG4gICAgICB0aGVuIHNcbiAgICAgIGVsc2VcbiAgICAgICAgbGV0IGMgPSBjaGFyICgpIGluXG4gICAgICAgIGlmIG5vdCAocmVhZCAnLScpXG4gICAgICAgIHRoZW4gbG9vcCAoQ2hhciBjIDo6IHMpXG4gICAgICAgIGVsc2UgaWYgcmVhZCAnXSdcbiAgICAgICAgdGhlbiBDaGFyIGMgOjogQ2hhciAnLScgOjogc1xuICAgICAgICBlbHNlXG4gICAgICAgICAgbGV0IGMnID0gY2hhciAoKSBpblxuICAgICAgICAgIGxvb3AgKFJhbmdlIChjLCBjJykgOjogcylcbiAgICBpblxuICAgIGxvb3AgW11cbiAgaW5cblxuICBsZXQgcGllY2UgKCkgPVxuICAgIGlmIGRvdWJsZV9hc3RlcmlzayAmJiByZWFkX2FoZWFkIFwiLyoqXCIgJiYgbm90IChlb3MgKCkpXG4gICAgdGhlbiBNYW55TWFueVxuICAgIGVsc2UgaWYgcmVhZCAnKidcbiAgICB0aGVuIGlmIGRvdWJsZV9hc3RlcmlzayAmJiByZWFkICcqJ1xuICAgICAgdGhlbiBNYW55TWFueVxuICAgICAgZWxzZSBNYW55XG4gICAgZWxzZSBpZiByZWFkICc/J1xuICAgIHRoZW4gT25lXG4gICAgZWxzZSBpZiBub3QgKHJlYWQgJ1snKVxuICAgIHRoZW4gRXhhY3RseSAoY2hhciAoKSlcbiAgICBlbHNlIGlmIHJlYWQgJ14nIHx8IHJlYWQgJyEnXG4gICAgdGhlbiBBbnlfYnV0IChlbmNsb3NlZCAoKSlcbiAgICBlbHNlIEFueV9vZiAoZW5jbG9zZWQgKCkpXG4gIGluXG5cbiAgbGV0IHJlYyBsb29wIHBpZWNlcyA9XG4gICAgaWYgZW9zICgpXG4gICAgdGhlbiBMaXN0LnJldiBwaWVjZXNcbiAgICBlbHNlIGxvb3AgKHBpZWNlICgpIDo6IHBpZWNlcylcbiAgaW5cblxuICBsb29wIFtdXG5cbmxldCBtdWwgbCBsJyA9XG4gIExpc3QuZmxhdHRlbiAoTGlzdC5tYXAgKGZ1biBzIC0+IExpc3QubWFwIChmdW4gcycgLT4gcyBeIHMnKSBsJykgbClcblxubGV0IGV4cGxvZGUgc3RyID1cbiAgbGV0IGwgPSBTdHJpbmcubGVuZ3RoIHN0ciBpblxuICBsZXQgcmVjIGV4cGwgaW5uZXIgcyBpIGFjYyBiZWcgPVxuICAgIGlmIGkgPj0gbCB0aGVuIGJlZ2luXG4gICAgICBpZiBpbm5lciB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgKG11bCBiZWcgW1N0cmluZy5zdWIgc3RyIHMgKGkgLSBzKV0sIGkpXG4gICAgZW5kIGVsc2VcbiAgICAgIG1hdGNoIHN0ci5baV0gd2l0aFxuICAgICAgfCAnXFxcXCcgLT4gZXhwbCBpbm5lciBzIChpICsgMikgYWNjIGJlZ1xuICAgICAgfCAneycgLT5cbiAgICAgICAgbGV0ICh0LCBpJykgPSBleHBsIHRydWUgKGkgKyAxKSAoaSArIDEpIFtdIFtcIlwiXSBpblxuICAgICAgICBleHBsIGlubmVyIGknIGknIGFjY1xuICAgICAgICAgIChtdWwgYmVnIChtdWwgW1N0cmluZy5zdWIgc3RyIHMgKGkgLSBzKV0gdCkpXG4gICAgICB8ICcsJyB3aGVuIGlubmVyIC0+XG4gICAgICAgIGV4cGwgaW5uZXIgKGkgKyAxKSAoaSArIDEpXG4gICAgICAgICAgKG11bCBiZWcgW1N0cmluZy5zdWIgc3RyIHMgKGkgLSBzKV0gQCBhY2MpIFtcIlwiXVxuICAgICAgfCAnfScgd2hlbiBpbm5lciAtPlxuICAgICAgICAobXVsIGJlZyBbU3RyaW5nLnN1YiBzdHIgcyAoaSAtIHMpXSBAIGFjYywgaSArIDEpXG4gICAgICB8IF8gLT5cbiAgICAgICAgZXhwbCBpbm5lciBzIChpICsgMSkgYWNjIGJlZ1xuICBpblxuICBMaXN0LnJldiAoZnN0IChleHBsIGZhbHNlIDAgMCBbXSBbXCJcIl0pKVxuXG5tb2R1bGUgU3RhdGUgPSBzdHJ1Y3RcbiAgdHlwZSB0ID0ge1xuICAgIHJlX3BpZWNlcyAgICAgICAgICAgICAgICA6IFJlLnQgbGlzdDsgICgqIGxhc3QgcGllY2UgYXQgaGVhZCBvZiBsaXN0LiAqKVxuICAgIHJlbWFpbmluZyAgICAgICAgICAgICAgICA6IHBpZWNlIGxpc3Q7ICgqIGxhc3QgcGllY2UgYXQgdGFpbCBvZiBsaXN0LiAqKVxuICAgIGFtX2F0X3N0YXJ0X29mX3BhdHRlcm4gICA6IGJvb2w7ICAgICAgICgqIHRydWUgYXQgc3RhcnQgb2YgcGF0dGVybiAqKVxuICAgIGFtX2F0X3N0YXJ0X29mX2NvbXBvbmVudCA6IGJvb2w7ICAgICAgICgqIHRydWUgYXQgc3RhcnQgb2YgcGF0dGVybiBvciBpbW1lZGlhdGVseVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFmdGVyICcvJyAqKVxuICAgIHBhdGhuYW1lICAgICAgICAgICAgICAgICA6IGJvb2w7XG4gICAgbWF0Y2hfYmFja3NsYXNoZXMgICAgICAgIDogYm9vbDtcbiAgICBwZXJpb2QgICAgICAgICAgICAgICAgICAgOiBib29sO1xuICB9XG5cbiAgbGV0IGNyZWF0ZSB+cGVyaW9kIH5wYXRobmFtZSB+bWF0Y2hfYmFja3NsYXNoZXMgcmVtYWluaW5nID1cbiAgICB7XG4gICAgICByZV9waWVjZXMgPSBbXTtcbiAgICAgIGFtX2F0X3N0YXJ0X29mX3BhdHRlcm4gPSB0cnVlO1xuICAgICAgYW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50ID0gdHJ1ZTtcbiAgICAgIHBhdGhuYW1lO1xuICAgICAgbWF0Y2hfYmFja3NsYXNoZXM7XG4gICAgICBwZXJpb2Q7XG4gICAgICByZW1haW5pbmc7XG4gICAgfVxuXG4gIGxldCBleHBsaWNpdF9wZXJpb2QgdCA9XG4gICAgdC5wZXJpb2QgJiYgKFxuICAgICAgdC5hbV9hdF9zdGFydF9vZl9wYXR0ZXJuIHx8XG4gICAgICAodC5hbV9hdF9zdGFydF9vZl9jb21wb25lbnQgJiYgdC5wYXRobmFtZSlcbiAgICApXG5cbiAgbGV0IGV4cGxpY2l0X3NsYXNoIHQgPSB0LnBhdGhuYW1lXG5cbiAgbGV0IHNsYXNoZXMgdCA9XG4gICAgaWYgdC5tYXRjaF9iYWNrc2xhc2hlcyB0aGVuIFsnLyc7ICdcXFxcJ10gZWxzZSBbJy8nXVxuXG4gIGxldCBhcHBlbmQgPyhhbV9hdF9zdGFydF9vZl9jb21wb25lbnQ9ZmFsc2UpIHQgcGllY2UgPVxuICAgIHsgdCB3aXRoXG4gICAgICByZV9waWVjZXMgPSBwaWVjZSA6OiB0LnJlX3BpZWNlcztcbiAgICAgIGFtX2F0X3N0YXJ0X29mX3BhdHRlcm4gPSBmYWxzZTtcbiAgICAgIGFtX2F0X3N0YXJ0X29mX2NvbXBvbmVudDtcbiAgICB9XG5cbiAgbGV0IHRvX3JlIHQgPSBSZS5zZXEgKExpc3QucmV2IHQucmVfcGllY2VzKVxuXG4gIGxldCBuZXh0IHQgPVxuICAgIG1hdGNoIHQucmVtYWluaW5nIHdpdGhcbiAgICB8IFtdIC0+IE5vbmVcbiAgICB8IHBpZWNlIDo6IHJlbWFpbmluZyAtPiBTb21lIChwaWVjZSwgeyB0IHdpdGggcmVtYWluaW5nIH0pXG5lbmRcblxubGV0IG9uZSB+ZXhwbGljaXRfc2xhc2ggfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZCA9XG4gIFJlLmNvbXBsIChcbiAgICBMaXN0LmNvbmNhdCBbXG4gICAgICBpZiBleHBsaWNpdF9zbGFzaCAgdGhlbiBMaXN0Lm1hcCBSZS5jaGFyIHNsYXNoZXMgZWxzZSBbXTtcbiAgICAgIGlmIGV4cGxpY2l0X3BlcmlvZCB0aGVuIFtSZS5jaGFyICcuJ10gZWxzZSBbXTtcbiAgICBdXG4gIClcblxubGV0IGVuY2xvc2VkIGVuY2xvc2VkID1cbiAgbWF0Y2ggZW5jbG9zZWQgd2l0aFxuICB8IENoYXIgYyAtPiBSZS5jaGFyIGNcbiAgfCBSYW5nZSAobG93LCBoaWdoKSAtPiBSZS5yZyBsb3cgaGlnaFxuXG5sZXQgZW5jbG9zZWRfc2V0IH5leHBsaWNpdF9zbGFzaCB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kIGtpbmQgc2V0ID1cbiAgbGV0IHNldCA9IExpc3QubWFwIGVuY2xvc2VkIHNldCBpblxuICBsZXQgZW5jbG9zdXJlID1cbiAgICBtYXRjaCBraW5kIHdpdGhcbiAgICB8IGBBbnlfb2YgLT4gUmUuYWx0IHNldFxuICAgIHwgYEFueV9idXQgLT4gUmUuY29tcGwgc2V0XG4gIGluXG4gIFJlLmludGVyIFtlbmNsb3N1cmU7IG9uZSB+ZXhwbGljaXRfc2xhc2ggfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZF1cblxubGV0IGV4YWN0bHkgc3RhdGUgYyA9XG4gIGxldCBzbGFzaGVzID0gU3RhdGUuc2xhc2hlcyBzdGF0ZSBpblxuICBsZXQgYW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50ID0gTGlzdC5tZW0gYyBzbGFzaGVzIGluXG4gIGxldCBjaGFycyA9IGlmIGFtX2F0X3N0YXJ0X29mX2NvbXBvbmVudCB0aGVuIHNsYXNoZXMgZWxzZSBbY10gaW5cbiAgU3RhdGUuYXBwZW5kIHN0YXRlIChSZS5hbHQgKExpc3QubWFwIFJlLmNoYXIgY2hhcnMpKSB+YW1fYXRfc3RhcnRfb2ZfY29tcG9uZW50XG5cbmxldCBtYW55X21hbnkgc3RhdGUgPVxuICBsZXQgZXhwbGljaXRfcGVyaW9kID0gc3RhdGUuU3RhdGUucGVyaW9kICYmIHN0YXRlLlN0YXRlLnBhdGhuYW1lIGluXG4gIGxldCBmaXJzdF9leHBsaWNpdF9wZXJpb2QgPSBTdGF0ZS5leHBsaWNpdF9wZXJpb2Qgc3RhdGUgaW5cbiAgbGV0IHNsYXNoZXMgPSBTdGF0ZS5zbGFzaGVzIHN0YXRlIGluXG4gIGxldCBtYXRjaF9jb21wb25lbnQgfmV4cGxpY2l0X3BlcmlvZCA9XG4gICAgUmUuc2VxIFtcbiAgICAgIG9uZSAgICAgICAgIH5leHBsaWNpdF9zbGFzaDp0cnVlIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2Q7XG4gICAgICBSZS5yZXAgKG9uZSB+ZXhwbGljaXRfc2xhc2g6dHJ1ZSB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kOmZhbHNlKTtcbiAgICBdXG4gIGluXG4gICgqIFdlIG11c3QgbWF0Y2ggY29tcG9uZW50cyBpbmRpdmlkdWFsbHkgd2hlbiBbcGVyaW9kXSBmbGFnIGlzIHNldCxcbiAgICAgbWFraW5nIHN1cmUgdG8gbm90IG1hdGNoIFtcImZvby8uYmFyXCJdLiAqKVxuICBTdGF0ZS5hcHBlbmQgc3RhdGUgKFxuICAgIFJlLnNlcSBbXG4gICAgICBSZS5vcHQgKG1hdGNoX2NvbXBvbmVudCB+ZXhwbGljaXRfcGVyaW9kOmZpcnN0X2V4cGxpY2l0X3BlcmlvZCk7XG4gICAgICBSZS5yZXAgKFxuICAgICAgICBSZS5zZXEgW1xuICAgICAgICAgIFJlLmFsdCAoTGlzdC5tYXAgUmUuY2hhciBzbGFzaGVzKTtcbiAgICAgICAgICBSZS5vcHQgKG1hdGNoX2NvbXBvbmVudCB+ZXhwbGljaXRfcGVyaW9kKTtcbiAgICAgICAgXVxuICAgICAgKTtcbiAgICBdKVxuXG5sZXQgbWFueSAoc3RhdGUgOiBTdGF0ZS50KSA9XG4gIGxldCBleHBsaWNpdF9zbGFzaCA9IFN0YXRlLmV4cGxpY2l0X3NsYXNoIHN0YXRlIGluXG4gIGxldCBleHBsaWNpdF9wZXJpb2QgPSBTdGF0ZS5leHBsaWNpdF9wZXJpb2Qgc3RhdGUgaW5cbiAgbGV0IHNsYXNoZXMgPSBTdGF0ZS5zbGFzaGVzIHN0YXRlIGluXG4gICgqIFdoZXRoZXIgd2UgbXVzdCBleHBsaWNpdGx5IG1hdGNoIHBlcmlvZCBkZXBlbmRzIG9uIHRoZSBzdXJyb3VuZGluZyBjaGFyYWN0ZXJzLCBidXRcbiAgICAgc2xhc2hlcyBhcmUgZWFzeSB0byBleHBsaWNpdCBtYXRjaC4gVGhpcyBjb25kaXRpb25hbCBzcGxpdHMgb3V0IHNvbWUgc2ltcGxlIGNhc2VzLlxuICAqKVxuICBpZiBub3QgZXhwbGljaXRfcGVyaW9kIHRoZW4gYmVnaW5cbiAgICBTdGF0ZS5hcHBlbmQgc3RhdGUgKFJlLnJlcCAob25lIH5leHBsaWNpdF9zbGFzaCB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kKSlcbiAgZW5kIGVsc2UgaWYgbm90IGV4cGxpY2l0X3NsYXNoIHRoZW4gYmVnaW5cbiAgICAoKiBJbiB0aGlzIHN0YXRlLCB3ZSBleHBsaWNpdGx5IG1hdGNoIHBlcmlvZHMgb25seSBhdCB0aGUgdmVyeSBiZWdpbm5pbmcgKilcbiAgICBTdGF0ZS5hcHBlbmQgc3RhdGUgKFJlLm9wdCAoXG4gICAgICBSZS5zZXEgW1xuICAgICAgICBvbmUgICAgICAgICB+ZXhwbGljaXRfc2xhc2g6ZmFsc2UgfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZDtcbiAgICAgICAgUmUucmVwIChvbmUgfmV4cGxpY2l0X3NsYXNoOmZhbHNlIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2Q6ZmFsc2UpO1xuICAgICAgXVxuICAgICkpXG4gIGVuZCBlbHNlIGJlZ2luXG4gICAgbGV0IG5vdF9lbXB0eSA9XG4gICAgICBSZS5zZXEgW1xuICAgICAgICBvbmUgICAgICAgICB+ZXhwbGljaXRfc2xhc2g6dHJ1ZSB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kOnRydWU7XG4gICAgICAgIFJlLnJlcCAob25lIH5leHBsaWNpdF9zbGFzaDp0cnVlIH5zbGFzaGVzIH5leHBsaWNpdF9wZXJpb2Q6ZmFsc2UpO1xuICAgICAgXVxuICAgIGluXG4gICAgKCogW21heWJlX2VtcHR5XSBpcyB0aGUgZGVmYXVsdCB0cmFuc2xhdGlvbiBvZiBNYW55LCBleGNlcHQgaW4gc29tZSBzcGVjaWFsIGNhc2VzLlxuICAgICopXG4gICAgbGV0IG1heWJlX2VtcHR5ID0gUmUub3B0IG5vdF9lbXB0eSBpblxuICAgIGxldCBlbmNsb3NlZF9zZXQgc3RhdGUga2luZCBzZXQgPVxuICAgICAgU3RhdGUuYXBwZW5kIHN0YXRlIChSZS5hbHQgW1xuICAgICAgICBlbmNsb3NlZF9zZXQga2luZCBzZXQgfmV4cGxpY2l0X3NsYXNoOnRydWUgfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZDp0cnVlO1xuICAgICAgICBSZS5zZXEgW1xuICAgICAgICAgIG5vdF9lbXB0eTtcbiAgICAgICAgICAoKiBTaW5jZSBbbm90X2VtcHR5XSBtYXRjaGVkLCBzdWJzZXF1ZW50IGRvdHMgYXJlIG5vdCBsZWFkaW5nLiAqKVxuICAgICAgICAgIGVuY2xvc2VkX3NldCBraW5kIHNldCB+ZXhwbGljaXRfc2xhc2g6dHJ1ZSB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kOmZhbHNlO1xuICAgICAgICBdO1xuICAgICAgXSlcbiAgICBpblxuICAgIGxldCByZWMgbG9va2FoZWFkIHN0YXRlID1cbiAgICAgIG1hdGNoIFN0YXRlLm5leHQgc3RhdGUgd2l0aFxuICAgICAgfCBOb25lIC0+IFN0YXRlLmFwcGVuZCBzdGF0ZSBtYXliZV9lbXB0eVxuICAgICAgKCogZ2xvYiAqKiA9PT0gZ2xvYiAqIC4gKilcbiAgICAgIHwgU29tZSAoTWFueSwgc3RhdGUpIC0+IGxvb2thaGVhZCBzdGF0ZVxuICAgICAgfCBTb21lIChFeGFjdGx5IGMsIHN0YXRlKSAtPlxuICAgICAgICBsZXQgc3RhdGUgPVxuICAgICAgICAgIFN0YXRlLmFwcGVuZCBzdGF0ZVxuICAgICAgICAgICAgKGlmIGMgPSAnLidcbiAgICAgICAgICAgICB0aGVuIG5vdF9lbXB0eVxuICAgICAgICAgICAgIGVsc2UgbWF5YmVfZW1wdHkpXG4gICAgICAgIGluXG4gICAgICAgIGV4YWN0bHkgc3RhdGUgY1xuICAgICAgKCogZ2xvYiAqPyA9PT0gZ2xvYiA/KiAqKVxuICAgICAgfCBTb21lIChPbmUsIHN0YXRlKSAtPiBTdGF0ZS5hcHBlbmQgc3RhdGUgbm90X2VtcHR5XG4gICAgICB8IFNvbWUgKEFueV9vZiBlbmNsb3NlZCwgc3RhdGUpIC0+IGVuY2xvc2VkX3NldCBzdGF0ZSBgQW55X29mIGVuY2xvc2VkXG4gICAgICB8IFNvbWUgKEFueV9idXQgZW5jbG9zZWQsIHN0YXRlKSAtPiBlbmNsb3NlZF9zZXQgc3RhdGUgYEFueV9idXQgZW5jbG9zZWRcbiAgICAgICgqICogdGhlbiAqKiA9PT0gKiogKilcbiAgICAgIHwgU29tZSAoTWFueU1hbnksIHN0YXRlKSAtPiBtYW55X21hbnkgc3RhdGVcbiAgICBpblxuICAgIGxvb2thaGVhZCBzdGF0ZVxuICBlbmRcblxubGV0IHBpZWNlIHN0YXRlIHBpZWNlID1cbiAgbGV0IGV4cGxpY2l0X3NsYXNoID0gU3RhdGUuZXhwbGljaXRfc2xhc2ggc3RhdGUgaW5cbiAgbGV0IGV4cGxpY2l0X3BlcmlvZCA9IFN0YXRlLmV4cGxpY2l0X3BlcmlvZCBzdGF0ZSBpblxuICBsZXQgc2xhc2hlcyA9IFN0YXRlLnNsYXNoZXMgc3RhdGUgaW5cbiAgbWF0Y2ggcGllY2Ugd2l0aFxuICB8IE9uZSAtPiBTdGF0ZS5hcHBlbmQgc3RhdGUgKG9uZSB+ZXhwbGljaXRfc2xhc2ggfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZClcbiAgfCBNYW55IC0+IG1hbnkgc3RhdGVcbiAgfCBBbnlfb2YgZW5jbG9zZWQgLT5cbiAgICBTdGF0ZS5hcHBlbmQgc3RhdGUgKGVuY2xvc2VkX3NldCBgQW55X29mIH5leHBsaWNpdF9zbGFzaCB+c2xhc2hlcyB+ZXhwbGljaXRfcGVyaW9kIGVuY2xvc2VkKVxuICB8IEFueV9idXQgZW5jbG9zZWQgLT5cbiAgICBTdGF0ZS5hcHBlbmQgc3RhdGUgKGVuY2xvc2VkX3NldCBgQW55X2J1dCB+ZXhwbGljaXRfc2xhc2ggfnNsYXNoZXMgfmV4cGxpY2l0X3BlcmlvZCBlbmNsb3NlZClcbiAgfCBFeGFjdGx5IGMgLT4gZXhhY3RseSBzdGF0ZSBjXG4gIHwgTWFueU1hbnkgLT4gbWFueV9tYW55IHN0YXRlXG5cbmxldCBnbG9iIH5wYXRobmFtZSB+bWF0Y2hfYmFja3NsYXNoZXMgfnBlcmlvZCBnbG9iID1cbiAgbGV0IHJlYyBsb29wIHN0YXRlID1cbiAgICBtYXRjaCBTdGF0ZS5uZXh0IHN0YXRlIHdpdGhcbiAgICB8IE5vbmUgLT4gU3RhdGUudG9fcmUgc3RhdGVcbiAgICB8IFNvbWUgKHAsIHN0YXRlKSAtPiBsb29wIChwaWVjZSBzdGF0ZSBwKVxuICBpblxuICBsb29wIChTdGF0ZS5jcmVhdGUgfnBhdGhuYW1lIH5tYXRjaF9iYWNrc2xhc2hlcyB+cGVyaW9kIGdsb2IpXG5cbmxldCBnbG9iXG4gICAgICA/KGFuY2hvcmVkID0gZmFsc2UpXG4gICAgICA/KHBhdGhuYW1lID0gdHJ1ZSlcbiAgICAgID8obWF0Y2hfYmFja3NsYXNoZXMgPSBmYWxzZSlcbiAgICAgID8ocGVyaW9kID0gdHJ1ZSlcbiAgICAgID8oZXhwYW5kX2JyYWNlcyA9IGZhbHNlKVxuICAgICAgPyhkb3VibGVfYXN0ZXJpc2sgPSB0cnVlKVxuICAgICAgc1xuICA9XG4gIGxldCB0b19yZSBzID1cbiAgICBsZXQgcmUgPSBnbG9iIH5wYXRobmFtZSB+bWF0Y2hfYmFja3NsYXNoZXMgfnBlcmlvZCAob2Zfc3RyaW5nIH5kb3VibGVfYXN0ZXJpc2sgcykgaW5cbiAgICBpZiBhbmNob3JlZFxuICAgIHRoZW4gUmUud2hvbGVfc3RyaW5nIHJlXG4gICAgZWxzZSByZVxuICBpblxuICBpZiBleHBhbmRfYnJhY2VzXG4gIHRoZW4gUmUuYWx0IChMaXN0Lm1hcCB0b19yZSAoZXhwbG9kZSBzKSlcbiAgZWxzZSB0b19yZSBzXG5cbmxldCBnbG9iJyA/YW5jaG9yZWQgcGVyaW9kIHMgPSBnbG9iID9hbmNob3JlZCB+cGVyaW9kIHNcblxubGV0IGdsb2J4ID9hbmNob3JlZCBzID0gZ2xvYiA/YW5jaG9yZWQgfmV4cGFuZF9icmFjZXM6dHJ1ZSBzXG5cbmxldCBnbG9ieCcgP2FuY2hvcmVkIHBlcmlvZCBzID0gZ2xvYiA/YW5jaG9yZWQgfmV4cGFuZF9icmFjZXM6dHJ1ZSB+cGVyaW9kIHNcbiIsIigqXG4gICBSRSAtIEEgcmVndWxhciBleHByZXNzaW9uIGxpYnJhcnlcblxuICAgQ29weXJpZ2h0IChDKSAyMDAxIEplcm9tZSBWb3VpbGxvblxuICAgZW1haWw6IEplcm9tZS5Wb3VpbGxvbkBwcHMuanVzc2lldS5mclxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoXG4gICBsaW5raW5nIGV4Y2VwdGlvbjsgZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXRcbiAgIHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAgIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAgIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0FcbiopXG5cbm1vZHVsZSBSZSA9IENvcmVcblxuZXhjZXB0aW9uIFBhcnNlX2Vycm9yXG5leGNlcHRpb24gTm90X3N1cHBvcnRlZFxuXG5sZXQgcG9zaXhfY2xhc3Nfb2Zfc3RyaW5nID0gZnVuY3Rpb25cbiAgfCBcImFscGhhXCIgIC0+IFJlLmFscGhhXG4gIHwgXCJhbG51bVwiICAtPiBSZS5hbG51bVxuICB8IFwiYXNjaWlcIiAgLT4gUmUuYXNjaWlcbiAgfCBcImJsYW5rXCIgIC0+IFJlLmJsYW5rXG4gIHwgXCJjbnRybFwiICAtPiBSZS5jbnRybFxuICB8IFwiZGlnaXRcIiAgLT4gUmUuZGlnaXRcbiAgfCBcImxvd2VyXCIgIC0+IFJlLmxvd2VyXG4gIHwgXCJwcmludFwiICAtPiBSZS5wcmludFxuICB8IFwic3BhY2VcIiAgLT4gUmUuc3BhY2VcbiAgfCBcInVwcGVyXCIgIC0+IFJlLnVwcGVyXG4gIHwgXCJ3b3JkXCIgICAtPiBSZS53b3JkY1xuICB8IFwicHVuY3RcIiAgLT4gUmUucHVuY3RcbiAgfCBcImdyYXBoXCIgIC0+IFJlLmdyYXBoXG4gIHwgXCJ4ZGlnaXRcIiAtPiBSZS54ZGlnaXRcbiAgfCBjbGFzc18gICAtPiBpbnZhbGlkX2FyZyAoXCJJbnZhbGlkIHBjcmUgY2xhc3M6IFwiIF4gY2xhc3NfKVxuXG5sZXQgcG9zaXhfY2xhc3Nfc3RyaW5ncyA9XG4gIFsgXCJhbHBoYVwiIDsgXCJhbG51bVwiIDsgXCJhc2NpaVwiXG4gIDsgXCJibGFua1wiIDsgXCJjbnRybFwiIDsgXCJkaWdpdFwiXG4gIDsgXCJsb3dlclwiIDsgXCJwcmludFwiIDsgXCJzcGFjZVwiXG4gIDsgXCJ1cHBlclwiIDsgXCJ3b3JkXCIgIDsgXCJwdW5jdFwiXG4gIDsgXCJncmFwaFwiIDsgXCJ4ZGlnaXRcIiBdXG5cbmxldCBwYXJzZSBtdWx0aWxpbmUgZG9sbGFyX2VuZG9ubHkgZG90YWxsIHVuZ3JlZWR5IHMgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBlb3MgKCkgPSAhaSA9IGwgaW5cbiAgbGV0IHRlc3QgYyA9IG5vdCAoZW9zICgpKSAmJiBzLlshaV0gPSBjIGluXG4gIGxldCBhY2NlcHQgYyA9IGxldCByID0gdGVzdCBjIGluIGlmIHIgdGhlbiBpbmNyIGk7IHIgaW5cbiAgbGV0IGFjY2VwdF9zIHMnID1cbiAgICBsZXQgbGVuID0gU3RyaW5nLmxlbmd0aCBzJyBpblxuICAgIHRyeVxuICAgICAgZm9yIGogPSAwIHRvIGxlbiAtIDEgZG9cbiAgICAgICAgdHJ5IGlmIHMnLltqXSA8PiBzLlshaSArIGpdIHRoZW4gcmFpc2UgRXhpdFxuICAgICAgICB3aXRoIF8gLT4gcmFpc2UgRXhpdFxuICAgICAgZG9uZTtcbiAgICAgIGkgOj0gIWkgKyBsZW47XG4gICAgICB0cnVlXG4gICAgd2l0aCBFeGl0IC0+IGZhbHNlIGluXG4gIGxldCBnZXQgKCkgPSBsZXQgciA9IHMuWyFpXSBpbiBpbmNyIGk7IHIgaW5cbiAgbGV0IHVuZ2V0ICgpID0gZGVjciBpIGluXG4gIGxldCBncmVlZHlfbW9kIHIgPVxuICAgIGxldCBnciA9IGFjY2VwdCAnPycgaW5cbiAgICBsZXQgZ3IgPSBpZiB1bmdyZWVkeSB0aGVuIG5vdCBnciBlbHNlIGdyIGluXG4gICAgaWYgZ3IgdGhlbiBSZS5ub25fZ3JlZWR5IHIgZWxzZSBSZS5ncmVlZHkgclxuICBpblxuICBsZXQgcmVjIHJlZ2V4cCAoKSA9IHJlZ2V4cCcgKGJyYW5jaCAoKSlcbiAgYW5kIHJlZ2V4cCcgbGVmdCA9XG4gICAgaWYgYWNjZXB0ICd8JyB0aGVuIHJlZ2V4cCcgKFJlLmFsdCBbbGVmdDsgYnJhbmNoICgpXSkgZWxzZSBsZWZ0XG4gIGFuZCBicmFuY2ggKCkgPSBicmFuY2gnIFtdXG4gIGFuZCBicmFuY2gnIGxlZnQgPVxuICAgIGlmIGVvcyAoKSB8fCB0ZXN0ICd8JyB8fCB0ZXN0ICcpJyB0aGVuIFJlLnNlcSAoTGlzdC5yZXYgbGVmdClcbiAgICBlbHNlIGJyYW5jaCcgKHBpZWNlICgpIDo6IGxlZnQpXG4gIGFuZCBwaWVjZSAoKSA9XG4gICAgbGV0IHIgPSBhdG9tICgpIGluXG4gICAgaWYgYWNjZXB0ICcqJyB0aGVuIGdyZWVkeV9tb2QgKFJlLnJlcCByKSBlbHNlXG4gICAgaWYgYWNjZXB0ICcrJyB0aGVuIGdyZWVkeV9tb2QgKFJlLnJlcDEgcikgZWxzZVxuICAgIGlmIGFjY2VwdCAnPycgdGhlbiBncmVlZHlfbW9kIChSZS5vcHQgcikgZWxzZVxuICAgIGlmIGFjY2VwdCAneycgdGhlblxuICAgICAgbWF0Y2ggaW50ZWdlciAoKSB3aXRoXG4gICAgICAgIFNvbWUgaSAtPlxuICAgICAgICAgIGxldCBqID0gaWYgYWNjZXB0ICcsJyB0aGVuIGludGVnZXIgKCkgZWxzZSBTb21lIGkgaW5cbiAgICAgICAgICBpZiBub3QgKGFjY2VwdCAnfScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgICAgYmVnaW4gbWF0Y2ggaiB3aXRoXG4gICAgICAgICAgICBTb21lIGogd2hlbiBqIDwgaSAtPiByYWlzZSBQYXJzZV9lcnJvciB8IF8gLT4gKClcbiAgICAgICAgICBlbmQ7XG4gICAgICAgICAgZ3JlZWR5X21vZCAoUmUucmVwbiByIGkgailcbiAgICAgIHwgTm9uZSAtPlxuICAgICAgICAgIHVuZ2V0ICgpOyByXG4gICAgZWxzZVxuICAgICAgclxuICBhbmQgYXRvbSAoKSA9XG4gICAgaWYgYWNjZXB0ICcuJyB0aGVuIGJlZ2luXG4gICAgICBpZiBkb3RhbGwgdGhlbiBSZS5hbnkgZWxzZSBSZS5ub3RubFxuICAgIGVuZCBlbHNlIGlmIGFjY2VwdCAnKCcgdGhlbiBiZWdpblxuICAgICAgaWYgYWNjZXB0ICc/JyB0aGVuIGJlZ2luXG4gICAgICAgIGlmIGFjY2VwdCAnOicgdGhlbiBiZWdpblxuICAgICAgICAgIGxldCByID0gcmVnZXhwICgpIGluXG4gICAgICAgICAgaWYgbm90IChhY2NlcHQgJyknKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgICAgIHJcbiAgICAgICAgZW5kIGVsc2UgaWYgYWNjZXB0ICcjJyB0aGVuIGJlZ2luXG4gICAgICAgICAgY29tbWVudCAoKVxuICAgICAgICBlbmQgZWxzZSBpZiBhY2NlcHQgJzwnIHRoZW4gYmVnaW5cbiAgICAgICAgICBsZXQgbmFtZSA9IG5hbWUgKCkgaW5cbiAgICAgICAgICBsZXQgciA9IHJlZ2V4cCAoKSBpblxuICAgICAgICAgIGlmIG5vdCAoYWNjZXB0ICcpJykgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgICAgICBSZS5ncm91cCB+bmFtZSByXG4gICAgICAgIGVuZCBlbHNlXG4gICAgICAgICAgcmFpc2UgUGFyc2VfZXJyb3JcbiAgICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICAgIGxldCByID0gcmVnZXhwICgpIGluXG4gICAgICAgIGlmIG5vdCAoYWNjZXB0ICcpJykgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgICAgUmUuZ3JvdXAgclxuICAgICAgZW5kXG4gICAgZW5kIGVsc2VcbiAgICBpZiBhY2NlcHQgJ14nIHRoZW4gYmVnaW5cbiAgICAgIGlmIG11bHRpbGluZSB0aGVuIFJlLmJvbCBlbHNlIFJlLmJvc1xuICAgIGVuZCBlbHNlIGlmIGFjY2VwdCAnJCcgdGhlbiBiZWdpblxuICAgICAgaWYgbXVsdGlsaW5lIHRoZW4gUmUuZW9sIGVsc2UgaWYgZG9sbGFyX2VuZG9ubHkgdGhlbiBSZS5sZW9sIGVsc2UgUmUuZW9zXG4gICAgZW5kIGVsc2UgaWYgYWNjZXB0ICdbJyB0aGVuIGJlZ2luXG4gICAgICBpZiBhY2NlcHQgJ14nIHRoZW5cbiAgICAgICAgUmUuY29tcGwgKGJyYWNrZXQgW10pXG4gICAgICBlbHNlXG4gICAgICAgIFJlLmFsdCAoYnJhY2tldCBbXSlcbiAgICBlbmQgZWxzZSBpZiBhY2NlcHQgJ1xcXFwnIHRoZW4gYmVnaW5cbigqIFhYWFxuICAgLSBCYWNrLXJlZmVyZW5jZXNcbiAgIC0gXFxjeCAoY29udHJvbC14KSwgXFxkZGRcbiopXG4gICAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICAgICd3JyAtPlxuICAgICAgICAgIFJlLmFsdCBbUmUuYWxudW07IFJlLmNoYXIgJ18nXVxuICAgICAgfCAnVycgLT5cbiAgICAgICAgICBSZS5jb21wbCBbUmUuYWxudW07IFJlLmNoYXIgJ18nXVxuICAgICAgfCAncycgLT5cbiAgICAgICAgICBSZS5zcGFjZVxuICAgICAgfCAnUycgLT5cbiAgICAgICAgICBSZS5jb21wbCBbUmUuc3BhY2VdXG4gICAgICB8ICdkJyAtPlxuICAgICAgICAgIFJlLmRpZ2l0XG4gICAgICB8ICdEJyAtPlxuICAgICAgICAgIFJlLmNvbXBsIFtSZS5kaWdpdF1cbiAgICAgIHwgJ2InIC0+XG4gICAgICAgICAgUmUuYWx0IFtSZS5ib3c7IFJlLmVvd11cbiAgICAgIHwgJ0InIC0+XG4gICAgICAgICAgUmUubm90X2JvdW5kYXJ5XG4gICAgICB8ICdBJyAtPlxuICAgICAgICAgIFJlLmJvc1xuICAgICAgfCAnWicgLT5cbiAgICAgICAgICBSZS5sZW9sXG4gICAgICB8ICd6JyAtPlxuICAgICAgICAgIFJlLmVvc1xuICAgICAgfCAnRycgLT5cbiAgICAgICAgICBSZS5zdGFydFxuICAgICAgfCAnZScgLT5cbiAgICAgICAgICBSZS5jaGFyICdcXHgxYidcbiAgICAgIHwgJ2YnIC0+XG4gICAgICAgICAgUmUuY2hhciAnXFx4MGMnXG4gICAgICB8ICduJyAtPlxuICAgICAgICAgIFJlLmNoYXIgJ1xcbidcbiAgICAgIHwgJ3InIC0+XG4gICAgICAgICAgUmUuY2hhciAnXFxyJ1xuICAgICAgfCAndCcgLT5cbiAgICAgICAgICBSZS5jaGFyICdcXHQnXG4gICAgICB8ICd4JyAtPlxuICAgICAgICAgIGxldCBjMSA9IGhleGRpZ2l0ICgpIGluXG4gICAgICAgICAgbGV0IGMyID0gaGV4ZGlnaXQgKCkgaW5cbiAgICAgICAgICBsZXQgY29kZSA9IGMxICogMTYgKyBjMiBpblxuICAgICAgICAgIFJlLmNoYXIgKGNoYXJfb2ZfaW50IGNvZGUpXG4gICAgICB8ICdhJy4uJ3onIHwgJ0EnLi4nWicgLT5cbiAgICAgICAgICByYWlzZSBQYXJzZV9lcnJvclxuICAgICAgfCAnMCcuLic5JyAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9zdXBwb3J0ZWRcbiAgICAgIHwgYyAtPlxuICAgICAgICAgIFJlLmNoYXIgY1xuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICAgICcqJyB8ICcrJyB8ICc/JyB8ICd7JyB8ICdcXFxcJyAtPiByYWlzZSBQYXJzZV9lcnJvclxuICAgICAgfCAgICAgICAgICAgICAgICAgYyAgICAgICAgICAgIC0+IFJlLmNoYXIgY1xuICAgIGVuZFxuICBhbmQgaGV4ZGlnaXQgKCkgPVxuICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICAnMCcuLic5JyBhcyBkIC0+IENoYXIuY29kZSBkIC0gQ2hhci5jb2RlICcwJ1xuICAgIHwgJ2EnLi4nZicgYXMgZCAtPiBDaGFyLmNvZGUgZCAtIENoYXIuY29kZSAnYScgKyAxMFxuICAgIHwgJ0EnLi4nRicgYXMgZCAtPiBDaGFyLmNvZGUgZCAtIENoYXIuY29kZSAnQScgKyAxMFxuICAgIHwgXyAtPiByYWlzZSBQYXJzZV9lcnJvclxuICBhbmQgaW50ZWdlciAoKSA9XG4gICAgaWYgZW9zICgpIHRoZW4gTm9uZSBlbHNlXG4gICAgbWF0Y2ggZ2V0ICgpIHdpdGhcbiAgICAgICcwJy4uJzknIGFzIGQgLT4gaW50ZWdlcicgKENoYXIuY29kZSBkIC0gQ2hhci5jb2RlICcwJylcbiAgICB8ICAgICBfICAgICAgICAtPiB1bmdldCAoKTsgTm9uZVxuICBhbmQgaW50ZWdlcicgaSA9XG4gICAgaWYgZW9zICgpIHRoZW4gU29tZSBpIGVsc2VcbiAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgJzAnLi4nOScgYXMgZCAtPlxuICAgICAgICBsZXQgaScgPSAxMCAqIGkgKyAoQ2hhci5jb2RlIGQgLSBDaGFyLmNvZGUgJzAnKSBpblxuICAgICAgICBpZiBpJyA8IGkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgICAgaW50ZWdlcicgaSdcbiAgICB8IF8gLT5cbiAgICAgICAgdW5nZXQgKCk7IFNvbWUgaVxuICBhbmQgbmFtZSAoKSA9XG4gICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3IgZWxzZVxuICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICAoJ18nIHwgJ2EnLi4neicgfCAnQScuLidaJykgYXMgYyAtPlxuICAgICAgbGV0IGIgPSBCdWZmZXIuY3JlYXRlIDMyIGluXG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYiBjO1xuICAgICAgbmFtZScgYlxuICAgIHwgXyAtPiByYWlzZSBQYXJzZV9lcnJvclxuICBhbmQgbmFtZScgYiA9XG4gICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3IgZWxzZVxuICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICAoJ18nIHwgJ2EnLi4neicgfCAnQScuLidaJyB8ICcwJy4uJzknKSBhcyBjIC0+XG4gICAgICBCdWZmZXIuYWRkX2NoYXIgYiBjO1xuICAgICAgbmFtZScgYlxuICAgIHwgJz4nIC0+IEJ1ZmZlci5jb250ZW50cyBiXG4gICAgfCBfIC0+IHJhaXNlIFBhcnNlX2Vycm9yXG4gIGFuZCBicmFja2V0IHMgPVxuICAgIGlmIHMgPD4gW10gJiYgYWNjZXB0ICddJyB0aGVuIHMgZWxzZSBiZWdpblxuICAgICAgbWF0Y2ggY2hhciAoKSB3aXRoXG4gICAgICB8IGBDaGFyIGMgLT5cbiAgICAgICAgaWYgYWNjZXB0ICctJyB0aGVuIGJlZ2luXG4gICAgICAgICAgaWYgYWNjZXB0ICddJyB0aGVuIFJlLmNoYXIgYyA6OiBSZS5jaGFyICctJyA6OiBzIGVsc2UgYmVnaW5cbiAgICAgICAgICAgIG1hdGNoIGNoYXIgKCkgd2l0aFxuICAgICAgICAgICAgICBgQ2hhciBjJyAtPlxuICAgICAgICAgICAgICBicmFja2V0IChSZS5yZyBjIGMnIDo6IHMpXG4gICAgICAgICAgICB8IGBTZXQgc3QnIC0+XG4gICAgICAgICAgICAgIGJyYWNrZXQgKFJlLmNoYXIgYyA6OiBSZS5jaGFyICctJyA6OiBzdCcgOjogcylcbiAgICAgICAgICBlbmRcbiAgICAgICAgZW5kIGVsc2VcbiAgICAgICAgICBicmFja2V0IChSZS5jaGFyIGMgOjogcylcbiAgICAgIHwgYFNldCBzdCAtPiBicmFja2V0IChzdCA6OiBzKVxuICAgIGVuZFxuICBhbmQgY2hhciAoKSA9XG4gICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgbGV0IGMgPSBnZXQgKCkgaW5cbiAgICBpZiBjID0gJ1snIHRoZW4gYmVnaW5cbiAgICAgIGlmIGFjY2VwdCAnPScgdGhlbiByYWlzZSBOb3Rfc3VwcG9ydGVkO1xuICAgICAgaWYgYWNjZXB0ICc6JyB0aGVuXG4gICAgICAgIGxldCBjb21wbCA9IGFjY2VwdCAnXicgaW5cbiAgICAgICAgbGV0IGNscyA9XG4gICAgICAgICAgdHJ5IExpc3QuZmluZCBhY2NlcHRfcyBwb3NpeF9jbGFzc19zdHJpbmdzXG4gICAgICAgICAgd2l0aCBOb3RfZm91bmQgLT4gcmFpc2UgUGFyc2VfZXJyb3IgaW5cbiAgICAgICAgaWYgbm90IChhY2NlcHRfcyBcIjpdXCIpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgIGxldCByZSA9XG4gICAgICAgICAgbGV0IHBvc2l4X2NsYXNzID0gcG9zaXhfY2xhc3Nfb2Zfc3RyaW5nIGNscyBpblxuICAgICAgICAgIGlmIGNvbXBsIHRoZW4gUmUuY29tcGwgW3Bvc2l4X2NsYXNzXSBlbHNlIHBvc2l4X2NsYXNzIGluXG4gICAgICAgIGBTZXQgKHJlKVxuICAgICAgZWxzZSBpZiBhY2NlcHQgJy4nIHRoZW4gYmVnaW5cbiAgICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgIGxldCBjID0gZ2V0ICgpIGluXG4gICAgICAgIGlmIG5vdCAoYWNjZXB0ICcuJykgdGhlbiByYWlzZSBOb3Rfc3VwcG9ydGVkO1xuICAgICAgICBpZiBub3QgKGFjY2VwdCAnXScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgIGBDaGFyIGNcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIGBDaGFyIGNcbiAgICBlbmQgZWxzZSBpZiBjID0gJ1xcXFwnIHRoZW4gYmVnaW5cbiAgICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgICAgbGV0IGMgPSBnZXQgKCkgaW5cbigqIFhYWFxuICAgXFwxMjcsIC4uLlxuKilcbiAgICAgIG1hdGNoIGMgd2l0aFxuICAgICAgICAnYicgLT4gYENoYXIgJ1xcMDA4J1xuICAgICAgfCAnbicgLT4gYENoYXIgJ1xcbicgKCpYWFgqKVxuICAgICAgfCAncicgLT4gYENoYXIgJ1xccicgKCpYWFgqKVxuICAgICAgfCAndCcgLT4gYENoYXIgJ1xcdCcgKCpYWFgqKVxuICAgICAgfCAndycgLT4gYFNldCAoUmUuYWx0IFtSZS5hbG51bTsgUmUuY2hhciAnXyddKVxuICAgICAgfCAnVycgLT4gYFNldCAoUmUuY29tcGwgW1JlLmFsbnVtOyBSZS5jaGFyICdfJ10pXG4gICAgICB8ICdzJyAtPiBgU2V0IChSZS5zcGFjZSlcbiAgICAgIHwgJ1MnIC0+IGBTZXQgKFJlLmNvbXBsIFtSZS5zcGFjZV0pXG4gICAgICB8ICdkJyAtPiBgU2V0IChSZS5kaWdpdClcbiAgICAgIHwgJ0QnIC0+IGBTZXQgKFJlLmNvbXBsIFtSZS5kaWdpdF0pXG4gICAgICB8ICdhJy4uJ3onIHwgJ0EnLi4nWicgLT5cbiAgICAgICAgICByYWlzZSBQYXJzZV9lcnJvclxuICAgICAgfCAnMCcuLic5JyAtPlxuICAgICAgICAgIHJhaXNlIE5vdF9zdXBwb3J0ZWRcbiAgICAgIHwgXyAtPlxuICAgICAgICAgIGBDaGFyIGNcbiAgICBlbmQgZWxzZVxuICAgICAgYENoYXIgY1xuICBhbmQgY29tbWVudCAoKSA9XG4gICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgaWYgYWNjZXB0ICcpJyB0aGVuIFJlLmVwc2lsb24gZWxzZSBiZWdpbiBpbmNyIGk7IGNvbW1lbnQgKCkgZW5kXG4gIGluXG4gIGxldCByZXMgPSByZWdleHAgKCkgaW5cbiAgaWYgbm90IChlb3MgKCkpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gIHJlc1xuXG50eXBlIG9wdCA9XG4gIFsgYFVuZ3JlZWR5IHwgYERvdGFsbCB8IGBEb2xsYXJfZW5kb25seVxuICB8IGBNdWx0aWxpbmUgfCBgQW5jaG9yZWQgfCBgQ2FzZWxlc3MgXVxuXG5sZXQgcmUgID8ob3B0cyA9IFtdKSBzID1cbiAgbGV0IHIgPVxuICAgIHBhcnNlXG4gICAgICAoTGlzdC5tZW1xIGBNdWx0aWxpbmUgb3B0cykgKExpc3QubWVtcSBgRG9sbGFyX2VuZG9ubHkgb3B0cylcbiAgICAgIChMaXN0Lm1lbXEgYERvdGFsbCBvcHRzKSAoTGlzdC5tZW1xIGBVbmdyZWVkeSBvcHRzKVxuICAgICAgc1xuICBpblxuICBsZXQgciA9IGlmIExpc3QubWVtcSBgQW5jaG9yZWQgb3B0cyB0aGVuIFJlLnNlcSBbUmUuc3RhcnQ7IHJdIGVsc2UgciBpblxuICBsZXQgciA9IGlmIExpc3QubWVtcSBgQ2FzZWxlc3Mgb3B0cyB0aGVuIFJlLm5vX2Nhc2UgciBlbHNlIHIgaW5cbiAgclxuXG5sZXQgY29tcGlsZSA9IFJlLmNvbXBpbGVcbmxldCBjb21waWxlX3BhdCA/KG9wdHMgPSBbXSkgcyA9IGNvbXBpbGUgKHJlIH5vcHRzIHMpXG4iLCJtb2R1bGUgUmUgPSBDb3JlXG5cbmV4Y2VwdGlvbiBQYXJzZV9lcnJvciA9IFBlcmwuUGFyc2VfZXJyb3JcbmV4Y2VwdGlvbiBOb3Rfc3VwcG9ydGVkID0gUGVybC5Ob3Rfc3VwcG9ydGVkXG5cbnR5cGUgcmVnZXhwID0gUmUucmVcblxudHlwZSBmbGFnID0gWyBgQ0FTRUxFU1MgfCBgTVVMVElMSU5FIHwgYEFOQ0hPUkVEIHwgYERPVEFMTCBdXG5cbnR5cGUgc3BsaXRfcmVzdWx0ID1cbiAgfCBUZXh0ICBvZiBzdHJpbmdcbiAgfCBEZWxpbSBvZiBzdHJpbmdcbiAgfCBHcm91cCBvZiBpbnQgKiBzdHJpbmdcbiAgfCBOb0dyb3VwXG5cbnR5cGUgZ3JvdXBzID0gQ29yZS5Hcm91cC50XG5cbmxldCByZSA/KGZsYWdzID0gW10pIHBhdCA9XG4gIGxldCBvcHRzID0gTGlzdC5tYXAgKGZ1bmN0aW9uXG4gICAgfCBgQ0FTRUxFU1MgLT4gYENhc2VsZXNzXG4gICAgfCBgTVVMVElMSU5FIC0+IGBNdWx0aWxpbmVcbiAgICB8IGBBTkNIT1JFRCAtPiBgQW5jaG9yZWRcbiAgICB8IGBET1RBTEwgLT4gYERvdGFsbFxuICApIGZsYWdzIGluXG4gIFBlcmwucmUgfm9wdHMgcGF0XG5cbmxldCByZWdleHAgP2ZsYWdzIHBhdCA9IFJlLmNvbXBpbGUgKHJlID9mbGFncyBwYXQpXG5cbmxldCBleHRyYWN0IH5yZXggcyA9XG4gIFJlLkdyb3VwLmFsbCAoUmUuZXhlYyByZXggcylcblxubGV0IGV4ZWMgfnJleCA/cG9zIHMgPVxuICBSZS5leGVjIHJleCA/cG9zIHNcblxubGV0IGdldF9zdWJzdHJpbmcgcyBpID1cbiAgUmUuR3JvdXAuZ2V0IHMgaVxuXG5sZXQgbmFtZXMgcmV4ID1cbiAgUmUuZ3JvdXBfbmFtZXMgcmV4XG4gIHw+IExpc3QubWFwIGZzdFxuICB8PiBBcnJheS5vZl9saXN0XG5cbmxldCBnZXRfbmFtZWRfc3Vic3RyaW5nIHJleCBuYW1lIHMgPVxuICBsZXQgcmVjIGxvb3AgPSBmdW5jdGlvblxuICAgIHwgW10gLT4gcmFpc2UgTm90X2ZvdW5kXG4gICAgfCAobiwgaSkgOjogcmVtIHdoZW4gbiA9IG5hbWUgLT5cbiAgICAgICBiZWdpblxuICAgICAgICAgdHJ5IGdldF9zdWJzdHJpbmcgcyBpXG4gICAgICAgICB3aXRoIE5vdF9mb3VuZCAtPiBsb29wIHJlbVxuICAgICAgIGVuZFxuICAgIHwgXyA6OiByZW0gLT4gbG9vcCByZW1cbiAgaW5cbiAgbG9vcCAoUmUuZ3JvdXBfbmFtZXMgcmV4KVxuXG5sZXQgZ2V0X3N1YnN0cmluZ19vZnMgcyBpID1cbiAgUmUuR3JvdXAub2Zmc2V0IHMgaVxuXG5sZXQgcG1hdGNoIH5yZXggcyA9XG4gIFJlLmV4ZWNwIHJleCBzXG5cbmxldCBzdWJzdGl0dXRlIH5yZXggfnN1YnN0IHN0ciA9XG4gIGxldCBiID0gQnVmZmVyLmNyZWF0ZSAxMDI0IGluXG4gIGxldCByZWMgbG9vcCBwb3MgPVxuICAgIGlmIHBvcyA+PSBTdHJpbmcubGVuZ3RoIHN0ciB0aGVuXG4gICAgICBCdWZmZXIuY29udGVudHMgYlxuICAgIGVsc2UgaWYgUmUuZXhlY3AgfnBvcyByZXggc3RyIHRoZW4gKFxuICAgICAgbGV0IHNzID0gUmUuZXhlYyB+cG9zIHJleCBzdHIgaW5cbiAgICAgIGxldCBzdGFydCwgZmluID0gUmUuR3JvdXAub2Zmc2V0IHNzIDAgaW5cbiAgICAgIGxldCBwYXQgPSBSZS5Hcm91cC5nZXQgc3MgMCBpblxuICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYiBzdHIgcG9zIChzdGFydCAtIHBvcyk7XG4gICAgICBCdWZmZXIuYWRkX3N0cmluZyBiIChzdWJzdCBwYXQpO1xuICAgICAgbG9vcCBmaW5cbiAgICApIGVsc2UgKFxuICAgICAgQnVmZmVyLmFkZF9zdWJzdHJpbmcgYiBzdHIgcG9zIChTdHJpbmcubGVuZ3RoIHN0ciAtIHBvcyk7XG4gICAgICBsb29wIChTdHJpbmcubGVuZ3RoIHN0cilcbiAgICApXG4gIGluXG4gIGxvb3AgMFxuXG5sZXQgc3BsaXQgfnJleCBzdHIgPVxuICBsZXQgcmVjIGxvb3AgYWNjdSBwb3MgPVxuICAgIGlmIHBvcyA+PSBTdHJpbmcubGVuZ3RoIHN0ciB0aGVuXG4gICAgICBMaXN0LnJldiBhY2N1XG4gICAgZWxzZSBpZiBSZS5leGVjcCB+cG9zIHJleCBzdHIgdGhlbiAoXG4gICAgICBsZXQgc3MgPSBSZS5leGVjIH5wb3MgcmV4IHN0ciBpblxuICAgICAgbGV0IHN0YXJ0LCBmaW4gPSBSZS5Hcm91cC5vZmZzZXQgc3MgMCBpblxuICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciBwb3MgKHN0YXJ0IC0gcG9zKSBpblxuICAgICAgbG9vcCAocyA6OiBhY2N1KSBmaW5cbiAgICApIGVsc2UgKFxuICAgICAgbGV0IHMgPSBTdHJpbmcuc3ViIHN0ciBwb3MgKFN0cmluZy5sZW5ndGggc3RyIC0gcG9zKSBpblxuICAgICAgbG9vcCAocyA6OiBhY2N1KSAoU3RyaW5nLmxlbmd0aCBzdHIpXG4gICAgKSBpblxuICBsb29wIFtdIDBcblxuKCogRnJvbSBQQ1JFICopXG5sZXQgc3RyaW5nX3Vuc2FmZV9zdWIgcyBvZnMgbGVuID1cbiAgbGV0IHIgPSBCeXRlcy5jcmVhdGUgbGVuIGluXG4gIEJ5dGVzLnVuc2FmZV9ibGl0IHMgb2ZzIHIgMCBsZW47XG4gIEJ5dGVzLnVuc2FmZV90b19zdHJpbmcgclxuXG5sZXQgcXVvdGUgcyA9XG4gIGxldCBsZW4gPSBTdHJpbmcubGVuZ3RoIHMgaW5cbiAgbGV0IGJ1ZiA9IEJ5dGVzLmNyZWF0ZSAobGVuIGxzbCAxKSBpblxuICBsZXQgcG9zID0gcmVmIDAgaW5cbiAgZm9yIGkgPSAwIHRvIGxlbiAtIDEgZG9cbiAgICBtYXRjaCBTdHJpbmcudW5zYWZlX2dldCBzIGkgd2l0aFxuICAgIHwgJ1xcXFwnIHwgJ14nIHwgJyQnIHwgJy4nIHwgJ1snIHwgJ3wnXG4gICAgfCAnKCcgIHwgJyknIHwgJz8nIHwgJyonIHwgJysnIHwgJ3snIGFzIGMgLT5cbiAgICAgIEJ5dGVzLnVuc2FmZV9zZXQgYnVmICFwb3MgJ1xcXFwnO1xuICAgICAgaW5jciBwb3M7XG4gICAgICBCeXRlcy51bnNhZmVfc2V0IGJ1ZiAhcG9zIGM7IGluY3IgcG9zXG4gICAgfCBjIC0+IEJ5dGVzLnVuc2FmZV9zZXQgYnVmICFwb3MgYzsgaW5jciBwb3NcbiAgZG9uZTtcbiAgc3RyaW5nX3Vuc2FmZV9zdWIgYnVmIDAgIXBvc1xuXG5sZXQgZnVsbF9zcGxpdCA/KG1heD0wKSB+cmV4IHMgPVxuICBpZiBTdHJpbmcubGVuZ3RoIHMgPSAwIHRoZW4gW11cbiAgZWxzZSBpZiBtYXggPSAxIHRoZW4gW1RleHQgc11cbiAgZWxzZVxuICAgIGxldCByZXN1bHRzID0gUmUuc3BsaXRfZnVsbCByZXggcyBpblxuICAgIGxldCBtYXRjaGVzID1cbiAgICAgIExpc3QubWFwIChmdW5jdGlvblxuICAgICAgICB8IGBUZXh0IHMgLT4gW1RleHQgc11cbiAgICAgICAgfCBgRGVsaW0gZCAtPlxuICAgICAgICAgIGxldCBtYXRjaGVzID0gUmUuR3JvdXAuYWxsX29mZnNldCBkIGluXG4gICAgICAgICAgbGV0IGRlbGltID0gUmUuR3JvdXAuZ2V0IGQgMCBpblxuICAgICAgICAgIChEZWxpbSBkZWxpbSk6OihcbiAgICAgICAgICAgIGxldCBsID0gcmVmIFtdIGluXG4gICAgICAgICAgICBmb3IgaSA9IDEgdG8gQXJyYXkubGVuZ3RoIG1hdGNoZXMgLSAxIGRvXG4gICAgICAgICAgICAgIGwgOj1cbiAgICAgICAgICAgICAgICAoaWYgbWF0Y2hlcy4oaSkgPSAoLTEsIC0xKVxuICAgICAgICAgICAgICAgICB0aGVuIE5vR3JvdXBcbiAgICAgICAgICAgICAgICAgZWxzZSBHcm91cCAoaSwgUmUuR3JvdXAuZ2V0IGQgaSkpXG4gICAgICAgICAgICAgICAgOjooIWwpXG4gICAgICAgICAgICBkb25lO1xuICAgICAgICAgICAgTGlzdC5yZXYgIWwpKSByZXN1bHRzIGluXG4gICAgTGlzdC5jb25jYXQgbWF0Y2hlc1xuXG5cbnR5cGUgc3Vic3RyaW5ncyA9IEdyb3VwLnRcbiIsIigqXG4gICBSRSAtIEEgcmVndWxhciBleHByZXNzaW9uIGxpYnJhcnlcblxuICAgQ29weXJpZ2h0IChDKSAyMDAxIEplcm9tZSBWb3VpbGxvblxuICAgZW1haWw6IEplcm9tZS5Wb3VpbGxvbkBwcHMuanVzc2lldS5mclxuXG4gICBUaGlzIGxpYnJhcnkgaXMgZnJlZSBzb2Z0d2FyZTsgeW91IGNhbiByZWRpc3RyaWJ1dGUgaXQgYW5kL29yXG4gICBtb2RpZnkgaXQgdW5kZXIgdGhlIHRlcm1zIG9mIHRoZSBHTlUgTGVzc2VyIEdlbmVyYWwgUHVibGljXG4gICBMaWNlbnNlIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLCB3aXRoXG4gICBsaW5raW5nIGV4Y2VwdGlvbjsgZWl0aGVyIHZlcnNpb24gMi4xIG9mIHRoZSBMaWNlbnNlLCBvciAoYXRcbiAgIHlvdXIgb3B0aW9uKSBhbnkgbGF0ZXIgdmVyc2lvbi5cblxuICAgVGhpcyBsaWJyYXJ5IGlzIGRpc3RyaWJ1dGVkIGluIHRoZSBob3BlIHRoYXQgaXQgd2lsbCBiZSB1c2VmdWwsXG4gICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICAgTUVSQ0hBTlRBQklMSVRZIG9yIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLiAgU2VlIHRoZSBHTlVcbiAgIExlc3NlciBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgIFlvdSBzaG91bGQgaGF2ZSByZWNlaXZlZCBhIGNvcHkgb2YgdGhlIEdOVSBMZXNzZXIgR2VuZXJhbCBQdWJsaWNcbiAgIExpY2Vuc2UgYWxvbmcgd2l0aCB0aGlzIGxpYnJhcnk7IGlmIG5vdCwgd3JpdGUgdG8gdGhlIEZyZWUgU29mdHdhcmVcbiAgIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCwgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEgMDIxMTAtMTMwMSBVU0FcbiopXG5cbigqXG5XaGF0IHdlIGNvdWxkIChzaG91bGQ/KSBkbzpcbi0gYSogPT0+IGxvbmdlc3QgKChzaG9ydGVzdCAobm9fZ3JvdXAgYSkqICksIGEgfCAoKSkgICghISEpXG4tIGFiYyB1bmRlcnN0b29kIGFzIChhYiljXG4tIFwiKChhPyl8YilcIiBhZ2FpbnN0IFwiYWJcIiBzaG91bGQgbm90IGJpbmQgdGhlIGZpcnN0IHN1YnBhdHRlcm4gdG8gYW55dGhpbmdcblxuTm90ZSB0aGF0IGl0IHNob3VsZCBiZSBwb3NzaWJsZSB0byBoYW5kbGUgXCIoKChhYiljKWQpZVwiIGVmZmljaWVudGx5XG4qKVxubW9kdWxlIFJlID0gQ29yZVxuXG5leGNlcHRpb24gUGFyc2VfZXJyb3JcbmV4Y2VwdGlvbiBOb3Rfc3VwcG9ydGVkXG5cbmxldCBwYXJzZSBuZXdsaW5lIHMgPVxuICBsZXQgaSA9IHJlZiAwIGluXG4gIGxldCBsID0gU3RyaW5nLmxlbmd0aCBzIGluXG4gIGxldCBlb3MgKCkgPSAhaSA9IGwgaW5cbiAgbGV0IHRlc3QgYyA9IG5vdCAoZW9zICgpKSAmJiBzLlshaV0gPSBjIGluXG4gIGxldCBhY2NlcHQgYyA9IGxldCByID0gdGVzdCBjIGluIGlmIHIgdGhlbiBpbmNyIGk7IHIgaW5cbiAgbGV0IGdldCAoKSA9IGxldCByID0gcy5bIWldIGluIGluY3IgaTsgciBpblxuICBsZXQgdW5nZXQgKCkgPSBkZWNyIGkgaW5cblxuICBsZXQgcmVjIHJlZ2V4cCAoKSA9IHJlZ2V4cCcgKGJyYW5jaCAoKSlcbiAgYW5kIHJlZ2V4cCcgbGVmdCA9XG4gICAgaWYgYWNjZXB0ICd8JyB0aGVuIHJlZ2V4cCcgKFJlLmFsdCBbbGVmdDsgYnJhbmNoICgpXSkgZWxzZSBsZWZ0XG4gIGFuZCBicmFuY2ggKCkgPSBicmFuY2gnIFtdXG4gIGFuZCBicmFuY2gnIGxlZnQgPVxuICAgIGlmIGVvcyAoKSB8fCB0ZXN0ICd8JyB8fCB0ZXN0ICcpJyB0aGVuIFJlLnNlcSAoTGlzdC5yZXYgbGVmdClcbiAgICBlbHNlIGJyYW5jaCcgKHBpZWNlICgpIDo6IGxlZnQpXG4gIGFuZCBwaWVjZSAoKSA9XG4gICAgbGV0IHIgPSBhdG9tICgpIGluXG4gICAgaWYgYWNjZXB0ICcqJyB0aGVuIFJlLnJlcCAoUmUubmVzdCByKSBlbHNlXG4gICAgaWYgYWNjZXB0ICcrJyB0aGVuIFJlLnJlcDEgKFJlLm5lc3QgcikgZWxzZVxuICAgIGlmIGFjY2VwdCAnPycgdGhlbiBSZS5vcHQgciBlbHNlXG4gICAgaWYgYWNjZXB0ICd7JyB0aGVuXG4gICAgICBtYXRjaCBpbnRlZ2VyICgpIHdpdGhcbiAgICAgICAgU29tZSBpIC0+XG4gICAgICAgICAgbGV0IGogPSBpZiBhY2NlcHQgJywnIHRoZW4gaW50ZWdlciAoKSBlbHNlIFNvbWUgaSBpblxuICAgICAgICAgIGlmIG5vdCAoYWNjZXB0ICd9JykgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgICAgICBiZWdpbiBtYXRjaCBqIHdpdGhcbiAgICAgICAgICAgIFNvbWUgaiB3aGVuIGogPCBpIC0+IHJhaXNlIFBhcnNlX2Vycm9yIHwgXyAtPiAoKVxuICAgICAgICAgIGVuZDtcbiAgICAgICAgICBSZS5yZXBuIChSZS5uZXN0IHIpIGkgalxuICAgICAgfCBOb25lIC0+XG4gICAgICAgICAgdW5nZXQgKCk7IHJcbiAgICBlbHNlXG4gICAgICByXG4gIGFuZCBhdG9tICgpID1cbiAgICBpZiBhY2NlcHQgJy4nIHRoZW4gYmVnaW5cbiAgICAgIGlmIG5ld2xpbmUgdGhlbiBSZS5ub3RubCBlbHNlIFJlLmFueVxuICAgIGVuZCBlbHNlIGlmIGFjY2VwdCAnKCcgdGhlbiBiZWdpblxuICAgICAgbGV0IHIgPSByZWdleHAgKCkgaW5cbiAgICAgIGlmIG5vdCAoYWNjZXB0ICcpJykgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIFJlLmdyb3VwIHJcbiAgICBlbmQgZWxzZVxuICAgIGlmIGFjY2VwdCAnXicgdGhlbiBiZWdpblxuICAgICAgaWYgbmV3bGluZSB0aGVuIFJlLmJvbCBlbHNlIFJlLmJvc1xuICAgIGVuZCBlbHNlIGlmIGFjY2VwdCAnJCcgdGhlbiBiZWdpblxuICAgICAgaWYgbmV3bGluZSB0aGVuIFJlLmVvbCBlbHNlIFJlLmVvc1xuICAgIGVuZCBlbHNlIGlmIGFjY2VwdCAnWycgdGhlbiBiZWdpblxuICAgICAgaWYgYWNjZXB0ICdeJyB0aGVuXG4gICAgICAgIFJlLmRpZmYgKFJlLmNvbXBsIChicmFja2V0IFtdKSkgKFJlLmNoYXIgJ1xcbicpXG4gICAgICBlbHNlXG4gICAgICAgIFJlLmFsdCAoYnJhY2tldCBbXSlcbiAgICBlbmQgZWxzZVxuICAgIGlmIGFjY2VwdCAnXFxcXCcgdGhlbiBiZWdpblxuICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgICAnfCcgfCAnKCcgfCAnKScgfCAnKicgfCAnKycgfCAnPydcbiAgICAgIHwgJ1snIHwgJy4nIHwgJ14nIHwgJyQnIHwgJ3snIHwgJ1xcXFwnIGFzIGMgLT4gUmUuY2hhciBjXG4gICAgICB8ICAgICAgICAgICAgICAgICBfICAgICAgICAgICAgICAgICAgICAgICAtPiByYWlzZSBQYXJzZV9lcnJvclxuICAgIGVuZCBlbHNlIGJlZ2luXG4gICAgICBpZiBlb3MgKCkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgIG1hdGNoIGdldCAoKSB3aXRoXG4gICAgICAgICcqJyB8ICcrJyB8ICc/JyB8ICd7JyB8ICdcXFxcJyAtPiByYWlzZSBQYXJzZV9lcnJvclxuICAgICAgfCAgICAgICAgICAgICAgICAgYyAgICAgICAgICAgIC0+IFJlLmNoYXIgY1xuICAgIGVuZFxuICBhbmQgaW50ZWdlciAoKSA9XG4gICAgaWYgZW9zICgpIHRoZW4gTm9uZSBlbHNlXG4gICAgbWF0Y2ggZ2V0ICgpIHdpdGhcbiAgICAgICcwJy4uJzknIGFzIGQgLT4gaW50ZWdlcicgKENoYXIuY29kZSBkIC0gQ2hhci5jb2RlICcwJylcbiAgICB8ICAgICBfICAgICAgICAtPiB1bmdldCAoKTsgTm9uZVxuICBhbmQgaW50ZWdlcicgaSA9XG4gICAgaWYgZW9zICgpIHRoZW4gU29tZSBpIGVsc2VcbiAgICBtYXRjaCBnZXQgKCkgd2l0aFxuICAgICAgJzAnLi4nOScgYXMgZCAtPlxuICAgICAgICBsZXQgaScgPSAxMCAqIGkgKyAoQ2hhci5jb2RlIGQgLSBDaGFyLmNvZGUgJzAnKSBpblxuICAgICAgICBpZiBpJyA8IGkgdGhlbiByYWlzZSBQYXJzZV9lcnJvcjtcbiAgICAgICAgaW50ZWdlcicgaSdcbiAgICB8IF8gLT5cbiAgICAgICAgdW5nZXQgKCk7IFNvbWUgaVxuICBhbmQgYnJhY2tldCBzID1cbiAgICBpZiBzIDw+IFtdICYmIGFjY2VwdCAnXScgdGhlbiBzIGVsc2UgYmVnaW5cbiAgICAgIGxldCBjID0gY2hhciAoKSBpblxuICAgICAgaWYgYWNjZXB0ICctJyB0aGVuIGJlZ2luXG4gICAgICAgIGlmIGFjY2VwdCAnXScgdGhlbiBSZS5jaGFyIGMgOjogUmUuY2hhciAnLScgOjogcyBlbHNlIGJlZ2luXG4gICAgICAgICAgbGV0IGMnID0gY2hhciAoKSBpblxuICAgICAgICAgIGJyYWNrZXQgKFJlLnJnIGMgYycgOjogcylcbiAgICAgICAgZW5kXG4gICAgICBlbmQgZWxzZVxuICAgICAgICBicmFja2V0IChSZS5jaGFyIGMgOjogcylcbiAgICBlbmRcbiAgYW5kIGNoYXIgKCkgPVxuICAgIGlmIGVvcyAoKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICAgIGxldCBjID0gZ2V0ICgpIGluXG4gICAgaWYgYyA9ICdbJyB0aGVuIGJlZ2luXG4gICAgICBpZiBhY2NlcHQgJz0nIHRoZW4gcmFpc2UgTm90X3N1cHBvcnRlZFxuICAgICAgZWxzZSBpZiBhY2NlcHQgJzonIHRoZW4gYmVnaW5cbiAgICAgICAgcmFpc2UgTm90X3N1cHBvcnRlZCAoKlhYWCopXG4gICAgICBlbmQgZWxzZSBpZiBhY2NlcHQgJy4nIHRoZW4gYmVnaW5cbiAgICAgICAgaWYgZW9zICgpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgIGxldCBjID0gZ2V0ICgpIGluXG4gICAgICAgIGlmIG5vdCAoYWNjZXB0ICcuJykgdGhlbiByYWlzZSBOb3Rfc3VwcG9ydGVkO1xuICAgICAgICBpZiBub3QgKGFjY2VwdCAnXScpIHRoZW4gcmFpc2UgUGFyc2VfZXJyb3I7XG4gICAgICAgIGNcbiAgICAgIGVuZCBlbHNlXG4gICAgICAgIGNcbiAgICBlbmQgZWxzZVxuICAgICAgY1xuICBpblxuICBsZXQgcmVzID0gcmVnZXhwICgpIGluXG4gIGlmIG5vdCAoZW9zICgpKSB0aGVuIHJhaXNlIFBhcnNlX2Vycm9yO1xuICByZXNcblxudHlwZSBvcHQgPSBbYElDYXNlIHwgYE5vU3ViIHwgYE5ld2xpbmVdXG5cbmxldCByZSA/KG9wdHMgPSBbXSkgcyA9XG4gIGxldCByID0gcGFyc2UgKExpc3QubWVtcSBgTmV3bGluZSBvcHRzKSBzIGluXG4gIGxldCByID0gaWYgTGlzdC5tZW1xIGBJQ2FzZSBvcHRzIHRoZW4gUmUubm9fY2FzZSByIGVsc2UgciBpblxuICBsZXQgciA9IGlmIExpc3QubWVtcSBgTm9TdWIgb3B0cyB0aGVuIFJlLm5vX2dyb3VwIHIgZWxzZSByIGluXG4gIHJcblxubGV0IGNvbXBpbGUgcmUgPSBSZS5jb21waWxlIChSZS5sb25nZXN0IHJlKVxubGV0IGNvbXBpbGVfcGF0ID8ob3B0cyA9IFtdKSBzID0gY29tcGlsZSAocmUgfm9wdHMgcylcbiJdfQ==
